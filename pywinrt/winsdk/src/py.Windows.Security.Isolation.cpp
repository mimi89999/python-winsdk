// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.Security.Isolation.h"


PyObject* py::converter<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress>::convert(winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress py::converter<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress");
    throw python_exception();
}

namespace py::cpp::Windows::Security::Isolation
{
    struct module_state
    {
        PyObject* type_IsolatedWindowsEnvironmentActivator;
        PyObject* type_IsolatedWindowsEnvironmentAllowedClipboardFormats;
        PyObject* type_IsolatedWindowsEnvironmentAvailablePrinters;
        PyObject* type_IsolatedWindowsEnvironmentClipboardCopyPasteDirections;
        PyObject* type_IsolatedWindowsEnvironmentCreateStatus;
        PyObject* type_IsolatedWindowsEnvironmentCreationPriority;
        PyObject* type_IsolatedWindowsEnvironmentHostError;
        PyObject* type_IsolatedWindowsEnvironmentLaunchFileStatus;
        PyObject* type_IsolatedWindowsEnvironmentOwnerRegistrationStatus;
        PyObject* type_IsolatedWindowsEnvironmentPostMessageStatus;
        PyObject* type_IsolatedWindowsEnvironmentProcessState;
        PyObject* type_IsolatedWindowsEnvironmentProgressState;
        PyObject* type_IsolatedWindowsEnvironmentShareFileStatus;
        PyObject* type_IsolatedWindowsEnvironmentShareFolderStatus;
        PyObject* type_IsolatedWindowsEnvironmentSignInProgress;
        PyObject* type_IsolatedWindowsEnvironmentStartProcessStatus;
        PyTypeObject* type_IsolatedWindowsEnvironment;
        PyTypeObject* type_IsolatedWindowsEnvironmentCreateResult;
        PyTypeObject* type_IsolatedWindowsEnvironmentFile;
        PyTypeObject* type_IsolatedWindowsEnvironmentHost;
        PyTypeObject* type_IsolatedWindowsEnvironmentLaunchFileResult;
        PyTypeObject* type_IsolatedWindowsEnvironmentOptions;
        PyTypeObject* type_IsolatedWindowsEnvironmentOwnerRegistration;
        PyTypeObject* type_IsolatedWindowsEnvironmentOwnerRegistrationData;
        PyTypeObject* type_IsolatedWindowsEnvironmentOwnerRegistrationResult;
        PyTypeObject* type_IsolatedWindowsEnvironmentPostMessageResult;
        PyTypeObject* type_IsolatedWindowsEnvironmentProcess;
        PyTypeObject* type_IsolatedWindowsEnvironmentShareFileRequestOptions;
        PyTypeObject* type_IsolatedWindowsEnvironmentShareFileResult;
        PyTypeObject* type_IsolatedWindowsEnvironmentShareFolderRequestOptions;
        PyTypeObject* type_IsolatedWindowsEnvironmentShareFolderResult;
        PyTypeObject* type_IsolatedWindowsEnvironmentStartProcessResult;
        PyTypeObject* type_IsolatedWindowsEnvironmentTelemetryParameters;
        PyTypeObject* type_IsolatedWindowsEnvironmentUserInfo;
        PyTypeObject* type_IsolatedWindowsHostMessenger;
        PyTypeObject* type_IsolatedWindowsEnvironmentCreateProgress;
    };

    static PyObject* register_IsolatedWindowsEnvironmentActivator(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_IsolatedWindowsEnvironmentActivator)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_IsolatedWindowsEnvironmentActivator = type;
        Py_INCREF(state->type_IsolatedWindowsEnvironmentActivator);


        Py_RETURN_NONE;
    }

    static PyObject* register_IsolatedWindowsEnvironmentAllowedClipboardFormats(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_IsolatedWindowsEnvironmentAllowedClipboardFormats)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_IsolatedWindowsEnvironmentAllowedClipboardFormats = type;
        Py_INCREF(state->type_IsolatedWindowsEnvironmentAllowedClipboardFormats);


        Py_RETURN_NONE;
    }

    static PyObject* register_IsolatedWindowsEnvironmentAvailablePrinters(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_IsolatedWindowsEnvironmentAvailablePrinters)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_IsolatedWindowsEnvironmentAvailablePrinters = type;
        Py_INCREF(state->type_IsolatedWindowsEnvironmentAvailablePrinters);


        Py_RETURN_NONE;
    }

    static PyObject* register_IsolatedWindowsEnvironmentClipboardCopyPasteDirections(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_IsolatedWindowsEnvironmentClipboardCopyPasteDirections)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_IsolatedWindowsEnvironmentClipboardCopyPasteDirections = type;
        Py_INCREF(state->type_IsolatedWindowsEnvironmentClipboardCopyPasteDirections);


        Py_RETURN_NONE;
    }

    static PyObject* register_IsolatedWindowsEnvironmentCreateStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_IsolatedWindowsEnvironmentCreateStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_IsolatedWindowsEnvironmentCreateStatus = type;
        Py_INCREF(state->type_IsolatedWindowsEnvironmentCreateStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_IsolatedWindowsEnvironmentCreationPriority(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_IsolatedWindowsEnvironmentCreationPriority)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_IsolatedWindowsEnvironmentCreationPriority = type;
        Py_INCREF(state->type_IsolatedWindowsEnvironmentCreationPriority);


        Py_RETURN_NONE;
    }

    static PyObject* register_IsolatedWindowsEnvironmentHostError(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_IsolatedWindowsEnvironmentHostError)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_IsolatedWindowsEnvironmentHostError = type;
        Py_INCREF(state->type_IsolatedWindowsEnvironmentHostError);


        Py_RETURN_NONE;
    }

    static PyObject* register_IsolatedWindowsEnvironmentLaunchFileStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_IsolatedWindowsEnvironmentLaunchFileStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_IsolatedWindowsEnvironmentLaunchFileStatus = type;
        Py_INCREF(state->type_IsolatedWindowsEnvironmentLaunchFileStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_IsolatedWindowsEnvironmentOwnerRegistrationStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_IsolatedWindowsEnvironmentOwnerRegistrationStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_IsolatedWindowsEnvironmentOwnerRegistrationStatus = type;
        Py_INCREF(state->type_IsolatedWindowsEnvironmentOwnerRegistrationStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_IsolatedWindowsEnvironmentPostMessageStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_IsolatedWindowsEnvironmentPostMessageStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_IsolatedWindowsEnvironmentPostMessageStatus = type;
        Py_INCREF(state->type_IsolatedWindowsEnvironmentPostMessageStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_IsolatedWindowsEnvironmentProcessState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_IsolatedWindowsEnvironmentProcessState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_IsolatedWindowsEnvironmentProcessState = type;
        Py_INCREF(state->type_IsolatedWindowsEnvironmentProcessState);


        Py_RETURN_NONE;
    }

    static PyObject* register_IsolatedWindowsEnvironmentProgressState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_IsolatedWindowsEnvironmentProgressState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_IsolatedWindowsEnvironmentProgressState = type;
        Py_INCREF(state->type_IsolatedWindowsEnvironmentProgressState);


        Py_RETURN_NONE;
    }

    static PyObject* register_IsolatedWindowsEnvironmentShareFileStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_IsolatedWindowsEnvironmentShareFileStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_IsolatedWindowsEnvironmentShareFileStatus = type;
        Py_INCREF(state->type_IsolatedWindowsEnvironmentShareFileStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_IsolatedWindowsEnvironmentShareFolderStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_IsolatedWindowsEnvironmentShareFolderStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_IsolatedWindowsEnvironmentShareFolderStatus = type;
        Py_INCREF(state->type_IsolatedWindowsEnvironmentShareFolderStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_IsolatedWindowsEnvironmentSignInProgress(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_IsolatedWindowsEnvironmentSignInProgress)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_IsolatedWindowsEnvironmentSignInProgress = type;
        Py_INCREF(state->type_IsolatedWindowsEnvironmentSignInProgress);


        Py_RETURN_NONE;
    }

    static PyObject* register_IsolatedWindowsEnvironmentStartProcessStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_IsolatedWindowsEnvironmentStartProcessStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_IsolatedWindowsEnvironmentStartProcessStatus = type;
        Py_INCREF(state->type_IsolatedWindowsEnvironmentStartProcessStatus);


        Py_RETURN_NONE;
    }

    // ----- IsolatedWindowsEnvironment class --------------------
    static constexpr const char* const type_name_IsolatedWindowsEnvironment = "IsolatedWindowsEnvironment";

    static PyObject* _new_IsolatedWindowsEnvironment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_IsolatedWindowsEnvironment);
        return nullptr;
    }

    static void _dealloc_IsolatedWindowsEnvironment(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironment* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironment_ChangePriority(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"ChangePriority", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreationPriority>(args, 0);

                self->obj.ChangePriority(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironment_CreateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"CreateAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions>(args, 0);

                return py::convert(winrt::Windows::Security::Isolation::IsolatedWindowsEnvironment::CreateAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"CreateAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters>(args, 1);

                return py::convert(winrt::Windows::Security::Isolation::IsolatedWindowsEnvironment::CreateAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironment_FindByOwnerId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"FindByOwnerId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Isolation::IsolatedWindowsEnvironment::FindByOwnerId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironment_GetById(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"GetById", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Isolation::IsolatedWindowsEnvironment::GetById(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironment_GetUserInfo(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"GetUserInfo", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetUserInfo());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironment_LaunchFileWithUIAsync(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"LaunchFileWithUIAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.LaunchFileWithUIAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"LaunchFileWithUIAsync", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters>(args, 3);

                return py::convert(self->obj.LaunchFileWithUIAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironment_PostMessageToReceiverAsync(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"PostMessageToReceiverAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::IInspectable>>(args, 1);

                return py::convert(self->obj.PostMessageToReceiverAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"PostMessageToReceiverAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::IInspectable>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters>(args, 2);

                return py::convert(self->obj.PostMessageToReceiverAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironment_RegisterMessageReceiver(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"RegisterMessageReceiver", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Isolation::MessageReceivedCallback>(args, 1);

                self->obj.RegisterMessageReceiver(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironment_ShareFileAsync(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"ShareFileAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileRequestOptions>(args, 1);

                return py::convert(self->obj.ShareFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"ShareFileAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileRequestOptions>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters>(args, 2);

                return py::convert(self->obj.ShareFileAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironment_ShareFolderAsync(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"ShareFolderAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderRequestOptions>(args, 1);

                return py::convert(self->obj.ShareFolderAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"ShareFolderAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderRequestOptions>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters>(args, 2);

                return py::convert(self->obj.ShareFolderAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironment_StartProcessSilentlyAsync(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"StartProcessSilentlyAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentActivator>(args, 2);

                return py::convert(self->obj.StartProcessSilentlyAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"StartProcessSilentlyAsync", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentActivator>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters>(args, 3);

                return py::convert(self->obj.StartProcessSilentlyAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironment_TerminateAsync(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"TerminateAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TerminateAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"TerminateAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters>(args, 0);

                return py::convert(self->obj.TerminateAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironment_UnregisterMessageReceiver(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"UnregisterMessageReceiver", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.UnregisterMessageReceiver(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironment_get_Id(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironment[] = {
        { "change_priority", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironment_ChangePriority), METH_VARARGS, nullptr },
        { "create_async", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironment_CreateAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "find_by_owner_id", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironment_FindByOwnerId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_by_id", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironment_GetById), METH_VARARGS | METH_STATIC, nullptr },
        { "get_user_info", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironment_GetUserInfo), METH_VARARGS, nullptr },
        { "launch_file_with_u_i_async", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironment_LaunchFileWithUIAsync), METH_VARARGS, nullptr },
        { "post_message_to_receiver_async", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironment_PostMessageToReceiverAsync), METH_VARARGS, nullptr },
        { "register_message_receiver", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironment_RegisterMessageReceiver), METH_VARARGS, nullptr },
        { "share_file_async", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironment_ShareFileAsync), METH_VARARGS, nullptr },
        { "share_folder_async", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironment_ShareFolderAsync), METH_VARARGS, nullptr },
        { "start_process_silently_async", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironment_StartProcessSilentlyAsync), METH_VARARGS, nullptr },
        { "terminate_async", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironment_TerminateAsync), METH_VARARGS, nullptr },
        { "unregister_message_receiver", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironment_UnregisterMessageReceiver), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironment[] = {
        { "id", reinterpret_cast<getter>(IsolatedWindowsEnvironment_get_Id), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironment[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironment) },
        { },
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironment =
    {
        "_winsdk_Windows_Security_Isolation.IsolatedWindowsEnvironment",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironment
    };

    // ----- IsolatedWindowsEnvironmentCreateResult class --------------------
    static constexpr const char* const type_name_IsolatedWindowsEnvironmentCreateResult = "IsolatedWindowsEnvironmentCreateResult";

    static PyObject* _new_IsolatedWindowsEnvironmentCreateResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_IsolatedWindowsEnvironmentCreateResult);
        return nullptr;
    }

    static void _dealloc_IsolatedWindowsEnvironmentCreateResult(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentCreateResult_ChangeCreationPriority(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentCreateResult", L"ChangeCreationPriority", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreationPriority>(args, 0);

                self->obj.ChangeCreationPriority(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentCreateResult_get_Environment(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentCreateResult", L"Environment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Environment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentCreateResult_get_ExtendedError(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentCreateResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentCreateResult_get_Status(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentCreateResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentCreateResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentCreateResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentCreateResult[] = {
        { "change_creation_priority", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironmentCreateResult_ChangeCreationPriority), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentCreateResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentCreateResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentCreateResult[] = {
        { "environment", reinterpret_cast<getter>(IsolatedWindowsEnvironmentCreateResult_get_Environment), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(IsolatedWindowsEnvironmentCreateResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IsolatedWindowsEnvironmentCreateResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentCreateResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentCreateResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentCreateResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentCreateResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentCreateResult) },
        { },
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentCreateResult =
    {
        "_winsdk_Windows_Security_Isolation.IsolatedWindowsEnvironmentCreateResult",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentCreateResult
    };

    // ----- IsolatedWindowsEnvironmentFile class --------------------
    static constexpr const char* const type_name_IsolatedWindowsEnvironmentFile = "IsolatedWindowsEnvironmentFile";

    static PyObject* _new_IsolatedWindowsEnvironmentFile(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_IsolatedWindowsEnvironmentFile);
        return nullptr;
    }

    static void _dealloc_IsolatedWindowsEnvironmentFile(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentFile* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentFile_Close(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentFile", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentFile_get_HostPath(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentFile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentFile", L"HostPath"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HostPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentFile_get_Id(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentFile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentFile", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentFile_get_GuestPath(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentFile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentFile", L"GuestPath"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.GuestPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentFile_get_IsReadOnly(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentFile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentFile", L"IsReadOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentFile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentFile>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentFile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentFile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentFile[] = {
        { "close", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironmentFile_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentFile, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentFile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentFile[] = {
        { "host_path", reinterpret_cast<getter>(IsolatedWindowsEnvironmentFile_get_HostPath), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(IsolatedWindowsEnvironmentFile_get_Id), nullptr, nullptr, nullptr },
        { "guest_path", reinterpret_cast<getter>(IsolatedWindowsEnvironmentFile_get_GuestPath), nullptr, nullptr, nullptr },
        { "is_read_only", reinterpret_cast<getter>(IsolatedWindowsEnvironmentFile_get_IsReadOnly), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentFile[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentFile) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentFile) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentFile) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentFile) },
        { },
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentFile =
    {
        "_winsdk_Windows_Security_Isolation.IsolatedWindowsEnvironmentFile",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentFile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentFile
    };

    // ----- IsolatedWindowsEnvironmentHost class --------------------
    static constexpr const char* const type_name_IsolatedWindowsEnvironmentHost = "IsolatedWindowsEnvironmentHost";

    static PyObject* _new_IsolatedWindowsEnvironmentHost(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_IsolatedWindowsEnvironmentHost);
        return nullptr;
    }

    static PyObject* IsolatedWindowsEnvironmentHost_get_HostErrors(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentHost", L"HostErrors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentHost::HostErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentHost_get_IsReady(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentHost", L"IsReady"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentHost::IsReady());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentHost[] = {
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentHost[] = {
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentHost[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentHost) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentHost) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentHost) },
        { },
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentHost =
    {
        "_winsdk_Windows_Security_Isolation.IsolatedWindowsEnvironmentHost",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentHost
    };

    static PyGetSetDef getset_IsolatedWindowsEnvironmentHost_Meta[] = {
        { "host_errors", reinterpret_cast<getter>(IsolatedWindowsEnvironmentHost_get_HostErrors), nullptr, nullptr, nullptr },
        { "is_ready", reinterpret_cast<getter>(IsolatedWindowsEnvironmentHost_get_IsReady), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_IsolatedWindowsEnvironmentHost_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_IsolatedWindowsEnvironmentHost_Meta) },
        { }
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentHost_Meta =
    {
        "_winsdk_Windows_Security_Isolation.IsolatedWindowsEnvironmentHost_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_IsolatedWindowsEnvironmentHost_Meta
    };

    // ----- IsolatedWindowsEnvironmentLaunchFileResult class --------------------
    static constexpr const char* const type_name_IsolatedWindowsEnvironmentLaunchFileResult = "IsolatedWindowsEnvironmentLaunchFileResult";

    static PyObject* _new_IsolatedWindowsEnvironmentLaunchFileResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_IsolatedWindowsEnvironmentLaunchFileResult);
        return nullptr;
    }

    static void _dealloc_IsolatedWindowsEnvironmentLaunchFileResult(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentLaunchFileResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentLaunchFileResult_get_ExtendedError(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentLaunchFileResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentLaunchFileResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentLaunchFileResult_get_File(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentLaunchFileResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentLaunchFileResult", L"File"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.File());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentLaunchFileResult_get_Status(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentLaunchFileResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentLaunchFileResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentLaunchFileResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentLaunchFileResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentLaunchFileResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentLaunchFileResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentLaunchFileResult[] = {
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentLaunchFileResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentLaunchFileResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentLaunchFileResult[] = {
        { "extended_error", reinterpret_cast<getter>(IsolatedWindowsEnvironmentLaunchFileResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "file", reinterpret_cast<getter>(IsolatedWindowsEnvironmentLaunchFileResult_get_File), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IsolatedWindowsEnvironmentLaunchFileResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentLaunchFileResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentLaunchFileResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentLaunchFileResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentLaunchFileResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentLaunchFileResult) },
        { },
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentLaunchFileResult =
    {
        "_winsdk_Windows_Security_Isolation.IsolatedWindowsEnvironmentLaunchFileResult",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentLaunchFileResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentLaunchFileResult
    };

    // ----- IsolatedWindowsEnvironmentOptions class --------------------
    static constexpr const char* const type_name_IsolatedWindowsEnvironmentOptions = "IsolatedWindowsEnvironmentOptions";

    static PyObject* _new_IsolatedWindowsEnvironmentOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_IsolatedWindowsEnvironmentOptions(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_ShareHostFolderForUntrustedItems(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"ShareHostFolderForUntrustedItems", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.ShareHostFolderForUntrustedItems(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_get_PersistUserProfile(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"PersistUserProfile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PersistUserProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentOptions_put_PersistUserProfile(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"PersistUserProfile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.PersistUserProfile(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_get_EnvironmentOwnerId(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"EnvironmentOwnerId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EnvironmentOwnerId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentOptions_put_EnvironmentOwnerId(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"EnvironmentOwnerId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.EnvironmentOwnerId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_get_ClipboardCopyPasteDirections(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"ClipboardCopyPasteDirections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ClipboardCopyPasteDirections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentOptions_put_ClipboardCopyPasteDirections(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"ClipboardCopyPasteDirections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentClipboardCopyPasteDirections>(arg);

            self->obj.ClipboardCopyPasteDirections(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_get_AvailablePrinters(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"AvailablePrinters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AvailablePrinters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentOptions_put_AvailablePrinters(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"AvailablePrinters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentAvailablePrinters>(arg);

            self->obj.AvailablePrinters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_get_AllowedClipboardFormats(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"AllowedClipboardFormats"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowedClipboardFormats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentOptions_put_AllowedClipboardFormats(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"AllowedClipboardFormats"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentAllowedClipboardFormats>(arg);

            self->obj.AllowedClipboardFormats(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_get_AllowGraphicsHardwareAcceleration(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"AllowGraphicsHardwareAcceleration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowGraphicsHardwareAcceleration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentOptions_put_AllowGraphicsHardwareAcceleration(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"AllowGraphicsHardwareAcceleration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowGraphicsHardwareAcceleration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_get_AllowCameraAndMicrophoneAccess(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"AllowCameraAndMicrophoneAccess"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowCameraAndMicrophoneAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentOptions_put_AllowCameraAndMicrophoneAccess(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"AllowCameraAndMicrophoneAccess"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowCameraAndMicrophoneAccess(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_get_SharedFolderNameInEnvironment(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"SharedFolderNameInEnvironment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SharedFolderNameInEnvironment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_get_SharedHostFolderPath(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"SharedHostFolderPath"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SharedHostFolderPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_get_WindowAnnotationOverride(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"WindowAnnotationOverride"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WindowAnnotationOverride());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentOptions_put_WindowAnnotationOverride(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"WindowAnnotationOverride"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.WindowAnnotationOverride(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_get_CreationPriority(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"CreationPriority"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CreationPriority());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentOptions_put_CreationPriority(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"CreationPriority"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreationPriority>(arg);

            self->obj.CreationPriority(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_get_AllowedClipboardFormatsToHost(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"AllowedClipboardFormatsToHost"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowedClipboardFormatsToHost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentOptions_put_AllowedClipboardFormatsToHost(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"AllowedClipboardFormatsToHost"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentAllowedClipboardFormats>(arg);

            self->obj.AllowedClipboardFormatsToHost(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_get_AllowedClipboardFormatsToEnvironment(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"AllowedClipboardFormatsToEnvironment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowedClipboardFormatsToEnvironment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentOptions_put_AllowedClipboardFormatsToEnvironment(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"AllowedClipboardFormatsToEnvironment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentAllowedClipboardFormats>(arg);

            self->obj.AllowedClipboardFormatsToEnvironment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentOptions[] = {
        { "share_host_folder_for_untrusted_items", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironmentOptions_ShareHostFolderForUntrustedItems), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentOptions[] = {
        { "persist_user_profile", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOptions_get_PersistUserProfile), reinterpret_cast<setter>(IsolatedWindowsEnvironmentOptions_put_PersistUserProfile), nullptr, nullptr },
        { "environment_owner_id", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOptions_get_EnvironmentOwnerId), reinterpret_cast<setter>(IsolatedWindowsEnvironmentOptions_put_EnvironmentOwnerId), nullptr, nullptr },
        { "clipboard_copy_paste_directions", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOptions_get_ClipboardCopyPasteDirections), reinterpret_cast<setter>(IsolatedWindowsEnvironmentOptions_put_ClipboardCopyPasteDirections), nullptr, nullptr },
        { "available_printers", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOptions_get_AvailablePrinters), reinterpret_cast<setter>(IsolatedWindowsEnvironmentOptions_put_AvailablePrinters), nullptr, nullptr },
        { "allowed_clipboard_formats", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOptions_get_AllowedClipboardFormats), reinterpret_cast<setter>(IsolatedWindowsEnvironmentOptions_put_AllowedClipboardFormats), nullptr, nullptr },
        { "allow_graphics_hardware_acceleration", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOptions_get_AllowGraphicsHardwareAcceleration), reinterpret_cast<setter>(IsolatedWindowsEnvironmentOptions_put_AllowGraphicsHardwareAcceleration), nullptr, nullptr },
        { "allow_camera_and_microphone_access", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOptions_get_AllowCameraAndMicrophoneAccess), reinterpret_cast<setter>(IsolatedWindowsEnvironmentOptions_put_AllowCameraAndMicrophoneAccess), nullptr, nullptr },
        { "shared_folder_name_in_environment", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOptions_get_SharedFolderNameInEnvironment), nullptr, nullptr, nullptr },
        { "shared_host_folder_path", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOptions_get_SharedHostFolderPath), nullptr, nullptr, nullptr },
        { "window_annotation_override", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOptions_get_WindowAnnotationOverride), reinterpret_cast<setter>(IsolatedWindowsEnvironmentOptions_put_WindowAnnotationOverride), nullptr, nullptr },
        { "creation_priority", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOptions_get_CreationPriority), reinterpret_cast<setter>(IsolatedWindowsEnvironmentOptions_put_CreationPriority), nullptr, nullptr },
        { "allowed_clipboard_formats_to_host", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOptions_get_AllowedClipboardFormatsToHost), reinterpret_cast<setter>(IsolatedWindowsEnvironmentOptions_put_AllowedClipboardFormatsToHost), nullptr, nullptr },
        { "allowed_clipboard_formats_to_environment", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOptions_get_AllowedClipboardFormatsToEnvironment), reinterpret_cast<setter>(IsolatedWindowsEnvironmentOptions_put_AllowedClipboardFormatsToEnvironment), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentOptions) },
        { },
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentOptions =
    {
        "_winsdk_Windows_Security_Isolation.IsolatedWindowsEnvironmentOptions",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentOptions
    };

    // ----- IsolatedWindowsEnvironmentOwnerRegistration class --------------------
    static constexpr const char* const type_name_IsolatedWindowsEnvironmentOwnerRegistration = "IsolatedWindowsEnvironmentOwnerRegistration";

    static PyObject* _new_IsolatedWindowsEnvironmentOwnerRegistration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_IsolatedWindowsEnvironmentOwnerRegistration);
        return nullptr;
    }

    static PyObject* IsolatedWindowsEnvironmentOwnerRegistration_Register(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOwnerRegistration", L"Register", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationData>(args, 1);

                return py::convert(winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistration::Register(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOwnerRegistration_Unregister(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOwnerRegistration", L"Unregister", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistration::Unregister(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentOwnerRegistration[] = {
        { "register", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironmentOwnerRegistration_Register), METH_VARARGS | METH_STATIC, nullptr },
        { "unregister", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironmentOwnerRegistration_Unregister), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentOwnerRegistration[] = {
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentOwnerRegistration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentOwnerRegistration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentOwnerRegistration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentOwnerRegistration) },
        { },
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentOwnerRegistration =
    {
        "_winsdk_Windows_Security_Isolation.IsolatedWindowsEnvironmentOwnerRegistration",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentOwnerRegistration
    };

    // ----- IsolatedWindowsEnvironmentOwnerRegistrationData class --------------------
    static constexpr const char* const type_name_IsolatedWindowsEnvironmentOwnerRegistrationData = "IsolatedWindowsEnvironmentOwnerRegistrationData";

    static PyObject* _new_IsolatedWindowsEnvironmentOwnerRegistrationData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationData instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_IsolatedWindowsEnvironmentOwnerRegistrationData(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationData* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentOwnerRegistrationData_get_ActivationFileExtensions(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOwnerRegistrationData", L"ActivationFileExtensions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivationFileExtensions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOwnerRegistrationData_get_ProcessesRunnableAsSystem(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOwnerRegistrationData", L"ProcessesRunnableAsSystem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProcessesRunnableAsSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOwnerRegistrationData_get_ProcessesRunnableAsUser(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOwnerRegistrationData", L"ProcessesRunnableAsUser"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProcessesRunnableAsUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOwnerRegistrationData_get_ShareableFolders(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOwnerRegistrationData", L"ShareableFolders"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShareableFolders());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentOwnerRegistrationData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentOwnerRegistrationData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentOwnerRegistrationData[] = {
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentOwnerRegistrationData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentOwnerRegistrationData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentOwnerRegistrationData[] = {
        { "activation_file_extensions", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOwnerRegistrationData_get_ActivationFileExtensions), nullptr, nullptr, nullptr },
        { "processes_runnable_as_system", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOwnerRegistrationData_get_ProcessesRunnableAsSystem), nullptr, nullptr, nullptr },
        { "processes_runnable_as_user", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOwnerRegistrationData_get_ProcessesRunnableAsUser), nullptr, nullptr, nullptr },
        { "shareable_folders", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOwnerRegistrationData_get_ShareableFolders), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentOwnerRegistrationData[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentOwnerRegistrationData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentOwnerRegistrationData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentOwnerRegistrationData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentOwnerRegistrationData) },
        { },
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentOwnerRegistrationData =
    {
        "_winsdk_Windows_Security_Isolation.IsolatedWindowsEnvironmentOwnerRegistrationData",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentOwnerRegistrationData
    };

    // ----- IsolatedWindowsEnvironmentOwnerRegistrationResult class --------------------
    static constexpr const char* const type_name_IsolatedWindowsEnvironmentOwnerRegistrationResult = "IsolatedWindowsEnvironmentOwnerRegistrationResult";

    static PyObject* _new_IsolatedWindowsEnvironmentOwnerRegistrationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_IsolatedWindowsEnvironmentOwnerRegistrationResult);
        return nullptr;
    }

    static void _dealloc_IsolatedWindowsEnvironmentOwnerRegistrationResult(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentOwnerRegistrationResult_get_ExtendedError(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOwnerRegistrationResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOwnerRegistrationResult_get_Status(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOwnerRegistrationResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentOwnerRegistrationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentOwnerRegistrationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentOwnerRegistrationResult[] = {
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentOwnerRegistrationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentOwnerRegistrationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentOwnerRegistrationResult[] = {
        { "extended_error", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOwnerRegistrationResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOwnerRegistrationResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentOwnerRegistrationResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentOwnerRegistrationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentOwnerRegistrationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentOwnerRegistrationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentOwnerRegistrationResult) },
        { },
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentOwnerRegistrationResult =
    {
        "_winsdk_Windows_Security_Isolation.IsolatedWindowsEnvironmentOwnerRegistrationResult",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentOwnerRegistrationResult
    };

    // ----- IsolatedWindowsEnvironmentPostMessageResult class --------------------
    static constexpr const char* const type_name_IsolatedWindowsEnvironmentPostMessageResult = "IsolatedWindowsEnvironmentPostMessageResult";

    static PyObject* _new_IsolatedWindowsEnvironmentPostMessageResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_IsolatedWindowsEnvironmentPostMessageResult);
        return nullptr;
    }

    static void _dealloc_IsolatedWindowsEnvironmentPostMessageResult(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentPostMessageResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentPostMessageResult_get_ExtendedError(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentPostMessageResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentPostMessageResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentPostMessageResult_get_Status(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentPostMessageResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentPostMessageResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentPostMessageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentPostMessageResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentPostMessageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentPostMessageResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentPostMessageResult[] = {
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentPostMessageResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentPostMessageResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentPostMessageResult[] = {
        { "extended_error", reinterpret_cast<getter>(IsolatedWindowsEnvironmentPostMessageResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IsolatedWindowsEnvironmentPostMessageResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentPostMessageResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentPostMessageResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentPostMessageResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentPostMessageResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentPostMessageResult) },
        { },
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentPostMessageResult =
    {
        "_winsdk_Windows_Security_Isolation.IsolatedWindowsEnvironmentPostMessageResult",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentPostMessageResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentPostMessageResult
    };

    // ----- IsolatedWindowsEnvironmentProcess class --------------------
    static constexpr const char* const type_name_IsolatedWindowsEnvironmentProcess = "IsolatedWindowsEnvironmentProcess";

    static PyObject* _new_IsolatedWindowsEnvironmentProcess(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_IsolatedWindowsEnvironmentProcess);
        return nullptr;
    }

    static void _dealloc_IsolatedWindowsEnvironmentProcess(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentProcess* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentProcess_WaitForExit(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentProcess* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentProcess", L"WaitForExit", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.WaitForExit();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentProcess_WaitForExitAsync(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentProcess* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentProcess", L"WaitForExitAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.WaitForExitAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentProcess_WaitForExitWithTimeout(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentProcess* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentProcess", L"WaitForExitWithTimeout", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.WaitForExitWithTimeout(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentProcess_get_ExitCode(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentProcess* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentProcess", L"ExitCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExitCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentProcess_get_State(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentProcess* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentProcess", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentProcess(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentProcess>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentProcess(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentProcess>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentProcess[] = {
        { "wait_for_exit", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironmentProcess_WaitForExit), METH_VARARGS, nullptr },
        { "wait_for_exit_async", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironmentProcess_WaitForExitAsync), METH_VARARGS, nullptr },
        { "wait_for_exit_with_timeout", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironmentProcess_WaitForExitWithTimeout), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentProcess, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentProcess), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentProcess[] = {
        { "exit_code", reinterpret_cast<getter>(IsolatedWindowsEnvironmentProcess_get_ExitCode), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(IsolatedWindowsEnvironmentProcess_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentProcess[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentProcess) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentProcess) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentProcess) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentProcess) },
        { },
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentProcess =
    {
        "_winsdk_Windows_Security_Isolation.IsolatedWindowsEnvironmentProcess",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentProcess),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentProcess
    };

    // ----- IsolatedWindowsEnvironmentShareFileRequestOptions class --------------------
    static constexpr const char* const type_name_IsolatedWindowsEnvironmentShareFileRequestOptions = "IsolatedWindowsEnvironmentShareFileRequestOptions";

    static PyObject* _new_IsolatedWindowsEnvironmentShareFileRequestOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileRequestOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_IsolatedWindowsEnvironmentShareFileRequestOptions(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileRequestOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentShareFileRequestOptions_get_AllowWrite(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileRequestOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentShareFileRequestOptions", L"AllowWrite"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowWrite());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentShareFileRequestOptions_put_AllowWrite(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileRequestOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentShareFileRequestOptions", L"AllowWrite"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowWrite(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentShareFileRequestOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileRequestOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentShareFileRequestOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileRequestOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentShareFileRequestOptions[] = {
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentShareFileRequestOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentShareFileRequestOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentShareFileRequestOptions[] = {
        { "allow_write", reinterpret_cast<getter>(IsolatedWindowsEnvironmentShareFileRequestOptions_get_AllowWrite), reinterpret_cast<setter>(IsolatedWindowsEnvironmentShareFileRequestOptions_put_AllowWrite), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentShareFileRequestOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentShareFileRequestOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentShareFileRequestOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentShareFileRequestOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentShareFileRequestOptions) },
        { },
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentShareFileRequestOptions =
    {
        "_winsdk_Windows_Security_Isolation.IsolatedWindowsEnvironmentShareFileRequestOptions",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileRequestOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentShareFileRequestOptions
    };

    // ----- IsolatedWindowsEnvironmentShareFileResult class --------------------
    static constexpr const char* const type_name_IsolatedWindowsEnvironmentShareFileResult = "IsolatedWindowsEnvironmentShareFileResult";

    static PyObject* _new_IsolatedWindowsEnvironmentShareFileResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_IsolatedWindowsEnvironmentShareFileResult);
        return nullptr;
    }

    static void _dealloc_IsolatedWindowsEnvironmentShareFileResult(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentShareFileResult_get_ExtendedError(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentShareFileResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentShareFileResult_get_File(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentShareFileResult", L"File"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.File());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentShareFileResult_get_Status(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentShareFileResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentShareFileResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentShareFileResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentShareFileResult[] = {
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentShareFileResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentShareFileResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentShareFileResult[] = {
        { "extended_error", reinterpret_cast<getter>(IsolatedWindowsEnvironmentShareFileResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "file", reinterpret_cast<getter>(IsolatedWindowsEnvironmentShareFileResult_get_File), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IsolatedWindowsEnvironmentShareFileResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentShareFileResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentShareFileResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentShareFileResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentShareFileResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentShareFileResult) },
        { },
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentShareFileResult =
    {
        "_winsdk_Windows_Security_Isolation.IsolatedWindowsEnvironmentShareFileResult",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentShareFileResult
    };

    // ----- IsolatedWindowsEnvironmentShareFolderRequestOptions class --------------------
    static constexpr const char* const type_name_IsolatedWindowsEnvironmentShareFolderRequestOptions = "IsolatedWindowsEnvironmentShareFolderRequestOptions";

    static PyObject* _new_IsolatedWindowsEnvironmentShareFolderRequestOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderRequestOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_IsolatedWindowsEnvironmentShareFolderRequestOptions(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderRequestOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentShareFolderRequestOptions_get_AllowWrite(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderRequestOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentShareFolderRequestOptions", L"AllowWrite"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowWrite());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentShareFolderRequestOptions_put_AllowWrite(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderRequestOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentShareFolderRequestOptions", L"AllowWrite"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowWrite(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentShareFolderRequestOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderRequestOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentShareFolderRequestOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderRequestOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentShareFolderRequestOptions[] = {
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentShareFolderRequestOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentShareFolderRequestOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentShareFolderRequestOptions[] = {
        { "allow_write", reinterpret_cast<getter>(IsolatedWindowsEnvironmentShareFolderRequestOptions_get_AllowWrite), reinterpret_cast<setter>(IsolatedWindowsEnvironmentShareFolderRequestOptions_put_AllowWrite), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentShareFolderRequestOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentShareFolderRequestOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentShareFolderRequestOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentShareFolderRequestOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentShareFolderRequestOptions) },
        { },
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentShareFolderRequestOptions =
    {
        "_winsdk_Windows_Security_Isolation.IsolatedWindowsEnvironmentShareFolderRequestOptions",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderRequestOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentShareFolderRequestOptions
    };

    // ----- IsolatedWindowsEnvironmentShareFolderResult class --------------------
    static constexpr const char* const type_name_IsolatedWindowsEnvironmentShareFolderResult = "IsolatedWindowsEnvironmentShareFolderResult";

    static PyObject* _new_IsolatedWindowsEnvironmentShareFolderResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_IsolatedWindowsEnvironmentShareFolderResult);
        return nullptr;
    }

    static void _dealloc_IsolatedWindowsEnvironmentShareFolderResult(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentShareFolderResult_get_ExtendedError(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentShareFolderResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentShareFolderResult_get_Status(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentShareFolderResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentShareFolderResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentShareFolderResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentShareFolderResult[] = {
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentShareFolderResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentShareFolderResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentShareFolderResult[] = {
        { "extended_error", reinterpret_cast<getter>(IsolatedWindowsEnvironmentShareFolderResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IsolatedWindowsEnvironmentShareFolderResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentShareFolderResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentShareFolderResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentShareFolderResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentShareFolderResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentShareFolderResult) },
        { },
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentShareFolderResult =
    {
        "_winsdk_Windows_Security_Isolation.IsolatedWindowsEnvironmentShareFolderResult",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentShareFolderResult
    };

    // ----- IsolatedWindowsEnvironmentStartProcessResult class --------------------
    static constexpr const char* const type_name_IsolatedWindowsEnvironmentStartProcessResult = "IsolatedWindowsEnvironmentStartProcessResult";

    static PyObject* _new_IsolatedWindowsEnvironmentStartProcessResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_IsolatedWindowsEnvironmentStartProcessResult);
        return nullptr;
    }

    static void _dealloc_IsolatedWindowsEnvironmentStartProcessResult(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentStartProcessResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentStartProcessResult_get_ExtendedError(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentStartProcessResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentStartProcessResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentStartProcessResult_get_Process(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentStartProcessResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentStartProcessResult", L"Process"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Process());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentStartProcessResult_get_Status(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentStartProcessResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentStartProcessResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentStartProcessResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentStartProcessResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentStartProcessResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentStartProcessResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentStartProcessResult[] = {
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentStartProcessResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentStartProcessResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentStartProcessResult[] = {
        { "extended_error", reinterpret_cast<getter>(IsolatedWindowsEnvironmentStartProcessResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "process", reinterpret_cast<getter>(IsolatedWindowsEnvironmentStartProcessResult_get_Process), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IsolatedWindowsEnvironmentStartProcessResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentStartProcessResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentStartProcessResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentStartProcessResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentStartProcessResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentStartProcessResult) },
        { },
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentStartProcessResult =
    {
        "_winsdk_Windows_Security_Isolation.IsolatedWindowsEnvironmentStartProcessResult",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentStartProcessResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentStartProcessResult
    };

    // ----- IsolatedWindowsEnvironmentTelemetryParameters class --------------------
    static constexpr const char* const type_name_IsolatedWindowsEnvironmentTelemetryParameters = "IsolatedWindowsEnvironmentTelemetryParameters";

    static PyObject* _new_IsolatedWindowsEnvironmentTelemetryParameters(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_IsolatedWindowsEnvironmentTelemetryParameters(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentTelemetryParameters_get_CorrelationId(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentTelemetryParameters", L"CorrelationId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CorrelationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentTelemetryParameters_put_CorrelationId(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentTelemetryParameters", L"CorrelationId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::guid>(arg);

            self->obj.CorrelationId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentTelemetryParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentTelemetryParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentTelemetryParameters[] = {
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentTelemetryParameters, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentTelemetryParameters), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentTelemetryParameters[] = {
        { "correlation_id", reinterpret_cast<getter>(IsolatedWindowsEnvironmentTelemetryParameters_get_CorrelationId), reinterpret_cast<setter>(IsolatedWindowsEnvironmentTelemetryParameters_put_CorrelationId), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentTelemetryParameters[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentTelemetryParameters) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentTelemetryParameters) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentTelemetryParameters) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentTelemetryParameters) },
        { },
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentTelemetryParameters =
    {
        "_winsdk_Windows_Security_Isolation.IsolatedWindowsEnvironmentTelemetryParameters",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentTelemetryParameters
    };

    // ----- IsolatedWindowsEnvironmentUserInfo class --------------------
    static constexpr const char* const type_name_IsolatedWindowsEnvironmentUserInfo = "IsolatedWindowsEnvironmentUserInfo";

    static PyObject* _new_IsolatedWindowsEnvironmentUserInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_IsolatedWindowsEnvironmentUserInfo);
        return nullptr;
    }

    static void _dealloc_IsolatedWindowsEnvironmentUserInfo(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentUserInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentUserInfo_TryWaitForSignInAsync(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentUserInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentUserInfo", L"TryWaitForSignInAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryWaitForSignInAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentUserInfo_TryWaitForSignInWithProgressAsync(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentUserInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentUserInfo", L"TryWaitForSignInWithProgressAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryWaitForSignInWithProgressAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentUserInfo_get_EnvironmentUserName(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentUserInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentUserInfo", L"EnvironmentUserName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EnvironmentUserName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentUserInfo_get_EnvironmentUserSid(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentUserInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentUserInfo", L"EnvironmentUserSid"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EnvironmentUserSid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentUserInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentUserInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentUserInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentUserInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentUserInfo[] = {
        { "try_wait_for_sign_in_async", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironmentUserInfo_TryWaitForSignInAsync), METH_VARARGS, nullptr },
        { "try_wait_for_sign_in_with_progress_async", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironmentUserInfo_TryWaitForSignInWithProgressAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentUserInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentUserInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentUserInfo[] = {
        { "environment_user_name", reinterpret_cast<getter>(IsolatedWindowsEnvironmentUserInfo_get_EnvironmentUserName), nullptr, nullptr, nullptr },
        { "environment_user_sid", reinterpret_cast<getter>(IsolatedWindowsEnvironmentUserInfo_get_EnvironmentUserSid), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentUserInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentUserInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentUserInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentUserInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentUserInfo) },
        { },
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentUserInfo =
    {
        "_winsdk_Windows_Security_Isolation.IsolatedWindowsEnvironmentUserInfo",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentUserInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentUserInfo
    };

    // ----- IsolatedWindowsHostMessenger class --------------------
    static constexpr const char* const type_name_IsolatedWindowsHostMessenger = "IsolatedWindowsHostMessenger";

    static PyObject* _new_IsolatedWindowsHostMessenger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_IsolatedWindowsHostMessenger);
        return nullptr;
    }

    static PyObject* IsolatedWindowsHostMessenger_GetFileId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsHostMessenger", L"GetFileId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Isolation::IsolatedWindowsHostMessenger::GetFileId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsHostMessenger_PostMessageToReceiver(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsHostMessenger", L"PostMessageToReceiver", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::IInspectable>>(args, 1);

                winrt::Windows::Security::Isolation::IsolatedWindowsHostMessenger::PostMessageToReceiver(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsHostMessenger_RegisterHostMessageReceiver(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsHostMessenger", L"RegisterHostMessageReceiver", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Isolation::HostMessageReceivedCallback>(args, 1);

                winrt::Windows::Security::Isolation::IsolatedWindowsHostMessenger::RegisterHostMessageReceiver(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsHostMessenger_UnregisterHostMessageReceiver(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsHostMessenger", L"UnregisterHostMessageReceiver", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                winrt::Windows::Security::Isolation::IsolatedWindowsHostMessenger::UnregisterHostMessageReceiver(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsHostMessenger[] = {
        { "get_file_id", reinterpret_cast<PyCFunction>(IsolatedWindowsHostMessenger_GetFileId), METH_VARARGS | METH_STATIC, nullptr },
        { "post_message_to_receiver", reinterpret_cast<PyCFunction>(IsolatedWindowsHostMessenger_PostMessageToReceiver), METH_VARARGS | METH_STATIC, nullptr },
        { "register_host_message_receiver", reinterpret_cast<PyCFunction>(IsolatedWindowsHostMessenger_RegisterHostMessageReceiver), METH_VARARGS | METH_STATIC, nullptr },
        { "unregister_host_message_receiver", reinterpret_cast<PyCFunction>(IsolatedWindowsHostMessenger_UnregisterHostMessageReceiver), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsHostMessenger[] = {
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsHostMessenger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsHostMessenger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsHostMessenger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsHostMessenger) },
        { },
    };

    static PyType_Spec type_spec_IsolatedWindowsHostMessenger =
    {
        "_winsdk_Windows_Security_Isolation.IsolatedWindowsHostMessenger",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsHostMessenger
    };

    // ----- IsolatedWindowsEnvironmentCreateProgress struct --------------------
    static constexpr const char* const type_name_IsolatedWindowsEnvironmentCreateProgress = "IsolatedWindowsEnvironmentCreateProgress";

    PyObject* _new_IsolatedWindowsEnvironmentCreateProgress(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        int32_t _State{};
        uint32_t _PercentComplete{};

        static const char* kwlist[] = {"state", "percent_complete", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "iI", const_cast<char**>(kwlist), &_State, &_PercentComplete))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress return_value{ static_cast<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentProgressState>(_State), _PercentComplete };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_IsolatedWindowsEnvironmentCreateProgress(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress* self) noexcept
    {
    }

    static PyObject* IsolatedWindowsEnvironmentCreateProgress_get_State(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentCreateProgress_set_State(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.State = py::converter<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentProgressState>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentCreateProgress_get_PercentComplete(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PercentComplete);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentCreateProgress_set_PercentComplete(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PercentComplete = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentCreateProgress[] = {
        { "state", reinterpret_cast<getter>(IsolatedWindowsEnvironmentCreateProgress_get_State), reinterpret_cast<setter>(IsolatedWindowsEnvironmentCreateProgress_set_State), nullptr, nullptr },
        { "percent_complete", reinterpret_cast<getter>(IsolatedWindowsEnvironmentCreateProgress_get_PercentComplete), reinterpret_cast<setter>(IsolatedWindowsEnvironmentCreateProgress_set_PercentComplete), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentCreateProgress[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentCreateProgress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentCreateProgress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentCreateProgress) },
        { },
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentCreateProgress =
    {
        "_winsdk_Windows_Security_Isolation.IsolatedWindowsEnvironmentCreateProgress",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentCreateProgress
    };

    // ----- Windows.Security.Isolation Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Security::Isolation");

    static PyMethodDef module_methods[] = {
        {"_register_IsolatedWindowsEnvironmentActivator", register_IsolatedWindowsEnvironmentActivator, METH_O, "registers type"},
        {"_register_IsolatedWindowsEnvironmentAllowedClipboardFormats", register_IsolatedWindowsEnvironmentAllowedClipboardFormats, METH_O, "registers type"},
        {"_register_IsolatedWindowsEnvironmentAvailablePrinters", register_IsolatedWindowsEnvironmentAvailablePrinters, METH_O, "registers type"},
        {"_register_IsolatedWindowsEnvironmentClipboardCopyPasteDirections", register_IsolatedWindowsEnvironmentClipboardCopyPasteDirections, METH_O, "registers type"},
        {"_register_IsolatedWindowsEnvironmentCreateStatus", register_IsolatedWindowsEnvironmentCreateStatus, METH_O, "registers type"},
        {"_register_IsolatedWindowsEnvironmentCreationPriority", register_IsolatedWindowsEnvironmentCreationPriority, METH_O, "registers type"},
        {"_register_IsolatedWindowsEnvironmentHostError", register_IsolatedWindowsEnvironmentHostError, METH_O, "registers type"},
        {"_register_IsolatedWindowsEnvironmentLaunchFileStatus", register_IsolatedWindowsEnvironmentLaunchFileStatus, METH_O, "registers type"},
        {"_register_IsolatedWindowsEnvironmentOwnerRegistrationStatus", register_IsolatedWindowsEnvironmentOwnerRegistrationStatus, METH_O, "registers type"},
        {"_register_IsolatedWindowsEnvironmentPostMessageStatus", register_IsolatedWindowsEnvironmentPostMessageStatus, METH_O, "registers type"},
        {"_register_IsolatedWindowsEnvironmentProcessState", register_IsolatedWindowsEnvironmentProcessState, METH_O, "registers type"},
        {"_register_IsolatedWindowsEnvironmentProgressState", register_IsolatedWindowsEnvironmentProgressState, METH_O, "registers type"},
        {"_register_IsolatedWindowsEnvironmentShareFileStatus", register_IsolatedWindowsEnvironmentShareFileStatus, METH_O, "registers type"},
        {"_register_IsolatedWindowsEnvironmentShareFolderStatus", register_IsolatedWindowsEnvironmentShareFolderStatus, METH_O, "registers type"},
        {"_register_IsolatedWindowsEnvironmentSignInProgress", register_IsolatedWindowsEnvironmentSignInProgress, METH_O, "registers type"},
        {"_register_IsolatedWindowsEnvironmentStartProcessStatus", register_IsolatedWindowsEnvironmentStartProcessStatus, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_IsolatedWindowsEnvironmentActivator);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentAllowedClipboardFormats);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentAvailablePrinters);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentClipboardCopyPasteDirections);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentCreateStatus);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentCreationPriority);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentHostError);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentLaunchFileStatus);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentOwnerRegistrationStatus);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentPostMessageStatus);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentProcessState);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentProgressState);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentShareFileStatus);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentShareFolderStatus);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentSignInProgress);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentStartProcessStatus);
        Py_VISIT(state->type_IsolatedWindowsEnvironment);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentCreateResult);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentFile);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentHost);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentLaunchFileResult);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentOptions);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentOwnerRegistration);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentOwnerRegistrationData);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentOwnerRegistrationResult);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentPostMessageResult);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentProcess);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentShareFileRequestOptions);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentShareFileResult);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentShareFolderRequestOptions);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentShareFolderResult);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentStartProcessResult);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentTelemetryParameters);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentUserInfo);
        Py_VISIT(state->type_IsolatedWindowsHostMessenger);
        Py_VISIT(state->type_IsolatedWindowsEnvironmentCreateProgress);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_IsolatedWindowsEnvironmentActivator);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentAllowedClipboardFormats);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentAvailablePrinters);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentClipboardCopyPasteDirections);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentCreateStatus);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentCreationPriority);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentHostError);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentLaunchFileStatus);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentOwnerRegistrationStatus);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentPostMessageStatus);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentProcessState);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentProgressState);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentShareFileStatus);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentShareFolderStatus);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentSignInProgress);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentStartProcessStatus);
        Py_CLEAR(state->type_IsolatedWindowsEnvironment);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentCreateResult);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentFile);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentHost);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentLaunchFileResult);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentOptions);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentOwnerRegistration);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentOwnerRegistrationData);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentOwnerRegistrationResult);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentPostMessageResult);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentProcess);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentShareFileRequestOptions);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentShareFileResult);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentShareFolderRequestOptions);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentShareFolderResult);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentStartProcessResult);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentTelemetryParameters);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentUserInfo);
        Py_CLEAR(state->type_IsolatedWindowsHostMessenger);
        Py_CLEAR(state->type_IsolatedWindowsEnvironmentCreateProgress);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Security_Isolation",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Security::Isolation

PyMODINIT_FUNC PyInit__winsdk_Windows_Security_Isolation(void) noexcept
{
    using namespace py::cpp::Windows::Security::Isolation;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_IsolatedWindowsEnvironment = py::register_python_type(module.get(), type_name_IsolatedWindowsEnvironment, &type_spec_IsolatedWindowsEnvironment, bases.get(), nullptr);
    if (!state->type_IsolatedWindowsEnvironment)
    {
        return nullptr;
    }

    state->type_IsolatedWindowsEnvironmentCreateResult = py::register_python_type(module.get(), type_name_IsolatedWindowsEnvironmentCreateResult, &type_spec_IsolatedWindowsEnvironmentCreateResult, bases.get(), nullptr);
    if (!state->type_IsolatedWindowsEnvironmentCreateResult)
    {
        return nullptr;
    }

    state->type_IsolatedWindowsEnvironmentFile = py::register_python_type(module.get(), type_name_IsolatedWindowsEnvironmentFile, &type_spec_IsolatedWindowsEnvironmentFile, bases.get(), nullptr);
    if (!state->type_IsolatedWindowsEnvironmentFile)
    {
        return nullptr;
    }

    py::pyobj_handle type_IsolatedWindowsEnvironmentHost_Meta{PyType_FromSpec(&type_spec_IsolatedWindowsEnvironmentHost_Meta)};
    if (!type_IsolatedWindowsEnvironmentHost_Meta)
    {
        return nullptr;
    }

    state->type_IsolatedWindowsEnvironmentHost = py::register_python_type(module.get(), type_name_IsolatedWindowsEnvironmentHost, &type_spec_IsolatedWindowsEnvironmentHost, nullptr, reinterpret_cast<PyTypeObject*>(type_IsolatedWindowsEnvironmentHost_Meta.get()));
    if (!state->type_IsolatedWindowsEnvironmentHost)
    {
        return nullptr;
    }

    state->type_IsolatedWindowsEnvironmentLaunchFileResult = py::register_python_type(module.get(), type_name_IsolatedWindowsEnvironmentLaunchFileResult, &type_spec_IsolatedWindowsEnvironmentLaunchFileResult, bases.get(), nullptr);
    if (!state->type_IsolatedWindowsEnvironmentLaunchFileResult)
    {
        return nullptr;
    }

    state->type_IsolatedWindowsEnvironmentOptions = py::register_python_type(module.get(), type_name_IsolatedWindowsEnvironmentOptions, &type_spec_IsolatedWindowsEnvironmentOptions, bases.get(), nullptr);
    if (!state->type_IsolatedWindowsEnvironmentOptions)
    {
        return nullptr;
    }

    state->type_IsolatedWindowsEnvironmentOwnerRegistration = py::register_python_type(module.get(), type_name_IsolatedWindowsEnvironmentOwnerRegistration, &type_spec_IsolatedWindowsEnvironmentOwnerRegistration, nullptr, nullptr);
    if (!state->type_IsolatedWindowsEnvironmentOwnerRegistration)
    {
        return nullptr;
    }

    state->type_IsolatedWindowsEnvironmentOwnerRegistrationData = py::register_python_type(module.get(), type_name_IsolatedWindowsEnvironmentOwnerRegistrationData, &type_spec_IsolatedWindowsEnvironmentOwnerRegistrationData, bases.get(), nullptr);
    if (!state->type_IsolatedWindowsEnvironmentOwnerRegistrationData)
    {
        return nullptr;
    }

    state->type_IsolatedWindowsEnvironmentOwnerRegistrationResult = py::register_python_type(module.get(), type_name_IsolatedWindowsEnvironmentOwnerRegistrationResult, &type_spec_IsolatedWindowsEnvironmentOwnerRegistrationResult, bases.get(), nullptr);
    if (!state->type_IsolatedWindowsEnvironmentOwnerRegistrationResult)
    {
        return nullptr;
    }

    state->type_IsolatedWindowsEnvironmentPostMessageResult = py::register_python_type(module.get(), type_name_IsolatedWindowsEnvironmentPostMessageResult, &type_spec_IsolatedWindowsEnvironmentPostMessageResult, bases.get(), nullptr);
    if (!state->type_IsolatedWindowsEnvironmentPostMessageResult)
    {
        return nullptr;
    }

    state->type_IsolatedWindowsEnvironmentProcess = py::register_python_type(module.get(), type_name_IsolatedWindowsEnvironmentProcess, &type_spec_IsolatedWindowsEnvironmentProcess, bases.get(), nullptr);
    if (!state->type_IsolatedWindowsEnvironmentProcess)
    {
        return nullptr;
    }

    state->type_IsolatedWindowsEnvironmentShareFileRequestOptions = py::register_python_type(module.get(), type_name_IsolatedWindowsEnvironmentShareFileRequestOptions, &type_spec_IsolatedWindowsEnvironmentShareFileRequestOptions, bases.get(), nullptr);
    if (!state->type_IsolatedWindowsEnvironmentShareFileRequestOptions)
    {
        return nullptr;
    }

    state->type_IsolatedWindowsEnvironmentShareFileResult = py::register_python_type(module.get(), type_name_IsolatedWindowsEnvironmentShareFileResult, &type_spec_IsolatedWindowsEnvironmentShareFileResult, bases.get(), nullptr);
    if (!state->type_IsolatedWindowsEnvironmentShareFileResult)
    {
        return nullptr;
    }

    state->type_IsolatedWindowsEnvironmentShareFolderRequestOptions = py::register_python_type(module.get(), type_name_IsolatedWindowsEnvironmentShareFolderRequestOptions, &type_spec_IsolatedWindowsEnvironmentShareFolderRequestOptions, bases.get(), nullptr);
    if (!state->type_IsolatedWindowsEnvironmentShareFolderRequestOptions)
    {
        return nullptr;
    }

    state->type_IsolatedWindowsEnvironmentShareFolderResult = py::register_python_type(module.get(), type_name_IsolatedWindowsEnvironmentShareFolderResult, &type_spec_IsolatedWindowsEnvironmentShareFolderResult, bases.get(), nullptr);
    if (!state->type_IsolatedWindowsEnvironmentShareFolderResult)
    {
        return nullptr;
    }

    state->type_IsolatedWindowsEnvironmentStartProcessResult = py::register_python_type(module.get(), type_name_IsolatedWindowsEnvironmentStartProcessResult, &type_spec_IsolatedWindowsEnvironmentStartProcessResult, bases.get(), nullptr);
    if (!state->type_IsolatedWindowsEnvironmentStartProcessResult)
    {
        return nullptr;
    }

    state->type_IsolatedWindowsEnvironmentTelemetryParameters = py::register_python_type(module.get(), type_name_IsolatedWindowsEnvironmentTelemetryParameters, &type_spec_IsolatedWindowsEnvironmentTelemetryParameters, bases.get(), nullptr);
    if (!state->type_IsolatedWindowsEnvironmentTelemetryParameters)
    {
        return nullptr;
    }

    state->type_IsolatedWindowsEnvironmentUserInfo = py::register_python_type(module.get(), type_name_IsolatedWindowsEnvironmentUserInfo, &type_spec_IsolatedWindowsEnvironmentUserInfo, bases.get(), nullptr);
    if (!state->type_IsolatedWindowsEnvironmentUserInfo)
    {
        return nullptr;
    }

    state->type_IsolatedWindowsHostMessenger = py::register_python_type(module.get(), type_name_IsolatedWindowsHostMessenger, &type_spec_IsolatedWindowsHostMessenger, nullptr, nullptr);
    if (!state->type_IsolatedWindowsHostMessenger)
    {
        return nullptr;
    }

    state->type_IsolatedWindowsEnvironmentCreateProgress = py::register_python_type(module.get(), type_name_IsolatedWindowsEnvironmentCreateProgress, &type_spec_IsolatedWindowsEnvironmentCreateProgress, bases.get(), nullptr);
    if (!state->type_IsolatedWindowsEnvironmentCreateProgress)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentActivator>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentActivator;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentActivator is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentAllowedClipboardFormats>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentAllowedClipboardFormats;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentAllowedClipboardFormats is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentAvailablePrinters>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentAvailablePrinters;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentAvailablePrinters is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentClipboardCopyPasteDirections>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentClipboardCopyPasteDirections;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentClipboardCopyPasteDirections is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentCreateStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreationPriority>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentCreationPriority;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreationPriority is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentHostError>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentHostError;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentHostError is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentLaunchFileStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentLaunchFileStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentLaunchFileStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentOwnerRegistrationStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentPostMessageStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentPostMessageStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentPostMessageStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentProcessState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentProcessState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentProcessState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentProgressState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentProgressState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentProgressState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentShareFileStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentShareFolderStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentSignInProgress>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentSignInProgress;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentSignInProgress is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentStartProcessStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentStartProcessStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentStartProcessStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironment>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironment;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironment is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentCreateResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentFile>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentFile;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentFile is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentHost>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentHost;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentHost is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentLaunchFileResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentLaunchFileResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentLaunchFileResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistration>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentOwnerRegistration;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistration is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationData>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentOwnerRegistrationData;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationData is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentOwnerRegistrationResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentPostMessageResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentPostMessageResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentPostMessageResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentProcess>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentProcess;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentProcess is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileRequestOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentShareFileRequestOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileRequestOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentShareFileResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderRequestOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentShareFolderRequestOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderRequestOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentShareFolderResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentStartProcessResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentStartProcessResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentStartProcessResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentTelemetryParameters;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentUserInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentUserInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentUserInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Isolation::IsolatedWindowsHostMessenger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsHostMessenger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsHostMessenger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Isolation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Isolation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IsolatedWindowsEnvironmentCreateProgress;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress is not registered");
        return nullptr;
    }

    return python_type;
}
