// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.Phone.Notification.Management.h"


namespace py::cpp::Windows::Phone::Notification::Management
{
    struct module_state
    {
        PyObject* type_AccessoryNotificationType;
        PyObject* type_CalendarChangedEvent;
        PyObject* type_PhoneCallAudioEndpoint;
        PyObject* type_PhoneCallDirection;
        PyObject* type_PhoneCallState;
        PyObject* type_PhoneCallTransport;
        PyObject* type_PhoneLineRegistrationState;
        PyObject* type_PhoneMediaType;
        PyObject* type_PhoneNotificationType;
        PyObject* type_PlaybackCapability;
        PyObject* type_PlaybackCommand;
        PyObject* type_PlaybackStatus;
        PyObject* type_ReminderState;
        PyObject* type_VibrateState;
        PyTypeObject* type_AccessoryManager;
        PyTypeObject* type_AlarmNotificationTriggerDetails;
        PyTypeObject* type_AppNotificationInfo;
        PyTypeObject* type_BinaryId;
        PyTypeObject* type_CalendarChangedNotificationTriggerDetails;
        PyTypeObject* type_CortanaTileNotificationTriggerDetails;
        PyTypeObject* type_EmailAccountInfo;
        PyTypeObject* type_EmailFolderInfo;
        PyTypeObject* type_EmailNotificationTriggerDetails;
        PyTypeObject* type_EmailReadNotificationTriggerDetails;
        PyTypeObject* type_MediaControlsTriggerDetails;
        PyTypeObject* type_MediaMetadata;
        PyTypeObject* type_PhoneCallDetails;
        PyTypeObject* type_PhoneLineDetails;
        PyTypeObject* type_PhoneNotificationTriggerDetails;
        PyTypeObject* type_ReminderNotificationTriggerDetails;
        PyTypeObject* type_SpeedDialEntry;
        PyTypeObject* type_TextResponse;
        PyTypeObject* type_ToastNotificationTriggerDetails;
        PyTypeObject* type_VolumeInfo;
        PyTypeObject* type_IAccessoryNotificationTriggerDetails;
    };

    static PyObject* register_AccessoryNotificationType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AccessoryNotificationType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AccessoryNotificationType = type;
        Py_INCREF(state->type_AccessoryNotificationType);


        Py_RETURN_NONE;
    }

    static PyObject* register_CalendarChangedEvent(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CalendarChangedEvent)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CalendarChangedEvent = type;
        Py_INCREF(state->type_CalendarChangedEvent);


        Py_RETURN_NONE;
    }

    static PyObject* register_PhoneCallAudioEndpoint(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PhoneCallAudioEndpoint)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PhoneCallAudioEndpoint = type;
        Py_INCREF(state->type_PhoneCallAudioEndpoint);


        Py_RETURN_NONE;
    }

    static PyObject* register_PhoneCallDirection(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PhoneCallDirection)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PhoneCallDirection = type;
        Py_INCREF(state->type_PhoneCallDirection);


        Py_RETURN_NONE;
    }

    static PyObject* register_PhoneCallState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PhoneCallState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PhoneCallState = type;
        Py_INCREF(state->type_PhoneCallState);


        Py_RETURN_NONE;
    }

    static PyObject* register_PhoneCallTransport(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PhoneCallTransport)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PhoneCallTransport = type;
        Py_INCREF(state->type_PhoneCallTransport);


        Py_RETURN_NONE;
    }

    static PyObject* register_PhoneLineRegistrationState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PhoneLineRegistrationState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PhoneLineRegistrationState = type;
        Py_INCREF(state->type_PhoneLineRegistrationState);


        Py_RETURN_NONE;
    }

    static PyObject* register_PhoneMediaType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PhoneMediaType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PhoneMediaType = type;
        Py_INCREF(state->type_PhoneMediaType);


        Py_RETURN_NONE;
    }

    static PyObject* register_PhoneNotificationType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PhoneNotificationType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PhoneNotificationType = type;
        Py_INCREF(state->type_PhoneNotificationType);


        Py_RETURN_NONE;
    }

    static PyObject* register_PlaybackCapability(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PlaybackCapability)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PlaybackCapability = type;
        Py_INCREF(state->type_PlaybackCapability);


        Py_RETURN_NONE;
    }

    static PyObject* register_PlaybackCommand(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PlaybackCommand)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PlaybackCommand = type;
        Py_INCREF(state->type_PlaybackCommand);


        Py_RETURN_NONE;
    }

    static PyObject* register_PlaybackStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PlaybackStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PlaybackStatus = type;
        Py_INCREF(state->type_PlaybackStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_ReminderState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ReminderState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ReminderState = type;
        Py_INCREF(state->type_ReminderState);


        Py_RETURN_NONE;
    }

    static PyObject* register_VibrateState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_VibrateState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_VibrateState = type;
        Py_INCREF(state->type_VibrateState);


        Py_RETURN_NONE;
    }

    // ----- AccessoryManager class --------------------
    static constexpr const char* const type_name_AccessoryManager = "AccessoryManager";

    static PyObject* _new_AccessoryManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AccessoryManager);
        return nullptr;
    }

    static PyObject* AccessoryManager_AcceptPhoneCall(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"AcceptPhoneCall", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::AcceptPhoneCall(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"AcceptPhoneCall", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Phone::Notification::Management::PhoneCallAudioEndpoint>(args, 1);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::AcceptPhoneCall(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_AcceptPhoneCallWithVideo(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"AcceptPhoneCallWithVideo", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::AcceptPhoneCallWithVideo(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"AcceptPhoneCallWithVideo", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Phone::Notification::Management::PhoneCallAudioEndpoint>(args, 1);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::AcceptPhoneCallWithVideo(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_ClearToast(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"ClearToast", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::ClearToast(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_DecreaseVolume(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"DecreaseVolume", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::DecreaseVolume(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_DisableAllAccessoryNotificationTypes(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"DisableAllAccessoryNotificationTypes", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::Windows::Phone::Notification::Management::AccessoryManager::DisableAllAccessoryNotificationTypes();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_DisableEmailNotificationEmailAccount(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"DisableEmailNotificationEmailAccount", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::DisableEmailNotificationEmailAccount(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_DisableNotificationsForApplication(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"DisableNotificationsForApplication", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::DisableNotificationsForApplication(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_DismissAlarm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"DismissAlarm", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::DismissAlarm(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_DismissAlarmByInstanceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"DismissAlarmByInstanceId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::DismissAlarmByInstanceId(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_DismissReminder(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"DismissReminder", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::DismissReminder(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_DismissReminderByInstanceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"DismissReminderByInstanceId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::DismissReminderByInstanceId(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_EnableAccessoryNotificationTypes(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"EnableAccessoryNotificationTypes", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::EnableAccessoryNotificationTypes(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_EnableEmailNotificationEmailAccount(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"EnableEmailNotificationEmailAccount", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::EnableEmailNotificationEmailAccount(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_EnableEmailNotificationFolderFilter(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"EnableEmailNotificationFolderFilter", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring>>(args, 1);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::EnableEmailNotificationFolderFilter(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_EnableNotificationsForApplication(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"EnableNotificationsForApplication", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::EnableNotificationsForApplication(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_EndPhoneCall(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"EndPhoneCall", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::EndPhoneCall(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_GetAllEmailAccounts(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"GetAllEmailAccounts", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::GetAllEmailAccounts());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_GetAppIcon(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"GetAppIcon", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::GetAppIcon(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_GetApps(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"GetApps", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::GetApps());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_GetEnabledAccessoryNotificationTypes(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"GetEnabledAccessoryNotificationTypes", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::GetEnabledAccessoryNotificationTypes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_GetFolders(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"GetFolders", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::GetFolders(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_GetMediaMetadata(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"GetMediaMetadata", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::GetMediaMetadata());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_GetNextTriggerDetails(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"GetNextTriggerDetails", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::GetNextTriggerDetails());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_GetPhoneLineDetails(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"GetPhoneLineDetails", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::GetPhoneLineDetails(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_GetUserConsent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"GetUserConsent", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::GetUserConsent());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_HoldPhoneCall(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"HoldPhoneCall", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::HoldPhoneCall(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_IncreaseVolume(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"IncreaseVolume", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::IncreaseVolume(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_IsNotificationEnabledForApplication(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"IsNotificationEnabledForApplication", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::IsNotificationEnabledForApplication(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_MakePhoneCall(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"MakePhoneCall", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::MakePhoneCall(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"MakePhoneCall", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Phone::Notification::Management::PhoneCallAudioEndpoint>(args, 2);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::MakePhoneCall(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_MakePhoneCallWithVideo(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"MakePhoneCallWithVideo", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::MakePhoneCallWithVideo(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"MakePhoneCallWithVideo", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Phone::Notification::Management::PhoneCallAudioEndpoint>(args, 2);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::MakePhoneCallWithVideo(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_PerformMediaPlaybackCommand(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"PerformMediaPlaybackCommand", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Phone::Notification::Management::PlaybackCommand>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::PerformMediaPlaybackCommand(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_ProcessTriggerDetails(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"ProcessTriggerDetails", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Phone::Notification::Management::IAccessoryNotificationTriggerDetails>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::ProcessTriggerDetails(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_RegisterAccessoryApp(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"RegisterAccessoryApp", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::RegisterAccessoryApp());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_RejectPhoneCall(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"RejectPhoneCall", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::RejectPhoneCall(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"RejectPhoneCall", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::RejectPhoneCall(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_RingDevice(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"RingDevice", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::Windows::Phone::Notification::Management::AccessoryManager::RingDevice();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_SetMute(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"SetMute", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::SetMute(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_SetRingerVibrate(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"SetRingerVibrate", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::SetRingerVibrate(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_SnoozeAlarm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"SnoozeAlarm", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::SnoozeAlarm(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"SnoozeAlarm", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::SnoozeAlarm(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_SnoozeAlarmByInstanceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"SnoozeAlarmByInstanceId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::SnoozeAlarmByInstanceId(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_SnoozeReminder(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"SnoozeReminder", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::SnoozeReminder(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"SnoozeReminder", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::SnoozeReminder(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_SnoozeReminderByInstanceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"SnoozeReminderByInstanceId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::SnoozeReminderByInstanceId(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_SwapPhoneCalls(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"SwapPhoneCalls", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::SwapPhoneCalls(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_UpdateEmailReadStatus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"UpdateEmailReadStatus", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Phone::Notification::Management::BinaryId>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::UpdateEmailReadStatus(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_get_PhoneMute(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"PhoneMute"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::PhoneMute());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_put_PhoneMute(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"PhoneMute"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            winrt::Windows::Phone::Notification::Management::AccessoryManager::PhoneMute(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_get_PhoneCallAudioEndpoint(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"PhoneCallAudioEndpoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::PhoneCallAudioEndpoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_put_PhoneCallAudioEndpoint(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"PhoneCallAudioEndpoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Phone::Notification::Management::PhoneCallAudioEndpoint>(arg);

            winrt::Windows::Phone::Notification::Management::AccessoryManager::PhoneCallAudioEndpoint(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_get_BatterySaverState(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"BatterySaverState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::BatterySaverState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_get_DoNotDisturbEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"DoNotDisturbEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::DoNotDisturbEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_get_DrivingModeEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"DrivingModeEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::DrivingModeEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_get_MediaPlaybackCapabilities(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"MediaPlaybackCapabilities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::MediaPlaybackCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_get_MediaPlaybackStatus(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"MediaPlaybackStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::MediaPlaybackStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_get_PhoneLineDetails(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"PhoneLineDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::PhoneLineDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_get_IsPhonePinLocked(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"IsPhonePinLocked"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::IsPhonePinLocked());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_get_SpeedDialList(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"SpeedDialList"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::SpeedDialList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_get_VolumeInfo(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"VolumeInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::VolumeInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AccessoryManager[] = {
        { "accept_phone_call", reinterpret_cast<PyCFunction>(AccessoryManager_AcceptPhoneCall), METH_VARARGS | METH_STATIC, nullptr },
        { "accept_phone_call_with_video", reinterpret_cast<PyCFunction>(AccessoryManager_AcceptPhoneCallWithVideo), METH_VARARGS | METH_STATIC, nullptr },
        { "clear_toast", reinterpret_cast<PyCFunction>(AccessoryManager_ClearToast), METH_VARARGS | METH_STATIC, nullptr },
        { "decrease_volume", reinterpret_cast<PyCFunction>(AccessoryManager_DecreaseVolume), METH_VARARGS | METH_STATIC, nullptr },
        { "disable_all_accessory_notification_types", reinterpret_cast<PyCFunction>(AccessoryManager_DisableAllAccessoryNotificationTypes), METH_VARARGS | METH_STATIC, nullptr },
        { "disable_email_notification_email_account", reinterpret_cast<PyCFunction>(AccessoryManager_DisableEmailNotificationEmailAccount), METH_VARARGS | METH_STATIC, nullptr },
        { "disable_notifications_for_application", reinterpret_cast<PyCFunction>(AccessoryManager_DisableNotificationsForApplication), METH_VARARGS | METH_STATIC, nullptr },
        { "dismiss_alarm", reinterpret_cast<PyCFunction>(AccessoryManager_DismissAlarm), METH_VARARGS | METH_STATIC, nullptr },
        { "dismiss_alarm_by_instance_id", reinterpret_cast<PyCFunction>(AccessoryManager_DismissAlarmByInstanceId), METH_VARARGS | METH_STATIC, nullptr },
        { "dismiss_reminder", reinterpret_cast<PyCFunction>(AccessoryManager_DismissReminder), METH_VARARGS | METH_STATIC, nullptr },
        { "dismiss_reminder_by_instance_id", reinterpret_cast<PyCFunction>(AccessoryManager_DismissReminderByInstanceId), METH_VARARGS | METH_STATIC, nullptr },
        { "enable_accessory_notification_types", reinterpret_cast<PyCFunction>(AccessoryManager_EnableAccessoryNotificationTypes), METH_VARARGS | METH_STATIC, nullptr },
        { "enable_email_notification_email_account", reinterpret_cast<PyCFunction>(AccessoryManager_EnableEmailNotificationEmailAccount), METH_VARARGS | METH_STATIC, nullptr },
        { "enable_email_notification_folder_filter", reinterpret_cast<PyCFunction>(AccessoryManager_EnableEmailNotificationFolderFilter), METH_VARARGS | METH_STATIC, nullptr },
        { "enable_notifications_for_application", reinterpret_cast<PyCFunction>(AccessoryManager_EnableNotificationsForApplication), METH_VARARGS | METH_STATIC, nullptr },
        { "end_phone_call", reinterpret_cast<PyCFunction>(AccessoryManager_EndPhoneCall), METH_VARARGS | METH_STATIC, nullptr },
        { "get_all_email_accounts", reinterpret_cast<PyCFunction>(AccessoryManager_GetAllEmailAccounts), METH_VARARGS | METH_STATIC, nullptr },
        { "get_app_icon", reinterpret_cast<PyCFunction>(AccessoryManager_GetAppIcon), METH_VARARGS | METH_STATIC, nullptr },
        { "get_apps", reinterpret_cast<PyCFunction>(AccessoryManager_GetApps), METH_VARARGS | METH_STATIC, nullptr },
        { "get_enabled_accessory_notification_types", reinterpret_cast<PyCFunction>(AccessoryManager_GetEnabledAccessoryNotificationTypes), METH_VARARGS | METH_STATIC, nullptr },
        { "get_folders", reinterpret_cast<PyCFunction>(AccessoryManager_GetFolders), METH_VARARGS | METH_STATIC, nullptr },
        { "get_media_metadata", reinterpret_cast<PyCFunction>(AccessoryManager_GetMediaMetadata), METH_VARARGS | METH_STATIC, nullptr },
        { "get_next_trigger_details", reinterpret_cast<PyCFunction>(AccessoryManager_GetNextTriggerDetails), METH_VARARGS | METH_STATIC, nullptr },
        { "get_phone_line_details", reinterpret_cast<PyCFunction>(AccessoryManager_GetPhoneLineDetails), METH_VARARGS | METH_STATIC, nullptr },
        { "get_user_consent", reinterpret_cast<PyCFunction>(AccessoryManager_GetUserConsent), METH_VARARGS | METH_STATIC, nullptr },
        { "hold_phone_call", reinterpret_cast<PyCFunction>(AccessoryManager_HoldPhoneCall), METH_VARARGS | METH_STATIC, nullptr },
        { "increase_volume", reinterpret_cast<PyCFunction>(AccessoryManager_IncreaseVolume), METH_VARARGS | METH_STATIC, nullptr },
        { "is_notification_enabled_for_application", reinterpret_cast<PyCFunction>(AccessoryManager_IsNotificationEnabledForApplication), METH_VARARGS | METH_STATIC, nullptr },
        { "make_phone_call", reinterpret_cast<PyCFunction>(AccessoryManager_MakePhoneCall), METH_VARARGS | METH_STATIC, nullptr },
        { "make_phone_call_with_video", reinterpret_cast<PyCFunction>(AccessoryManager_MakePhoneCallWithVideo), METH_VARARGS | METH_STATIC, nullptr },
        { "perform_media_playback_command", reinterpret_cast<PyCFunction>(AccessoryManager_PerformMediaPlaybackCommand), METH_VARARGS | METH_STATIC, nullptr },
        { "process_trigger_details", reinterpret_cast<PyCFunction>(AccessoryManager_ProcessTriggerDetails), METH_VARARGS | METH_STATIC, nullptr },
        { "register_accessory_app", reinterpret_cast<PyCFunction>(AccessoryManager_RegisterAccessoryApp), METH_VARARGS | METH_STATIC, nullptr },
        { "reject_phone_call", reinterpret_cast<PyCFunction>(AccessoryManager_RejectPhoneCall), METH_VARARGS | METH_STATIC, nullptr },
        { "ring_device", reinterpret_cast<PyCFunction>(AccessoryManager_RingDevice), METH_VARARGS | METH_STATIC, nullptr },
        { "set_mute", reinterpret_cast<PyCFunction>(AccessoryManager_SetMute), METH_VARARGS | METH_STATIC, nullptr },
        { "set_ringer_vibrate", reinterpret_cast<PyCFunction>(AccessoryManager_SetRingerVibrate), METH_VARARGS | METH_STATIC, nullptr },
        { "snooze_alarm", reinterpret_cast<PyCFunction>(AccessoryManager_SnoozeAlarm), METH_VARARGS | METH_STATIC, nullptr },
        { "snooze_alarm_by_instance_id", reinterpret_cast<PyCFunction>(AccessoryManager_SnoozeAlarmByInstanceId), METH_VARARGS | METH_STATIC, nullptr },
        { "snooze_reminder", reinterpret_cast<PyCFunction>(AccessoryManager_SnoozeReminder), METH_VARARGS | METH_STATIC, nullptr },
        { "snooze_reminder_by_instance_id", reinterpret_cast<PyCFunction>(AccessoryManager_SnoozeReminderByInstanceId), METH_VARARGS | METH_STATIC, nullptr },
        { "swap_phone_calls", reinterpret_cast<PyCFunction>(AccessoryManager_SwapPhoneCalls), METH_VARARGS | METH_STATIC, nullptr },
        { "update_email_read_status", reinterpret_cast<PyCFunction>(AccessoryManager_UpdateEmailReadStatus), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AccessoryManager[] = {
        { }
    };

    static PyType_Slot _type_slots_AccessoryManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AccessoryManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AccessoryManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AccessoryManager) },
        { },
    };

    static PyType_Spec type_spec_AccessoryManager =
    {
        "_winsdk_Windows_Phone_Notification_Management.AccessoryManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AccessoryManager
    };

    static PyGetSetDef getset_AccessoryManager_Meta[] = {
        { "phone_mute", reinterpret_cast<getter>(AccessoryManager_get_PhoneMute), reinterpret_cast<setter>(AccessoryManager_put_PhoneMute), nullptr, nullptr },
        { "phone_call_audio_endpoint", reinterpret_cast<getter>(AccessoryManager_get_PhoneCallAudioEndpoint), reinterpret_cast<setter>(AccessoryManager_put_PhoneCallAudioEndpoint), nullptr, nullptr },
        { "battery_saver_state", reinterpret_cast<getter>(AccessoryManager_get_BatterySaverState), nullptr, nullptr, nullptr },
        { "do_not_disturb_enabled", reinterpret_cast<getter>(AccessoryManager_get_DoNotDisturbEnabled), nullptr, nullptr, nullptr },
        { "driving_mode_enabled", reinterpret_cast<getter>(AccessoryManager_get_DrivingModeEnabled), nullptr, nullptr, nullptr },
        { "media_playback_capabilities", reinterpret_cast<getter>(AccessoryManager_get_MediaPlaybackCapabilities), nullptr, nullptr, nullptr },
        { "media_playback_status", reinterpret_cast<getter>(AccessoryManager_get_MediaPlaybackStatus), nullptr, nullptr, nullptr },
        { "phone_line_details", reinterpret_cast<getter>(AccessoryManager_get_PhoneLineDetails), nullptr, nullptr, nullptr },
        { "is_phone_pin_locked", reinterpret_cast<getter>(AccessoryManager_get_IsPhonePinLocked), nullptr, nullptr, nullptr },
        { "speed_dial_list", reinterpret_cast<getter>(AccessoryManager_get_SpeedDialList), nullptr, nullptr, nullptr },
        { "volume_info", reinterpret_cast<getter>(AccessoryManager_get_VolumeInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_AccessoryManager_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AccessoryManager_Meta) },
        { }
    };

    static PyType_Spec type_spec_AccessoryManager_Meta =
    {
        "_winsdk_Windows_Phone_Notification_Management.AccessoryManager_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AccessoryManager_Meta
    };

    // ----- AlarmNotificationTriggerDetails class --------------------
    static constexpr const char* const type_name_AlarmNotificationTriggerDetails = "AlarmNotificationTriggerDetails";

    static PyObject* _new_AlarmNotificationTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AlarmNotificationTriggerDetails);
        return nullptr;
    }

    static void _dealloc_AlarmNotificationTriggerDetails(py::wrapper::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AlarmNotificationTriggerDetails_get_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AlarmNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartedProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AlarmNotificationTriggerDetails_put_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AlarmNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StartedProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AlarmNotificationTriggerDetails_get_AccessoryNotificationType(py::wrapper::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AlarmNotificationTriggerDetails", L"AccessoryNotificationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessoryNotificationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AlarmNotificationTriggerDetails_get_AppDisplayName(py::wrapper::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AlarmNotificationTriggerDetails", L"AppDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AlarmNotificationTriggerDetails_get_AppId(py::wrapper::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AlarmNotificationTriggerDetails", L"AppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AlarmNotificationTriggerDetails_get_TimeCreated(py::wrapper::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AlarmNotificationTriggerDetails", L"TimeCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AlarmNotificationTriggerDetails_get_AlarmId(py::wrapper::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AlarmNotificationTriggerDetails", L"AlarmId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AlarmId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AlarmNotificationTriggerDetails_get_ReminderState(py::wrapper::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AlarmNotificationTriggerDetails", L"ReminderState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReminderState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AlarmNotificationTriggerDetails_get_Timestamp(py::wrapper::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AlarmNotificationTriggerDetails", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AlarmNotificationTriggerDetails_get_Title(py::wrapper::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AlarmNotificationTriggerDetails", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AlarmNotificationTriggerDetails_get_InstanceId(py::wrapper::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AlarmNotificationTriggerDetails", L"InstanceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AlarmNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AlarmNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AlarmNotificationTriggerDetails[] = {
        { "_assign_array_", _assign_array_AlarmNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AlarmNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AlarmNotificationTriggerDetails[] = {
        { "started_processing", reinterpret_cast<getter>(AlarmNotificationTriggerDetails_get_StartedProcessing), reinterpret_cast<setter>(AlarmNotificationTriggerDetails_put_StartedProcessing), nullptr, nullptr },
        { "accessory_notification_type", reinterpret_cast<getter>(AlarmNotificationTriggerDetails_get_AccessoryNotificationType), nullptr, nullptr, nullptr },
        { "app_display_name", reinterpret_cast<getter>(AlarmNotificationTriggerDetails_get_AppDisplayName), nullptr, nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(AlarmNotificationTriggerDetails_get_AppId), nullptr, nullptr, nullptr },
        { "time_created", reinterpret_cast<getter>(AlarmNotificationTriggerDetails_get_TimeCreated), nullptr, nullptr, nullptr },
        { "alarm_id", reinterpret_cast<getter>(AlarmNotificationTriggerDetails_get_AlarmId), nullptr, nullptr, nullptr },
        { "reminder_state", reinterpret_cast<getter>(AlarmNotificationTriggerDetails_get_ReminderState), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(AlarmNotificationTriggerDetails_get_Timestamp), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(AlarmNotificationTriggerDetails_get_Title), nullptr, nullptr, nullptr },
        { "instance_id", reinterpret_cast<getter>(AlarmNotificationTriggerDetails_get_InstanceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AlarmNotificationTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AlarmNotificationTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AlarmNotificationTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AlarmNotificationTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AlarmNotificationTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_AlarmNotificationTriggerDetails =
    {
        "_winsdk_Windows_Phone_Notification_Management.AlarmNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AlarmNotificationTriggerDetails
    };

    // ----- AppNotificationInfo class --------------------
    static constexpr const char* const type_name_AppNotificationInfo = "AppNotificationInfo";

    static PyObject* _new_AppNotificationInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppNotificationInfo);
        return nullptr;
    }

    static void _dealloc_AppNotificationInfo(py::wrapper::Windows::Phone::Notification::Management::AppNotificationInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppNotificationInfo_get_Id(py::wrapper::Windows::Phone::Notification::Management::AppNotificationInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AppNotificationInfo", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppNotificationInfo_get_Name(py::wrapper::Windows::Phone::Notification::Management::AppNotificationInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AppNotificationInfo", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppNotificationInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::AppNotificationInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppNotificationInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::AppNotificationInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppNotificationInfo[] = {
        { "_assign_array_", _assign_array_AppNotificationInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppNotificationInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppNotificationInfo[] = {
        { "id", reinterpret_cast<getter>(AppNotificationInfo_get_Id), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(AppNotificationInfo_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppNotificationInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppNotificationInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppNotificationInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppNotificationInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppNotificationInfo) },
        { },
    };

    static PyType_Spec type_spec_AppNotificationInfo =
    {
        "_winsdk_Windows_Phone_Notification_Management.AppNotificationInfo",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::AppNotificationInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppNotificationInfo
    };

    // ----- BinaryId class --------------------
    static constexpr const char* const type_name_BinaryId = "BinaryId";

    static PyObject* _new_BinaryId(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BinaryId);
        return nullptr;
    }

    static void _dealloc_BinaryId(py::wrapper::Windows::Phone::Notification::Management::BinaryId* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BinaryId_get_Id(py::wrapper::Windows::Phone::Notification::Management::BinaryId* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.BinaryId", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BinaryId_get_Length(py::wrapper::Windows::Phone::Notification::Management::BinaryId* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.BinaryId", L"Length"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BinaryId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::BinaryId>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BinaryId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::BinaryId>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BinaryId[] = {
        { "_assign_array_", _assign_array_BinaryId, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BinaryId), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BinaryId[] = {
        { "id", reinterpret_cast<getter>(BinaryId_get_Id), nullptr, nullptr, nullptr },
        { "length", reinterpret_cast<getter>(BinaryId_get_Length), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BinaryId[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BinaryId) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BinaryId) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BinaryId) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BinaryId) },
        { },
    };

    static PyType_Spec type_spec_BinaryId =
    {
        "_winsdk_Windows_Phone_Notification_Management.BinaryId",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::BinaryId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BinaryId
    };

    // ----- CalendarChangedNotificationTriggerDetails class --------------------
    static constexpr const char* const type_name_CalendarChangedNotificationTriggerDetails = "CalendarChangedNotificationTriggerDetails";

    static PyObject* _new_CalendarChangedNotificationTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CalendarChangedNotificationTriggerDetails);
        return nullptr;
    }

    static void _dealloc_CalendarChangedNotificationTriggerDetails(py::wrapper::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CalendarChangedNotificationTriggerDetails_get_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CalendarChangedNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartedProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CalendarChangedNotificationTriggerDetails_put_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CalendarChangedNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StartedProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CalendarChangedNotificationTriggerDetails_get_AccessoryNotificationType(py::wrapper::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CalendarChangedNotificationTriggerDetails", L"AccessoryNotificationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessoryNotificationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarChangedNotificationTriggerDetails_get_AppDisplayName(py::wrapper::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CalendarChangedNotificationTriggerDetails", L"AppDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarChangedNotificationTriggerDetails_get_AppId(py::wrapper::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CalendarChangedNotificationTriggerDetails", L"AppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarChangedNotificationTriggerDetails_get_TimeCreated(py::wrapper::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CalendarChangedNotificationTriggerDetails", L"TimeCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarChangedNotificationTriggerDetails_get_EventType(py::wrapper::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CalendarChangedNotificationTriggerDetails", L"EventType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EventType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarChangedNotificationTriggerDetails_get_ItemId(py::wrapper::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CalendarChangedNotificationTriggerDetails", L"ItemId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ItemId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CalendarChangedNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CalendarChangedNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CalendarChangedNotificationTriggerDetails[] = {
        { "_assign_array_", _assign_array_CalendarChangedNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CalendarChangedNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CalendarChangedNotificationTriggerDetails[] = {
        { "started_processing", reinterpret_cast<getter>(CalendarChangedNotificationTriggerDetails_get_StartedProcessing), reinterpret_cast<setter>(CalendarChangedNotificationTriggerDetails_put_StartedProcessing), nullptr, nullptr },
        { "accessory_notification_type", reinterpret_cast<getter>(CalendarChangedNotificationTriggerDetails_get_AccessoryNotificationType), nullptr, nullptr, nullptr },
        { "app_display_name", reinterpret_cast<getter>(CalendarChangedNotificationTriggerDetails_get_AppDisplayName), nullptr, nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(CalendarChangedNotificationTriggerDetails_get_AppId), nullptr, nullptr, nullptr },
        { "time_created", reinterpret_cast<getter>(CalendarChangedNotificationTriggerDetails_get_TimeCreated), nullptr, nullptr, nullptr },
        { "event_type", reinterpret_cast<getter>(CalendarChangedNotificationTriggerDetails_get_EventType), nullptr, nullptr, nullptr },
        { "item_id", reinterpret_cast<getter>(CalendarChangedNotificationTriggerDetails_get_ItemId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CalendarChangedNotificationTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CalendarChangedNotificationTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CalendarChangedNotificationTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CalendarChangedNotificationTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CalendarChangedNotificationTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_CalendarChangedNotificationTriggerDetails =
    {
        "_winsdk_Windows_Phone_Notification_Management.CalendarChangedNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CalendarChangedNotificationTriggerDetails
    };

    // ----- CortanaTileNotificationTriggerDetails class --------------------
    static constexpr const char* const type_name_CortanaTileNotificationTriggerDetails = "CortanaTileNotificationTriggerDetails";

    static PyObject* _new_CortanaTileNotificationTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CortanaTileNotificationTriggerDetails);
        return nullptr;
    }

    static void _dealloc_CortanaTileNotificationTriggerDetails(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartedProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CortanaTileNotificationTriggerDetails_put_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StartedProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_AccessoryNotificationType(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"AccessoryNotificationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessoryNotificationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_AppDisplayName(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"AppDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_AppId(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"AppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_TimeCreated(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"TimeCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_Content(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"Content"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_EmphasizedText(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"EmphasizedText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmphasizedText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_LargeContent1(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"LargeContent1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LargeContent1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_LargeContent2(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"LargeContent2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LargeContent2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_NonWrappedSmallContent1(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"NonWrappedSmallContent1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NonWrappedSmallContent1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_NonWrappedSmallContent2(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"NonWrappedSmallContent2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NonWrappedSmallContent2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_NonWrappedSmallContent3(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"NonWrappedSmallContent3"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NonWrappedSmallContent3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_NonWrappedSmallContent4(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"NonWrappedSmallContent4"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NonWrappedSmallContent4());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_Source(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_TileId(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"TileId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TileId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CortanaTileNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CortanaTileNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CortanaTileNotificationTriggerDetails[] = {
        { "_assign_array_", _assign_array_CortanaTileNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CortanaTileNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CortanaTileNotificationTriggerDetails[] = {
        { "started_processing", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_StartedProcessing), reinterpret_cast<setter>(CortanaTileNotificationTriggerDetails_put_StartedProcessing), nullptr, nullptr },
        { "accessory_notification_type", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_AccessoryNotificationType), nullptr, nullptr, nullptr },
        { "app_display_name", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_AppDisplayName), nullptr, nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_AppId), nullptr, nullptr, nullptr },
        { "time_created", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_TimeCreated), nullptr, nullptr, nullptr },
        { "content", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_Content), nullptr, nullptr, nullptr },
        { "emphasized_text", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_EmphasizedText), nullptr, nullptr, nullptr },
        { "large_content1", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_LargeContent1), nullptr, nullptr, nullptr },
        { "large_content2", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_LargeContent2), nullptr, nullptr, nullptr },
        { "non_wrapped_small_content1", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_NonWrappedSmallContent1), nullptr, nullptr, nullptr },
        { "non_wrapped_small_content2", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_NonWrappedSmallContent2), nullptr, nullptr, nullptr },
        { "non_wrapped_small_content3", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_NonWrappedSmallContent3), nullptr, nullptr, nullptr },
        { "non_wrapped_small_content4", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_NonWrappedSmallContent4), nullptr, nullptr, nullptr },
        { "source", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_Source), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_TileId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CortanaTileNotificationTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CortanaTileNotificationTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CortanaTileNotificationTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CortanaTileNotificationTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CortanaTileNotificationTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_CortanaTileNotificationTriggerDetails =
    {
        "_winsdk_Windows_Phone_Notification_Management.CortanaTileNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CortanaTileNotificationTriggerDetails
    };

    // ----- EmailAccountInfo class --------------------
    static constexpr const char* const type_name_EmailAccountInfo = "EmailAccountInfo";

    static PyObject* _new_EmailAccountInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailAccountInfo);
        return nullptr;
    }

    static void _dealloc_EmailAccountInfo(py::wrapper::Windows::Phone::Notification::Management::EmailAccountInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailAccountInfo_get_DisplayName(py::wrapper::Windows::Phone::Notification::Management::EmailAccountInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailAccountInfo", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailAccountInfo_get_IsNotificationEnabled(py::wrapper::Windows::Phone::Notification::Management::EmailAccountInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailAccountInfo", L"IsNotificationEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsNotificationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailAccountInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::EmailAccountInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailAccountInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::EmailAccountInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailAccountInfo[] = {
        { "_assign_array_", _assign_array_EmailAccountInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailAccountInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailAccountInfo[] = {
        { "display_name", reinterpret_cast<getter>(EmailAccountInfo_get_DisplayName), nullptr, nullptr, nullptr },
        { "is_notification_enabled", reinterpret_cast<getter>(EmailAccountInfo_get_IsNotificationEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailAccountInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailAccountInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailAccountInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailAccountInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailAccountInfo) },
        { },
    };

    static PyType_Spec type_spec_EmailAccountInfo =
    {
        "_winsdk_Windows_Phone_Notification_Management.EmailAccountInfo",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::EmailAccountInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailAccountInfo
    };

    // ----- EmailFolderInfo class --------------------
    static constexpr const char* const type_name_EmailFolderInfo = "EmailFolderInfo";

    static PyObject* _new_EmailFolderInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailFolderInfo);
        return nullptr;
    }

    static void _dealloc_EmailFolderInfo(py::wrapper::Windows::Phone::Notification::Management::EmailFolderInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailFolderInfo_get_DisplayName(py::wrapper::Windows::Phone::Notification::Management::EmailFolderInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailFolderInfo", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailFolderInfo_get_IsNotificationEnabled(py::wrapper::Windows::Phone::Notification::Management::EmailFolderInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailFolderInfo", L"IsNotificationEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsNotificationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailFolderInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::EmailFolderInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailFolderInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::EmailFolderInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailFolderInfo[] = {
        { "_assign_array_", _assign_array_EmailFolderInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailFolderInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailFolderInfo[] = {
        { "display_name", reinterpret_cast<getter>(EmailFolderInfo_get_DisplayName), nullptr, nullptr, nullptr },
        { "is_notification_enabled", reinterpret_cast<getter>(EmailFolderInfo_get_IsNotificationEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailFolderInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailFolderInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailFolderInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailFolderInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailFolderInfo) },
        { },
    };

    static PyType_Spec type_spec_EmailFolderInfo =
    {
        "_winsdk_Windows_Phone_Notification_Management.EmailFolderInfo",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::EmailFolderInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailFolderInfo
    };

    // ----- EmailNotificationTriggerDetails class --------------------
    static constexpr const char* const type_name_EmailNotificationTriggerDetails = "EmailNotificationTriggerDetails";

    static PyObject* _new_EmailNotificationTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailNotificationTriggerDetails);
        return nullptr;
    }

    static void _dealloc_EmailNotificationTriggerDetails(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailNotificationTriggerDetails_get_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartedProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailNotificationTriggerDetails_put_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StartedProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailNotificationTriggerDetails_get_AccessoryNotificationType(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailNotificationTriggerDetails", L"AccessoryNotificationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessoryNotificationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailNotificationTriggerDetails_get_AppDisplayName(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailNotificationTriggerDetails", L"AppDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailNotificationTriggerDetails_get_AppId(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailNotificationTriggerDetails", L"AppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailNotificationTriggerDetails_get_TimeCreated(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailNotificationTriggerDetails", L"TimeCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailNotificationTriggerDetails_get_AccountName(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailNotificationTriggerDetails", L"AccountName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccountName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailNotificationTriggerDetails_get_EmailMessage(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailNotificationTriggerDetails", L"EmailMessage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailNotificationTriggerDetails_get_ParentFolderName(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailNotificationTriggerDetails", L"ParentFolderName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ParentFolderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailNotificationTriggerDetails_get_SenderAddress(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailNotificationTriggerDetails", L"SenderAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SenderAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailNotificationTriggerDetails_get_SenderName(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailNotificationTriggerDetails", L"SenderName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SenderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailNotificationTriggerDetails_get_Timestamp(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailNotificationTriggerDetails", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailNotificationTriggerDetails_get_MessageEntryId(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailNotificationTriggerDetails", L"MessageEntryId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MessageEntryId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailNotificationTriggerDetails[] = {
        { "_assign_array_", _assign_array_EmailNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailNotificationTriggerDetails[] = {
        { "started_processing", reinterpret_cast<getter>(EmailNotificationTriggerDetails_get_StartedProcessing), reinterpret_cast<setter>(EmailNotificationTriggerDetails_put_StartedProcessing), nullptr, nullptr },
        { "accessory_notification_type", reinterpret_cast<getter>(EmailNotificationTriggerDetails_get_AccessoryNotificationType), nullptr, nullptr, nullptr },
        { "app_display_name", reinterpret_cast<getter>(EmailNotificationTriggerDetails_get_AppDisplayName), nullptr, nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(EmailNotificationTriggerDetails_get_AppId), nullptr, nullptr, nullptr },
        { "time_created", reinterpret_cast<getter>(EmailNotificationTriggerDetails_get_TimeCreated), nullptr, nullptr, nullptr },
        { "account_name", reinterpret_cast<getter>(EmailNotificationTriggerDetails_get_AccountName), nullptr, nullptr, nullptr },
        { "email_message", reinterpret_cast<getter>(EmailNotificationTriggerDetails_get_EmailMessage), nullptr, nullptr, nullptr },
        { "parent_folder_name", reinterpret_cast<getter>(EmailNotificationTriggerDetails_get_ParentFolderName), nullptr, nullptr, nullptr },
        { "sender_address", reinterpret_cast<getter>(EmailNotificationTriggerDetails_get_SenderAddress), nullptr, nullptr, nullptr },
        { "sender_name", reinterpret_cast<getter>(EmailNotificationTriggerDetails_get_SenderName), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(EmailNotificationTriggerDetails_get_Timestamp), nullptr, nullptr, nullptr },
        { "message_entry_id", reinterpret_cast<getter>(EmailNotificationTriggerDetails_get_MessageEntryId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailNotificationTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailNotificationTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailNotificationTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailNotificationTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailNotificationTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_EmailNotificationTriggerDetails =
    {
        "_winsdk_Windows_Phone_Notification_Management.EmailNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailNotificationTriggerDetails
    };

    // ----- EmailReadNotificationTriggerDetails class --------------------
    static constexpr const char* const type_name_EmailReadNotificationTriggerDetails = "EmailReadNotificationTriggerDetails";

    static PyObject* _new_EmailReadNotificationTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailReadNotificationTriggerDetails);
        return nullptr;
    }

    static void _dealloc_EmailReadNotificationTriggerDetails(py::wrapper::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailReadNotificationTriggerDetails_get_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailReadNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartedProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailReadNotificationTriggerDetails_put_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailReadNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StartedProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailReadNotificationTriggerDetails_get_AccessoryNotificationType(py::wrapper::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailReadNotificationTriggerDetails", L"AccessoryNotificationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessoryNotificationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailReadNotificationTriggerDetails_get_AppDisplayName(py::wrapper::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailReadNotificationTriggerDetails", L"AppDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailReadNotificationTriggerDetails_get_AppId(py::wrapper::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailReadNotificationTriggerDetails", L"AppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailReadNotificationTriggerDetails_get_TimeCreated(py::wrapper::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailReadNotificationTriggerDetails", L"TimeCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailReadNotificationTriggerDetails_get_AccountName(py::wrapper::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailReadNotificationTriggerDetails", L"AccountName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccountName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailReadNotificationTriggerDetails_get_IsRead(py::wrapper::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailReadNotificationTriggerDetails", L"IsRead"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailReadNotificationTriggerDetails_get_MessageEntryId(py::wrapper::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailReadNotificationTriggerDetails", L"MessageEntryId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MessageEntryId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailReadNotificationTriggerDetails_get_ParentFolderName(py::wrapper::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailReadNotificationTriggerDetails", L"ParentFolderName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ParentFolderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailReadNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailReadNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailReadNotificationTriggerDetails[] = {
        { "_assign_array_", _assign_array_EmailReadNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailReadNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailReadNotificationTriggerDetails[] = {
        { "started_processing", reinterpret_cast<getter>(EmailReadNotificationTriggerDetails_get_StartedProcessing), reinterpret_cast<setter>(EmailReadNotificationTriggerDetails_put_StartedProcessing), nullptr, nullptr },
        { "accessory_notification_type", reinterpret_cast<getter>(EmailReadNotificationTriggerDetails_get_AccessoryNotificationType), nullptr, nullptr, nullptr },
        { "app_display_name", reinterpret_cast<getter>(EmailReadNotificationTriggerDetails_get_AppDisplayName), nullptr, nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(EmailReadNotificationTriggerDetails_get_AppId), nullptr, nullptr, nullptr },
        { "time_created", reinterpret_cast<getter>(EmailReadNotificationTriggerDetails_get_TimeCreated), nullptr, nullptr, nullptr },
        { "account_name", reinterpret_cast<getter>(EmailReadNotificationTriggerDetails_get_AccountName), nullptr, nullptr, nullptr },
        { "is_read", reinterpret_cast<getter>(EmailReadNotificationTriggerDetails_get_IsRead), nullptr, nullptr, nullptr },
        { "message_entry_id", reinterpret_cast<getter>(EmailReadNotificationTriggerDetails_get_MessageEntryId), nullptr, nullptr, nullptr },
        { "parent_folder_name", reinterpret_cast<getter>(EmailReadNotificationTriggerDetails_get_ParentFolderName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailReadNotificationTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailReadNotificationTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailReadNotificationTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailReadNotificationTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailReadNotificationTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_EmailReadNotificationTriggerDetails =
    {
        "_winsdk_Windows_Phone_Notification_Management.EmailReadNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailReadNotificationTriggerDetails
    };

    // ----- MediaControlsTriggerDetails class --------------------
    static constexpr const char* const type_name_MediaControlsTriggerDetails = "MediaControlsTriggerDetails";

    static PyObject* _new_MediaControlsTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaControlsTriggerDetails);
        return nullptr;
    }

    static void _dealloc_MediaControlsTriggerDetails(py::wrapper::Windows::Phone::Notification::Management::MediaControlsTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaControlsTriggerDetails_get_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::MediaControlsTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaControlsTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartedProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaControlsTriggerDetails_put_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::MediaControlsTriggerDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaControlsTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StartedProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaControlsTriggerDetails_get_AccessoryNotificationType(py::wrapper::Windows::Phone::Notification::Management::MediaControlsTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaControlsTriggerDetails", L"AccessoryNotificationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessoryNotificationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControlsTriggerDetails_get_AppDisplayName(py::wrapper::Windows::Phone::Notification::Management::MediaControlsTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaControlsTriggerDetails", L"AppDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControlsTriggerDetails_get_AppId(py::wrapper::Windows::Phone::Notification::Management::MediaControlsTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaControlsTriggerDetails", L"AppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControlsTriggerDetails_get_TimeCreated(py::wrapper::Windows::Phone::Notification::Management::MediaControlsTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaControlsTriggerDetails", L"TimeCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControlsTriggerDetails_get_MediaMetadata(py::wrapper::Windows::Phone::Notification::Management::MediaControlsTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaControlsTriggerDetails", L"MediaMetadata"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MediaMetadata());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControlsTriggerDetails_get_PlaybackStatus(py::wrapper::Windows::Phone::Notification::Management::MediaControlsTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaControlsTriggerDetails", L"PlaybackStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaControlsTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::MediaControlsTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaControlsTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::MediaControlsTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaControlsTriggerDetails[] = {
        { "_assign_array_", _assign_array_MediaControlsTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaControlsTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaControlsTriggerDetails[] = {
        { "started_processing", reinterpret_cast<getter>(MediaControlsTriggerDetails_get_StartedProcessing), reinterpret_cast<setter>(MediaControlsTriggerDetails_put_StartedProcessing), nullptr, nullptr },
        { "accessory_notification_type", reinterpret_cast<getter>(MediaControlsTriggerDetails_get_AccessoryNotificationType), nullptr, nullptr, nullptr },
        { "app_display_name", reinterpret_cast<getter>(MediaControlsTriggerDetails_get_AppDisplayName), nullptr, nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(MediaControlsTriggerDetails_get_AppId), nullptr, nullptr, nullptr },
        { "time_created", reinterpret_cast<getter>(MediaControlsTriggerDetails_get_TimeCreated), nullptr, nullptr, nullptr },
        { "media_metadata", reinterpret_cast<getter>(MediaControlsTriggerDetails_get_MediaMetadata), nullptr, nullptr, nullptr },
        { "playback_status", reinterpret_cast<getter>(MediaControlsTriggerDetails_get_PlaybackStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaControlsTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaControlsTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaControlsTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaControlsTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaControlsTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_MediaControlsTriggerDetails =
    {
        "_winsdk_Windows_Phone_Notification_Management.MediaControlsTriggerDetails",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::MediaControlsTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaControlsTriggerDetails
    };

    // ----- MediaMetadata class --------------------
    static constexpr const char* const type_name_MediaMetadata = "MediaMetadata";

    static PyObject* _new_MediaMetadata(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaMetadata);
        return nullptr;
    }

    static void _dealloc_MediaMetadata(py::wrapper::Windows::Phone::Notification::Management::MediaMetadata* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaMetadata_get_Album(py::wrapper::Windows::Phone::Notification::Management::MediaMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaMetadata", L"Album"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Album());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaMetadata_get_Artist(py::wrapper::Windows::Phone::Notification::Management::MediaMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaMetadata", L"Artist"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Artist());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaMetadata_get_Duration(py::wrapper::Windows::Phone::Notification::Management::MediaMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaMetadata", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaMetadata_get_Subtitle(py::wrapper::Windows::Phone::Notification::Management::MediaMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaMetadata", L"Subtitle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Subtitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaMetadata_get_Thumbnail(py::wrapper::Windows::Phone::Notification::Management::MediaMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaMetadata", L"Thumbnail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaMetadata_get_Title(py::wrapper::Windows::Phone::Notification::Management::MediaMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaMetadata", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaMetadata_get_Track(py::wrapper::Windows::Phone::Notification::Management::MediaMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaMetadata", L"Track"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Track());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaMetadata(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::MediaMetadata>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaMetadata(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::MediaMetadata>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaMetadata[] = {
        { "_assign_array_", _assign_array_MediaMetadata, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaMetadata), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaMetadata[] = {
        { "album", reinterpret_cast<getter>(MediaMetadata_get_Album), nullptr, nullptr, nullptr },
        { "artist", reinterpret_cast<getter>(MediaMetadata_get_Artist), nullptr, nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(MediaMetadata_get_Duration), nullptr, nullptr, nullptr },
        { "subtitle", reinterpret_cast<getter>(MediaMetadata_get_Subtitle), nullptr, nullptr, nullptr },
        { "thumbnail", reinterpret_cast<getter>(MediaMetadata_get_Thumbnail), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(MediaMetadata_get_Title), nullptr, nullptr, nullptr },
        { "track", reinterpret_cast<getter>(MediaMetadata_get_Track), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaMetadata[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaMetadata) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaMetadata) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaMetadata) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaMetadata) },
        { },
    };

    static PyType_Spec type_spec_MediaMetadata =
    {
        "_winsdk_Windows_Phone_Notification_Management.MediaMetadata",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::MediaMetadata),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaMetadata
    };

    // ----- PhoneCallDetails class --------------------
    static constexpr const char* const type_name_PhoneCallDetails = "PhoneCallDetails";

    static PyObject* _new_PhoneCallDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PhoneCallDetails);
        return nullptr;
    }

    static void _dealloc_PhoneCallDetails(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCallDetails_get_CallDirection(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneCallDetails", L"CallDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CallDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallDetails_get_CallId(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneCallDetails", L"CallId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CallId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallDetails_get_CallMediaType(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneCallDetails", L"CallMediaType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CallMediaType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallDetails_get_CallTransport(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneCallDetails", L"CallTransport"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CallTransport());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallDetails_get_ConferenceCallId(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneCallDetails", L"ConferenceCallId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConferenceCallId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallDetails_get_ContactName(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneCallDetails", L"ContactName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallDetails_get_EndTime(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneCallDetails", L"EndTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallDetails_get_PhoneLine(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneCallDetails", L"PhoneLine"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhoneLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallDetails_get_PhoneNumber(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneCallDetails", L"PhoneNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhoneNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallDetails_get_PresetTextResponses(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneCallDetails", L"PresetTextResponses"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PresetTextResponses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallDetails_get_StartTime(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneCallDetails", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallDetails_get_State(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneCallDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneCallDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::PhoneCallDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCallDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::PhoneCallDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallDetails[] = {
        { "_assign_array_", _assign_array_PhoneCallDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallDetails[] = {
        { "call_direction", reinterpret_cast<getter>(PhoneCallDetails_get_CallDirection), nullptr, nullptr, nullptr },
        { "call_id", reinterpret_cast<getter>(PhoneCallDetails_get_CallId), nullptr, nullptr, nullptr },
        { "call_media_type", reinterpret_cast<getter>(PhoneCallDetails_get_CallMediaType), nullptr, nullptr, nullptr },
        { "call_transport", reinterpret_cast<getter>(PhoneCallDetails_get_CallTransport), nullptr, nullptr, nullptr },
        { "conference_call_id", reinterpret_cast<getter>(PhoneCallDetails_get_ConferenceCallId), nullptr, nullptr, nullptr },
        { "contact_name", reinterpret_cast<getter>(PhoneCallDetails_get_ContactName), nullptr, nullptr, nullptr },
        { "end_time", reinterpret_cast<getter>(PhoneCallDetails_get_EndTime), nullptr, nullptr, nullptr },
        { "phone_line", reinterpret_cast<getter>(PhoneCallDetails_get_PhoneLine), nullptr, nullptr, nullptr },
        { "phone_number", reinterpret_cast<getter>(PhoneCallDetails_get_PhoneNumber), nullptr, nullptr, nullptr },
        { "preset_text_responses", reinterpret_cast<getter>(PhoneCallDetails_get_PresetTextResponses), nullptr, nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(PhoneCallDetails_get_StartTime), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(PhoneCallDetails_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCallDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCallDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallDetails) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallDetails =
    {
        "_winsdk_Windows_Phone_Notification_Management.PhoneCallDetails",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallDetails
    };

    // ----- PhoneLineDetails class --------------------
    static constexpr const char* const type_name_PhoneLineDetails = "PhoneLineDetails";

    static PyObject* _new_PhoneLineDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PhoneLineDetails);
        return nullptr;
    }

    static void _dealloc_PhoneLineDetails(py::wrapper::Windows::Phone::Notification::Management::PhoneLineDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneLineDetails_get_DefaultOutgoingLine(py::wrapper::Windows::Phone::Notification::Management::PhoneLineDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneLineDetails", L"DefaultOutgoingLine"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultOutgoingLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineDetails_get_DisplayName(py::wrapper::Windows::Phone::Notification::Management::PhoneLineDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneLineDetails", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineDetails_get_LineId(py::wrapper::Windows::Phone::Notification::Management::PhoneLineDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneLineDetails", L"LineId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineDetails_get_LineNumber(py::wrapper::Windows::Phone::Notification::Management::PhoneLineDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneLineDetails", L"LineNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineDetails_get_RegistrationState(py::wrapper::Windows::Phone::Notification::Management::PhoneLineDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneLineDetails", L"RegistrationState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RegistrationState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineDetails_get_VoicemailCount(py::wrapper::Windows::Phone::Notification::Management::PhoneLineDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneLineDetails", L"VoicemailCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VoicemailCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineDetails_get_MissedCallCount(py::wrapper::Windows::Phone::Notification::Management::PhoneLineDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneLineDetails", L"MissedCallCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MissedCallCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneLineDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::PhoneLineDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneLineDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::PhoneLineDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLineDetails[] = {
        { "_assign_array_", _assign_array_PhoneLineDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneLineDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneLineDetails[] = {
        { "default_outgoing_line", reinterpret_cast<getter>(PhoneLineDetails_get_DefaultOutgoingLine), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PhoneLineDetails_get_DisplayName), nullptr, nullptr, nullptr },
        { "line_id", reinterpret_cast<getter>(PhoneLineDetails_get_LineId), nullptr, nullptr, nullptr },
        { "line_number", reinterpret_cast<getter>(PhoneLineDetails_get_LineNumber), nullptr, nullptr, nullptr },
        { "registration_state", reinterpret_cast<getter>(PhoneLineDetails_get_RegistrationState), nullptr, nullptr, nullptr },
        { "voicemail_count", reinterpret_cast<getter>(PhoneLineDetails_get_VoicemailCount), nullptr, nullptr, nullptr },
        { "missed_call_count", reinterpret_cast<getter>(PhoneLineDetails_get_MissedCallCount), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneLineDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneLineDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneLineDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneLineDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneLineDetails) },
        { },
    };

    static PyType_Spec type_spec_PhoneLineDetails =
    {
        "_winsdk_Windows_Phone_Notification_Management.PhoneLineDetails",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::PhoneLineDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLineDetails
    };

    // ----- PhoneNotificationTriggerDetails class --------------------
    static constexpr const char* const type_name_PhoneNotificationTriggerDetails = "PhoneNotificationTriggerDetails";

    static PyObject* _new_PhoneNotificationTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PhoneNotificationTriggerDetails);
        return nullptr;
    }

    static void _dealloc_PhoneNotificationTriggerDetails(py::wrapper::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneNotificationTriggerDetails_get_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartedProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneNotificationTriggerDetails_put_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StartedProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneNotificationTriggerDetails_get_AccessoryNotificationType(py::wrapper::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneNotificationTriggerDetails", L"AccessoryNotificationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessoryNotificationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneNotificationTriggerDetails_get_AppDisplayName(py::wrapper::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneNotificationTriggerDetails", L"AppDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneNotificationTriggerDetails_get_AppId(py::wrapper::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneNotificationTriggerDetails", L"AppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneNotificationTriggerDetails_get_TimeCreated(py::wrapper::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneNotificationTriggerDetails", L"TimeCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneNotificationTriggerDetails_get_CallDetails(py::wrapper::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneNotificationTriggerDetails", L"CallDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CallDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneNotificationTriggerDetails_get_PhoneLineChangedId(py::wrapper::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneNotificationTriggerDetails", L"PhoneLineChangedId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhoneLineChangedId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneNotificationTriggerDetails_get_PhoneNotificationType(py::wrapper::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneNotificationTriggerDetails", L"PhoneNotificationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhoneNotificationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneNotificationTriggerDetails[] = {
        { "_assign_array_", _assign_array_PhoneNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneNotificationTriggerDetails[] = {
        { "started_processing", reinterpret_cast<getter>(PhoneNotificationTriggerDetails_get_StartedProcessing), reinterpret_cast<setter>(PhoneNotificationTriggerDetails_put_StartedProcessing), nullptr, nullptr },
        { "accessory_notification_type", reinterpret_cast<getter>(PhoneNotificationTriggerDetails_get_AccessoryNotificationType), nullptr, nullptr, nullptr },
        { "app_display_name", reinterpret_cast<getter>(PhoneNotificationTriggerDetails_get_AppDisplayName), nullptr, nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(PhoneNotificationTriggerDetails_get_AppId), nullptr, nullptr, nullptr },
        { "time_created", reinterpret_cast<getter>(PhoneNotificationTriggerDetails_get_TimeCreated), nullptr, nullptr, nullptr },
        { "call_details", reinterpret_cast<getter>(PhoneNotificationTriggerDetails_get_CallDetails), nullptr, nullptr, nullptr },
        { "phone_line_changed_id", reinterpret_cast<getter>(PhoneNotificationTriggerDetails_get_PhoneLineChangedId), nullptr, nullptr, nullptr },
        { "phone_notification_type", reinterpret_cast<getter>(PhoneNotificationTriggerDetails_get_PhoneNotificationType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneNotificationTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneNotificationTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneNotificationTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneNotificationTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneNotificationTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_PhoneNotificationTriggerDetails =
    {
        "_winsdk_Windows_Phone_Notification_Management.PhoneNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneNotificationTriggerDetails
    };

    // ----- ReminderNotificationTriggerDetails class --------------------
    static constexpr const char* const type_name_ReminderNotificationTriggerDetails = "ReminderNotificationTriggerDetails";

    static PyObject* _new_ReminderNotificationTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ReminderNotificationTriggerDetails);
        return nullptr;
    }

    static void _dealloc_ReminderNotificationTriggerDetails(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ReminderNotificationTriggerDetails_get_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartedProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReminderNotificationTriggerDetails_put_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StartedProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReminderNotificationTriggerDetails_get_AccessoryNotificationType(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"AccessoryNotificationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessoryNotificationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReminderNotificationTriggerDetails_get_AppDisplayName(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"AppDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReminderNotificationTriggerDetails_get_AppId(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"AppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReminderNotificationTriggerDetails_get_TimeCreated(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"TimeCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReminderNotificationTriggerDetails_get_Appointment(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"Appointment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Appointment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReminderNotificationTriggerDetails_get_Description(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReminderNotificationTriggerDetails_get_Details(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"Details"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Details());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReminderNotificationTriggerDetails_get_ReminderId(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"ReminderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReminderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReminderNotificationTriggerDetails_get_ReminderState(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"ReminderState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReminderState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReminderNotificationTriggerDetails_get_Timestamp(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReminderNotificationTriggerDetails_get_Title(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReminderNotificationTriggerDetails_get_InstanceId(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"InstanceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ReminderNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ReminderNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ReminderNotificationTriggerDetails[] = {
        { "_assign_array_", _assign_array_ReminderNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ReminderNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ReminderNotificationTriggerDetails[] = {
        { "started_processing", reinterpret_cast<getter>(ReminderNotificationTriggerDetails_get_StartedProcessing), reinterpret_cast<setter>(ReminderNotificationTriggerDetails_put_StartedProcessing), nullptr, nullptr },
        { "accessory_notification_type", reinterpret_cast<getter>(ReminderNotificationTriggerDetails_get_AccessoryNotificationType), nullptr, nullptr, nullptr },
        { "app_display_name", reinterpret_cast<getter>(ReminderNotificationTriggerDetails_get_AppDisplayName), nullptr, nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(ReminderNotificationTriggerDetails_get_AppId), nullptr, nullptr, nullptr },
        { "time_created", reinterpret_cast<getter>(ReminderNotificationTriggerDetails_get_TimeCreated), nullptr, nullptr, nullptr },
        { "appointment", reinterpret_cast<getter>(ReminderNotificationTriggerDetails_get_Appointment), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(ReminderNotificationTriggerDetails_get_Description), nullptr, nullptr, nullptr },
        { "details", reinterpret_cast<getter>(ReminderNotificationTriggerDetails_get_Details), nullptr, nullptr, nullptr },
        { "reminder_id", reinterpret_cast<getter>(ReminderNotificationTriggerDetails_get_ReminderId), nullptr, nullptr, nullptr },
        { "reminder_state", reinterpret_cast<getter>(ReminderNotificationTriggerDetails_get_ReminderState), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(ReminderNotificationTriggerDetails_get_Timestamp), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(ReminderNotificationTriggerDetails_get_Title), nullptr, nullptr, nullptr },
        { "instance_id", reinterpret_cast<getter>(ReminderNotificationTriggerDetails_get_InstanceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ReminderNotificationTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ReminderNotificationTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ReminderNotificationTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ReminderNotificationTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ReminderNotificationTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_ReminderNotificationTriggerDetails =
    {
        "_winsdk_Windows_Phone_Notification_Management.ReminderNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ReminderNotificationTriggerDetails
    };

    // ----- SpeedDialEntry class --------------------
    static constexpr const char* const type_name_SpeedDialEntry = "SpeedDialEntry";

    static PyObject* _new_SpeedDialEntry(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpeedDialEntry);
        return nullptr;
    }

    static void _dealloc_SpeedDialEntry(py::wrapper::Windows::Phone::Notification::Management::SpeedDialEntry* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeedDialEntry_get_ContactName(py::wrapper::Windows::Phone::Notification::Management::SpeedDialEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.SpeedDialEntry", L"ContactName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeedDialEntry_get_NumberType(py::wrapper::Windows::Phone::Notification::Management::SpeedDialEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.SpeedDialEntry", L"NumberType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NumberType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeedDialEntry_get_PhoneNumber(py::wrapper::Windows::Phone::Notification::Management::SpeedDialEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.SpeedDialEntry", L"PhoneNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhoneNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeedDialEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::SpeedDialEntry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeedDialEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::SpeedDialEntry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeedDialEntry[] = {
        { "_assign_array_", _assign_array_SpeedDialEntry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeedDialEntry), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeedDialEntry[] = {
        { "contact_name", reinterpret_cast<getter>(SpeedDialEntry_get_ContactName), nullptr, nullptr, nullptr },
        { "number_type", reinterpret_cast<getter>(SpeedDialEntry_get_NumberType), nullptr, nullptr, nullptr },
        { "phone_number", reinterpret_cast<getter>(SpeedDialEntry_get_PhoneNumber), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeedDialEntry[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeedDialEntry) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeedDialEntry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeedDialEntry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeedDialEntry) },
        { },
    };

    static PyType_Spec type_spec_SpeedDialEntry =
    {
        "_winsdk_Windows_Phone_Notification_Management.SpeedDialEntry",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::SpeedDialEntry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeedDialEntry
    };

    // ----- TextResponse class --------------------
    static constexpr const char* const type_name_TextResponse = "TextResponse";

    static PyObject* _new_TextResponse(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TextResponse);
        return nullptr;
    }

    static void _dealloc_TextResponse(py::wrapper::Windows::Phone::Notification::Management::TextResponse* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TextResponse_get_Content(py::wrapper::Windows::Phone::Notification::Management::TextResponse* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.TextResponse", L"Content"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextResponse_get_Id(py::wrapper::Windows::Phone::Notification::Management::TextResponse* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.TextResponse", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TextResponse(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::TextResponse>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TextResponse(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::TextResponse>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TextResponse[] = {
        { "_assign_array_", _assign_array_TextResponse, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TextResponse), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TextResponse[] = {
        { "content", reinterpret_cast<getter>(TextResponse_get_Content), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(TextResponse_get_Id), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TextResponse[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TextResponse) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TextResponse) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TextResponse) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TextResponse) },
        { },
    };

    static PyType_Spec type_spec_TextResponse =
    {
        "_winsdk_Windows_Phone_Notification_Management.TextResponse",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::TextResponse),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TextResponse
    };

    // ----- ToastNotificationTriggerDetails class --------------------
    static constexpr const char* const type_name_ToastNotificationTriggerDetails = "ToastNotificationTriggerDetails";

    static PyObject* _new_ToastNotificationTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ToastNotificationTriggerDetails);
        return nullptr;
    }

    static void _dealloc_ToastNotificationTriggerDetails(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToastNotificationTriggerDetails_get_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ToastNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartedProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotificationTriggerDetails_put_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ToastNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StartedProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotificationTriggerDetails_get_AccessoryNotificationType(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ToastNotificationTriggerDetails", L"AccessoryNotificationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessoryNotificationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationTriggerDetails_get_AppDisplayName(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ToastNotificationTriggerDetails", L"AppDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationTriggerDetails_get_AppId(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ToastNotificationTriggerDetails", L"AppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationTriggerDetails_get_TimeCreated(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ToastNotificationTriggerDetails", L"TimeCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationTriggerDetails_get_SuppressPopup(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ToastNotificationTriggerDetails", L"SuppressPopup"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SuppressPopup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationTriggerDetails_get_Text1(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ToastNotificationTriggerDetails", L"Text1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationTriggerDetails_get_Text2(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ToastNotificationTriggerDetails", L"Text2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationTriggerDetails_get_Text3(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ToastNotificationTriggerDetails", L"Text3"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationTriggerDetails_get_Text4(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ToastNotificationTriggerDetails", L"Text4"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text4());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationTriggerDetails_get_InstanceId(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ToastNotificationTriggerDetails", L"InstanceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToastNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotificationTriggerDetails[] = {
        { "_assign_array_", _assign_array_ToastNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToastNotificationTriggerDetails[] = {
        { "started_processing", reinterpret_cast<getter>(ToastNotificationTriggerDetails_get_StartedProcessing), reinterpret_cast<setter>(ToastNotificationTriggerDetails_put_StartedProcessing), nullptr, nullptr },
        { "accessory_notification_type", reinterpret_cast<getter>(ToastNotificationTriggerDetails_get_AccessoryNotificationType), nullptr, nullptr, nullptr },
        { "app_display_name", reinterpret_cast<getter>(ToastNotificationTriggerDetails_get_AppDisplayName), nullptr, nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(ToastNotificationTriggerDetails_get_AppId), nullptr, nullptr, nullptr },
        { "time_created", reinterpret_cast<getter>(ToastNotificationTriggerDetails_get_TimeCreated), nullptr, nullptr, nullptr },
        { "suppress_popup", reinterpret_cast<getter>(ToastNotificationTriggerDetails_get_SuppressPopup), nullptr, nullptr, nullptr },
        { "text1", reinterpret_cast<getter>(ToastNotificationTriggerDetails_get_Text1), nullptr, nullptr, nullptr },
        { "text2", reinterpret_cast<getter>(ToastNotificationTriggerDetails_get_Text2), nullptr, nullptr, nullptr },
        { "text3", reinterpret_cast<getter>(ToastNotificationTriggerDetails_get_Text3), nullptr, nullptr, nullptr },
        { "text4", reinterpret_cast<getter>(ToastNotificationTriggerDetails_get_Text4), nullptr, nullptr, nullptr },
        { "instance_id", reinterpret_cast<getter>(ToastNotificationTriggerDetails_get_InstanceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToastNotificationTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastNotificationTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastNotificationTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastNotificationTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastNotificationTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_ToastNotificationTriggerDetails =
    {
        "_winsdk_Windows_Phone_Notification_Management.ToastNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotificationTriggerDetails
    };

    // ----- VolumeInfo class --------------------
    static constexpr const char* const type_name_VolumeInfo = "VolumeInfo";

    static PyObject* _new_VolumeInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_VolumeInfo);
        return nullptr;
    }

    static void _dealloc_VolumeInfo(py::wrapper::Windows::Phone::Notification::Management::VolumeInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VolumeInfo_get_CallVolume(py::wrapper::Windows::Phone::Notification::Management::VolumeInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.VolumeInfo", L"CallVolume"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CallVolume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VolumeInfo_get_IsMuted(py::wrapper::Windows::Phone::Notification::Management::VolumeInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.VolumeInfo", L"IsMuted"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsMuted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VolumeInfo_get_IsVibrateEnabled(py::wrapper::Windows::Phone::Notification::Management::VolumeInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.VolumeInfo", L"IsVibrateEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsVibrateEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VolumeInfo_get_MediaVolume(py::wrapper::Windows::Phone::Notification::Management::VolumeInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.VolumeInfo", L"MediaVolume"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MediaVolume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VolumeInfo_get_SystemVolume(py::wrapper::Windows::Phone::Notification::Management::VolumeInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.VolumeInfo", L"SystemVolume"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SystemVolume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VolumeInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::VolumeInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VolumeInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::VolumeInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VolumeInfo[] = {
        { "_assign_array_", _assign_array_VolumeInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VolumeInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VolumeInfo[] = {
        { "call_volume", reinterpret_cast<getter>(VolumeInfo_get_CallVolume), nullptr, nullptr, nullptr },
        { "is_muted", reinterpret_cast<getter>(VolumeInfo_get_IsMuted), nullptr, nullptr, nullptr },
        { "is_vibrate_enabled", reinterpret_cast<getter>(VolumeInfo_get_IsVibrateEnabled), nullptr, nullptr, nullptr },
        { "media_volume", reinterpret_cast<getter>(VolumeInfo_get_MediaVolume), nullptr, nullptr, nullptr },
        { "system_volume", reinterpret_cast<getter>(VolumeInfo_get_SystemVolume), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VolumeInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VolumeInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VolumeInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VolumeInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VolumeInfo) },
        { },
    };

    static PyType_Spec type_spec_VolumeInfo =
    {
        "_winsdk_Windows_Phone_Notification_Management.VolumeInfo",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::VolumeInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VolumeInfo
    };

    // ----- IAccessoryNotificationTriggerDetails interface --------------------
    static constexpr const char* const type_name_IAccessoryNotificationTriggerDetails = "IAccessoryNotificationTriggerDetails";

    static PyObject* _new_IAccessoryNotificationTriggerDetails(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IAccessoryNotificationTriggerDetails);
        return nullptr;
    }

    static void _dealloc_IAccessoryNotificationTriggerDetails(py::wrapper::Windows::Phone::Notification::Management::IAccessoryNotificationTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAccessoryNotificationTriggerDetails_get_AccessoryNotificationType(py::wrapper::Windows::Phone::Notification::Management::IAccessoryNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.IAccessoryNotificationTriggerDetails", L"AccessoryNotificationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessoryNotificationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAccessoryNotificationTriggerDetails_get_AppDisplayName(py::wrapper::Windows::Phone::Notification::Management::IAccessoryNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.IAccessoryNotificationTriggerDetails", L"AppDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAccessoryNotificationTriggerDetails_get_AppId(py::wrapper::Windows::Phone::Notification::Management::IAccessoryNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.IAccessoryNotificationTriggerDetails", L"AppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAccessoryNotificationTriggerDetails_get_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::IAccessoryNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.IAccessoryNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartedProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAccessoryNotificationTriggerDetails_put_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::IAccessoryNotificationTriggerDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.IAccessoryNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StartedProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAccessoryNotificationTriggerDetails_get_TimeCreated(py::wrapper::Windows::Phone::Notification::Management::IAccessoryNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.IAccessoryNotificationTriggerDetails", L"TimeCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IAccessoryNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::IAccessoryNotificationTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAccessoryNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::IAccessoryNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAccessoryNotificationTriggerDetails[] = {
        { "_assign_array_", _assign_array_IAccessoryNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAccessoryNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAccessoryNotificationTriggerDetails[] = {
        { "accessory_notification_type", reinterpret_cast<getter>(IAccessoryNotificationTriggerDetails_get_AccessoryNotificationType), nullptr, nullptr, nullptr },
        { "app_display_name", reinterpret_cast<getter>(IAccessoryNotificationTriggerDetails_get_AppDisplayName), nullptr, nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(IAccessoryNotificationTriggerDetails_get_AppId), nullptr, nullptr, nullptr },
        { "started_processing", reinterpret_cast<getter>(IAccessoryNotificationTriggerDetails_get_StartedProcessing), reinterpret_cast<setter>(IAccessoryNotificationTriggerDetails_put_StartedProcessing), nullptr, nullptr },
        { "time_created", reinterpret_cast<getter>(IAccessoryNotificationTriggerDetails_get_TimeCreated), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAccessoryNotificationTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAccessoryNotificationTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAccessoryNotificationTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAccessoryNotificationTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAccessoryNotificationTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_IAccessoryNotificationTriggerDetails =
    {
        "_winsdk_Windows_Phone_Notification_Management.IAccessoryNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::IAccessoryNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAccessoryNotificationTriggerDetails
    };

    // ----- Windows.Phone.Notification.Management Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Phone::Notification::Management");

    static PyMethodDef module_methods[] = {
        {"_register_AccessoryNotificationType", register_AccessoryNotificationType, METH_O, "registers type"},
        {"_register_CalendarChangedEvent", register_CalendarChangedEvent, METH_O, "registers type"},
        {"_register_PhoneCallAudioEndpoint", register_PhoneCallAudioEndpoint, METH_O, "registers type"},
        {"_register_PhoneCallDirection", register_PhoneCallDirection, METH_O, "registers type"},
        {"_register_PhoneCallState", register_PhoneCallState, METH_O, "registers type"},
        {"_register_PhoneCallTransport", register_PhoneCallTransport, METH_O, "registers type"},
        {"_register_PhoneLineRegistrationState", register_PhoneLineRegistrationState, METH_O, "registers type"},
        {"_register_PhoneMediaType", register_PhoneMediaType, METH_O, "registers type"},
        {"_register_PhoneNotificationType", register_PhoneNotificationType, METH_O, "registers type"},
        {"_register_PlaybackCapability", register_PlaybackCapability, METH_O, "registers type"},
        {"_register_PlaybackCommand", register_PlaybackCommand, METH_O, "registers type"},
        {"_register_PlaybackStatus", register_PlaybackStatus, METH_O, "registers type"},
        {"_register_ReminderState", register_ReminderState, METH_O, "registers type"},
        {"_register_VibrateState", register_VibrateState, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_AccessoryNotificationType);
        Py_VISIT(state->type_CalendarChangedEvent);
        Py_VISIT(state->type_PhoneCallAudioEndpoint);
        Py_VISIT(state->type_PhoneCallDirection);
        Py_VISIT(state->type_PhoneCallState);
        Py_VISIT(state->type_PhoneCallTransport);
        Py_VISIT(state->type_PhoneLineRegistrationState);
        Py_VISIT(state->type_PhoneMediaType);
        Py_VISIT(state->type_PhoneNotificationType);
        Py_VISIT(state->type_PlaybackCapability);
        Py_VISIT(state->type_PlaybackCommand);
        Py_VISIT(state->type_PlaybackStatus);
        Py_VISIT(state->type_ReminderState);
        Py_VISIT(state->type_VibrateState);
        Py_VISIT(state->type_AccessoryManager);
        Py_VISIT(state->type_AlarmNotificationTriggerDetails);
        Py_VISIT(state->type_AppNotificationInfo);
        Py_VISIT(state->type_BinaryId);
        Py_VISIT(state->type_CalendarChangedNotificationTriggerDetails);
        Py_VISIT(state->type_CortanaTileNotificationTriggerDetails);
        Py_VISIT(state->type_EmailAccountInfo);
        Py_VISIT(state->type_EmailFolderInfo);
        Py_VISIT(state->type_EmailNotificationTriggerDetails);
        Py_VISIT(state->type_EmailReadNotificationTriggerDetails);
        Py_VISIT(state->type_MediaControlsTriggerDetails);
        Py_VISIT(state->type_MediaMetadata);
        Py_VISIT(state->type_PhoneCallDetails);
        Py_VISIT(state->type_PhoneLineDetails);
        Py_VISIT(state->type_PhoneNotificationTriggerDetails);
        Py_VISIT(state->type_ReminderNotificationTriggerDetails);
        Py_VISIT(state->type_SpeedDialEntry);
        Py_VISIT(state->type_TextResponse);
        Py_VISIT(state->type_ToastNotificationTriggerDetails);
        Py_VISIT(state->type_VolumeInfo);
        Py_VISIT(state->type_IAccessoryNotificationTriggerDetails);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_AccessoryNotificationType);
        Py_CLEAR(state->type_CalendarChangedEvent);
        Py_CLEAR(state->type_PhoneCallAudioEndpoint);
        Py_CLEAR(state->type_PhoneCallDirection);
        Py_CLEAR(state->type_PhoneCallState);
        Py_CLEAR(state->type_PhoneCallTransport);
        Py_CLEAR(state->type_PhoneLineRegistrationState);
        Py_CLEAR(state->type_PhoneMediaType);
        Py_CLEAR(state->type_PhoneNotificationType);
        Py_CLEAR(state->type_PlaybackCapability);
        Py_CLEAR(state->type_PlaybackCommand);
        Py_CLEAR(state->type_PlaybackStatus);
        Py_CLEAR(state->type_ReminderState);
        Py_CLEAR(state->type_VibrateState);
        Py_CLEAR(state->type_AccessoryManager);
        Py_CLEAR(state->type_AlarmNotificationTriggerDetails);
        Py_CLEAR(state->type_AppNotificationInfo);
        Py_CLEAR(state->type_BinaryId);
        Py_CLEAR(state->type_CalendarChangedNotificationTriggerDetails);
        Py_CLEAR(state->type_CortanaTileNotificationTriggerDetails);
        Py_CLEAR(state->type_EmailAccountInfo);
        Py_CLEAR(state->type_EmailFolderInfo);
        Py_CLEAR(state->type_EmailNotificationTriggerDetails);
        Py_CLEAR(state->type_EmailReadNotificationTriggerDetails);
        Py_CLEAR(state->type_MediaControlsTriggerDetails);
        Py_CLEAR(state->type_MediaMetadata);
        Py_CLEAR(state->type_PhoneCallDetails);
        Py_CLEAR(state->type_PhoneLineDetails);
        Py_CLEAR(state->type_PhoneNotificationTriggerDetails);
        Py_CLEAR(state->type_ReminderNotificationTriggerDetails);
        Py_CLEAR(state->type_SpeedDialEntry);
        Py_CLEAR(state->type_TextResponse);
        Py_CLEAR(state->type_ToastNotificationTriggerDetails);
        Py_CLEAR(state->type_VolumeInfo);
        Py_CLEAR(state->type_IAccessoryNotificationTriggerDetails);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Phone_Notification_Management",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Phone::Notification::Management

PyMODINIT_FUNC PyInit__winsdk_Windows_Phone_Notification_Management(void) noexcept
{
    using namespace py::cpp::Windows::Phone::Notification::Management;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    py::pyobj_handle type_AccessoryManager_Meta{PyType_FromSpec(&type_spec_AccessoryManager_Meta)};
    if (!type_AccessoryManager_Meta)
    {
        return nullptr;
    }

    state->type_AccessoryManager = py::register_python_type(module.get(), type_name_AccessoryManager, &type_spec_AccessoryManager, nullptr, reinterpret_cast<PyTypeObject*>(type_AccessoryManager_Meta.get()));
    if (!state->type_AccessoryManager)
    {
        return nullptr;
    }

    state->type_AlarmNotificationTriggerDetails = py::register_python_type(module.get(), type_name_AlarmNotificationTriggerDetails, &type_spec_AlarmNotificationTriggerDetails, bases.get(), nullptr);
    if (!state->type_AlarmNotificationTriggerDetails)
    {
        return nullptr;
    }

    state->type_AppNotificationInfo = py::register_python_type(module.get(), type_name_AppNotificationInfo, &type_spec_AppNotificationInfo, bases.get(), nullptr);
    if (!state->type_AppNotificationInfo)
    {
        return nullptr;
    }

    state->type_BinaryId = py::register_python_type(module.get(), type_name_BinaryId, &type_spec_BinaryId, bases.get(), nullptr);
    if (!state->type_BinaryId)
    {
        return nullptr;
    }

    state->type_CalendarChangedNotificationTriggerDetails = py::register_python_type(module.get(), type_name_CalendarChangedNotificationTriggerDetails, &type_spec_CalendarChangedNotificationTriggerDetails, bases.get(), nullptr);
    if (!state->type_CalendarChangedNotificationTriggerDetails)
    {
        return nullptr;
    }

    state->type_CortanaTileNotificationTriggerDetails = py::register_python_type(module.get(), type_name_CortanaTileNotificationTriggerDetails, &type_spec_CortanaTileNotificationTriggerDetails, bases.get(), nullptr);
    if (!state->type_CortanaTileNotificationTriggerDetails)
    {
        return nullptr;
    }

    state->type_EmailAccountInfo = py::register_python_type(module.get(), type_name_EmailAccountInfo, &type_spec_EmailAccountInfo, bases.get(), nullptr);
    if (!state->type_EmailAccountInfo)
    {
        return nullptr;
    }

    state->type_EmailFolderInfo = py::register_python_type(module.get(), type_name_EmailFolderInfo, &type_spec_EmailFolderInfo, bases.get(), nullptr);
    if (!state->type_EmailFolderInfo)
    {
        return nullptr;
    }

    state->type_EmailNotificationTriggerDetails = py::register_python_type(module.get(), type_name_EmailNotificationTriggerDetails, &type_spec_EmailNotificationTriggerDetails, bases.get(), nullptr);
    if (!state->type_EmailNotificationTriggerDetails)
    {
        return nullptr;
    }

    state->type_EmailReadNotificationTriggerDetails = py::register_python_type(module.get(), type_name_EmailReadNotificationTriggerDetails, &type_spec_EmailReadNotificationTriggerDetails, bases.get(), nullptr);
    if (!state->type_EmailReadNotificationTriggerDetails)
    {
        return nullptr;
    }

    state->type_MediaControlsTriggerDetails = py::register_python_type(module.get(), type_name_MediaControlsTriggerDetails, &type_spec_MediaControlsTriggerDetails, bases.get(), nullptr);
    if (!state->type_MediaControlsTriggerDetails)
    {
        return nullptr;
    }

    state->type_MediaMetadata = py::register_python_type(module.get(), type_name_MediaMetadata, &type_spec_MediaMetadata, bases.get(), nullptr);
    if (!state->type_MediaMetadata)
    {
        return nullptr;
    }

    state->type_PhoneCallDetails = py::register_python_type(module.get(), type_name_PhoneCallDetails, &type_spec_PhoneCallDetails, bases.get(), nullptr);
    if (!state->type_PhoneCallDetails)
    {
        return nullptr;
    }

    state->type_PhoneLineDetails = py::register_python_type(module.get(), type_name_PhoneLineDetails, &type_spec_PhoneLineDetails, bases.get(), nullptr);
    if (!state->type_PhoneLineDetails)
    {
        return nullptr;
    }

    state->type_PhoneNotificationTriggerDetails = py::register_python_type(module.get(), type_name_PhoneNotificationTriggerDetails, &type_spec_PhoneNotificationTriggerDetails, bases.get(), nullptr);
    if (!state->type_PhoneNotificationTriggerDetails)
    {
        return nullptr;
    }

    state->type_ReminderNotificationTriggerDetails = py::register_python_type(module.get(), type_name_ReminderNotificationTriggerDetails, &type_spec_ReminderNotificationTriggerDetails, bases.get(), nullptr);
    if (!state->type_ReminderNotificationTriggerDetails)
    {
        return nullptr;
    }

    state->type_SpeedDialEntry = py::register_python_type(module.get(), type_name_SpeedDialEntry, &type_spec_SpeedDialEntry, bases.get(), nullptr);
    if (!state->type_SpeedDialEntry)
    {
        return nullptr;
    }

    state->type_TextResponse = py::register_python_type(module.get(), type_name_TextResponse, &type_spec_TextResponse, bases.get(), nullptr);
    if (!state->type_TextResponse)
    {
        return nullptr;
    }

    state->type_ToastNotificationTriggerDetails = py::register_python_type(module.get(), type_name_ToastNotificationTriggerDetails, &type_spec_ToastNotificationTriggerDetails, bases.get(), nullptr);
    if (!state->type_ToastNotificationTriggerDetails)
    {
        return nullptr;
    }

    state->type_VolumeInfo = py::register_python_type(module.get(), type_name_VolumeInfo, &type_spec_VolumeInfo, bases.get(), nullptr);
    if (!state->type_VolumeInfo)
    {
        return nullptr;
    }

    state->type_IAccessoryNotificationTriggerDetails = py::register_python_type(module.get(), type_name_IAccessoryNotificationTriggerDetails, &type_spec_IAccessoryNotificationTriggerDetails, bases.get(), nullptr);
    if (!state->type_IAccessoryNotificationTriggerDetails)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Phone::Notification::Management::AccessoryNotificationType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AccessoryNotificationType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::AccessoryNotificationType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Phone::Notification::Management::CalendarChangedEvent>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CalendarChangedEvent;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::CalendarChangedEvent is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Phone::Notification::Management::PhoneCallAudioEndpoint>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallAudioEndpoint;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::PhoneCallAudioEndpoint is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Phone::Notification::Management::PhoneCallDirection>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallDirection;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::PhoneCallDirection is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Phone::Notification::Management::PhoneCallState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::PhoneCallState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Phone::Notification::Management::PhoneCallTransport>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallTransport;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::PhoneCallTransport is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Phone::Notification::Management::PhoneLineRegistrationState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneLineRegistrationState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::PhoneLineRegistrationState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Phone::Notification::Management::PhoneMediaType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneMediaType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::PhoneMediaType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Phone::Notification::Management::PhoneNotificationType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneNotificationType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::PhoneNotificationType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Phone::Notification::Management::PlaybackCapability>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PlaybackCapability;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::PlaybackCapability is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Phone::Notification::Management::PlaybackCommand>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PlaybackCommand;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::PlaybackCommand is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Phone::Notification::Management::PlaybackStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PlaybackStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::PlaybackStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Phone::Notification::Management::ReminderState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ReminderState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::ReminderState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Phone::Notification::Management::VibrateState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VibrateState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::VibrateState is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::Notification::Management::AccessoryManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AccessoryManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::AccessoryManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AlarmNotificationTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::Notification::Management::AppNotificationInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppNotificationInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::AppNotificationInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::Notification::Management::BinaryId>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BinaryId;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::BinaryId is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CalendarChangedNotificationTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CortanaTileNotificationTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::Notification::Management::EmailAccountInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailAccountInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::EmailAccountInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::Notification::Management::EmailFolderInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailFolderInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::EmailFolderInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailNotificationTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailReadNotificationTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::Notification::Management::MediaControlsTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaControlsTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::MediaControlsTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::Notification::Management::MediaMetadata>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaMetadata;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::MediaMetadata is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::Notification::Management::PhoneCallDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::PhoneCallDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::Notification::Management::PhoneLineDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneLineDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::PhoneLineDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneNotificationTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ReminderNotificationTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::Notification::Management::SpeedDialEntry>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpeedDialEntry;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::SpeedDialEntry is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::Notification::Management::TextResponse>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TextResponse;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::TextResponse is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ToastNotificationTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::Notification::Management::VolumeInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VolumeInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::VolumeInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::Notification::Management::IAccessoryNotificationTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::Notification::Management;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::Notification::Management");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IAccessoryNotificationTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::Notification::Management::IAccessoryNotificationTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}
