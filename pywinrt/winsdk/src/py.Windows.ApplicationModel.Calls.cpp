// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.ApplicationModel.Calls.h"


namespace py::cpp::Windows::ApplicationModel::Calls
{
    struct module_state
    {
        PyObject* type_CellularDtmfMode;
        PyObject* type_DtmfKey;
        PyObject* type_DtmfToneAudioPlayback;
        PyObject* type_PhoneAudioRoutingEndpoint;
        PyObject* type_PhoneCallAudioDevice;
        PyObject* type_PhoneCallDirection;
        PyObject* type_PhoneCallHistoryEntryMedia;
        PyObject* type_PhoneCallHistoryEntryOtherAppReadAccess;
        PyObject* type_PhoneCallHistoryEntryQueryDesiredMedia;
        PyObject* type_PhoneCallHistoryEntryRawAddressKind;
        PyObject* type_PhoneCallHistorySourceIdKind;
        PyObject* type_PhoneCallHistoryStoreAccessType;
        PyObject* type_PhoneCallMedia;
        PyObject* type_PhoneCallOperationStatus;
        PyObject* type_PhoneCallStatus;
        PyObject* type_PhoneLineNetworkOperatorDisplayTextLocation;
        PyObject* type_PhoneLineOperationStatus;
        PyObject* type_PhoneLineTransport;
        PyObject* type_PhoneLineWatcherStatus;
        PyObject* type_PhoneNetworkState;
        PyObject* type_PhoneSimState;
        PyObject* type_PhoneVoicemailType;
        PyObject* type_TransportDeviceAudioRoutingStatus;
        PyObject* type_VoipPhoneCallMedia;
        PyObject* type_VoipPhoneCallRejectReason;
        PyObject* type_VoipPhoneCallResourceReservationStatus;
        PyObject* type_VoipPhoneCallState;
        PyTypeObject* type_CallAnswerEventArgs;
        PyTypeObject* type_CallRejectEventArgs;
        PyTypeObject* type_CallStateChangeEventArgs;
        PyTypeObject* type_LockScreenCallEndCallDeferral;
        PyTypeObject* type_LockScreenCallEndRequestedEventArgs;
        PyTypeObject* type_LockScreenCallUI;
        PyTypeObject* type_MuteChangeEventArgs;
        PyTypeObject* type_PhoneCall;
        PyTypeObject* type_PhoneCallBlocking;
        PyTypeObject* type_PhoneCallHistoryEntry;
        PyTypeObject* type_PhoneCallHistoryEntryAddress;
        PyTypeObject* type_PhoneCallHistoryEntryQueryOptions;
        PyTypeObject* type_PhoneCallHistoryEntryReader;
        PyTypeObject* type_PhoneCallHistoryManager;
        PyTypeObject* type_PhoneCallHistoryManagerForUser;
        PyTypeObject* type_PhoneCallHistoryStore;
        PyTypeObject* type_PhoneCallInfo;
        PyTypeObject* type_PhoneCallManager;
        PyTypeObject* type_PhoneCallStore;
        PyTypeObject* type_PhoneCallVideoCapabilities;
        PyTypeObject* type_PhoneCallVideoCapabilitiesManager;
        PyTypeObject* type_PhoneCallsResult;
        PyTypeObject* type_PhoneDialOptions;
        PyTypeObject* type_PhoneLine;
        PyTypeObject* type_PhoneLineCellularDetails;
        PyTypeObject* type_PhoneLineConfiguration;
        PyTypeObject* type_PhoneLineDialResult;
        PyTypeObject* type_PhoneLineTransportDevice;
        PyTypeObject* type_PhoneLineWatcher;
        PyTypeObject* type_PhoneLineWatcherEventArgs;
        PyTypeObject* type_PhoneVoicemail;
        PyTypeObject* type_VoipCallCoordinator;
        PyTypeObject* type_VoipPhoneCall;
    };

    static PyObject* register_CellularDtmfMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CellularDtmfMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CellularDtmfMode = type;
        Py_INCREF(state->type_CellularDtmfMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_DtmfKey(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DtmfKey)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DtmfKey = type;
        Py_INCREF(state->type_DtmfKey);


        Py_RETURN_NONE;
    }

    static PyObject* register_DtmfToneAudioPlayback(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DtmfToneAudioPlayback)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DtmfToneAudioPlayback = type;
        Py_INCREF(state->type_DtmfToneAudioPlayback);


        Py_RETURN_NONE;
    }

    static PyObject* register_PhoneAudioRoutingEndpoint(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PhoneAudioRoutingEndpoint)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PhoneAudioRoutingEndpoint = type;
        Py_INCREF(state->type_PhoneAudioRoutingEndpoint);


        Py_RETURN_NONE;
    }

    static PyObject* register_PhoneCallAudioDevice(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PhoneCallAudioDevice)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PhoneCallAudioDevice = type;
        Py_INCREF(state->type_PhoneCallAudioDevice);


        Py_RETURN_NONE;
    }

    static PyObject* register_PhoneCallDirection(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PhoneCallDirection)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PhoneCallDirection = type;
        Py_INCREF(state->type_PhoneCallDirection);


        Py_RETURN_NONE;
    }

    static PyObject* register_PhoneCallHistoryEntryMedia(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PhoneCallHistoryEntryMedia)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PhoneCallHistoryEntryMedia = type;
        Py_INCREF(state->type_PhoneCallHistoryEntryMedia);


        Py_RETURN_NONE;
    }

    static PyObject* register_PhoneCallHistoryEntryOtherAppReadAccess(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PhoneCallHistoryEntryOtherAppReadAccess)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PhoneCallHistoryEntryOtherAppReadAccess = type;
        Py_INCREF(state->type_PhoneCallHistoryEntryOtherAppReadAccess);


        Py_RETURN_NONE;
    }

    static PyObject* register_PhoneCallHistoryEntryQueryDesiredMedia(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PhoneCallHistoryEntryQueryDesiredMedia)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PhoneCallHistoryEntryQueryDesiredMedia = type;
        Py_INCREF(state->type_PhoneCallHistoryEntryQueryDesiredMedia);


        Py_RETURN_NONE;
    }

    static PyObject* register_PhoneCallHistoryEntryRawAddressKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PhoneCallHistoryEntryRawAddressKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PhoneCallHistoryEntryRawAddressKind = type;
        Py_INCREF(state->type_PhoneCallHistoryEntryRawAddressKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_PhoneCallHistorySourceIdKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PhoneCallHistorySourceIdKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PhoneCallHistorySourceIdKind = type;
        Py_INCREF(state->type_PhoneCallHistorySourceIdKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_PhoneCallHistoryStoreAccessType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PhoneCallHistoryStoreAccessType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PhoneCallHistoryStoreAccessType = type;
        Py_INCREF(state->type_PhoneCallHistoryStoreAccessType);


        Py_RETURN_NONE;
    }

    static PyObject* register_PhoneCallMedia(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PhoneCallMedia)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PhoneCallMedia = type;
        Py_INCREF(state->type_PhoneCallMedia);


        Py_RETURN_NONE;
    }

    static PyObject* register_PhoneCallOperationStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PhoneCallOperationStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PhoneCallOperationStatus = type;
        Py_INCREF(state->type_PhoneCallOperationStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_PhoneCallStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PhoneCallStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PhoneCallStatus = type;
        Py_INCREF(state->type_PhoneCallStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_PhoneLineNetworkOperatorDisplayTextLocation(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PhoneLineNetworkOperatorDisplayTextLocation)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PhoneLineNetworkOperatorDisplayTextLocation = type;
        Py_INCREF(state->type_PhoneLineNetworkOperatorDisplayTextLocation);


        Py_RETURN_NONE;
    }

    static PyObject* register_PhoneLineOperationStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PhoneLineOperationStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PhoneLineOperationStatus = type;
        Py_INCREF(state->type_PhoneLineOperationStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_PhoneLineTransport(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PhoneLineTransport)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PhoneLineTransport = type;
        Py_INCREF(state->type_PhoneLineTransport);


        Py_RETURN_NONE;
    }

    static PyObject* register_PhoneLineWatcherStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PhoneLineWatcherStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PhoneLineWatcherStatus = type;
        Py_INCREF(state->type_PhoneLineWatcherStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_PhoneNetworkState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PhoneNetworkState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PhoneNetworkState = type;
        Py_INCREF(state->type_PhoneNetworkState);


        Py_RETURN_NONE;
    }

    static PyObject* register_PhoneSimState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PhoneSimState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PhoneSimState = type;
        Py_INCREF(state->type_PhoneSimState);


        Py_RETURN_NONE;
    }

    static PyObject* register_PhoneVoicemailType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PhoneVoicemailType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PhoneVoicemailType = type;
        Py_INCREF(state->type_PhoneVoicemailType);


        Py_RETURN_NONE;
    }

    static PyObject* register_TransportDeviceAudioRoutingStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TransportDeviceAudioRoutingStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TransportDeviceAudioRoutingStatus = type;
        Py_INCREF(state->type_TransportDeviceAudioRoutingStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_VoipPhoneCallMedia(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_VoipPhoneCallMedia)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_VoipPhoneCallMedia = type;
        Py_INCREF(state->type_VoipPhoneCallMedia);


        Py_RETURN_NONE;
    }

    static PyObject* register_VoipPhoneCallRejectReason(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_VoipPhoneCallRejectReason)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_VoipPhoneCallRejectReason = type;
        Py_INCREF(state->type_VoipPhoneCallRejectReason);


        Py_RETURN_NONE;
    }

    static PyObject* register_VoipPhoneCallResourceReservationStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_VoipPhoneCallResourceReservationStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_VoipPhoneCallResourceReservationStatus = type;
        Py_INCREF(state->type_VoipPhoneCallResourceReservationStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_VoipPhoneCallState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_VoipPhoneCallState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_VoipPhoneCallState = type;
        Py_INCREF(state->type_VoipPhoneCallState);


        Py_RETURN_NONE;
    }

    // ----- CallAnswerEventArgs class --------------------
    static constexpr const char* const type_name_CallAnswerEventArgs = "CallAnswerEventArgs";

    static PyObject* _new_CallAnswerEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CallAnswerEventArgs);
        return nullptr;
    }

    static void _dealloc_CallAnswerEventArgs(py::wrapper::Windows::ApplicationModel::Calls::CallAnswerEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CallAnswerEventArgs_get_AcceptedMedia(py::wrapper::Windows::ApplicationModel::Calls::CallAnswerEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.CallAnswerEventArgs", L"AcceptedMedia"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AcceptedMedia());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CallAnswerEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::CallAnswerEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CallAnswerEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::CallAnswerEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CallAnswerEventArgs[] = {
        { "_assign_array_", _assign_array_CallAnswerEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CallAnswerEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CallAnswerEventArgs[] = {
        { "accepted_media", reinterpret_cast<getter>(CallAnswerEventArgs_get_AcceptedMedia), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CallAnswerEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CallAnswerEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CallAnswerEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CallAnswerEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CallAnswerEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CallAnswerEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Calls.CallAnswerEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::CallAnswerEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CallAnswerEventArgs
    };

    // ----- CallRejectEventArgs class --------------------
    static constexpr const char* const type_name_CallRejectEventArgs = "CallRejectEventArgs";

    static PyObject* _new_CallRejectEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CallRejectEventArgs);
        return nullptr;
    }

    static void _dealloc_CallRejectEventArgs(py::wrapper::Windows::ApplicationModel::Calls::CallRejectEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CallRejectEventArgs_get_RejectReason(py::wrapper::Windows::ApplicationModel::Calls::CallRejectEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.CallRejectEventArgs", L"RejectReason"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RejectReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CallRejectEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::CallRejectEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CallRejectEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::CallRejectEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CallRejectEventArgs[] = {
        { "_assign_array_", _assign_array_CallRejectEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CallRejectEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CallRejectEventArgs[] = {
        { "reject_reason", reinterpret_cast<getter>(CallRejectEventArgs_get_RejectReason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CallRejectEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CallRejectEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CallRejectEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CallRejectEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CallRejectEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CallRejectEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Calls.CallRejectEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::CallRejectEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CallRejectEventArgs
    };

    // ----- CallStateChangeEventArgs class --------------------
    static constexpr const char* const type_name_CallStateChangeEventArgs = "CallStateChangeEventArgs";

    static PyObject* _new_CallStateChangeEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CallStateChangeEventArgs);
        return nullptr;
    }

    static void _dealloc_CallStateChangeEventArgs(py::wrapper::Windows::ApplicationModel::Calls::CallStateChangeEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CallStateChangeEventArgs_get_State(py::wrapper::Windows::ApplicationModel::Calls::CallStateChangeEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.CallStateChangeEventArgs", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CallStateChangeEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::CallStateChangeEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CallStateChangeEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::CallStateChangeEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CallStateChangeEventArgs[] = {
        { "_assign_array_", _assign_array_CallStateChangeEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CallStateChangeEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CallStateChangeEventArgs[] = {
        { "state", reinterpret_cast<getter>(CallStateChangeEventArgs_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CallStateChangeEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CallStateChangeEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CallStateChangeEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CallStateChangeEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CallStateChangeEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CallStateChangeEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Calls.CallStateChangeEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::CallStateChangeEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CallStateChangeEventArgs
    };

    // ----- LockScreenCallEndCallDeferral class --------------------
    static constexpr const char* const type_name_LockScreenCallEndCallDeferral = "LockScreenCallEndCallDeferral";

    static PyObject* _new_LockScreenCallEndCallDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LockScreenCallEndCallDeferral);
        return nullptr;
    }

    static void _dealloc_LockScreenCallEndCallDeferral(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallEndCallDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LockScreenCallEndCallDeferral_Complete(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallEndCallDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.LockScreenCallEndCallDeferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_LockScreenCallEndCallDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::LockScreenCallEndCallDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LockScreenCallEndCallDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::LockScreenCallEndCallDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LockScreenCallEndCallDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(LockScreenCallEndCallDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LockScreenCallEndCallDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LockScreenCallEndCallDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LockScreenCallEndCallDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_LockScreenCallEndCallDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LockScreenCallEndCallDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LockScreenCallEndCallDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LockScreenCallEndCallDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LockScreenCallEndCallDeferral) },
        { },
    };

    static PyType_Spec type_spec_LockScreenCallEndCallDeferral =
    {
        "_winsdk_Windows_ApplicationModel_Calls.LockScreenCallEndCallDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallEndCallDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LockScreenCallEndCallDeferral
    };

    // ----- LockScreenCallEndRequestedEventArgs class --------------------
    static constexpr const char* const type_name_LockScreenCallEndRequestedEventArgs = "LockScreenCallEndRequestedEventArgs";

    static PyObject* _new_LockScreenCallEndRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LockScreenCallEndRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_LockScreenCallEndRequestedEventArgs(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallEndRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LockScreenCallEndRequestedEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallEndRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.LockScreenCallEndRequestedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LockScreenCallEndRequestedEventArgs_get_Deadline(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallEndRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.LockScreenCallEndRequestedEventArgs", L"Deadline"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Deadline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LockScreenCallEndRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::LockScreenCallEndRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LockScreenCallEndRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::LockScreenCallEndRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LockScreenCallEndRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(LockScreenCallEndRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LockScreenCallEndRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LockScreenCallEndRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LockScreenCallEndRequestedEventArgs[] = {
        { "deadline", reinterpret_cast<getter>(LockScreenCallEndRequestedEventArgs_get_Deadline), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LockScreenCallEndRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LockScreenCallEndRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LockScreenCallEndRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LockScreenCallEndRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LockScreenCallEndRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_LockScreenCallEndRequestedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Calls.LockScreenCallEndRequestedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallEndRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LockScreenCallEndRequestedEventArgs
    };

    // ----- LockScreenCallUI class --------------------
    static constexpr const char* const type_name_LockScreenCallUI = "LockScreenCallUI";

    static PyObject* _new_LockScreenCallUI(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LockScreenCallUI);
        return nullptr;
    }

    static void _dealloc_LockScreenCallUI(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallUI* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LockScreenCallUI_Dismiss(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallUI* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.LockScreenCallUI", L"Dismiss", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Dismiss();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LockScreenCallUI_get_CallTitle(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallUI* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.LockScreenCallUI", L"CallTitle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CallTitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LockScreenCallUI_put_CallTitle(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.LockScreenCallUI", L"CallTitle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CallTitle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LockScreenCallUI_add_Closed(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallUI* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.LockScreenCallUI", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::LockScreenCallUI, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenCallUI_remove_Closed(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallUI* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.LockScreenCallUI", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenCallUI_add_EndRequested(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallUI* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.LockScreenCallUI", L"EndRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::LockScreenCallUI, winrt::Windows::ApplicationModel::Calls::LockScreenCallEndRequestedEventArgs>>(arg);

            return py::convert(self->obj.EndRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenCallUI_remove_EndRequested(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallUI* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.LockScreenCallUI", L"EndRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EndRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LockScreenCallUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::LockScreenCallUI>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LockScreenCallUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::LockScreenCallUI>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LockScreenCallUI[] = {
        { "dismiss", reinterpret_cast<PyCFunction>(LockScreenCallUI_Dismiss), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(LockScreenCallUI_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(LockScreenCallUI_remove_Closed), METH_O, nullptr },
        { "add_end_requested", reinterpret_cast<PyCFunction>(LockScreenCallUI_add_EndRequested), METH_O, nullptr },
        { "remove_end_requested", reinterpret_cast<PyCFunction>(LockScreenCallUI_remove_EndRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_LockScreenCallUI, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LockScreenCallUI), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LockScreenCallUI[] = {
        { "call_title", reinterpret_cast<getter>(LockScreenCallUI_get_CallTitle), reinterpret_cast<setter>(LockScreenCallUI_put_CallTitle), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LockScreenCallUI[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LockScreenCallUI) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LockScreenCallUI) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LockScreenCallUI) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LockScreenCallUI) },
        { },
    };

    static PyType_Spec type_spec_LockScreenCallUI =
    {
        "_winsdk_Windows_ApplicationModel_Calls.LockScreenCallUI",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallUI),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LockScreenCallUI
    };

    // ----- MuteChangeEventArgs class --------------------
    static constexpr const char* const type_name_MuteChangeEventArgs = "MuteChangeEventArgs";

    static PyObject* _new_MuteChangeEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MuteChangeEventArgs);
        return nullptr;
    }

    static void _dealloc_MuteChangeEventArgs(py::wrapper::Windows::ApplicationModel::Calls::MuteChangeEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MuteChangeEventArgs_get_Muted(py::wrapper::Windows::ApplicationModel::Calls::MuteChangeEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.MuteChangeEventArgs", L"Muted"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Muted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MuteChangeEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::MuteChangeEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MuteChangeEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::MuteChangeEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MuteChangeEventArgs[] = {
        { "_assign_array_", _assign_array_MuteChangeEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MuteChangeEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MuteChangeEventArgs[] = {
        { "muted", reinterpret_cast<getter>(MuteChangeEventArgs_get_Muted), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MuteChangeEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MuteChangeEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MuteChangeEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MuteChangeEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MuteChangeEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MuteChangeEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Calls.MuteChangeEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::MuteChangeEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MuteChangeEventArgs
    };

    // ----- PhoneCall class --------------------
    static constexpr const char* const type_name_PhoneCall = "PhoneCall";

    static PyObject* _new_PhoneCall(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PhoneCall);
        return nullptr;
    }

    static void _dealloc_PhoneCall(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCall_AcceptIncoming(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"AcceptIncoming", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.AcceptIncoming());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_AcceptIncomingAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"AcceptIncomingAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.AcceptIncomingAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_ChangeAudioDevice(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"ChangeAudioDevice", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallAudioDevice>(args, 0);

                return py::convert(self->obj.ChangeAudioDevice(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_ChangeAudioDeviceAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"ChangeAudioDeviceAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallAudioDevice>(args, 0);

                return py::convert(self->obj.ChangeAudioDeviceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_End(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"End", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.End());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_EndAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"EndAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.EndAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_GetFromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"GetFromId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCall::GetFromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_GetPhoneCallInfo(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"GetPhoneCallInfo", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetPhoneCallInfo());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_GetPhoneCallInfoAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"GetPhoneCallInfoAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetPhoneCallInfoAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_Hold(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"Hold", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Hold());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_HoldAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"HoldAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.HoldAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_Mute(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"Mute", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Mute());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_MuteAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"MuteAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.MuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_RejectIncoming(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"RejectIncoming", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RejectIncoming());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_RejectIncomingAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"RejectIncomingAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RejectIncomingAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_ResumeFromHold(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"ResumeFromHold", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ResumeFromHold());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_ResumeFromHoldAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"ResumeFromHoldAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ResumeFromHoldAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_SendDtmfKey(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"SendDtmfKey", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::DtmfKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Calls::DtmfToneAudioPlayback>(args, 1);

                return py::convert(self->obj.SendDtmfKey(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_SendDtmfKeyAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"SendDtmfKeyAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::DtmfKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Calls::DtmfToneAudioPlayback>(args, 1);

                return py::convert(self->obj.SendDtmfKeyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_Unmute(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"Unmute", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Unmute());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_UnmuteAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"UnmuteAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.UnmuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_get_AudioDevice(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"AudioDevice"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_get_CallId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"CallId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CallId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_get_IsMuted(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"IsMuted"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsMuted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_get_Status(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_add_AudioDeviceChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"AudioDeviceChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneCall, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AudioDeviceChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_remove_AudioDeviceChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"AudioDeviceChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AudioDeviceChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_add_IsMutedChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"IsMutedChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneCall, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.IsMutedChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_remove_IsMutedChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"IsMutedChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsMutedChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_add_StatusChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"StatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneCall, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_remove_StatusChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"StatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneCall(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneCall>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCall(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCall>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCall[] = {
        { "accept_incoming", reinterpret_cast<PyCFunction>(PhoneCall_AcceptIncoming), METH_VARARGS, nullptr },
        { "accept_incoming_async", reinterpret_cast<PyCFunction>(PhoneCall_AcceptIncomingAsync), METH_VARARGS, nullptr },
        { "change_audio_device", reinterpret_cast<PyCFunction>(PhoneCall_ChangeAudioDevice), METH_VARARGS, nullptr },
        { "change_audio_device_async", reinterpret_cast<PyCFunction>(PhoneCall_ChangeAudioDeviceAsync), METH_VARARGS, nullptr },
        { "end", reinterpret_cast<PyCFunction>(PhoneCall_End), METH_VARARGS, nullptr },
        { "end_async", reinterpret_cast<PyCFunction>(PhoneCall_EndAsync), METH_VARARGS, nullptr },
        { "get_from_id", reinterpret_cast<PyCFunction>(PhoneCall_GetFromId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_phone_call_info", reinterpret_cast<PyCFunction>(PhoneCall_GetPhoneCallInfo), METH_VARARGS, nullptr },
        { "get_phone_call_info_async", reinterpret_cast<PyCFunction>(PhoneCall_GetPhoneCallInfoAsync), METH_VARARGS, nullptr },
        { "hold", reinterpret_cast<PyCFunction>(PhoneCall_Hold), METH_VARARGS, nullptr },
        { "hold_async", reinterpret_cast<PyCFunction>(PhoneCall_HoldAsync), METH_VARARGS, nullptr },
        { "mute", reinterpret_cast<PyCFunction>(PhoneCall_Mute), METH_VARARGS, nullptr },
        { "mute_async", reinterpret_cast<PyCFunction>(PhoneCall_MuteAsync), METH_VARARGS, nullptr },
        { "reject_incoming", reinterpret_cast<PyCFunction>(PhoneCall_RejectIncoming), METH_VARARGS, nullptr },
        { "reject_incoming_async", reinterpret_cast<PyCFunction>(PhoneCall_RejectIncomingAsync), METH_VARARGS, nullptr },
        { "resume_from_hold", reinterpret_cast<PyCFunction>(PhoneCall_ResumeFromHold), METH_VARARGS, nullptr },
        { "resume_from_hold_async", reinterpret_cast<PyCFunction>(PhoneCall_ResumeFromHoldAsync), METH_VARARGS, nullptr },
        { "send_dtmf_key", reinterpret_cast<PyCFunction>(PhoneCall_SendDtmfKey), METH_VARARGS, nullptr },
        { "send_dtmf_key_async", reinterpret_cast<PyCFunction>(PhoneCall_SendDtmfKeyAsync), METH_VARARGS, nullptr },
        { "unmute", reinterpret_cast<PyCFunction>(PhoneCall_Unmute), METH_VARARGS, nullptr },
        { "unmute_async", reinterpret_cast<PyCFunction>(PhoneCall_UnmuteAsync), METH_VARARGS, nullptr },
        { "add_audio_device_changed", reinterpret_cast<PyCFunction>(PhoneCall_add_AudioDeviceChanged), METH_O, nullptr },
        { "remove_audio_device_changed", reinterpret_cast<PyCFunction>(PhoneCall_remove_AudioDeviceChanged), METH_O, nullptr },
        { "add_is_muted_changed", reinterpret_cast<PyCFunction>(PhoneCall_add_IsMutedChanged), METH_O, nullptr },
        { "remove_is_muted_changed", reinterpret_cast<PyCFunction>(PhoneCall_remove_IsMutedChanged), METH_O, nullptr },
        { "add_status_changed", reinterpret_cast<PyCFunction>(PhoneCall_add_StatusChanged), METH_O, nullptr },
        { "remove_status_changed", reinterpret_cast<PyCFunction>(PhoneCall_remove_StatusChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_PhoneCall, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCall), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCall[] = {
        { "audio_device", reinterpret_cast<getter>(PhoneCall_get_AudioDevice), nullptr, nullptr, nullptr },
        { "call_id", reinterpret_cast<getter>(PhoneCall_get_CallId), nullptr, nullptr, nullptr },
        { "is_muted", reinterpret_cast<getter>(PhoneCall_get_IsMuted), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(PhoneCall_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCall[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCall) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCall) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCall) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCall) },
        { },
    };

    static PyType_Spec type_spec_PhoneCall =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCall",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCall
    };

    // ----- PhoneCallBlocking class --------------------
    static constexpr const char* const type_name_PhoneCallBlocking = "PhoneCallBlocking";

    static PyObject* _new_PhoneCallBlocking(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PhoneCallBlocking);
        return nullptr;
    }

    static PyObject* PhoneCallBlocking_SetCallBlockingListAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallBlocking", L"SetCallBlockingListAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking::SetCallBlockingListAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallBlocking_get_BlockUnknownNumbers(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallBlocking", L"BlockUnknownNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking::BlockUnknownNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallBlocking_put_BlockUnknownNumbers(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallBlocking", L"BlockUnknownNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking::BlockUnknownNumbers(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallBlocking_get_BlockPrivateNumbers(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallBlocking", L"BlockPrivateNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking::BlockPrivateNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallBlocking_put_BlockPrivateNumbers(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallBlocking", L"BlockPrivateNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking::BlockPrivateNumbers(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallBlocking[] = {
        { "set_call_blocking_list_async", reinterpret_cast<PyCFunction>(PhoneCallBlocking_SetCallBlockingListAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallBlocking[] = {
        { }
    };

    static PyType_Slot _type_slots_PhoneCallBlocking[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallBlocking) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallBlocking) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallBlocking) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallBlocking =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallBlocking",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallBlocking
    };

    static PyGetSetDef getset_PhoneCallBlocking_Meta[] = {
        { "block_unknown_numbers", reinterpret_cast<getter>(PhoneCallBlocking_get_BlockUnknownNumbers), reinterpret_cast<setter>(PhoneCallBlocking_put_BlockUnknownNumbers), nullptr, nullptr },
        { "block_private_numbers", reinterpret_cast<getter>(PhoneCallBlocking_get_BlockPrivateNumbers), reinterpret_cast<setter>(PhoneCallBlocking_put_BlockPrivateNumbers), nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_PhoneCallBlocking_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PhoneCallBlocking_Meta) },
        { }
    };

    static PyType_Spec type_spec_PhoneCallBlocking_Meta =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallBlocking_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PhoneCallBlocking_Meta
    };

    // ----- PhoneCallHistoryEntry class --------------------
    static constexpr const char* const type_name_PhoneCallHistoryEntry = "PhoneCallHistoryEntry";

    static PyObject* _new_PhoneCallHistoryEntry(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PhoneCallHistoryEntry(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCallHistoryEntry_get_Media(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"Media"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Media());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_Media(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"Media"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryMedia>(arg);

            self->obj.Media(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsMissed(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsMissed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsMissed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsMissed(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsMissed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsMissed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsIncoming(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsIncoming"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsIncoming());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsIncoming(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsIncoming"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsIncoming(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsCallerIdBlocked(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsCallerIdBlocked"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCallerIdBlocked());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsCallerIdBlocked(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsCallerIdBlocked"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCallerIdBlocked(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsSeen(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsSeen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSeen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsSeen(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsSeen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSeen(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_Duration(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_Duration(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsEmergency(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsEmergency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEmergency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsEmergency(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsEmergency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEmergency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsSuppressed(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsSuppressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSuppressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsSuppressed(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsSuppressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSuppressed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_StartTime(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_StartTime(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_SourceIdKind(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"SourceIdKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceIdKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_SourceIdKind(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"SourceIdKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistorySourceIdKind>(arg);

            self->obj.SourceIdKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_Address(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"Address"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_Address(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"Address"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress>(arg);

            self->obj.Address(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_SourceId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"SourceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_SourceId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"SourceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SourceId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_RemoteId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"RemoteId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_RemoteId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"RemoteId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RemoteId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_OtherAppReadAccess(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"OtherAppReadAccess"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OtherAppReadAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_OtherAppReadAccess(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"OtherAppReadAccess"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryOtherAppReadAccess>(arg);

            self->obj.OtherAppReadAccess(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsRinging(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsRinging"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRinging());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsRinging(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsRinging"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRinging(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsVoicemail(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsVoicemail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsVoicemail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsVoicemail(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsVoicemail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsVoicemail(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_Id(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_SourceDisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"SourceDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneCallHistoryEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCallHistoryEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryEntry[] = {
        { "_assign_array_", _assign_array_PhoneCallHistoryEntry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallHistoryEntry), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallHistoryEntry[] = {
        { "media", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_Media), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_Media), nullptr, nullptr },
        { "is_missed", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_IsMissed), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_IsMissed), nullptr, nullptr },
        { "is_incoming", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_IsIncoming), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_IsIncoming), nullptr, nullptr },
        { "is_caller_id_blocked", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_IsCallerIdBlocked), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_IsCallerIdBlocked), nullptr, nullptr },
        { "is_seen", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_IsSeen), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_IsSeen), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_Duration), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_Duration), nullptr, nullptr },
        { "is_emergency", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_IsEmergency), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_IsEmergency), nullptr, nullptr },
        { "is_suppressed", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_IsSuppressed), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_IsSuppressed), nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_StartTime), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_StartTime), nullptr, nullptr },
        { "source_id_kind", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_SourceIdKind), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_SourceIdKind), nullptr, nullptr },
        { "address", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_Address), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_Address), nullptr, nullptr },
        { "source_id", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_SourceId), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_SourceId), nullptr, nullptr },
        { "remote_id", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_RemoteId), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_RemoteId), nullptr, nullptr },
        { "other_app_read_access", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_OtherAppReadAccess), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_OtherAppReadAccess), nullptr, nullptr },
        { "is_ringing", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_IsRinging), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_IsRinging), nullptr, nullptr },
        { "is_voicemail", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_IsVoicemail), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_IsVoicemail), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_Id), nullptr, nullptr, nullptr },
        { "source_display_name", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_SourceDisplayName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryEntry[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallHistoryEntry) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCallHistoryEntry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallHistoryEntry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallHistoryEntry) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallHistoryEntry =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallHistoryEntry",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryEntry
    };

    // ----- PhoneCallHistoryEntryAddress class --------------------
    static constexpr const char* const type_name_PhoneCallHistoryEntryAddress = "PhoneCallHistoryEntryAddress";

    static PyObject* _new_PhoneCallHistoryEntryAddress(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryRawAddressKind>(args, 1);

                winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PhoneCallHistoryEntryAddress(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCallHistoryEntryAddress_get_RawAddressKind(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntryAddress", L"RawAddressKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawAddressKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntryAddress_put_RawAddressKind(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntryAddress", L"RawAddressKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryRawAddressKind>(arg);

            self->obj.RawAddressKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntryAddress_get_RawAddress(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntryAddress", L"RawAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntryAddress_put_RawAddress(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntryAddress", L"RawAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RawAddress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntryAddress_get_DisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntryAddress", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntryAddress_put_DisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntryAddress", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntryAddress_get_ContactId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntryAddress", L"ContactId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntryAddress_put_ContactId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntryAddress", L"ContactId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContactId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PhoneCallHistoryEntryAddress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCallHistoryEntryAddress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryEntryAddress[] = {
        { "_assign_array_", _assign_array_PhoneCallHistoryEntryAddress, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallHistoryEntryAddress), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallHistoryEntryAddress[] = {
        { "raw_address_kind", reinterpret_cast<getter>(PhoneCallHistoryEntryAddress_get_RawAddressKind), reinterpret_cast<setter>(PhoneCallHistoryEntryAddress_put_RawAddressKind), nullptr, nullptr },
        { "raw_address", reinterpret_cast<getter>(PhoneCallHistoryEntryAddress_get_RawAddress), reinterpret_cast<setter>(PhoneCallHistoryEntryAddress_put_RawAddress), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PhoneCallHistoryEntryAddress_get_DisplayName), reinterpret_cast<setter>(PhoneCallHistoryEntryAddress_put_DisplayName), nullptr, nullptr },
        { "contact_id", reinterpret_cast<getter>(PhoneCallHistoryEntryAddress_get_ContactId), reinterpret_cast<setter>(PhoneCallHistoryEntryAddress_put_ContactId), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryEntryAddress[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallHistoryEntryAddress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCallHistoryEntryAddress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallHistoryEntryAddress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallHistoryEntryAddress) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallHistoryEntryAddress =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallHistoryEntryAddress",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryEntryAddress
    };

    // ----- PhoneCallHistoryEntryQueryOptions class --------------------
    static constexpr const char* const type_name_PhoneCallHistoryEntryQueryOptions = "PhoneCallHistoryEntryQueryOptions";

    static PyObject* _new_PhoneCallHistoryEntryQueryOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PhoneCallHistoryEntryQueryOptions(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCallHistoryEntryQueryOptions_get_DesiredMedia(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntryQueryOptions", L"DesiredMedia"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredMedia());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntryQueryOptions_put_DesiredMedia(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntryQueryOptions", L"DesiredMedia"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryDesiredMedia>(arg);

            self->obj.DesiredMedia(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntryQueryOptions_get_SourceIds(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntryQueryOptions", L"SourceIds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneCallHistoryEntryQueryOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCallHistoryEntryQueryOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryEntryQueryOptions[] = {
        { "_assign_array_", _assign_array_PhoneCallHistoryEntryQueryOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallHistoryEntryQueryOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallHistoryEntryQueryOptions[] = {
        { "desired_media", reinterpret_cast<getter>(PhoneCallHistoryEntryQueryOptions_get_DesiredMedia), reinterpret_cast<setter>(PhoneCallHistoryEntryQueryOptions_put_DesiredMedia), nullptr, nullptr },
        { "source_ids", reinterpret_cast<getter>(PhoneCallHistoryEntryQueryOptions_get_SourceIds), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryEntryQueryOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallHistoryEntryQueryOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCallHistoryEntryQueryOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallHistoryEntryQueryOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallHistoryEntryQueryOptions) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallHistoryEntryQueryOptions =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallHistoryEntryQueryOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryEntryQueryOptions
    };

    // ----- PhoneCallHistoryEntryReader class --------------------
    static constexpr const char* const type_name_PhoneCallHistoryEntryReader = "PhoneCallHistoryEntryReader";

    static PyObject* _new_PhoneCallHistoryEntryReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PhoneCallHistoryEntryReader);
        return nullptr;
    }

    static void _dealloc_PhoneCallHistoryEntryReader(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryReader* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCallHistoryEntryReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntryReader", L"ReadBatchAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneCallHistoryEntryReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCallHistoryEntryReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryEntryReader[] = {
        { "read_batch_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryEntryReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PhoneCallHistoryEntryReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallHistoryEntryReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallHistoryEntryReader[] = {
        { }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryEntryReader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallHistoryEntryReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCallHistoryEntryReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallHistoryEntryReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallHistoryEntryReader) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallHistoryEntryReader =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallHistoryEntryReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryEntryReader
    };

    // ----- PhoneCallHistoryManager class --------------------
    static constexpr const char* const type_name_PhoneCallHistoryManager = "PhoneCallHistoryManager";

    static PyObject* _new_PhoneCallHistoryManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PhoneCallHistoryManager);
        return nullptr;
    }

    static PyObject* PhoneCallHistoryManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryManager", L"GetForUser", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManager::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryManager_RequestStoreAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryManager", L"RequestStoreAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryStoreAccessType>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManager::RequestStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryManager[] = {
        { "get_for_user", reinterpret_cast<PyCFunction>(PhoneCallHistoryManager_GetForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "request_store_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryManager_RequestStoreAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallHistoryManager[] = {
        { }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallHistoryManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallHistoryManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallHistoryManager) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallHistoryManager =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallHistoryManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryManager
    };

    // ----- PhoneCallHistoryManagerForUser class --------------------
    static constexpr const char* const type_name_PhoneCallHistoryManagerForUser = "PhoneCallHistoryManagerForUser";

    static PyObject* _new_PhoneCallHistoryManagerForUser(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PhoneCallHistoryManagerForUser);
        return nullptr;
    }

    static void _dealloc_PhoneCallHistoryManagerForUser(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCallHistoryManagerForUser_RequestStoreAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryManagerForUser", L"RequestStoreAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryStoreAccessType>(args, 0);

                return py::convert(self->obj.RequestStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryManagerForUser_get_User(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryManagerForUser", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneCallHistoryManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCallHistoryManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryManagerForUser[] = {
        { "request_store_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryManagerForUser_RequestStoreAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PhoneCallHistoryManagerForUser, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallHistoryManagerForUser), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallHistoryManagerForUser[] = {
        { "user", reinterpret_cast<getter>(PhoneCallHistoryManagerForUser_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryManagerForUser[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallHistoryManagerForUser) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCallHistoryManagerForUser) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallHistoryManagerForUser) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallHistoryManagerForUser) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallHistoryManagerForUser =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallHistoryManagerForUser",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryManagerForUser
    };

    // ----- PhoneCallHistoryStore class --------------------
    static constexpr const char* const type_name_PhoneCallHistoryStore = "PhoneCallHistoryStore";

    static PyObject* _new_PhoneCallHistoryStore(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PhoneCallHistoryStore);
        return nullptr;
    }

    static void _dealloc_PhoneCallHistoryStore(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCallHistoryStore_DeleteEntriesAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryStore", L"DeleteEntriesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>>(args, 0);

                return py::convert(self->obj.DeleteEntriesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_DeleteEntryAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryStore", L"DeleteEntryAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>(args, 0);

                return py::convert(self->obj.DeleteEntryAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_GetEntryAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryStore", L"GetEntryAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetEntryAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_GetEntryReader(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryStore", L"GetEntryReader", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetEntryReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryStore", L"GetEntryReader", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions>(args, 0);

                return py::convert(self->obj.GetEntryReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_GetSourcesUnseenCountAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryStore", L"GetSourcesUnseenCountAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetSourcesUnseenCountAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_GetUnseenCountAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryStore", L"GetUnseenCountAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetUnseenCountAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_MarkAllAsSeenAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryStore", L"MarkAllAsSeenAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.MarkAllAsSeenAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_MarkEntriesAsSeenAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryStore", L"MarkEntriesAsSeenAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>>(args, 0);

                return py::convert(self->obj.MarkEntriesAsSeenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_MarkEntryAsSeenAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryStore", L"MarkEntryAsSeenAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>(args, 0);

                return py::convert(self->obj.MarkEntryAsSeenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_MarkSourcesAsSeenAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryStore", L"MarkSourcesAsSeenAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.MarkSourcesAsSeenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_SaveEntryAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryStore", L"SaveEntryAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>(args, 0);

                return py::convert(self->obj.SaveEntryAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneCallHistoryStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryStore>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCallHistoryStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryStore[] = {
        { "delete_entries_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_DeleteEntriesAsync), METH_VARARGS, nullptr },
        { "delete_entry_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_DeleteEntryAsync), METH_VARARGS, nullptr },
        { "get_entry_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_GetEntryAsync), METH_VARARGS, nullptr },
        { "get_entry_reader", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_GetEntryReader), METH_VARARGS, nullptr },
        { "get_sources_unseen_count_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_GetSourcesUnseenCountAsync), METH_VARARGS, nullptr },
        { "get_unseen_count_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_GetUnseenCountAsync), METH_VARARGS, nullptr },
        { "mark_all_as_seen_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_MarkAllAsSeenAsync), METH_VARARGS, nullptr },
        { "mark_entries_as_seen_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_MarkEntriesAsSeenAsync), METH_VARARGS, nullptr },
        { "mark_entry_as_seen_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_MarkEntryAsSeenAsync), METH_VARARGS, nullptr },
        { "mark_sources_as_seen_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_MarkSourcesAsSeenAsync), METH_VARARGS, nullptr },
        { "save_entry_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_SaveEntryAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PhoneCallHistoryStore, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallHistoryStore), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallHistoryStore[] = {
        { }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryStore[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallHistoryStore) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCallHistoryStore) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallHistoryStore) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallHistoryStore) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallHistoryStore =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallHistoryStore",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryStore
    };

    // ----- PhoneCallInfo class --------------------
    static constexpr const char* const type_name_PhoneCallInfo = "PhoneCallInfo";

    static PyObject* _new_PhoneCallInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PhoneCallInfo);
        return nullptr;
    }

    static void _dealloc_PhoneCallInfo(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCallInfo_get_CallDirection(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallInfo", L"CallDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CallDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallInfo_get_DisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallInfo", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallInfo_get_IsHoldSupported(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallInfo", L"IsHoldSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsHoldSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallInfo_get_LineId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallInfo", L"LineId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallInfo_get_PhoneNumber(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallInfo", L"PhoneNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhoneNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallInfo_get_StartTime(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallInfo", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneCallInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneCallInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCallInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallInfo[] = {
        { "_assign_array_", _assign_array_PhoneCallInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallInfo[] = {
        { "call_direction", reinterpret_cast<getter>(PhoneCallInfo_get_CallDirection), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PhoneCallInfo_get_DisplayName), nullptr, nullptr, nullptr },
        { "is_hold_supported", reinterpret_cast<getter>(PhoneCallInfo_get_IsHoldSupported), nullptr, nullptr, nullptr },
        { "line_id", reinterpret_cast<getter>(PhoneCallInfo_get_LineId), nullptr, nullptr, nullptr },
        { "phone_number", reinterpret_cast<getter>(PhoneCallInfo_get_PhoneNumber), nullptr, nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(PhoneCallInfo_get_StartTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCallInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCallInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallInfo) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallInfo =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallInfo
    };

    // ----- PhoneCallManager class --------------------
    static constexpr const char* const type_name_PhoneCallManager = "PhoneCallManager";

    static PyObject* _new_PhoneCallManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PhoneCallManager);
        return nullptr;
    }

    static PyObject* PhoneCallManager_RequestStoreAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallManager", L"RequestStoreAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallManager::RequestStoreAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallManager_ShowPhoneCallSettingsUI(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallManager", L"ShowPhoneCallSettingsUI", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::Windows::ApplicationModel::Calls::PhoneCallManager::ShowPhoneCallSettingsUI();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallManager_ShowPhoneCallUI(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallManager", L"ShowPhoneCallUI", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Calls::PhoneCallManager::ShowPhoneCallUI(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallManager_get_IsCallActive(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallManager", L"IsCallActive"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallManager::IsCallActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallManager_get_IsCallIncoming(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallManager", L"IsCallIncoming"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallManager::IsCallIncoming());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallManager_add_CallStateChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneCallManager", L"CallStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallManager::CallStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallManager_remove_CallStateChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneCallManager", L"CallStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::ApplicationModel::Calls::PhoneCallManager::CallStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallManager[] = {
        { "request_store_async", reinterpret_cast<PyCFunction>(PhoneCallManager_RequestStoreAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "show_phone_call_settings_u_i", reinterpret_cast<PyCFunction>(PhoneCallManager_ShowPhoneCallSettingsUI), METH_VARARGS | METH_STATIC, nullptr },
        { "show_phone_call_u_i", reinterpret_cast<PyCFunction>(PhoneCallManager_ShowPhoneCallUI), METH_VARARGS | METH_STATIC, nullptr },
        { "add_call_state_changed", reinterpret_cast<PyCFunction>(PhoneCallManager_add_CallStateChanged), METH_O | METH_STATIC, nullptr },
        { "remove_call_state_changed", reinterpret_cast<PyCFunction>(PhoneCallManager_remove_CallStateChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallManager[] = {
        { }
    };

    static PyType_Slot _type_slots_PhoneCallManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallManager) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallManager =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallManager
    };

    static PyGetSetDef getset_PhoneCallManager_Meta[] = {
        { "is_call_active", reinterpret_cast<getter>(PhoneCallManager_get_IsCallActive), nullptr, nullptr, nullptr },
        { "is_call_incoming", reinterpret_cast<getter>(PhoneCallManager_get_IsCallIncoming), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_PhoneCallManager_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PhoneCallManager_Meta) },
        { }
    };

    static PyType_Spec type_spec_PhoneCallManager_Meta =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallManager_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PhoneCallManager_Meta
    };

    // ----- PhoneCallStore class --------------------
    static constexpr const char* const type_name_PhoneCallStore = "PhoneCallStore";

    static PyObject* _new_PhoneCallStore(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PhoneCallStore);
        return nullptr;
    }

    static void _dealloc_PhoneCallStore(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallStore* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCallStore_GetDefaultLineAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallStore", L"GetDefaultLineAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDefaultLineAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallStore_IsEmergencyPhoneNumberAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallStore", L"IsEmergencyPhoneNumberAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsEmergencyPhoneNumberAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallStore_RequestLineWatcher(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallStore", L"RequestLineWatcher", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RequestLineWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneCallStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneCallStore>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCallStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallStore[] = {
        { "get_default_line_async", reinterpret_cast<PyCFunction>(PhoneCallStore_GetDefaultLineAsync), METH_VARARGS, nullptr },
        { "is_emergency_phone_number_async", reinterpret_cast<PyCFunction>(PhoneCallStore_IsEmergencyPhoneNumberAsync), METH_VARARGS, nullptr },
        { "request_line_watcher", reinterpret_cast<PyCFunction>(PhoneCallStore_RequestLineWatcher), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PhoneCallStore, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallStore), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallStore[] = {
        { }
    };

    static PyType_Slot _type_slots_PhoneCallStore[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallStore) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCallStore) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallStore) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallStore) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallStore =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallStore",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallStore
    };

    // ----- PhoneCallVideoCapabilities class --------------------
    static constexpr const char* const type_name_PhoneCallVideoCapabilities = "PhoneCallVideoCapabilities";

    static PyObject* _new_PhoneCallVideoCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PhoneCallVideoCapabilities);
        return nullptr;
    }

    static void _dealloc_PhoneCallVideoCapabilities(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCallVideoCapabilities_get_IsVideoCallingCapable(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallVideoCapabilities", L"IsVideoCallingCapable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsVideoCallingCapable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneCallVideoCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCallVideoCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallVideoCapabilities[] = {
        { "_assign_array_", _assign_array_PhoneCallVideoCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallVideoCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallVideoCapabilities[] = {
        { "is_video_calling_capable", reinterpret_cast<getter>(PhoneCallVideoCapabilities_get_IsVideoCallingCapable), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCallVideoCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallVideoCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCallVideoCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallVideoCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallVideoCapabilities) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallVideoCapabilities =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallVideoCapabilities",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallVideoCapabilities
    };

    // ----- PhoneCallVideoCapabilitiesManager class --------------------
    static constexpr const char* const type_name_PhoneCallVideoCapabilitiesManager = "PhoneCallVideoCapabilitiesManager";

    static PyObject* _new_PhoneCallVideoCapabilitiesManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PhoneCallVideoCapabilitiesManager);
        return nullptr;
    }

    static PyObject* PhoneCallVideoCapabilitiesManager_GetCapabilitiesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallVideoCapabilitiesManager", L"GetCapabilitiesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilitiesManager::GetCapabilitiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallVideoCapabilitiesManager[] = {
        { "get_capabilities_async", reinterpret_cast<PyCFunction>(PhoneCallVideoCapabilitiesManager_GetCapabilitiesAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallVideoCapabilitiesManager[] = {
        { }
    };

    static PyType_Slot _type_slots_PhoneCallVideoCapabilitiesManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallVideoCapabilitiesManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallVideoCapabilitiesManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallVideoCapabilitiesManager) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallVideoCapabilitiesManager =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallVideoCapabilitiesManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallVideoCapabilitiesManager
    };

    // ----- PhoneCallsResult class --------------------
    static constexpr const char* const type_name_PhoneCallsResult = "PhoneCallsResult";

    static PyObject* _new_PhoneCallsResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PhoneCallsResult);
        return nullptr;
    }

    static void _dealloc_PhoneCallsResult(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallsResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCallsResult_get_AllActivePhoneCalls(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallsResult", L"AllActivePhoneCalls"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllActivePhoneCalls());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallsResult_get_OperationStatus(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallsResult", L"OperationStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OperationStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneCallsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneCallsResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCallsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallsResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallsResult[] = {
        { "_assign_array_", _assign_array_PhoneCallsResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallsResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallsResult[] = {
        { "all_active_phone_calls", reinterpret_cast<getter>(PhoneCallsResult_get_AllActivePhoneCalls), nullptr, nullptr, nullptr },
        { "operation_status", reinterpret_cast<getter>(PhoneCallsResult_get_OperationStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCallsResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallsResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCallsResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallsResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallsResult) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallsResult =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallsResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallsResult
    };

    // ----- PhoneDialOptions class --------------------
    static constexpr const char* const type_name_PhoneDialOptions = "PhoneDialOptions";

    static PyObject* _new_PhoneDialOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Calls::PhoneDialOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PhoneDialOptions(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneDialOptions_get_Number(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneDialOptions", L"Number"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Number());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneDialOptions_put_Number(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneDialOptions", L"Number"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Number(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneDialOptions_get_Media(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneDialOptions", L"Media"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Media());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneDialOptions_put_Media(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneDialOptions", L"Media"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallMedia>(arg);

            self->obj.Media(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneDialOptions_get_DisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneDialOptions", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneDialOptions_put_DisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneDialOptions", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneDialOptions_get_ContactPhone(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneDialOptions", L"ContactPhone"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactPhone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneDialOptions_put_ContactPhone(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneDialOptions", L"ContactPhone"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactPhone>(arg);

            self->obj.ContactPhone(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneDialOptions_get_Contact(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneDialOptions", L"Contact"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneDialOptions_put_Contact(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneDialOptions", L"Contact"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(arg);

            self->obj.Contact(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneDialOptions_get_AudioEndpoint(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneDialOptions", L"AudioEndpoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioEndpoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneDialOptions_put_AudioEndpoint(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneDialOptions", L"AudioEndpoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneAudioRoutingEndpoint>(arg);

            self->obj.AudioEndpoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PhoneDialOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneDialOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneDialOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneDialOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneDialOptions[] = {
        { "_assign_array_", _assign_array_PhoneDialOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneDialOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneDialOptions[] = {
        { "number", reinterpret_cast<getter>(PhoneDialOptions_get_Number), reinterpret_cast<setter>(PhoneDialOptions_put_Number), nullptr, nullptr },
        { "media", reinterpret_cast<getter>(PhoneDialOptions_get_Media), reinterpret_cast<setter>(PhoneDialOptions_put_Media), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PhoneDialOptions_get_DisplayName), reinterpret_cast<setter>(PhoneDialOptions_put_DisplayName), nullptr, nullptr },
        { "contact_phone", reinterpret_cast<getter>(PhoneDialOptions_get_ContactPhone), reinterpret_cast<setter>(PhoneDialOptions_put_ContactPhone), nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(PhoneDialOptions_get_Contact), reinterpret_cast<setter>(PhoneDialOptions_put_Contact), nullptr, nullptr },
        { "audio_endpoint", reinterpret_cast<getter>(PhoneDialOptions_get_AudioEndpoint), reinterpret_cast<setter>(PhoneDialOptions_put_AudioEndpoint), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneDialOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneDialOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneDialOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneDialOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneDialOptions) },
        { },
    };

    static PyType_Spec type_spec_PhoneDialOptions =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneDialOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneDialOptions
    };

    // ----- PhoneLine class --------------------
    static constexpr const char* const type_name_PhoneLine = "PhoneLine";

    static PyObject* _new_PhoneLine(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PhoneLine);
        return nullptr;
    }

    static void _dealloc_PhoneLine(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneLine_Dial(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"Dial", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Dial(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_DialWithOptions(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"DialWithOptions", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneDialOptions>(args, 0);

                self->obj.DialWithOptions(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_DialWithResult(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"DialWithResult", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.DialWithResult(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_DialWithResultAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"DialWithResultAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.DialWithResultAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_EnableTextReply(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"EnableTextReply", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.EnableTextReply(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneLine::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_GetAllActivePhoneCalls(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"GetAllActivePhoneCalls", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAllActivePhoneCalls());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_GetAllActivePhoneCallsAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"GetAllActivePhoneCallsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAllActivePhoneCallsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_IsImmediateDialNumberAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"IsImmediateDialNumberAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsImmediateDialNumberAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_CanDial(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"CanDial"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanDial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_CellularDetails(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"CellularDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CellularDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_DisplayColor(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"DisplayColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_DisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_Id(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_LineConfiguration(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"LineConfiguration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineConfiguration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_NetworkName(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"NetworkName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_NetworkState(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"NetworkState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_SupportsTile(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"SupportsTile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportsTile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_Transport(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"Transport"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Transport());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_VideoCallingCapabilities(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"VideoCallingCapabilities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoCallingCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_Voicemail(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"Voicemail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Voicemail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_TransportDeviceId(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"TransportDeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransportDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_add_LineChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"LineChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLine, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.LineChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_remove_LineChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"LineChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LineChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneLine(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneLine>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneLine(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLine>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLine[] = {
        { "dial", reinterpret_cast<PyCFunction>(PhoneLine_Dial), METH_VARARGS, nullptr },
        { "dial_with_options", reinterpret_cast<PyCFunction>(PhoneLine_DialWithOptions), METH_VARARGS, nullptr },
        { "dial_with_result", reinterpret_cast<PyCFunction>(PhoneLine_DialWithResult), METH_VARARGS, nullptr },
        { "dial_with_result_async", reinterpret_cast<PyCFunction>(PhoneLine_DialWithResultAsync), METH_VARARGS, nullptr },
        { "enable_text_reply", reinterpret_cast<PyCFunction>(PhoneLine_EnableTextReply), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(PhoneLine_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_all_active_phone_calls", reinterpret_cast<PyCFunction>(PhoneLine_GetAllActivePhoneCalls), METH_VARARGS, nullptr },
        { "get_all_active_phone_calls_async", reinterpret_cast<PyCFunction>(PhoneLine_GetAllActivePhoneCallsAsync), METH_VARARGS, nullptr },
        { "is_immediate_dial_number_async", reinterpret_cast<PyCFunction>(PhoneLine_IsImmediateDialNumberAsync), METH_VARARGS, nullptr },
        { "add_line_changed", reinterpret_cast<PyCFunction>(PhoneLine_add_LineChanged), METH_O, nullptr },
        { "remove_line_changed", reinterpret_cast<PyCFunction>(PhoneLine_remove_LineChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_PhoneLine, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneLine), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneLine[] = {
        { "can_dial", reinterpret_cast<getter>(PhoneLine_get_CanDial), nullptr, nullptr, nullptr },
        { "cellular_details", reinterpret_cast<getter>(PhoneLine_get_CellularDetails), nullptr, nullptr, nullptr },
        { "display_color", reinterpret_cast<getter>(PhoneLine_get_DisplayColor), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PhoneLine_get_DisplayName), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(PhoneLine_get_Id), nullptr, nullptr, nullptr },
        { "line_configuration", reinterpret_cast<getter>(PhoneLine_get_LineConfiguration), nullptr, nullptr, nullptr },
        { "network_name", reinterpret_cast<getter>(PhoneLine_get_NetworkName), nullptr, nullptr, nullptr },
        { "network_state", reinterpret_cast<getter>(PhoneLine_get_NetworkState), nullptr, nullptr, nullptr },
        { "supports_tile", reinterpret_cast<getter>(PhoneLine_get_SupportsTile), nullptr, nullptr, nullptr },
        { "transport", reinterpret_cast<getter>(PhoneLine_get_Transport), nullptr, nullptr, nullptr },
        { "video_calling_capabilities", reinterpret_cast<getter>(PhoneLine_get_VideoCallingCapabilities), nullptr, nullptr, nullptr },
        { "voicemail", reinterpret_cast<getter>(PhoneLine_get_Voicemail), nullptr, nullptr, nullptr },
        { "transport_device_id", reinterpret_cast<getter>(PhoneLine_get_TransportDeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneLine[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneLine) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneLine) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneLine) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneLine) },
        { },
    };

    static PyType_Spec type_spec_PhoneLine =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneLine",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLine
    };

    // ----- PhoneLineCellularDetails class --------------------
    static constexpr const char* const type_name_PhoneLineCellularDetails = "PhoneLineCellularDetails";

    static PyObject* _new_PhoneLineCellularDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PhoneLineCellularDetails);
        return nullptr;
    }

    static void _dealloc_PhoneLineCellularDetails(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneLineCellularDetails_GetNetworkOperatorDisplayText(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineCellularDetails", L"GetNetworkOperatorDisplayText", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneLineNetworkOperatorDisplayTextLocation>(args, 0);

                return py::convert(self->obj.GetNetworkOperatorDisplayText(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineCellularDetails_get_IsModemOn(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineCellularDetails", L"IsModemOn"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsModemOn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineCellularDetails_get_RegistrationRejectCode(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineCellularDetails", L"RegistrationRejectCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RegistrationRejectCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineCellularDetails_get_SimSlotIndex(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineCellularDetails", L"SimSlotIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SimSlotIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineCellularDetails_get_SimState(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineCellularDetails", L"SimState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SimState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneLineCellularDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneLineCellularDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneLineCellularDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLineCellularDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLineCellularDetails[] = {
        { "get_network_operator_display_text", reinterpret_cast<PyCFunction>(PhoneLineCellularDetails_GetNetworkOperatorDisplayText), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PhoneLineCellularDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneLineCellularDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneLineCellularDetails[] = {
        { "is_modem_on", reinterpret_cast<getter>(PhoneLineCellularDetails_get_IsModemOn), nullptr, nullptr, nullptr },
        { "registration_reject_code", reinterpret_cast<getter>(PhoneLineCellularDetails_get_RegistrationRejectCode), nullptr, nullptr, nullptr },
        { "sim_slot_index", reinterpret_cast<getter>(PhoneLineCellularDetails_get_SimSlotIndex), nullptr, nullptr, nullptr },
        { "sim_state", reinterpret_cast<getter>(PhoneLineCellularDetails_get_SimState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneLineCellularDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneLineCellularDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneLineCellularDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneLineCellularDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneLineCellularDetails) },
        { },
    };

    static PyType_Spec type_spec_PhoneLineCellularDetails =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneLineCellularDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLineCellularDetails
    };

    // ----- PhoneLineConfiguration class --------------------
    static constexpr const char* const type_name_PhoneLineConfiguration = "PhoneLineConfiguration";

    static PyObject* _new_PhoneLineConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PhoneLineConfiguration);
        return nullptr;
    }

    static void _dealloc_PhoneLineConfiguration(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneLineConfiguration_get_ExtendedProperties(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineConfiguration", L"ExtendedProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineConfiguration_get_IsVideoCallingEnabled(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineConfiguration", L"IsVideoCallingEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsVideoCallingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneLineConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneLineConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneLineConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLineConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLineConfiguration[] = {
        { "_assign_array_", _assign_array_PhoneLineConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneLineConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneLineConfiguration[] = {
        { "extended_properties", reinterpret_cast<getter>(PhoneLineConfiguration_get_ExtendedProperties), nullptr, nullptr, nullptr },
        { "is_video_calling_enabled", reinterpret_cast<getter>(PhoneLineConfiguration_get_IsVideoCallingEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneLineConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneLineConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneLineConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneLineConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneLineConfiguration) },
        { },
    };

    static PyType_Spec type_spec_PhoneLineConfiguration =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneLineConfiguration",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLineConfiguration
    };

    // ----- PhoneLineDialResult class --------------------
    static constexpr const char* const type_name_PhoneLineDialResult = "PhoneLineDialResult";

    static PyObject* _new_PhoneLineDialResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PhoneLineDialResult);
        return nullptr;
    }

    static void _dealloc_PhoneLineDialResult(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineDialResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneLineDialResult_get_DialCallStatus(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineDialResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineDialResult", L"DialCallStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DialCallStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineDialResult_get_DialedCall(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineDialResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineDialResult", L"DialedCall"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DialedCall());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneLineDialResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneLineDialResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneLineDialResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLineDialResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLineDialResult[] = {
        { "_assign_array_", _assign_array_PhoneLineDialResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneLineDialResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneLineDialResult[] = {
        { "dial_call_status", reinterpret_cast<getter>(PhoneLineDialResult_get_DialCallStatus), nullptr, nullptr, nullptr },
        { "dialed_call", reinterpret_cast<getter>(PhoneLineDialResult_get_DialedCall), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneLineDialResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneLineDialResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneLineDialResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneLineDialResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneLineDialResult) },
        { },
    };

    static PyType_Spec type_spec_PhoneLineDialResult =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneLineDialResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineDialResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLineDialResult
    };

    // ----- PhoneLineTransportDevice class --------------------
    static constexpr const char* const type_name_PhoneLineTransportDevice = "PhoneLineTransportDevice";

    static PyObject* _new_PhoneLineTransportDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PhoneLineTransportDevice);
        return nullptr;
    }

    static void _dealloc_PhoneLineTransportDevice(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneLineTransportDevice_Connect(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"Connect", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Connect());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_ConnectAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"ConnectAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ConnectAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_FromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"FromId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice::FromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"GetDeviceSelector", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneLineTransport>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_IsRegistered(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"IsRegistered", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsRegistered());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_RegisterApp(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"RegisterApp", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RegisterApp();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_RegisterAppForUser(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"RegisterAppForUser", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                self->obj.RegisterAppForUser(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_RequestAccessAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"RequestAccessAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_UnregisterApp(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"UnregisterApp", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.UnregisterApp();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_UnregisterAppForUser(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"UnregisterAppForUser", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                self->obj.UnregisterAppForUser(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_get_DeviceId(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_get_Transport(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"Transport"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Transport());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_get_AudioRoutingStatus(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"AudioRoutingStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioRoutingStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_get_InBandRingingEnabled(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"InBandRingingEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InBandRingingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_add_AudioRoutingStatusChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"AudioRoutingStatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AudioRoutingStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_remove_AudioRoutingStatusChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"AudioRoutingStatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AudioRoutingStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_add_InBandRingingEnabledChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"InBandRingingEnabledChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.InBandRingingEnabledChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_remove_InBandRingingEnabledChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"InBandRingingEnabledChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InBandRingingEnabledChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneLineTransportDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneLineTransportDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLineTransportDevice[] = {
        { "connect", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_Connect), METH_VARARGS, nullptr },
        { "connect_async", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_ConnectAsync), METH_VARARGS, nullptr },
        { "from_id", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_FromId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "is_registered", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_IsRegistered), METH_VARARGS, nullptr },
        { "register_app", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_RegisterApp), METH_VARARGS, nullptr },
        { "register_app_for_user", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_RegisterAppForUser), METH_VARARGS, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_RequestAccessAsync), METH_VARARGS, nullptr },
        { "unregister_app", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_UnregisterApp), METH_VARARGS, nullptr },
        { "unregister_app_for_user", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_UnregisterAppForUser), METH_VARARGS, nullptr },
        { "add_audio_routing_status_changed", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_add_AudioRoutingStatusChanged), METH_O, nullptr },
        { "remove_audio_routing_status_changed", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_remove_AudioRoutingStatusChanged), METH_O, nullptr },
        { "add_in_band_ringing_enabled_changed", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_add_InBandRingingEnabledChanged), METH_O, nullptr },
        { "remove_in_band_ringing_enabled_changed", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_remove_InBandRingingEnabledChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_PhoneLineTransportDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneLineTransportDevice), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneLineTransportDevice[] = {
        { "device_id", reinterpret_cast<getter>(PhoneLineTransportDevice_get_DeviceId), nullptr, nullptr, nullptr },
        { "transport", reinterpret_cast<getter>(PhoneLineTransportDevice_get_Transport), nullptr, nullptr, nullptr },
        { "audio_routing_status", reinterpret_cast<getter>(PhoneLineTransportDevice_get_AudioRoutingStatus), nullptr, nullptr, nullptr },
        { "in_band_ringing_enabled", reinterpret_cast<getter>(PhoneLineTransportDevice_get_InBandRingingEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneLineTransportDevice[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneLineTransportDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneLineTransportDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneLineTransportDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneLineTransportDevice) },
        { },
    };

    static PyType_Spec type_spec_PhoneLineTransportDevice =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneLineTransportDevice",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLineTransportDevice
    };

    // ----- PhoneLineWatcher class --------------------
    static constexpr const char* const type_name_PhoneLineWatcher = "PhoneLineWatcher";

    static PyObject* _new_PhoneLineWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PhoneLineWatcher);
        return nullptr;
    }

    static void _dealloc_PhoneLineWatcher(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneLineWatcher_Start(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcher", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_Stop(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcher", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_get_Status(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcher", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_add_EnumerationCompleted(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_remove_EnumerationCompleted(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_add_LineAdded(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcher", L"LineAdded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher, winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs>>(arg);

            return py::convert(self->obj.LineAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_remove_LineAdded(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcher", L"LineAdded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LineAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_add_LineRemoved(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcher", L"LineRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher, winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs>>(arg);

            return py::convert(self->obj.LineRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_remove_LineRemoved(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcher", L"LineRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LineRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_add_LineUpdated(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcher", L"LineUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher, winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs>>(arg);

            return py::convert(self->obj.LineUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_remove_LineUpdated(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcher", L"LineUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LineUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_add_Stopped(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_remove_Stopped(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneLineWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneLineWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLineWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(PhoneLineWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(PhoneLineWatcher_Stop), METH_VARARGS, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(PhoneLineWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(PhoneLineWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_line_added", reinterpret_cast<PyCFunction>(PhoneLineWatcher_add_LineAdded), METH_O, nullptr },
        { "remove_line_added", reinterpret_cast<PyCFunction>(PhoneLineWatcher_remove_LineAdded), METH_O, nullptr },
        { "add_line_removed", reinterpret_cast<PyCFunction>(PhoneLineWatcher_add_LineRemoved), METH_O, nullptr },
        { "remove_line_removed", reinterpret_cast<PyCFunction>(PhoneLineWatcher_remove_LineRemoved), METH_O, nullptr },
        { "add_line_updated", reinterpret_cast<PyCFunction>(PhoneLineWatcher_add_LineUpdated), METH_O, nullptr },
        { "remove_line_updated", reinterpret_cast<PyCFunction>(PhoneLineWatcher_remove_LineUpdated), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(PhoneLineWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(PhoneLineWatcher_remove_Stopped), METH_O, nullptr },
        { "_assign_array_", _assign_array_PhoneLineWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneLineWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneLineWatcher[] = {
        { "status", reinterpret_cast<getter>(PhoneLineWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneLineWatcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneLineWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneLineWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneLineWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneLineWatcher) },
        { },
    };

    static PyType_Spec type_spec_PhoneLineWatcher =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneLineWatcher",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLineWatcher
    };

    // ----- PhoneLineWatcherEventArgs class --------------------
    static constexpr const char* const type_name_PhoneLineWatcherEventArgs = "PhoneLineWatcherEventArgs";

    static PyObject* _new_PhoneLineWatcherEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PhoneLineWatcherEventArgs);
        return nullptr;
    }

    static void _dealloc_PhoneLineWatcherEventArgs(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneLineWatcherEventArgs_get_LineId(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcherEventArgs", L"LineId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneLineWatcherEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneLineWatcherEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLineWatcherEventArgs[] = {
        { "_assign_array_", _assign_array_PhoneLineWatcherEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneLineWatcherEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneLineWatcherEventArgs[] = {
        { "line_id", reinterpret_cast<getter>(PhoneLineWatcherEventArgs_get_LineId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneLineWatcherEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneLineWatcherEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneLineWatcherEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneLineWatcherEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneLineWatcherEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PhoneLineWatcherEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneLineWatcherEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLineWatcherEventArgs
    };

    // ----- PhoneVoicemail class --------------------
    static constexpr const char* const type_name_PhoneVoicemail = "PhoneVoicemail";

    static PyObject* _new_PhoneVoicemail(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PhoneVoicemail);
        return nullptr;
    }

    static void _dealloc_PhoneVoicemail(py::wrapper::Windows::ApplicationModel::Calls::PhoneVoicemail* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneVoicemail_DialVoicemailAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneVoicemail* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneVoicemail", L"DialVoicemailAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DialVoicemailAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneVoicemail_get_MessageCount(py::wrapper::Windows::ApplicationModel::Calls::PhoneVoicemail* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneVoicemail", L"MessageCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MessageCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneVoicemail_get_Number(py::wrapper::Windows::ApplicationModel::Calls::PhoneVoicemail* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneVoicemail", L"Number"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Number());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneVoicemail_get_Type(py::wrapper::Windows::ApplicationModel::Calls::PhoneVoicemail* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneVoicemail", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneVoicemail(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneVoicemail>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneVoicemail(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneVoicemail>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneVoicemail[] = {
        { "dial_voicemail_async", reinterpret_cast<PyCFunction>(PhoneVoicemail_DialVoicemailAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PhoneVoicemail, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneVoicemail), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneVoicemail[] = {
        { "message_count", reinterpret_cast<getter>(PhoneVoicemail_get_MessageCount), nullptr, nullptr, nullptr },
        { "number", reinterpret_cast<getter>(PhoneVoicemail_get_Number), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(PhoneVoicemail_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneVoicemail[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneVoicemail) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneVoicemail) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneVoicemail) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneVoicemail) },
        { },
    };

    static PyType_Spec type_spec_PhoneVoicemail =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneVoicemail",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneVoicemail),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneVoicemail
    };

    // ----- VoipCallCoordinator class --------------------
    static constexpr const char* const type_name_VoipCallCoordinator = "VoipCallCoordinator";

    static PyObject* _new_VoipCallCoordinator(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_VoipCallCoordinator);
        return nullptr;
    }

    static void _dealloc_VoipCallCoordinator(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VoipCallCoordinator_CancelUpgrade(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"CancelUpgrade", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.CancelUpgrade(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Calls::VoipCallCoordinator::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_NotifyMuted(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"NotifyMuted", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.NotifyMuted();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_NotifyUnmuted(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"NotifyUnmuted", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.NotifyUnmuted();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_RequestIncomingUpgradeToVideoCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 9)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"RequestIncomingUpgradeToVideoCall", 9))
            {
                py::set_arg_count_version_error(9);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);
                auto param7 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 7);
                auto param8 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 8);

                return py::convert(self->obj.RequestIncomingUpgradeToVideoCall(param0, param1, param2, param3, param4, param5, param6, param7, param8));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_RequestNewAppInitiatedCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"RequestNewAppInitiatedCall", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(args, 4);

                return py::convert(self->obj.RequestNewAppInitiatedCall(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_RequestNewIncomingCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 10)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"RequestNewIncomingCall", 10))
            {
                py::set_arg_count_version_error(10);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);
                auto param7 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 7);
                auto param8 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(args, 8);
                auto param9 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 9);

                return py::convert(self->obj.RequestNewIncomingCall(param0, param1, param2, param3, param4, param5, param6, param7, param8, param9));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 11)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"RequestNewIncomingCall", 11))
            {
                py::set_arg_count_version_error(11);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);
                auto param7 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 7);
                auto param8 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(args, 8);
                auto param9 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 9);
                auto param10 = py::convert_to<winrt::hstring>(args, 10);

                return py::convert(self->obj.RequestNewIncomingCall(param0, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_RequestNewOutgoingCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"RequestNewOutgoingCall", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(args, 3);

                return py::convert(self->obj.RequestNewOutgoingCall(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_RequestOutgoingUpgradeToVideoCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"RequestOutgoingUpgradeToVideoCall", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.RequestOutgoingUpgradeToVideoCall(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_ReserveCallResourcesAsync(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"ReserveCallResourcesAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReserveCallResourcesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"ReserveCallResourcesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ReserveCallResourcesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_SetupNewAcceptedCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"SetupNewAcceptedCall", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(args, 4);

                return py::convert(self->obj.SetupNewAcceptedCall(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_TerminateCellularCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"TerminateCellularCall", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.TerminateCellularCall(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_add_MuteStateChanged(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"MuteStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::VoipCallCoordinator, winrt::Windows::ApplicationModel::Calls::MuteChangeEventArgs>>(arg);

            return py::convert(self->obj.MuteStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_remove_MuteStateChanged(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"MuteStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MuteStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VoipCallCoordinator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::VoipCallCoordinator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VoipCallCoordinator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::VoipCallCoordinator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VoipCallCoordinator[] = {
        { "cancel_upgrade", reinterpret_cast<PyCFunction>(VoipCallCoordinator_CancelUpgrade), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(VoipCallCoordinator_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "notify_muted", reinterpret_cast<PyCFunction>(VoipCallCoordinator_NotifyMuted), METH_VARARGS, nullptr },
        { "notify_unmuted", reinterpret_cast<PyCFunction>(VoipCallCoordinator_NotifyUnmuted), METH_VARARGS, nullptr },
        { "request_incoming_upgrade_to_video_call", reinterpret_cast<PyCFunction>(VoipCallCoordinator_RequestIncomingUpgradeToVideoCall), METH_VARARGS, nullptr },
        { "request_new_app_initiated_call", reinterpret_cast<PyCFunction>(VoipCallCoordinator_RequestNewAppInitiatedCall), METH_VARARGS, nullptr },
        { "request_new_incoming_call", reinterpret_cast<PyCFunction>(VoipCallCoordinator_RequestNewIncomingCall), METH_VARARGS, nullptr },
        { "request_new_outgoing_call", reinterpret_cast<PyCFunction>(VoipCallCoordinator_RequestNewOutgoingCall), METH_VARARGS, nullptr },
        { "request_outgoing_upgrade_to_video_call", reinterpret_cast<PyCFunction>(VoipCallCoordinator_RequestOutgoingUpgradeToVideoCall), METH_VARARGS, nullptr },
        { "reserve_call_resources_async", reinterpret_cast<PyCFunction>(VoipCallCoordinator_ReserveCallResourcesAsync), METH_VARARGS, nullptr },
        { "setup_new_accepted_call", reinterpret_cast<PyCFunction>(VoipCallCoordinator_SetupNewAcceptedCall), METH_VARARGS, nullptr },
        { "terminate_cellular_call", reinterpret_cast<PyCFunction>(VoipCallCoordinator_TerminateCellularCall), METH_VARARGS, nullptr },
        { "add_mute_state_changed", reinterpret_cast<PyCFunction>(VoipCallCoordinator_add_MuteStateChanged), METH_O, nullptr },
        { "remove_mute_state_changed", reinterpret_cast<PyCFunction>(VoipCallCoordinator_remove_MuteStateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_VoipCallCoordinator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VoipCallCoordinator), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VoipCallCoordinator[] = {
        { }
    };

    static PyType_Slot _type_slots_VoipCallCoordinator[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VoipCallCoordinator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VoipCallCoordinator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VoipCallCoordinator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VoipCallCoordinator) },
        { },
    };

    static PyType_Spec type_spec_VoipCallCoordinator =
    {
        "_winsdk_Windows_ApplicationModel_Calls.VoipCallCoordinator",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VoipCallCoordinator
    };

    // ----- VoipPhoneCall class --------------------
    static constexpr const char* const type_name_VoipPhoneCall = "VoipPhoneCall";

    static PyObject* _new_VoipPhoneCall(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_VoipPhoneCall);
        return nullptr;
    }

    static void _dealloc_VoipPhoneCall(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VoipPhoneCall_NotifyCallAccepted(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"NotifyCallAccepted", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(args, 0);

                self->obj.NotifyCallAccepted(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_NotifyCallActive(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"NotifyCallActive", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.NotifyCallActive();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_NotifyCallEnded(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"NotifyCallEnded", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.NotifyCallEnded();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_NotifyCallHeld(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"NotifyCallHeld", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.NotifyCallHeld();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_NotifyCallReady(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"NotifyCallReady", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.NotifyCallReady();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_TryShowAppUI(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"TryShowAppUI", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.TryShowAppUI();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_get_StartTime(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VoipPhoneCall_put_StartTime(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VoipPhoneCall_get_ContactName(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"ContactName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VoipPhoneCall_put_ContactName(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"ContactName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContactName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VoipPhoneCall_get_CallMedia(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"CallMedia"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CallMedia());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VoipPhoneCall_put_CallMedia(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"CallMedia"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(arg);

            self->obj.CallMedia(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VoipPhoneCall_add_AnswerRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"AnswerRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall, winrt::Windows::ApplicationModel::Calls::CallAnswerEventArgs>>(arg);

            return py::convert(self->obj.AnswerRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_remove_AnswerRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"AnswerRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AnswerRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_add_EndRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"EndRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall, winrt::Windows::ApplicationModel::Calls::CallStateChangeEventArgs>>(arg);

            return py::convert(self->obj.EndRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_remove_EndRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"EndRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EndRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_add_HoldRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"HoldRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall, winrt::Windows::ApplicationModel::Calls::CallStateChangeEventArgs>>(arg);

            return py::convert(self->obj.HoldRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_remove_HoldRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"HoldRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HoldRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_add_RejectRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"RejectRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall, winrt::Windows::ApplicationModel::Calls::CallRejectEventArgs>>(arg);

            return py::convert(self->obj.RejectRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_remove_RejectRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"RejectRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RejectRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_add_ResumeRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"ResumeRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall, winrt::Windows::ApplicationModel::Calls::CallStateChangeEventArgs>>(arg);

            return py::convert(self->obj.ResumeRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_remove_ResumeRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"ResumeRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ResumeRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VoipPhoneCall(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VoipPhoneCall(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VoipPhoneCall[] = {
        { "notify_call_accepted", reinterpret_cast<PyCFunction>(VoipPhoneCall_NotifyCallAccepted), METH_VARARGS, nullptr },
        { "notify_call_active", reinterpret_cast<PyCFunction>(VoipPhoneCall_NotifyCallActive), METH_VARARGS, nullptr },
        { "notify_call_ended", reinterpret_cast<PyCFunction>(VoipPhoneCall_NotifyCallEnded), METH_VARARGS, nullptr },
        { "notify_call_held", reinterpret_cast<PyCFunction>(VoipPhoneCall_NotifyCallHeld), METH_VARARGS, nullptr },
        { "notify_call_ready", reinterpret_cast<PyCFunction>(VoipPhoneCall_NotifyCallReady), METH_VARARGS, nullptr },
        { "try_show_app_u_i", reinterpret_cast<PyCFunction>(VoipPhoneCall_TryShowAppUI), METH_VARARGS, nullptr },
        { "add_answer_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_add_AnswerRequested), METH_O, nullptr },
        { "remove_answer_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_remove_AnswerRequested), METH_O, nullptr },
        { "add_end_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_add_EndRequested), METH_O, nullptr },
        { "remove_end_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_remove_EndRequested), METH_O, nullptr },
        { "add_hold_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_add_HoldRequested), METH_O, nullptr },
        { "remove_hold_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_remove_HoldRequested), METH_O, nullptr },
        { "add_reject_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_add_RejectRequested), METH_O, nullptr },
        { "remove_reject_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_remove_RejectRequested), METH_O, nullptr },
        { "add_resume_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_add_ResumeRequested), METH_O, nullptr },
        { "remove_resume_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_remove_ResumeRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_VoipPhoneCall, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VoipPhoneCall), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VoipPhoneCall[] = {
        { "start_time", reinterpret_cast<getter>(VoipPhoneCall_get_StartTime), reinterpret_cast<setter>(VoipPhoneCall_put_StartTime), nullptr, nullptr },
        { "contact_name", reinterpret_cast<getter>(VoipPhoneCall_get_ContactName), reinterpret_cast<setter>(VoipPhoneCall_put_ContactName), nullptr, nullptr },
        { "call_media", reinterpret_cast<getter>(VoipPhoneCall_get_CallMedia), reinterpret_cast<setter>(VoipPhoneCall_put_CallMedia), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VoipPhoneCall[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VoipPhoneCall) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VoipPhoneCall) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VoipPhoneCall) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VoipPhoneCall) },
        { },
    };

    static PyType_Spec type_spec_VoipPhoneCall =
    {
        "_winsdk_Windows_ApplicationModel_Calls.VoipPhoneCall",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VoipPhoneCall
    };

    // ----- Windows.ApplicationModel.Calls Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::ApplicationModel::Calls");

    static PyMethodDef module_methods[] = {
        {"_register_CellularDtmfMode", register_CellularDtmfMode, METH_O, "registers type"},
        {"_register_DtmfKey", register_DtmfKey, METH_O, "registers type"},
        {"_register_DtmfToneAudioPlayback", register_DtmfToneAudioPlayback, METH_O, "registers type"},
        {"_register_PhoneAudioRoutingEndpoint", register_PhoneAudioRoutingEndpoint, METH_O, "registers type"},
        {"_register_PhoneCallAudioDevice", register_PhoneCallAudioDevice, METH_O, "registers type"},
        {"_register_PhoneCallDirection", register_PhoneCallDirection, METH_O, "registers type"},
        {"_register_PhoneCallHistoryEntryMedia", register_PhoneCallHistoryEntryMedia, METH_O, "registers type"},
        {"_register_PhoneCallHistoryEntryOtherAppReadAccess", register_PhoneCallHistoryEntryOtherAppReadAccess, METH_O, "registers type"},
        {"_register_PhoneCallHistoryEntryQueryDesiredMedia", register_PhoneCallHistoryEntryQueryDesiredMedia, METH_O, "registers type"},
        {"_register_PhoneCallHistoryEntryRawAddressKind", register_PhoneCallHistoryEntryRawAddressKind, METH_O, "registers type"},
        {"_register_PhoneCallHistorySourceIdKind", register_PhoneCallHistorySourceIdKind, METH_O, "registers type"},
        {"_register_PhoneCallHistoryStoreAccessType", register_PhoneCallHistoryStoreAccessType, METH_O, "registers type"},
        {"_register_PhoneCallMedia", register_PhoneCallMedia, METH_O, "registers type"},
        {"_register_PhoneCallOperationStatus", register_PhoneCallOperationStatus, METH_O, "registers type"},
        {"_register_PhoneCallStatus", register_PhoneCallStatus, METH_O, "registers type"},
        {"_register_PhoneLineNetworkOperatorDisplayTextLocation", register_PhoneLineNetworkOperatorDisplayTextLocation, METH_O, "registers type"},
        {"_register_PhoneLineOperationStatus", register_PhoneLineOperationStatus, METH_O, "registers type"},
        {"_register_PhoneLineTransport", register_PhoneLineTransport, METH_O, "registers type"},
        {"_register_PhoneLineWatcherStatus", register_PhoneLineWatcherStatus, METH_O, "registers type"},
        {"_register_PhoneNetworkState", register_PhoneNetworkState, METH_O, "registers type"},
        {"_register_PhoneSimState", register_PhoneSimState, METH_O, "registers type"},
        {"_register_PhoneVoicemailType", register_PhoneVoicemailType, METH_O, "registers type"},
        {"_register_TransportDeviceAudioRoutingStatus", register_TransportDeviceAudioRoutingStatus, METH_O, "registers type"},
        {"_register_VoipPhoneCallMedia", register_VoipPhoneCallMedia, METH_O, "registers type"},
        {"_register_VoipPhoneCallRejectReason", register_VoipPhoneCallRejectReason, METH_O, "registers type"},
        {"_register_VoipPhoneCallResourceReservationStatus", register_VoipPhoneCallResourceReservationStatus, METH_O, "registers type"},
        {"_register_VoipPhoneCallState", register_VoipPhoneCallState, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_CellularDtmfMode);
        Py_VISIT(state->type_DtmfKey);
        Py_VISIT(state->type_DtmfToneAudioPlayback);
        Py_VISIT(state->type_PhoneAudioRoutingEndpoint);
        Py_VISIT(state->type_PhoneCallAudioDevice);
        Py_VISIT(state->type_PhoneCallDirection);
        Py_VISIT(state->type_PhoneCallHistoryEntryMedia);
        Py_VISIT(state->type_PhoneCallHistoryEntryOtherAppReadAccess);
        Py_VISIT(state->type_PhoneCallHistoryEntryQueryDesiredMedia);
        Py_VISIT(state->type_PhoneCallHistoryEntryRawAddressKind);
        Py_VISIT(state->type_PhoneCallHistorySourceIdKind);
        Py_VISIT(state->type_PhoneCallHistoryStoreAccessType);
        Py_VISIT(state->type_PhoneCallMedia);
        Py_VISIT(state->type_PhoneCallOperationStatus);
        Py_VISIT(state->type_PhoneCallStatus);
        Py_VISIT(state->type_PhoneLineNetworkOperatorDisplayTextLocation);
        Py_VISIT(state->type_PhoneLineOperationStatus);
        Py_VISIT(state->type_PhoneLineTransport);
        Py_VISIT(state->type_PhoneLineWatcherStatus);
        Py_VISIT(state->type_PhoneNetworkState);
        Py_VISIT(state->type_PhoneSimState);
        Py_VISIT(state->type_PhoneVoicemailType);
        Py_VISIT(state->type_TransportDeviceAudioRoutingStatus);
        Py_VISIT(state->type_VoipPhoneCallMedia);
        Py_VISIT(state->type_VoipPhoneCallRejectReason);
        Py_VISIT(state->type_VoipPhoneCallResourceReservationStatus);
        Py_VISIT(state->type_VoipPhoneCallState);
        Py_VISIT(state->type_CallAnswerEventArgs);
        Py_VISIT(state->type_CallRejectEventArgs);
        Py_VISIT(state->type_CallStateChangeEventArgs);
        Py_VISIT(state->type_LockScreenCallEndCallDeferral);
        Py_VISIT(state->type_LockScreenCallEndRequestedEventArgs);
        Py_VISIT(state->type_LockScreenCallUI);
        Py_VISIT(state->type_MuteChangeEventArgs);
        Py_VISIT(state->type_PhoneCall);
        Py_VISIT(state->type_PhoneCallBlocking);
        Py_VISIT(state->type_PhoneCallHistoryEntry);
        Py_VISIT(state->type_PhoneCallHistoryEntryAddress);
        Py_VISIT(state->type_PhoneCallHistoryEntryQueryOptions);
        Py_VISIT(state->type_PhoneCallHistoryEntryReader);
        Py_VISIT(state->type_PhoneCallHistoryManager);
        Py_VISIT(state->type_PhoneCallHistoryManagerForUser);
        Py_VISIT(state->type_PhoneCallHistoryStore);
        Py_VISIT(state->type_PhoneCallInfo);
        Py_VISIT(state->type_PhoneCallManager);
        Py_VISIT(state->type_PhoneCallStore);
        Py_VISIT(state->type_PhoneCallVideoCapabilities);
        Py_VISIT(state->type_PhoneCallVideoCapabilitiesManager);
        Py_VISIT(state->type_PhoneCallsResult);
        Py_VISIT(state->type_PhoneDialOptions);
        Py_VISIT(state->type_PhoneLine);
        Py_VISIT(state->type_PhoneLineCellularDetails);
        Py_VISIT(state->type_PhoneLineConfiguration);
        Py_VISIT(state->type_PhoneLineDialResult);
        Py_VISIT(state->type_PhoneLineTransportDevice);
        Py_VISIT(state->type_PhoneLineWatcher);
        Py_VISIT(state->type_PhoneLineWatcherEventArgs);
        Py_VISIT(state->type_PhoneVoicemail);
        Py_VISIT(state->type_VoipCallCoordinator);
        Py_VISIT(state->type_VoipPhoneCall);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_CellularDtmfMode);
        Py_CLEAR(state->type_DtmfKey);
        Py_CLEAR(state->type_DtmfToneAudioPlayback);
        Py_CLEAR(state->type_PhoneAudioRoutingEndpoint);
        Py_CLEAR(state->type_PhoneCallAudioDevice);
        Py_CLEAR(state->type_PhoneCallDirection);
        Py_CLEAR(state->type_PhoneCallHistoryEntryMedia);
        Py_CLEAR(state->type_PhoneCallHistoryEntryOtherAppReadAccess);
        Py_CLEAR(state->type_PhoneCallHistoryEntryQueryDesiredMedia);
        Py_CLEAR(state->type_PhoneCallHistoryEntryRawAddressKind);
        Py_CLEAR(state->type_PhoneCallHistorySourceIdKind);
        Py_CLEAR(state->type_PhoneCallHistoryStoreAccessType);
        Py_CLEAR(state->type_PhoneCallMedia);
        Py_CLEAR(state->type_PhoneCallOperationStatus);
        Py_CLEAR(state->type_PhoneCallStatus);
        Py_CLEAR(state->type_PhoneLineNetworkOperatorDisplayTextLocation);
        Py_CLEAR(state->type_PhoneLineOperationStatus);
        Py_CLEAR(state->type_PhoneLineTransport);
        Py_CLEAR(state->type_PhoneLineWatcherStatus);
        Py_CLEAR(state->type_PhoneNetworkState);
        Py_CLEAR(state->type_PhoneSimState);
        Py_CLEAR(state->type_PhoneVoicemailType);
        Py_CLEAR(state->type_TransportDeviceAudioRoutingStatus);
        Py_CLEAR(state->type_VoipPhoneCallMedia);
        Py_CLEAR(state->type_VoipPhoneCallRejectReason);
        Py_CLEAR(state->type_VoipPhoneCallResourceReservationStatus);
        Py_CLEAR(state->type_VoipPhoneCallState);
        Py_CLEAR(state->type_CallAnswerEventArgs);
        Py_CLEAR(state->type_CallRejectEventArgs);
        Py_CLEAR(state->type_CallStateChangeEventArgs);
        Py_CLEAR(state->type_LockScreenCallEndCallDeferral);
        Py_CLEAR(state->type_LockScreenCallEndRequestedEventArgs);
        Py_CLEAR(state->type_LockScreenCallUI);
        Py_CLEAR(state->type_MuteChangeEventArgs);
        Py_CLEAR(state->type_PhoneCall);
        Py_CLEAR(state->type_PhoneCallBlocking);
        Py_CLEAR(state->type_PhoneCallHistoryEntry);
        Py_CLEAR(state->type_PhoneCallHistoryEntryAddress);
        Py_CLEAR(state->type_PhoneCallHistoryEntryQueryOptions);
        Py_CLEAR(state->type_PhoneCallHistoryEntryReader);
        Py_CLEAR(state->type_PhoneCallHistoryManager);
        Py_CLEAR(state->type_PhoneCallHistoryManagerForUser);
        Py_CLEAR(state->type_PhoneCallHistoryStore);
        Py_CLEAR(state->type_PhoneCallInfo);
        Py_CLEAR(state->type_PhoneCallManager);
        Py_CLEAR(state->type_PhoneCallStore);
        Py_CLEAR(state->type_PhoneCallVideoCapabilities);
        Py_CLEAR(state->type_PhoneCallVideoCapabilitiesManager);
        Py_CLEAR(state->type_PhoneCallsResult);
        Py_CLEAR(state->type_PhoneDialOptions);
        Py_CLEAR(state->type_PhoneLine);
        Py_CLEAR(state->type_PhoneLineCellularDetails);
        Py_CLEAR(state->type_PhoneLineConfiguration);
        Py_CLEAR(state->type_PhoneLineDialResult);
        Py_CLEAR(state->type_PhoneLineTransportDevice);
        Py_CLEAR(state->type_PhoneLineWatcher);
        Py_CLEAR(state->type_PhoneLineWatcherEventArgs);
        Py_CLEAR(state->type_PhoneVoicemail);
        Py_CLEAR(state->type_VoipCallCoordinator);
        Py_CLEAR(state->type_VoipPhoneCall);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_ApplicationModel_Calls",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::ApplicationModel::Calls

PyMODINIT_FUNC PyInit__winsdk_Windows_ApplicationModel_Calls(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_CallAnswerEventArgs = py::register_python_type(module.get(), type_name_CallAnswerEventArgs, &type_spec_CallAnswerEventArgs, bases.get(), nullptr);
    if (!state->type_CallAnswerEventArgs)
    {
        return nullptr;
    }

    state->type_CallRejectEventArgs = py::register_python_type(module.get(), type_name_CallRejectEventArgs, &type_spec_CallRejectEventArgs, bases.get(), nullptr);
    if (!state->type_CallRejectEventArgs)
    {
        return nullptr;
    }

    state->type_CallStateChangeEventArgs = py::register_python_type(module.get(), type_name_CallStateChangeEventArgs, &type_spec_CallStateChangeEventArgs, bases.get(), nullptr);
    if (!state->type_CallStateChangeEventArgs)
    {
        return nullptr;
    }

    state->type_LockScreenCallEndCallDeferral = py::register_python_type(module.get(), type_name_LockScreenCallEndCallDeferral, &type_spec_LockScreenCallEndCallDeferral, bases.get(), nullptr);
    if (!state->type_LockScreenCallEndCallDeferral)
    {
        return nullptr;
    }

    state->type_LockScreenCallEndRequestedEventArgs = py::register_python_type(module.get(), type_name_LockScreenCallEndRequestedEventArgs, &type_spec_LockScreenCallEndRequestedEventArgs, bases.get(), nullptr);
    if (!state->type_LockScreenCallEndRequestedEventArgs)
    {
        return nullptr;
    }

    state->type_LockScreenCallUI = py::register_python_type(module.get(), type_name_LockScreenCallUI, &type_spec_LockScreenCallUI, bases.get(), nullptr);
    if (!state->type_LockScreenCallUI)
    {
        return nullptr;
    }

    state->type_MuteChangeEventArgs = py::register_python_type(module.get(), type_name_MuteChangeEventArgs, &type_spec_MuteChangeEventArgs, bases.get(), nullptr);
    if (!state->type_MuteChangeEventArgs)
    {
        return nullptr;
    }

    state->type_PhoneCall = py::register_python_type(module.get(), type_name_PhoneCall, &type_spec_PhoneCall, bases.get(), nullptr);
    if (!state->type_PhoneCall)
    {
        return nullptr;
    }

    py::pyobj_handle type_PhoneCallBlocking_Meta{PyType_FromSpec(&type_spec_PhoneCallBlocking_Meta)};
    if (!type_PhoneCallBlocking_Meta)
    {
        return nullptr;
    }

    state->type_PhoneCallBlocking = py::register_python_type(module.get(), type_name_PhoneCallBlocking, &type_spec_PhoneCallBlocking, nullptr, reinterpret_cast<PyTypeObject*>(type_PhoneCallBlocking_Meta.get()));
    if (!state->type_PhoneCallBlocking)
    {
        return nullptr;
    }

    state->type_PhoneCallHistoryEntry = py::register_python_type(module.get(), type_name_PhoneCallHistoryEntry, &type_spec_PhoneCallHistoryEntry, bases.get(), nullptr);
    if (!state->type_PhoneCallHistoryEntry)
    {
        return nullptr;
    }

    state->type_PhoneCallHistoryEntryAddress = py::register_python_type(module.get(), type_name_PhoneCallHistoryEntryAddress, &type_spec_PhoneCallHistoryEntryAddress, bases.get(), nullptr);
    if (!state->type_PhoneCallHistoryEntryAddress)
    {
        return nullptr;
    }

    state->type_PhoneCallHistoryEntryQueryOptions = py::register_python_type(module.get(), type_name_PhoneCallHistoryEntryQueryOptions, &type_spec_PhoneCallHistoryEntryQueryOptions, bases.get(), nullptr);
    if (!state->type_PhoneCallHistoryEntryQueryOptions)
    {
        return nullptr;
    }

    state->type_PhoneCallHistoryEntryReader = py::register_python_type(module.get(), type_name_PhoneCallHistoryEntryReader, &type_spec_PhoneCallHistoryEntryReader, bases.get(), nullptr);
    if (!state->type_PhoneCallHistoryEntryReader)
    {
        return nullptr;
    }

    state->type_PhoneCallHistoryManager = py::register_python_type(module.get(), type_name_PhoneCallHistoryManager, &type_spec_PhoneCallHistoryManager, nullptr, nullptr);
    if (!state->type_PhoneCallHistoryManager)
    {
        return nullptr;
    }

    state->type_PhoneCallHistoryManagerForUser = py::register_python_type(module.get(), type_name_PhoneCallHistoryManagerForUser, &type_spec_PhoneCallHistoryManagerForUser, bases.get(), nullptr);
    if (!state->type_PhoneCallHistoryManagerForUser)
    {
        return nullptr;
    }

    state->type_PhoneCallHistoryStore = py::register_python_type(module.get(), type_name_PhoneCallHistoryStore, &type_spec_PhoneCallHistoryStore, bases.get(), nullptr);
    if (!state->type_PhoneCallHistoryStore)
    {
        return nullptr;
    }

    state->type_PhoneCallInfo = py::register_python_type(module.get(), type_name_PhoneCallInfo, &type_spec_PhoneCallInfo, bases.get(), nullptr);
    if (!state->type_PhoneCallInfo)
    {
        return nullptr;
    }

    py::pyobj_handle type_PhoneCallManager_Meta{PyType_FromSpec(&type_spec_PhoneCallManager_Meta)};
    if (!type_PhoneCallManager_Meta)
    {
        return nullptr;
    }

    state->type_PhoneCallManager = py::register_python_type(module.get(), type_name_PhoneCallManager, &type_spec_PhoneCallManager, nullptr, reinterpret_cast<PyTypeObject*>(type_PhoneCallManager_Meta.get()));
    if (!state->type_PhoneCallManager)
    {
        return nullptr;
    }

    state->type_PhoneCallStore = py::register_python_type(module.get(), type_name_PhoneCallStore, &type_spec_PhoneCallStore, bases.get(), nullptr);
    if (!state->type_PhoneCallStore)
    {
        return nullptr;
    }

    state->type_PhoneCallVideoCapabilities = py::register_python_type(module.get(), type_name_PhoneCallVideoCapabilities, &type_spec_PhoneCallVideoCapabilities, bases.get(), nullptr);
    if (!state->type_PhoneCallVideoCapabilities)
    {
        return nullptr;
    }

    state->type_PhoneCallVideoCapabilitiesManager = py::register_python_type(module.get(), type_name_PhoneCallVideoCapabilitiesManager, &type_spec_PhoneCallVideoCapabilitiesManager, nullptr, nullptr);
    if (!state->type_PhoneCallVideoCapabilitiesManager)
    {
        return nullptr;
    }

    state->type_PhoneCallsResult = py::register_python_type(module.get(), type_name_PhoneCallsResult, &type_spec_PhoneCallsResult, bases.get(), nullptr);
    if (!state->type_PhoneCallsResult)
    {
        return nullptr;
    }

    state->type_PhoneDialOptions = py::register_python_type(module.get(), type_name_PhoneDialOptions, &type_spec_PhoneDialOptions, bases.get(), nullptr);
    if (!state->type_PhoneDialOptions)
    {
        return nullptr;
    }

    state->type_PhoneLine = py::register_python_type(module.get(), type_name_PhoneLine, &type_spec_PhoneLine, bases.get(), nullptr);
    if (!state->type_PhoneLine)
    {
        return nullptr;
    }

    state->type_PhoneLineCellularDetails = py::register_python_type(module.get(), type_name_PhoneLineCellularDetails, &type_spec_PhoneLineCellularDetails, bases.get(), nullptr);
    if (!state->type_PhoneLineCellularDetails)
    {
        return nullptr;
    }

    state->type_PhoneLineConfiguration = py::register_python_type(module.get(), type_name_PhoneLineConfiguration, &type_spec_PhoneLineConfiguration, bases.get(), nullptr);
    if (!state->type_PhoneLineConfiguration)
    {
        return nullptr;
    }

    state->type_PhoneLineDialResult = py::register_python_type(module.get(), type_name_PhoneLineDialResult, &type_spec_PhoneLineDialResult, bases.get(), nullptr);
    if (!state->type_PhoneLineDialResult)
    {
        return nullptr;
    }

    state->type_PhoneLineTransportDevice = py::register_python_type(module.get(), type_name_PhoneLineTransportDevice, &type_spec_PhoneLineTransportDevice, bases.get(), nullptr);
    if (!state->type_PhoneLineTransportDevice)
    {
        return nullptr;
    }

    state->type_PhoneLineWatcher = py::register_python_type(module.get(), type_name_PhoneLineWatcher, &type_spec_PhoneLineWatcher, bases.get(), nullptr);
    if (!state->type_PhoneLineWatcher)
    {
        return nullptr;
    }

    state->type_PhoneLineWatcherEventArgs = py::register_python_type(module.get(), type_name_PhoneLineWatcherEventArgs, &type_spec_PhoneLineWatcherEventArgs, bases.get(), nullptr);
    if (!state->type_PhoneLineWatcherEventArgs)
    {
        return nullptr;
    }

    state->type_PhoneVoicemail = py::register_python_type(module.get(), type_name_PhoneVoicemail, &type_spec_PhoneVoicemail, bases.get(), nullptr);
    if (!state->type_PhoneVoicemail)
    {
        return nullptr;
    }

    state->type_VoipCallCoordinator = py::register_python_type(module.get(), type_name_VoipCallCoordinator, &type_spec_VoipCallCoordinator, bases.get(), nullptr);
    if (!state->type_VoipCallCoordinator)
    {
        return nullptr;
    }

    state->type_VoipPhoneCall = py::register_python_type(module.get(), type_name_VoipPhoneCall, &type_spec_VoipPhoneCall, bases.get(), nullptr);
    if (!state->type_VoipPhoneCall)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Calls::CellularDtmfMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CellularDtmfMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::CellularDtmfMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Calls::DtmfKey>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DtmfKey;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::DtmfKey is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Calls::DtmfToneAudioPlayback>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DtmfToneAudioPlayback;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::DtmfToneAudioPlayback is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneAudioRoutingEndpoint>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneAudioRoutingEndpoint;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneAudioRoutingEndpoint is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallAudioDevice>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallAudioDevice;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneCallAudioDevice is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallDirection>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallDirection;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneCallDirection is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryMedia>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallHistoryEntryMedia;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryMedia is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryOtherAppReadAccess>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallHistoryEntryOtherAppReadAccess;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryOtherAppReadAccess is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryDesiredMedia>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallHistoryEntryQueryDesiredMedia;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryDesiredMedia is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryRawAddressKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallHistoryEntryRawAddressKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryRawAddressKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistorySourceIdKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallHistorySourceIdKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneCallHistorySourceIdKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryStoreAccessType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallHistoryStoreAccessType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryStoreAccessType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallMedia>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallMedia;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneCallMedia is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallOperationStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallOperationStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneCallOperationStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneCallStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneLineNetworkOperatorDisplayTextLocation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneLineNetworkOperatorDisplayTextLocation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneLineNetworkOperatorDisplayTextLocation is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneLineOperationStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneLineOperationStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneLineOperationStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneLineTransport>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneLineTransport;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneLineTransport is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneLineWatcherStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneNetworkState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneNetworkState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneNetworkState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneSimState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneSimState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneSimState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneVoicemailType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneVoicemailType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneVoicemailType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Calls::TransportDeviceAudioRoutingStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TransportDeviceAudioRoutingStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::TransportDeviceAudioRoutingStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VoipPhoneCallMedia;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallRejectReason>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VoipPhoneCallRejectReason;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::VoipPhoneCallRejectReason is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallResourceReservationStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VoipPhoneCallResourceReservationStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::VoipPhoneCallResourceReservationStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VoipPhoneCallState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::VoipPhoneCallState is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::CallAnswerEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CallAnswerEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::CallAnswerEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::CallRejectEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CallRejectEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::CallRejectEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::CallStateChangeEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CallStateChangeEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::CallStateChangeEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::LockScreenCallEndCallDeferral>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LockScreenCallEndCallDeferral;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::LockScreenCallEndCallDeferral is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::LockScreenCallEndRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LockScreenCallEndRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::LockScreenCallEndRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::LockScreenCallUI>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LockScreenCallUI;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::LockScreenCallUI is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::MuteChangeEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MuteChangeEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::MuteChangeEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCall>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCall;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneCall is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallBlocking;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallHistoryEntry;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallHistoryEntryAddress;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallHistoryEntryQueryOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryReader>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallHistoryEntryReader;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryReader is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallHistoryManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallHistoryManagerForUser;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryStore>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallHistoryStore;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryStore is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneCallInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneCallManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallStore>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallStore;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneCallStore is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilities>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallVideoCapabilities;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilities is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilitiesManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallVideoCapabilitiesManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilitiesManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallsResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallsResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneCallsResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneDialOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneDialOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneDialOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLine>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneLine;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneLine is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineCellularDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneLineCellularDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneLineCellularDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineConfiguration>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneLineConfiguration;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneLineConfiguration is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineDialResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneLineDialResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneLineDialResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneLineTransportDevice;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneLineWatcher;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneLineWatcherEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneVoicemail>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneVoicemail;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::PhoneVoicemail is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::VoipCallCoordinator>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VoipCallCoordinator;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::VoipCallCoordinator is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Calls");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VoipPhoneCall;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Calls::VoipPhoneCall is not registered");
        return nullptr;
    }

    return python_type;
}
