// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.Security.Cryptography.Certificates.h"


namespace py::cpp::Windows::Security::Cryptography::Certificates
{
    struct module_state
    {
        PyObject* type_CertificateChainPolicy;
        PyObject* type_ChainValidationResult;
        PyObject* type_EnrollKeyUsages;
        PyObject* type_ExportOption;
        PyObject* type_InstallOptions;
        PyObject* type_KeyProtectionLevel;
        PyObject* type_KeySize;
        PyObject* type_SignatureValidationResult;
        PyTypeObject* type_Certificate;
        PyTypeObject* type_CertificateChain;
        PyTypeObject* type_CertificateEnrollmentManager;
        PyTypeObject* type_CertificateExtension;
        PyTypeObject* type_CertificateKeyUsages;
        PyTypeObject* type_CertificateQuery;
        PyTypeObject* type_CertificateRequestProperties;
        PyTypeObject* type_CertificateStore;
        PyTypeObject* type_CertificateStores;
        PyTypeObject* type_ChainBuildingParameters;
        PyTypeObject* type_ChainValidationParameters;
        PyTypeObject* type_CmsAttachedSignature;
        PyTypeObject* type_CmsDetachedSignature;
        PyTypeObject* type_CmsSignerInfo;
        PyTypeObject* type_CmsTimestampInfo;
        PyTypeObject* type_KeyAlgorithmNames;
        PyTypeObject* type_KeyAttestationHelper;
        PyTypeObject* type_KeyStorageProviderNames;
        PyTypeObject* type_PfxImportParameters;
        PyTypeObject* type_StandardCertificateStoreNames;
        PyTypeObject* type_SubjectAlternativeNameInfo;
        PyTypeObject* type_UserCertificateEnrollmentManager;
        PyTypeObject* type_UserCertificateStore;
    };

    static PyObject* register_CertificateChainPolicy(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CertificateChainPolicy)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CertificateChainPolicy = type;
        Py_INCREF(state->type_CertificateChainPolicy);


        Py_RETURN_NONE;
    }

    static PyObject* register_ChainValidationResult(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ChainValidationResult)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ChainValidationResult = type;
        Py_INCREF(state->type_ChainValidationResult);


        Py_RETURN_NONE;
    }

    static PyObject* register_EnrollKeyUsages(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_EnrollKeyUsages)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_EnrollKeyUsages = type;
        Py_INCREF(state->type_EnrollKeyUsages);


        Py_RETURN_NONE;
    }

    static PyObject* register_ExportOption(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ExportOption)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ExportOption = type;
        Py_INCREF(state->type_ExportOption);


        Py_RETURN_NONE;
    }

    static PyObject* register_InstallOptions(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_InstallOptions)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_InstallOptions = type;
        Py_INCREF(state->type_InstallOptions);


        Py_RETURN_NONE;
    }

    static PyObject* register_KeyProtectionLevel(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_KeyProtectionLevel)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_KeyProtectionLevel = type;
        Py_INCREF(state->type_KeyProtectionLevel);


        Py_RETURN_NONE;
    }

    static PyObject* register_KeySize(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_KeySize)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_KeySize = type;
        Py_INCREF(state->type_KeySize);


        Py_RETURN_NONE;
    }

    static PyObject* register_SignatureValidationResult(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SignatureValidationResult)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SignatureValidationResult = type;
        Py_INCREF(state->type_SignatureValidationResult);


        Py_RETURN_NONE;
    }

    // ----- Certificate class --------------------
    static constexpr const char* const type_name_Certificate = "Certificate";

    static PyObject* _new_Certificate(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                winrt::Windows::Security::Cryptography::Certificates::Certificate instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Certificate(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Certificate_BuildChainAsync(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"BuildChainAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::Certificate>>(args, 0);

                return py::convert(self->obj.BuildChainAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"BuildChainAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::Certificate>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ChainBuildingParameters>(args, 1);

                return py::convert(self->obj.BuildChainAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Certificate_GetCertificateBlob(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"GetCertificateBlob", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCertificateBlob());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Certificate_GetHashValue(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"GetHashValue", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetHashValue());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"GetHashValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetHashValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Certificate_get_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"FriendlyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Certificate_put_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"FriendlyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FriendlyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Certificate_get_EnhancedKeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"EnhancedKeyUsages"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EnhancedKeyUsages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_HasPrivateKey(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"HasPrivateKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasPrivateKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_IsStronglyProtected(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"IsStronglyProtected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStronglyProtected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_Issuer(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"Issuer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Issuer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_SerialNumber(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"SerialNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SerialNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_Subject(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"Subject"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_ValidFrom(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"ValidFrom"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ValidFrom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_ValidTo(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"ValidTo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ValidTo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_IsSecurityDeviceBound(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"IsSecurityDeviceBound"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSecurityDeviceBound());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_KeyAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"KeyAlgorithmName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyAlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_KeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"KeyUsages"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyUsages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_SignatureAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"SignatureAlgorithmName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SignatureAlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_SignatureHashAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"SignatureHashAlgorithmName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SignatureHashAlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_SubjectAlternativeName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"SubjectAlternativeName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SubjectAlternativeName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_IsPerUser(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"IsPerUser"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPerUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_KeyStorageProviderName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"KeyStorageProviderName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyStorageProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_StoreName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"StoreName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StoreName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Certificate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::Certificate>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Certificate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::Certificate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Certificate[] = {
        { "build_chain_async", reinterpret_cast<PyCFunction>(Certificate_BuildChainAsync), METH_VARARGS, nullptr },
        { "get_certificate_blob", reinterpret_cast<PyCFunction>(Certificate_GetCertificateBlob), METH_VARARGS, nullptr },
        { "get_hash_value", reinterpret_cast<PyCFunction>(Certificate_GetHashValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Certificate, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Certificate), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Certificate[] = {
        { "friendly_name", reinterpret_cast<getter>(Certificate_get_FriendlyName), reinterpret_cast<setter>(Certificate_put_FriendlyName), nullptr, nullptr },
        { "enhanced_key_usages", reinterpret_cast<getter>(Certificate_get_EnhancedKeyUsages), nullptr, nullptr, nullptr },
        { "has_private_key", reinterpret_cast<getter>(Certificate_get_HasPrivateKey), nullptr, nullptr, nullptr },
        { "is_strongly_protected", reinterpret_cast<getter>(Certificate_get_IsStronglyProtected), nullptr, nullptr, nullptr },
        { "issuer", reinterpret_cast<getter>(Certificate_get_Issuer), nullptr, nullptr, nullptr },
        { "serial_number", reinterpret_cast<getter>(Certificate_get_SerialNumber), nullptr, nullptr, nullptr },
        { "subject", reinterpret_cast<getter>(Certificate_get_Subject), nullptr, nullptr, nullptr },
        { "valid_from", reinterpret_cast<getter>(Certificate_get_ValidFrom), nullptr, nullptr, nullptr },
        { "valid_to", reinterpret_cast<getter>(Certificate_get_ValidTo), nullptr, nullptr, nullptr },
        { "is_security_device_bound", reinterpret_cast<getter>(Certificate_get_IsSecurityDeviceBound), nullptr, nullptr, nullptr },
        { "key_algorithm_name", reinterpret_cast<getter>(Certificate_get_KeyAlgorithmName), nullptr, nullptr, nullptr },
        { "key_usages", reinterpret_cast<getter>(Certificate_get_KeyUsages), nullptr, nullptr, nullptr },
        { "signature_algorithm_name", reinterpret_cast<getter>(Certificate_get_SignatureAlgorithmName), nullptr, nullptr, nullptr },
        { "signature_hash_algorithm_name", reinterpret_cast<getter>(Certificate_get_SignatureHashAlgorithmName), nullptr, nullptr, nullptr },
        { "subject_alternative_name", reinterpret_cast<getter>(Certificate_get_SubjectAlternativeName), nullptr, nullptr, nullptr },
        { "is_per_user", reinterpret_cast<getter>(Certificate_get_IsPerUser), nullptr, nullptr, nullptr },
        { "key_storage_provider_name", reinterpret_cast<getter>(Certificate_get_KeyStorageProviderName), nullptr, nullptr, nullptr },
        { "store_name", reinterpret_cast<getter>(Certificate_get_StoreName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Certificate[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Certificate) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Certificate) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Certificate) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Certificate) },
        { },
    };

    static PyType_Spec type_spec_Certificate =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.Certificate",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Certificate
    };

    // ----- CertificateChain class --------------------
    static constexpr const char* const type_name_CertificateChain = "CertificateChain";

    static PyObject* _new_CertificateChain(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CertificateChain);
        return nullptr;
    }

    static void _dealloc_CertificateChain(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateChain* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CertificateChain_GetCertificates(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateChain* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateChain", L"GetCertificates", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.GetCertificates(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateChain_Validate(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateChain* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateChain", L"Validate", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Validate());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateChain", L"Validate", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ChainValidationParameters>(args, 0);

                return py::convert(self->obj.Validate(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_CertificateChain(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::CertificateChain>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CertificateChain(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CertificateChain>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateChain[] = {
        { "get_certificates", reinterpret_cast<PyCFunction>(CertificateChain_GetCertificates), METH_VARARGS, nullptr },
        { "validate", reinterpret_cast<PyCFunction>(CertificateChain_Validate), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CertificateChain, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CertificateChain), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CertificateChain[] = {
        { }
    };

    static PyType_Slot _type_slots_CertificateChain[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CertificateChain) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CertificateChain) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CertificateChain) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CertificateChain) },
        { },
    };

    static PyType_Spec type_spec_CertificateChain =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.CertificateChain",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateChain),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateChain
    };

    // ----- CertificateEnrollmentManager class --------------------
    static constexpr const char* const type_name_CertificateEnrollmentManager = "CertificateEnrollmentManager";

    static PyObject* _new_CertificateEnrollmentManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CertificateEnrollmentManager);
        return nullptr;
    }

    static PyObject* CertificateEnrollmentManager_CreateRequestAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateEnrollmentManager", L"CreateRequestAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::CertificateRequestProperties>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager::CreateRequestAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateEnrollmentManager_ImportPfxDataAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateEnrollmentManager", L"ImportPfxDataAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::PfxImportParameters>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager::ImportPfxDataAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 6)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateEnrollmentManager", L"ImportPfxDataAsync", 6))
            {
                py::set_arg_count_version_error(6);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ExportOption>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::KeyProtectionLevel>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager::ImportPfxDataAsync(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateEnrollmentManager", L"ImportPfxDataAsync", 7))
            {
                py::set_arg_count_version_error(7);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ExportOption>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::KeyProtectionLevel>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager::ImportPfxDataAsync(param0, param1, param2, param3, param4, param5, param6));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateEnrollmentManager_InstallCertificateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateEnrollmentManager", L"InstallCertificateAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager::InstallCertificateAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateEnrollmentManager_get_UserCertificateEnrollmentManager(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateEnrollmentManager", L"UserCertificateEnrollmentManager"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager::UserCertificateEnrollmentManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateEnrollmentManager[] = {
        { "create_request_async", reinterpret_cast<PyCFunction>(CertificateEnrollmentManager_CreateRequestAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "import_pfx_data_async", reinterpret_cast<PyCFunction>(CertificateEnrollmentManager_ImportPfxDataAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "install_certificate_async", reinterpret_cast<PyCFunction>(CertificateEnrollmentManager_InstallCertificateAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CertificateEnrollmentManager[] = {
        { }
    };

    static PyType_Slot _type_slots_CertificateEnrollmentManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CertificateEnrollmentManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CertificateEnrollmentManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CertificateEnrollmentManager) },
        { },
    };

    static PyType_Spec type_spec_CertificateEnrollmentManager =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.CertificateEnrollmentManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateEnrollmentManager
    };

    static PyGetSetDef getset_CertificateEnrollmentManager_Meta[] = {
        { "user_certificate_enrollment_manager", reinterpret_cast<getter>(CertificateEnrollmentManager_get_UserCertificateEnrollmentManager), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_CertificateEnrollmentManager_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CertificateEnrollmentManager_Meta) },
        { }
    };

    static PyType_Spec type_spec_CertificateEnrollmentManager_Meta =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.CertificateEnrollmentManager_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CertificateEnrollmentManager_Meta
    };

    // ----- CertificateExtension class --------------------
    static constexpr const char* const type_name_CertificateExtension = "CertificateExtension";

    static PyObject* _new_CertificateExtension(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::CertificateExtension instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CertificateExtension(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CertificateExtension_EncodeValue(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateExtension", L"EncodeValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.EncodeValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateExtension_get_Value(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateExtension", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateExtension_put_Value(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateExtension", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateExtension_get_ObjectId(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateExtension", L"ObjectId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ObjectId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateExtension_put_ObjectId(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateExtension", L"ObjectId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ObjectId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateExtension_get_IsCritical(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateExtension", L"IsCritical"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCritical());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateExtension_put_IsCritical(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateExtension", L"IsCritical"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCritical(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CertificateExtension(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::CertificateExtension>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CertificateExtension(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CertificateExtension>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateExtension[] = {
        { "encode_value", reinterpret_cast<PyCFunction>(CertificateExtension_EncodeValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CertificateExtension, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CertificateExtension), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CertificateExtension[] = {
        { "value", reinterpret_cast<getter>(CertificateExtension_get_Value), reinterpret_cast<setter>(CertificateExtension_put_Value), nullptr, nullptr },
        { "object_id", reinterpret_cast<getter>(CertificateExtension_get_ObjectId), reinterpret_cast<setter>(CertificateExtension_put_ObjectId), nullptr, nullptr },
        { "is_critical", reinterpret_cast<getter>(CertificateExtension_get_IsCritical), reinterpret_cast<setter>(CertificateExtension_put_IsCritical), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CertificateExtension[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CertificateExtension) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CertificateExtension) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CertificateExtension) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CertificateExtension) },
        { },
    };

    static PyType_Spec type_spec_CertificateExtension =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.CertificateExtension",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateExtension
    };

    // ----- CertificateKeyUsages class --------------------
    static constexpr const char* const type_name_CertificateKeyUsages = "CertificateKeyUsages";

    static PyObject* _new_CertificateKeyUsages(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::CertificateKeyUsages instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CertificateKeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CertificateKeyUsages_get_NonRepudiation(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"NonRepudiation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NonRepudiation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_NonRepudiation(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"NonRepudiation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.NonRepudiation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_KeyEncipherment(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"KeyEncipherment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyEncipherment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_KeyEncipherment(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"KeyEncipherment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.KeyEncipherment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_KeyCertificateSign(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"KeyCertificateSign"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyCertificateSign());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_KeyCertificateSign(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"KeyCertificateSign"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.KeyCertificateSign(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_KeyAgreement(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"KeyAgreement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyAgreement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_KeyAgreement(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"KeyAgreement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.KeyAgreement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_EncipherOnly(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"EncipherOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncipherOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_EncipherOnly(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"EncipherOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.EncipherOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_DigitalSignature(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"DigitalSignature"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DigitalSignature());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_DigitalSignature(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"DigitalSignature"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DigitalSignature(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_DataEncipherment(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"DataEncipherment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DataEncipherment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_DataEncipherment(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"DataEncipherment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DataEncipherment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_CrlSign(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"CrlSign"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CrlSign());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_CrlSign(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"CrlSign"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CrlSign(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CertificateKeyUsages(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::CertificateKeyUsages>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CertificateKeyUsages(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CertificateKeyUsages>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateKeyUsages[] = {
        { "_assign_array_", _assign_array_CertificateKeyUsages, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CertificateKeyUsages), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CertificateKeyUsages[] = {
        { "non_repudiation", reinterpret_cast<getter>(CertificateKeyUsages_get_NonRepudiation), reinterpret_cast<setter>(CertificateKeyUsages_put_NonRepudiation), nullptr, nullptr },
        { "key_encipherment", reinterpret_cast<getter>(CertificateKeyUsages_get_KeyEncipherment), reinterpret_cast<setter>(CertificateKeyUsages_put_KeyEncipherment), nullptr, nullptr },
        { "key_certificate_sign", reinterpret_cast<getter>(CertificateKeyUsages_get_KeyCertificateSign), reinterpret_cast<setter>(CertificateKeyUsages_put_KeyCertificateSign), nullptr, nullptr },
        { "key_agreement", reinterpret_cast<getter>(CertificateKeyUsages_get_KeyAgreement), reinterpret_cast<setter>(CertificateKeyUsages_put_KeyAgreement), nullptr, nullptr },
        { "encipher_only", reinterpret_cast<getter>(CertificateKeyUsages_get_EncipherOnly), reinterpret_cast<setter>(CertificateKeyUsages_put_EncipherOnly), nullptr, nullptr },
        { "digital_signature", reinterpret_cast<getter>(CertificateKeyUsages_get_DigitalSignature), reinterpret_cast<setter>(CertificateKeyUsages_put_DigitalSignature), nullptr, nullptr },
        { "data_encipherment", reinterpret_cast<getter>(CertificateKeyUsages_get_DataEncipherment), reinterpret_cast<setter>(CertificateKeyUsages_put_DataEncipherment), nullptr, nullptr },
        { "crl_sign", reinterpret_cast<getter>(CertificateKeyUsages_get_CrlSign), reinterpret_cast<setter>(CertificateKeyUsages_put_CrlSign), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CertificateKeyUsages[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CertificateKeyUsages) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CertificateKeyUsages) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CertificateKeyUsages) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CertificateKeyUsages) },
        { },
    };

    static PyType_Spec type_spec_CertificateKeyUsages =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.CertificateKeyUsages",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateKeyUsages
    };

    // ----- CertificateQuery class --------------------
    static constexpr const char* const type_name_CertificateQuery = "CertificateQuery";

    static PyObject* _new_CertificateQuery(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::CertificateQuery instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CertificateQuery(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CertificateQuery_get_Thumbprint(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"Thumbprint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Thumbprint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_Thumbprint(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"Thumbprint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(arg);

            self->obj.Thumbprint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateQuery_get_IssuerName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"IssuerName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IssuerName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_IssuerName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"IssuerName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.IssuerName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateQuery_get_HardwareOnly(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"HardwareOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_HardwareOnly(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"HardwareOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.HardwareOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateQuery_get_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"FriendlyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"FriendlyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FriendlyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateQuery_get_EnhancedKeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"EnhancedKeyUsages"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EnhancedKeyUsages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CertificateQuery_get_StoreName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"StoreName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StoreName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_StoreName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"StoreName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.StoreName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateQuery_get_IncludeExpiredCertificates(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"IncludeExpiredCertificates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IncludeExpiredCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_IncludeExpiredCertificates(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"IncludeExpiredCertificates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IncludeExpiredCertificates(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateQuery_get_IncludeDuplicates(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"IncludeDuplicates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IncludeDuplicates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_IncludeDuplicates(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"IncludeDuplicates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IncludeDuplicates(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CertificateQuery(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::CertificateQuery>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CertificateQuery(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CertificateQuery>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateQuery[] = {
        { "_assign_array_", _assign_array_CertificateQuery, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CertificateQuery), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CertificateQuery[] = {
        { "thumbprint", reinterpret_cast<getter>(CertificateQuery_get_Thumbprint), reinterpret_cast<setter>(CertificateQuery_put_Thumbprint), nullptr, nullptr },
        { "issuer_name", reinterpret_cast<getter>(CertificateQuery_get_IssuerName), reinterpret_cast<setter>(CertificateQuery_put_IssuerName), nullptr, nullptr },
        { "hardware_only", reinterpret_cast<getter>(CertificateQuery_get_HardwareOnly), reinterpret_cast<setter>(CertificateQuery_put_HardwareOnly), nullptr, nullptr },
        { "friendly_name", reinterpret_cast<getter>(CertificateQuery_get_FriendlyName), reinterpret_cast<setter>(CertificateQuery_put_FriendlyName), nullptr, nullptr },
        { "enhanced_key_usages", reinterpret_cast<getter>(CertificateQuery_get_EnhancedKeyUsages), nullptr, nullptr, nullptr },
        { "store_name", reinterpret_cast<getter>(CertificateQuery_get_StoreName), reinterpret_cast<setter>(CertificateQuery_put_StoreName), nullptr, nullptr },
        { "include_expired_certificates", reinterpret_cast<getter>(CertificateQuery_get_IncludeExpiredCertificates), reinterpret_cast<setter>(CertificateQuery_put_IncludeExpiredCertificates), nullptr, nullptr },
        { "include_duplicates", reinterpret_cast<getter>(CertificateQuery_get_IncludeDuplicates), reinterpret_cast<setter>(CertificateQuery_put_IncludeDuplicates), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CertificateQuery[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CertificateQuery) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CertificateQuery) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CertificateQuery) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CertificateQuery) },
        { },
    };

    static PyType_Spec type_spec_CertificateQuery =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.CertificateQuery",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateQuery
    };

    // ----- CertificateRequestProperties class --------------------
    static constexpr const char* const type_name_CertificateRequestProperties = "CertificateRequestProperties";

    static PyObject* _new_CertificateRequestProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::CertificateRequestProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CertificateRequestProperties(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CertificateRequestProperties_get_Subject(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"Subject"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_Subject(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"Subject"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subject(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_KeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"KeyUsages"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyUsages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_KeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"KeyUsages"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::EnrollKeyUsages>(arg);

            self->obj.KeyUsages(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_KeyStorageProviderName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"KeyStorageProviderName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyStorageProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_KeyStorageProviderName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"KeyStorageProviderName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.KeyStorageProviderName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_KeySize(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"KeySize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeySize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_KeySize(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"KeySize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.KeySize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_Exportable(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"Exportable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Exportable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_Exportable(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"Exportable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ExportOption>(arg);

            self->obj.Exportable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_KeyProtectionLevel(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"KeyProtectionLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_KeyProtectionLevel(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"KeyProtectionLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::KeyProtectionLevel>(arg);

            self->obj.KeyProtectionLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_KeyAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"KeyAlgorithmName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyAlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_KeyAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"KeyAlgorithmName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.KeyAlgorithmName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_HashAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"HashAlgorithmName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HashAlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_HashAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"HashAlgorithmName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.HashAlgorithmName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"FriendlyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"FriendlyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FriendlyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_AttestationCredentialCertificate(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"AttestationCredentialCertificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AttestationCredentialCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_AttestationCredentialCertificate(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"AttestationCredentialCertificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(arg);

            self->obj.AttestationCredentialCertificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_SigningCertificate(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"SigningCertificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SigningCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_SigningCertificate(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"SigningCertificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(arg);

            self->obj.SigningCertificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_SmartcardReaderName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"SmartcardReaderName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SmartcardReaderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_SmartcardReaderName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"SmartcardReaderName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SmartcardReaderName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_UseExistingKey(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"UseExistingKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UseExistingKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_UseExistingKey(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"UseExistingKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.UseExistingKey(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_CurveParameters(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"CurveParameters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurveParameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_CurveParameters(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"CurveParameters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(arg);

            self->obj.CurveParameters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_CurveName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"CurveName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurveName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_CurveName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"CurveName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CurveName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_ContainerNamePrefix(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"ContainerNamePrefix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContainerNamePrefix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_ContainerNamePrefix(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"ContainerNamePrefix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContainerNamePrefix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_ContainerName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"ContainerName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContainerName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_ContainerName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"ContainerName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContainerName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_Extensions(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"Extensions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Extensions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CertificateRequestProperties_get_SubjectAlternativeName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"SubjectAlternativeName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SubjectAlternativeName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CertificateRequestProperties_get_SuppressedDefaults(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"SuppressedDefaults"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SuppressedDefaults());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CertificateRequestProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::CertificateRequestProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CertificateRequestProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CertificateRequestProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateRequestProperties[] = {
        { "_assign_array_", _assign_array_CertificateRequestProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CertificateRequestProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CertificateRequestProperties[] = {
        { "subject", reinterpret_cast<getter>(CertificateRequestProperties_get_Subject), reinterpret_cast<setter>(CertificateRequestProperties_put_Subject), nullptr, nullptr },
        { "key_usages", reinterpret_cast<getter>(CertificateRequestProperties_get_KeyUsages), reinterpret_cast<setter>(CertificateRequestProperties_put_KeyUsages), nullptr, nullptr },
        { "key_storage_provider_name", reinterpret_cast<getter>(CertificateRequestProperties_get_KeyStorageProviderName), reinterpret_cast<setter>(CertificateRequestProperties_put_KeyStorageProviderName), nullptr, nullptr },
        { "key_size", reinterpret_cast<getter>(CertificateRequestProperties_get_KeySize), reinterpret_cast<setter>(CertificateRequestProperties_put_KeySize), nullptr, nullptr },
        { "exportable", reinterpret_cast<getter>(CertificateRequestProperties_get_Exportable), reinterpret_cast<setter>(CertificateRequestProperties_put_Exportable), nullptr, nullptr },
        { "key_protection_level", reinterpret_cast<getter>(CertificateRequestProperties_get_KeyProtectionLevel), reinterpret_cast<setter>(CertificateRequestProperties_put_KeyProtectionLevel), nullptr, nullptr },
        { "key_algorithm_name", reinterpret_cast<getter>(CertificateRequestProperties_get_KeyAlgorithmName), reinterpret_cast<setter>(CertificateRequestProperties_put_KeyAlgorithmName), nullptr, nullptr },
        { "hash_algorithm_name", reinterpret_cast<getter>(CertificateRequestProperties_get_HashAlgorithmName), reinterpret_cast<setter>(CertificateRequestProperties_put_HashAlgorithmName), nullptr, nullptr },
        { "friendly_name", reinterpret_cast<getter>(CertificateRequestProperties_get_FriendlyName), reinterpret_cast<setter>(CertificateRequestProperties_put_FriendlyName), nullptr, nullptr },
        { "attestation_credential_certificate", reinterpret_cast<getter>(CertificateRequestProperties_get_AttestationCredentialCertificate), reinterpret_cast<setter>(CertificateRequestProperties_put_AttestationCredentialCertificate), nullptr, nullptr },
        { "signing_certificate", reinterpret_cast<getter>(CertificateRequestProperties_get_SigningCertificate), reinterpret_cast<setter>(CertificateRequestProperties_put_SigningCertificate), nullptr, nullptr },
        { "smartcard_reader_name", reinterpret_cast<getter>(CertificateRequestProperties_get_SmartcardReaderName), reinterpret_cast<setter>(CertificateRequestProperties_put_SmartcardReaderName), nullptr, nullptr },
        { "use_existing_key", reinterpret_cast<getter>(CertificateRequestProperties_get_UseExistingKey), reinterpret_cast<setter>(CertificateRequestProperties_put_UseExistingKey), nullptr, nullptr },
        { "curve_parameters", reinterpret_cast<getter>(CertificateRequestProperties_get_CurveParameters), reinterpret_cast<setter>(CertificateRequestProperties_put_CurveParameters), nullptr, nullptr },
        { "curve_name", reinterpret_cast<getter>(CertificateRequestProperties_get_CurveName), reinterpret_cast<setter>(CertificateRequestProperties_put_CurveName), nullptr, nullptr },
        { "container_name_prefix", reinterpret_cast<getter>(CertificateRequestProperties_get_ContainerNamePrefix), reinterpret_cast<setter>(CertificateRequestProperties_put_ContainerNamePrefix), nullptr, nullptr },
        { "container_name", reinterpret_cast<getter>(CertificateRequestProperties_get_ContainerName), reinterpret_cast<setter>(CertificateRequestProperties_put_ContainerName), nullptr, nullptr },
        { "extensions", reinterpret_cast<getter>(CertificateRequestProperties_get_Extensions), nullptr, nullptr, nullptr },
        { "subject_alternative_name", reinterpret_cast<getter>(CertificateRequestProperties_get_SubjectAlternativeName), nullptr, nullptr, nullptr },
        { "suppressed_defaults", reinterpret_cast<getter>(CertificateRequestProperties_get_SuppressedDefaults), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CertificateRequestProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CertificateRequestProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CertificateRequestProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CertificateRequestProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CertificateRequestProperties) },
        { },
    };

    static PyType_Spec type_spec_CertificateRequestProperties =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.CertificateRequestProperties",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateRequestProperties
    };

    // ----- CertificateStore class --------------------
    static constexpr const char* const type_name_CertificateStore = "CertificateStore";

    static PyObject* _new_CertificateStore(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CertificateStore);
        return nullptr;
    }

    static void _dealloc_CertificateStore(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateStore* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CertificateStore_Add(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateStore", L"Add", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 0);

                self->obj.Add(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateStore_Delete(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateStore", L"Delete", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 0);

                self->obj.Delete(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateStore_get_Name(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateStore* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateStore", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CertificateStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::CertificateStore>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CertificateStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CertificateStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateStore[] = {
        { "add", reinterpret_cast<PyCFunction>(CertificateStore_Add), METH_VARARGS, nullptr },
        { "delete", reinterpret_cast<PyCFunction>(CertificateStore_Delete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CertificateStore, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CertificateStore), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CertificateStore[] = {
        { "name", reinterpret_cast<getter>(CertificateStore_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CertificateStore[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CertificateStore) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CertificateStore) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CertificateStore) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CertificateStore) },
        { },
    };

    static PyType_Spec type_spec_CertificateStore =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.CertificateStore",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateStore
    };

    // ----- CertificateStores class --------------------
    static constexpr const char* const type_name_CertificateStores = "CertificateStores";

    static PyObject* _new_CertificateStores(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CertificateStores);
        return nullptr;
    }

    static PyObject* CertificateStores_FindAllAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateStores", L"FindAllAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateStores::FindAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateStores", L"FindAllAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::CertificateQuery>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateStores::FindAllAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateStores_GetStoreByName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateStores", L"GetStoreByName", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateStores::GetStoreByName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateStores_GetUserStoreByName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateStores", L"GetUserStoreByName", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateStores::GetUserStoreByName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateStores_get_IntermediateCertificationAuthorities(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateStores", L"IntermediateCertificationAuthorities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateStores::IntermediateCertificationAuthorities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CertificateStores_get_TrustedRootCertificationAuthorities(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateStores", L"TrustedRootCertificationAuthorities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateStores::TrustedRootCertificationAuthorities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateStores[] = {
        { "find_all_async", reinterpret_cast<PyCFunction>(CertificateStores_FindAllAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_store_by_name", reinterpret_cast<PyCFunction>(CertificateStores_GetStoreByName), METH_VARARGS | METH_STATIC, nullptr },
        { "get_user_store_by_name", reinterpret_cast<PyCFunction>(CertificateStores_GetUserStoreByName), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CertificateStores[] = {
        { }
    };

    static PyType_Slot _type_slots_CertificateStores[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CertificateStores) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CertificateStores) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CertificateStores) },
        { },
    };

    static PyType_Spec type_spec_CertificateStores =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.CertificateStores",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateStores
    };

    static PyGetSetDef getset_CertificateStores_Meta[] = {
        { "intermediate_certification_authorities", reinterpret_cast<getter>(CertificateStores_get_IntermediateCertificationAuthorities), nullptr, nullptr, nullptr },
        { "trusted_root_certification_authorities", reinterpret_cast<getter>(CertificateStores_get_TrustedRootCertificationAuthorities), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_CertificateStores_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CertificateStores_Meta) },
        { }
    };

    static PyType_Spec type_spec_CertificateStores_Meta =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.CertificateStores_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CertificateStores_Meta
    };

    // ----- ChainBuildingParameters class --------------------
    static constexpr const char* const type_name_ChainBuildingParameters = "ChainBuildingParameters";

    static PyObject* _new_ChainBuildingParameters(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::ChainBuildingParameters instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChainBuildingParameters(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChainBuildingParameters_get_ValidationTimestamp(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainBuildingParameters", L"ValidationTimestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ValidationTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainBuildingParameters_put_ValidationTimestamp(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainBuildingParameters", L"ValidationTimestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.ValidationTimestamp(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChainBuildingParameters_get_RevocationCheckEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainBuildingParameters", L"RevocationCheckEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RevocationCheckEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainBuildingParameters_put_RevocationCheckEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainBuildingParameters", L"RevocationCheckEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RevocationCheckEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChainBuildingParameters_get_NetworkRetrievalEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainBuildingParameters", L"NetworkRetrievalEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkRetrievalEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainBuildingParameters_put_NetworkRetrievalEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainBuildingParameters", L"NetworkRetrievalEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.NetworkRetrievalEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChainBuildingParameters_get_CurrentTimeValidationEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainBuildingParameters", L"CurrentTimeValidationEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentTimeValidationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainBuildingParameters_put_CurrentTimeValidationEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainBuildingParameters", L"CurrentTimeValidationEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CurrentTimeValidationEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChainBuildingParameters_get_AuthorityInformationAccessEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainBuildingParameters", L"AuthorityInformationAccessEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AuthorityInformationAccessEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainBuildingParameters_put_AuthorityInformationAccessEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainBuildingParameters", L"AuthorityInformationAccessEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AuthorityInformationAccessEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChainBuildingParameters_get_EnhancedKeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainBuildingParameters", L"EnhancedKeyUsages"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EnhancedKeyUsages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChainBuildingParameters_get_ExclusiveTrustRoots(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainBuildingParameters", L"ExclusiveTrustRoots"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExclusiveTrustRoots());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChainBuildingParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::ChainBuildingParameters>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChainBuildingParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::ChainBuildingParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChainBuildingParameters[] = {
        { "_assign_array_", _assign_array_ChainBuildingParameters, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChainBuildingParameters), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChainBuildingParameters[] = {
        { "validation_timestamp", reinterpret_cast<getter>(ChainBuildingParameters_get_ValidationTimestamp), reinterpret_cast<setter>(ChainBuildingParameters_put_ValidationTimestamp), nullptr, nullptr },
        { "revocation_check_enabled", reinterpret_cast<getter>(ChainBuildingParameters_get_RevocationCheckEnabled), reinterpret_cast<setter>(ChainBuildingParameters_put_RevocationCheckEnabled), nullptr, nullptr },
        { "network_retrieval_enabled", reinterpret_cast<getter>(ChainBuildingParameters_get_NetworkRetrievalEnabled), reinterpret_cast<setter>(ChainBuildingParameters_put_NetworkRetrievalEnabled), nullptr, nullptr },
        { "current_time_validation_enabled", reinterpret_cast<getter>(ChainBuildingParameters_get_CurrentTimeValidationEnabled), reinterpret_cast<setter>(ChainBuildingParameters_put_CurrentTimeValidationEnabled), nullptr, nullptr },
        { "authority_information_access_enabled", reinterpret_cast<getter>(ChainBuildingParameters_get_AuthorityInformationAccessEnabled), reinterpret_cast<setter>(ChainBuildingParameters_put_AuthorityInformationAccessEnabled), nullptr, nullptr },
        { "enhanced_key_usages", reinterpret_cast<getter>(ChainBuildingParameters_get_EnhancedKeyUsages), nullptr, nullptr, nullptr },
        { "exclusive_trust_roots", reinterpret_cast<getter>(ChainBuildingParameters_get_ExclusiveTrustRoots), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChainBuildingParameters[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChainBuildingParameters) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChainBuildingParameters) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChainBuildingParameters) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChainBuildingParameters) },
        { },
    };

    static PyType_Spec type_spec_ChainBuildingParameters =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.ChainBuildingParameters",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChainBuildingParameters
    };

    // ----- ChainValidationParameters class --------------------
    static constexpr const char* const type_name_ChainValidationParameters = "ChainValidationParameters";

    static PyObject* _new_ChainValidationParameters(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::ChainValidationParameters instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChainValidationParameters(py::wrapper::Windows::Security::Cryptography::Certificates::ChainValidationParameters* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChainValidationParameters_get_ServerDnsName(py::wrapper::Windows::Security::Cryptography::Certificates::ChainValidationParameters* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainValidationParameters", L"ServerDnsName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerDnsName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainValidationParameters_put_ServerDnsName(py::wrapper::Windows::Security::Cryptography::Certificates::ChainValidationParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainValidationParameters", L"ServerDnsName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(arg);

            self->obj.ServerDnsName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChainValidationParameters_get_CertificateChainPolicy(py::wrapper::Windows::Security::Cryptography::Certificates::ChainValidationParameters* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainValidationParameters", L"CertificateChainPolicy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CertificateChainPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainValidationParameters_put_CertificateChainPolicy(py::wrapper::Windows::Security::Cryptography::Certificates::ChainValidationParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainValidationParameters", L"CertificateChainPolicy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::CertificateChainPolicy>(arg);

            self->obj.CertificateChainPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ChainValidationParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::ChainValidationParameters>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChainValidationParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::ChainValidationParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChainValidationParameters[] = {
        { "_assign_array_", _assign_array_ChainValidationParameters, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChainValidationParameters), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChainValidationParameters[] = {
        { "server_dns_name", reinterpret_cast<getter>(ChainValidationParameters_get_ServerDnsName), reinterpret_cast<setter>(ChainValidationParameters_put_ServerDnsName), nullptr, nullptr },
        { "certificate_chain_policy", reinterpret_cast<getter>(ChainValidationParameters_get_CertificateChainPolicy), reinterpret_cast<setter>(ChainValidationParameters_put_CertificateChainPolicy), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChainValidationParameters[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChainValidationParameters) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChainValidationParameters) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChainValidationParameters) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChainValidationParameters) },
        { },
    };

    static PyType_Spec type_spec_ChainValidationParameters =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.ChainValidationParameters",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::ChainValidationParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChainValidationParameters
    };

    // ----- CmsAttachedSignature class --------------------
    static constexpr const char* const type_name_CmsAttachedSignature = "CmsAttachedSignature";

    static PyObject* _new_CmsAttachedSignature(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                winrt::Windows::Security::Cryptography::Certificates::CmsAttachedSignature instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CmsAttachedSignature(py::wrapper::Windows::Security::Cryptography::Certificates::CmsAttachedSignature* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CmsAttachedSignature_GenerateSignatureAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CmsAttachedSignature", L"GenerateSignatureAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::CmsSignerInfo>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::Certificate>>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CmsAttachedSignature::GenerateSignatureAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CmsAttachedSignature_VerifySignature(py::wrapper::Windows::Security::Cryptography::Certificates::CmsAttachedSignature* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CmsAttachedSignature", L"VerifySignature", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.VerifySignature());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CmsAttachedSignature_get_Certificates(py::wrapper::Windows::Security::Cryptography::Certificates::CmsAttachedSignature* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CmsAttachedSignature", L"Certificates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Certificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CmsAttachedSignature_get_Content(py::wrapper::Windows::Security::Cryptography::Certificates::CmsAttachedSignature* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CmsAttachedSignature", L"Content"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CmsAttachedSignature_get_Signers(py::wrapper::Windows::Security::Cryptography::Certificates::CmsAttachedSignature* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CmsAttachedSignature", L"Signers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Signers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CmsAttachedSignature(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::CmsAttachedSignature>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CmsAttachedSignature(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CmsAttachedSignature>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CmsAttachedSignature[] = {
        { "generate_signature_async", reinterpret_cast<PyCFunction>(CmsAttachedSignature_GenerateSignatureAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "verify_signature", reinterpret_cast<PyCFunction>(CmsAttachedSignature_VerifySignature), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CmsAttachedSignature, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CmsAttachedSignature), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CmsAttachedSignature[] = {
        { "certificates", reinterpret_cast<getter>(CmsAttachedSignature_get_Certificates), nullptr, nullptr, nullptr },
        { "content", reinterpret_cast<getter>(CmsAttachedSignature_get_Content), nullptr, nullptr, nullptr },
        { "signers", reinterpret_cast<getter>(CmsAttachedSignature_get_Signers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CmsAttachedSignature[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CmsAttachedSignature) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CmsAttachedSignature) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CmsAttachedSignature) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CmsAttachedSignature) },
        { },
    };

    static PyType_Spec type_spec_CmsAttachedSignature =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.CmsAttachedSignature",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CmsAttachedSignature),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CmsAttachedSignature
    };

    // ----- CmsDetachedSignature class --------------------
    static constexpr const char* const type_name_CmsDetachedSignature = "CmsDetachedSignature";

    static PyObject* _new_CmsDetachedSignature(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                winrt::Windows::Security::Cryptography::Certificates::CmsDetachedSignature instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CmsDetachedSignature(py::wrapper::Windows::Security::Cryptography::Certificates::CmsDetachedSignature* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CmsDetachedSignature_GenerateSignatureAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CmsDetachedSignature", L"GenerateSignatureAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::CmsSignerInfo>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::Certificate>>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CmsDetachedSignature::GenerateSignatureAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CmsDetachedSignature_VerifySignatureAsync(py::wrapper::Windows::Security::Cryptography::Certificates::CmsDetachedSignature* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CmsDetachedSignature", L"VerifySignatureAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                return py::convert(self->obj.VerifySignatureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CmsDetachedSignature_get_Certificates(py::wrapper::Windows::Security::Cryptography::Certificates::CmsDetachedSignature* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CmsDetachedSignature", L"Certificates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Certificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CmsDetachedSignature_get_Signers(py::wrapper::Windows::Security::Cryptography::Certificates::CmsDetachedSignature* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CmsDetachedSignature", L"Signers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Signers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CmsDetachedSignature(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::CmsDetachedSignature>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CmsDetachedSignature(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CmsDetachedSignature>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CmsDetachedSignature[] = {
        { "generate_signature_async", reinterpret_cast<PyCFunction>(CmsDetachedSignature_GenerateSignatureAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "verify_signature_async", reinterpret_cast<PyCFunction>(CmsDetachedSignature_VerifySignatureAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CmsDetachedSignature, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CmsDetachedSignature), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CmsDetachedSignature[] = {
        { "certificates", reinterpret_cast<getter>(CmsDetachedSignature_get_Certificates), nullptr, nullptr, nullptr },
        { "signers", reinterpret_cast<getter>(CmsDetachedSignature_get_Signers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CmsDetachedSignature[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CmsDetachedSignature) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CmsDetachedSignature) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CmsDetachedSignature) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CmsDetachedSignature) },
        { },
    };

    static PyType_Spec type_spec_CmsDetachedSignature =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.CmsDetachedSignature",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CmsDetachedSignature),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CmsDetachedSignature
    };

    // ----- CmsSignerInfo class --------------------
    static constexpr const char* const type_name_CmsSignerInfo = "CmsSignerInfo";

    static PyObject* _new_CmsSignerInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::CmsSignerInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CmsSignerInfo(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CmsSignerInfo_get_HashAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CmsSignerInfo", L"HashAlgorithmName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HashAlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CmsSignerInfo_put_HashAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CmsSignerInfo", L"HashAlgorithmName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.HashAlgorithmName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CmsSignerInfo_get_Certificate(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CmsSignerInfo", L"Certificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Certificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CmsSignerInfo_put_Certificate(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CmsSignerInfo", L"Certificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(arg);

            self->obj.Certificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CmsSignerInfo_get_TimestampInfo(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CmsSignerInfo", L"TimestampInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimestampInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CmsSignerInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::CmsSignerInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CmsSignerInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CmsSignerInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CmsSignerInfo[] = {
        { "_assign_array_", _assign_array_CmsSignerInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CmsSignerInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CmsSignerInfo[] = {
        { "hash_algorithm_name", reinterpret_cast<getter>(CmsSignerInfo_get_HashAlgorithmName), reinterpret_cast<setter>(CmsSignerInfo_put_HashAlgorithmName), nullptr, nullptr },
        { "certificate", reinterpret_cast<getter>(CmsSignerInfo_get_Certificate), reinterpret_cast<setter>(CmsSignerInfo_put_Certificate), nullptr, nullptr },
        { "timestamp_info", reinterpret_cast<getter>(CmsSignerInfo_get_TimestampInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CmsSignerInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CmsSignerInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CmsSignerInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CmsSignerInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CmsSignerInfo) },
        { },
    };

    static PyType_Spec type_spec_CmsSignerInfo =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.CmsSignerInfo",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CmsSignerInfo
    };

    // ----- CmsTimestampInfo class --------------------
    static constexpr const char* const type_name_CmsTimestampInfo = "CmsTimestampInfo";

    static PyObject* _new_CmsTimestampInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CmsTimestampInfo);
        return nullptr;
    }

    static void _dealloc_CmsTimestampInfo(py::wrapper::Windows::Security::Cryptography::Certificates::CmsTimestampInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CmsTimestampInfo_get_Certificates(py::wrapper::Windows::Security::Cryptography::Certificates::CmsTimestampInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CmsTimestampInfo", L"Certificates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Certificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CmsTimestampInfo_get_SigningCertificate(py::wrapper::Windows::Security::Cryptography::Certificates::CmsTimestampInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CmsTimestampInfo", L"SigningCertificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SigningCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CmsTimestampInfo_get_Timestamp(py::wrapper::Windows::Security::Cryptography::Certificates::CmsTimestampInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CmsTimestampInfo", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CmsTimestampInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::CmsTimestampInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CmsTimestampInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CmsTimestampInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CmsTimestampInfo[] = {
        { "_assign_array_", _assign_array_CmsTimestampInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CmsTimestampInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CmsTimestampInfo[] = {
        { "certificates", reinterpret_cast<getter>(CmsTimestampInfo_get_Certificates), nullptr, nullptr, nullptr },
        { "signing_certificate", reinterpret_cast<getter>(CmsTimestampInfo_get_SigningCertificate), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(CmsTimestampInfo_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CmsTimestampInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CmsTimestampInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CmsTimestampInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CmsTimestampInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CmsTimestampInfo) },
        { },
    };

    static PyType_Spec type_spec_CmsTimestampInfo =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.CmsTimestampInfo",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CmsTimestampInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CmsTimestampInfo
    };

    // ----- KeyAlgorithmNames class --------------------
    static constexpr const char* const type_name_KeyAlgorithmNames = "KeyAlgorithmNames";

    static PyObject* _new_KeyAlgorithmNames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KeyAlgorithmNames);
        return nullptr;
    }

    static PyObject* KeyAlgorithmNames_get_Dsa(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyAlgorithmNames", L"Dsa"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Dsa());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdh256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyAlgorithmNames", L"Ecdh256"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdh256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdh384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyAlgorithmNames", L"Ecdh384"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdh384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdh521(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyAlgorithmNames", L"Ecdh521"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdh521());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdsa256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyAlgorithmNames", L"Ecdsa256"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdsa256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdsa384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyAlgorithmNames", L"Ecdsa384"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdsa384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdsa521(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyAlgorithmNames", L"Ecdsa521"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdsa521());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Rsa(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyAlgorithmNames", L"Rsa"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Rsa());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdh(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyAlgorithmNames", L"Ecdh"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdsa(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyAlgorithmNames", L"Ecdsa"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdsa());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyAlgorithmNames[] = {
        { }
    };

    static PyGetSetDef _getset_KeyAlgorithmNames[] = {
        { }
    };

    static PyType_Slot _type_slots_KeyAlgorithmNames[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyAlgorithmNames) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeyAlgorithmNames) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyAlgorithmNames) },
        { },
    };

    static PyType_Spec type_spec_KeyAlgorithmNames =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.KeyAlgorithmNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyAlgorithmNames
    };

    static PyGetSetDef getset_KeyAlgorithmNames_Meta[] = {
        { "dsa", reinterpret_cast<getter>(KeyAlgorithmNames_get_Dsa), nullptr, nullptr, nullptr },
        { "ecdh256", reinterpret_cast<getter>(KeyAlgorithmNames_get_Ecdh256), nullptr, nullptr, nullptr },
        { "ecdh384", reinterpret_cast<getter>(KeyAlgorithmNames_get_Ecdh384), nullptr, nullptr, nullptr },
        { "ecdh521", reinterpret_cast<getter>(KeyAlgorithmNames_get_Ecdh521), nullptr, nullptr, nullptr },
        { "ecdsa256", reinterpret_cast<getter>(KeyAlgorithmNames_get_Ecdsa256), nullptr, nullptr, nullptr },
        { "ecdsa384", reinterpret_cast<getter>(KeyAlgorithmNames_get_Ecdsa384), nullptr, nullptr, nullptr },
        { "ecdsa521", reinterpret_cast<getter>(KeyAlgorithmNames_get_Ecdsa521), nullptr, nullptr, nullptr },
        { "rsa", reinterpret_cast<getter>(KeyAlgorithmNames_get_Rsa), nullptr, nullptr, nullptr },
        { "ecdh", reinterpret_cast<getter>(KeyAlgorithmNames_get_Ecdh), nullptr, nullptr, nullptr },
        { "ecdsa", reinterpret_cast<getter>(KeyAlgorithmNames_get_Ecdsa), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_KeyAlgorithmNames_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KeyAlgorithmNames_Meta) },
        { }
    };

    static PyType_Spec type_spec_KeyAlgorithmNames_Meta =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.KeyAlgorithmNames_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KeyAlgorithmNames_Meta
    };

    // ----- KeyAttestationHelper class --------------------
    static constexpr const char* const type_name_KeyAttestationHelper = "KeyAttestationHelper";

    static PyObject* _new_KeyAttestationHelper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KeyAttestationHelper);
        return nullptr;
    }

    static PyObject* KeyAttestationHelper_DecryptTpmAttestationCredentialAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.KeyAttestationHelper", L"DecryptTpmAttestationCredentialAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAttestationHelper::DecryptTpmAttestationCredentialAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.KeyAttestationHelper", L"DecryptTpmAttestationCredentialAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAttestationHelper::DecryptTpmAttestationCredentialAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyAttestationHelper_GetTpmAttestationCredentialId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.KeyAttestationHelper", L"GetTpmAttestationCredentialId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAttestationHelper::GetTpmAttestationCredentialId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyAttestationHelper[] = {
        { "decrypt_tpm_attestation_credential_async", reinterpret_cast<PyCFunction>(KeyAttestationHelper_DecryptTpmAttestationCredentialAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_tpm_attestation_credential_id", reinterpret_cast<PyCFunction>(KeyAttestationHelper_GetTpmAttestationCredentialId), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KeyAttestationHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_KeyAttestationHelper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyAttestationHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeyAttestationHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyAttestationHelper) },
        { },
    };

    static PyType_Spec type_spec_KeyAttestationHelper =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.KeyAttestationHelper",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyAttestationHelper
    };

    // ----- KeyStorageProviderNames class --------------------
    static constexpr const char* const type_name_KeyStorageProviderNames = "KeyStorageProviderNames";

    static PyObject* _new_KeyStorageProviderNames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KeyStorageProviderNames);
        return nullptr;
    }

    static PyObject* KeyStorageProviderNames_get_PlatformKeyStorageProvider(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyStorageProviderNames", L"PlatformKeyStorageProvider"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyStorageProviderNames::PlatformKeyStorageProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyStorageProviderNames_get_SmartcardKeyStorageProvider(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyStorageProviderNames", L"SmartcardKeyStorageProvider"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyStorageProviderNames::SmartcardKeyStorageProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyStorageProviderNames_get_SoftwareKeyStorageProvider(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyStorageProviderNames", L"SoftwareKeyStorageProvider"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyStorageProviderNames::SoftwareKeyStorageProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyStorageProviderNames_get_PassportKeyStorageProvider(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyStorageProviderNames", L"PassportKeyStorageProvider"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyStorageProviderNames::PassportKeyStorageProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyStorageProviderNames[] = {
        { }
    };

    static PyGetSetDef _getset_KeyStorageProviderNames[] = {
        { }
    };

    static PyType_Slot _type_slots_KeyStorageProviderNames[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyStorageProviderNames) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeyStorageProviderNames) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyStorageProviderNames) },
        { },
    };

    static PyType_Spec type_spec_KeyStorageProviderNames =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.KeyStorageProviderNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyStorageProviderNames
    };

    static PyGetSetDef getset_KeyStorageProviderNames_Meta[] = {
        { "platform_key_storage_provider", reinterpret_cast<getter>(KeyStorageProviderNames_get_PlatformKeyStorageProvider), nullptr, nullptr, nullptr },
        { "smartcard_key_storage_provider", reinterpret_cast<getter>(KeyStorageProviderNames_get_SmartcardKeyStorageProvider), nullptr, nullptr, nullptr },
        { "software_key_storage_provider", reinterpret_cast<getter>(KeyStorageProviderNames_get_SoftwareKeyStorageProvider), nullptr, nullptr, nullptr },
        { "passport_key_storage_provider", reinterpret_cast<getter>(KeyStorageProviderNames_get_PassportKeyStorageProvider), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_KeyStorageProviderNames_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KeyStorageProviderNames_Meta) },
        { }
    };

    static PyType_Spec type_spec_KeyStorageProviderNames_Meta =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.KeyStorageProviderNames_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KeyStorageProviderNames_Meta
    };

    // ----- PfxImportParameters class --------------------
    static constexpr const char* const type_name_PfxImportParameters = "PfxImportParameters";

    static PyObject* _new_PfxImportParameters(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::PfxImportParameters instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PfxImportParameters(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PfxImportParameters_get_ReaderName(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"ReaderName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReaderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_ReaderName(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"ReaderName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ReaderName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PfxImportParameters_get_KeyStorageProviderName(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"KeyStorageProviderName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyStorageProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_KeyStorageProviderName(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"KeyStorageProviderName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.KeyStorageProviderName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PfxImportParameters_get_KeyProtectionLevel(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"KeyProtectionLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_KeyProtectionLevel(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"KeyProtectionLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::KeyProtectionLevel>(arg);

            self->obj.KeyProtectionLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PfxImportParameters_get_InstallOptions(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"InstallOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstallOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_InstallOptions(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"InstallOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(arg);

            self->obj.InstallOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PfxImportParameters_get_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"FriendlyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"FriendlyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FriendlyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PfxImportParameters_get_Exportable(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"Exportable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Exportable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_Exportable(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"Exportable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ExportOption>(arg);

            self->obj.Exportable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PfxImportParameters_get_ContainerNamePrefix(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"ContainerNamePrefix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContainerNamePrefix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_ContainerNamePrefix(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"ContainerNamePrefix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContainerNamePrefix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PfxImportParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::PfxImportParameters>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PfxImportParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::PfxImportParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PfxImportParameters[] = {
        { "_assign_array_", _assign_array_PfxImportParameters, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PfxImportParameters), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PfxImportParameters[] = {
        { "reader_name", reinterpret_cast<getter>(PfxImportParameters_get_ReaderName), reinterpret_cast<setter>(PfxImportParameters_put_ReaderName), nullptr, nullptr },
        { "key_storage_provider_name", reinterpret_cast<getter>(PfxImportParameters_get_KeyStorageProviderName), reinterpret_cast<setter>(PfxImportParameters_put_KeyStorageProviderName), nullptr, nullptr },
        { "key_protection_level", reinterpret_cast<getter>(PfxImportParameters_get_KeyProtectionLevel), reinterpret_cast<setter>(PfxImportParameters_put_KeyProtectionLevel), nullptr, nullptr },
        { "install_options", reinterpret_cast<getter>(PfxImportParameters_get_InstallOptions), reinterpret_cast<setter>(PfxImportParameters_put_InstallOptions), nullptr, nullptr },
        { "friendly_name", reinterpret_cast<getter>(PfxImportParameters_get_FriendlyName), reinterpret_cast<setter>(PfxImportParameters_put_FriendlyName), nullptr, nullptr },
        { "exportable", reinterpret_cast<getter>(PfxImportParameters_get_Exportable), reinterpret_cast<setter>(PfxImportParameters_put_Exportable), nullptr, nullptr },
        { "container_name_prefix", reinterpret_cast<getter>(PfxImportParameters_get_ContainerNamePrefix), reinterpret_cast<setter>(PfxImportParameters_put_ContainerNamePrefix), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PfxImportParameters[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PfxImportParameters) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PfxImportParameters) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PfxImportParameters) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PfxImportParameters) },
        { },
    };

    static PyType_Spec type_spec_PfxImportParameters =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.PfxImportParameters",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PfxImportParameters
    };

    // ----- StandardCertificateStoreNames class --------------------
    static constexpr const char* const type_name_StandardCertificateStoreNames = "StandardCertificateStoreNames";

    static PyObject* _new_StandardCertificateStoreNames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StandardCertificateStoreNames);
        return nullptr;
    }

    static PyObject* StandardCertificateStoreNames_get_IntermediateCertificationAuthorities(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.StandardCertificateStoreNames", L"IntermediateCertificationAuthorities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::StandardCertificateStoreNames::IntermediateCertificationAuthorities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StandardCertificateStoreNames_get_Personal(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.StandardCertificateStoreNames", L"Personal"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::StandardCertificateStoreNames::Personal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StandardCertificateStoreNames_get_TrustedRootCertificationAuthorities(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.StandardCertificateStoreNames", L"TrustedRootCertificationAuthorities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::StandardCertificateStoreNames::TrustedRootCertificationAuthorities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StandardCertificateStoreNames[] = {
        { }
    };

    static PyGetSetDef _getset_StandardCertificateStoreNames[] = {
        { }
    };

    static PyType_Slot _type_slots_StandardCertificateStoreNames[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StandardCertificateStoreNames) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StandardCertificateStoreNames) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StandardCertificateStoreNames) },
        { },
    };

    static PyType_Spec type_spec_StandardCertificateStoreNames =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.StandardCertificateStoreNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StandardCertificateStoreNames
    };

    static PyGetSetDef getset_StandardCertificateStoreNames_Meta[] = {
        { "intermediate_certification_authorities", reinterpret_cast<getter>(StandardCertificateStoreNames_get_IntermediateCertificationAuthorities), nullptr, nullptr, nullptr },
        { "personal", reinterpret_cast<getter>(StandardCertificateStoreNames_get_Personal), nullptr, nullptr, nullptr },
        { "trusted_root_certification_authorities", reinterpret_cast<getter>(StandardCertificateStoreNames_get_TrustedRootCertificationAuthorities), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_StandardCertificateStoreNames_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StandardCertificateStoreNames_Meta) },
        { }
    };

    static PyType_Spec type_spec_StandardCertificateStoreNames_Meta =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.StandardCertificateStoreNames_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StandardCertificateStoreNames_Meta
    };

    // ----- SubjectAlternativeNameInfo class --------------------
    static constexpr const char* const type_name_SubjectAlternativeNameInfo = "SubjectAlternativeNameInfo";

    static PyObject* _new_SubjectAlternativeNameInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SubjectAlternativeNameInfo(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SubjectAlternativeNameInfo_get_DistinguishedName(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo", L"DistinguishedName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DistinguishedName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_DnsName(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo", L"DnsName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DnsName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_EmailName(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo", L"EmailName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_IPAddress(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo", L"IPAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IPAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_PrincipalName(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo", L"PrincipalName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PrincipalName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_Url(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo", L"Url"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Url());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_DistinguishedNames(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo", L"DistinguishedNames"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DistinguishedNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_DnsNames(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo", L"DnsNames"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DnsNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_EmailNames(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo", L"EmailNames"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_Extension(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo", L"Extension"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Extension());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_IPAddresses(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo", L"IPAddresses"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IPAddresses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_PrincipalNames(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo", L"PrincipalNames"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PrincipalNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_Urls(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo", L"Urls"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Urls());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SubjectAlternativeNameInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SubjectAlternativeNameInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SubjectAlternativeNameInfo[] = {
        { "_assign_array_", _assign_array_SubjectAlternativeNameInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SubjectAlternativeNameInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SubjectAlternativeNameInfo[] = {
        { "distinguished_name", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_DistinguishedName), nullptr, nullptr, nullptr },
        { "dns_name", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_DnsName), nullptr, nullptr, nullptr },
        { "email_name", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_EmailName), nullptr, nullptr, nullptr },
        { "ip_address", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_IPAddress), nullptr, nullptr, nullptr },
        { "principal_name", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_PrincipalName), nullptr, nullptr, nullptr },
        { "url", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_Url), nullptr, nullptr, nullptr },
        { "distinguished_names", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_DistinguishedNames), nullptr, nullptr, nullptr },
        { "dns_names", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_DnsNames), nullptr, nullptr, nullptr },
        { "email_names", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_EmailNames), nullptr, nullptr, nullptr },
        { "extension", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_Extension), nullptr, nullptr, nullptr },
        { "ip_addresses", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_IPAddresses), nullptr, nullptr, nullptr },
        { "principal_names", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_PrincipalNames), nullptr, nullptr, nullptr },
        { "urls", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_Urls), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SubjectAlternativeNameInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SubjectAlternativeNameInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SubjectAlternativeNameInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SubjectAlternativeNameInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SubjectAlternativeNameInfo) },
        { },
    };

    static PyType_Spec type_spec_SubjectAlternativeNameInfo =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.SubjectAlternativeNameInfo",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SubjectAlternativeNameInfo
    };

    // ----- UserCertificateEnrollmentManager class --------------------
    static constexpr const char* const type_name_UserCertificateEnrollmentManager = "UserCertificateEnrollmentManager";

    static PyObject* _new_UserCertificateEnrollmentManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UserCertificateEnrollmentManager);
        return nullptr;
    }

    static void _dealloc_UserCertificateEnrollmentManager(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UserCertificateEnrollmentManager_CreateRequestAsync(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.UserCertificateEnrollmentManager", L"CreateRequestAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::CertificateRequestProperties>(args, 0);

                return py::convert(self->obj.CreateRequestAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserCertificateEnrollmentManager_ImportPfxDataAsync(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.UserCertificateEnrollmentManager", L"ImportPfxDataAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::PfxImportParameters>(args, 2);

                return py::convert(self->obj.ImportPfxDataAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 6)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.UserCertificateEnrollmentManager", L"ImportPfxDataAsync", 6))
            {
                py::set_arg_count_version_error(6);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ExportOption>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::KeyProtectionLevel>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);

                return py::convert(self->obj.ImportPfxDataAsync(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.UserCertificateEnrollmentManager", L"ImportPfxDataAsync", 7))
            {
                py::set_arg_count_version_error(7);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ExportOption>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::KeyProtectionLevel>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);

                return py::convert(self->obj.ImportPfxDataAsync(param0, param1, param2, param3, param4, param5, param6));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserCertificateEnrollmentManager_InstallCertificateAsync(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.UserCertificateEnrollmentManager", L"InstallCertificateAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(args, 1);

                return py::convert(self->obj.InstallCertificateAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_UserCertificateEnrollmentManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UserCertificateEnrollmentManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserCertificateEnrollmentManager[] = {
        { "create_request_async", reinterpret_cast<PyCFunction>(UserCertificateEnrollmentManager_CreateRequestAsync), METH_VARARGS, nullptr },
        { "import_pfx_data_async", reinterpret_cast<PyCFunction>(UserCertificateEnrollmentManager_ImportPfxDataAsync), METH_VARARGS, nullptr },
        { "install_certificate_async", reinterpret_cast<PyCFunction>(UserCertificateEnrollmentManager_InstallCertificateAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_UserCertificateEnrollmentManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserCertificateEnrollmentManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserCertificateEnrollmentManager[] = {
        { }
    };

    static PyType_Slot _type_slots_UserCertificateEnrollmentManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserCertificateEnrollmentManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UserCertificateEnrollmentManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserCertificateEnrollmentManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserCertificateEnrollmentManager) },
        { },
    };

    static PyType_Spec type_spec_UserCertificateEnrollmentManager =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.UserCertificateEnrollmentManager",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserCertificateEnrollmentManager
    };

    // ----- UserCertificateStore class --------------------
    static constexpr const char* const type_name_UserCertificateStore = "UserCertificateStore";

    static PyObject* _new_UserCertificateStore(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UserCertificateStore);
        return nullptr;
    }

    static void _dealloc_UserCertificateStore(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateStore* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UserCertificateStore_RequestAddAsync(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.UserCertificateStore", L"RequestAddAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 0);

                return py::convert(self->obj.RequestAddAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserCertificateStore_RequestDeleteAsync(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.UserCertificateStore", L"RequestDeleteAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 0);

                return py::convert(self->obj.RequestDeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserCertificateStore_get_Name(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateStore* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.UserCertificateStore", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UserCertificateStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::UserCertificateStore>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UserCertificateStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::UserCertificateStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserCertificateStore[] = {
        { "request_add_async", reinterpret_cast<PyCFunction>(UserCertificateStore_RequestAddAsync), METH_VARARGS, nullptr },
        { "request_delete_async", reinterpret_cast<PyCFunction>(UserCertificateStore_RequestDeleteAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_UserCertificateStore, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserCertificateStore), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserCertificateStore[] = {
        { "name", reinterpret_cast<getter>(UserCertificateStore_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UserCertificateStore[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserCertificateStore) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UserCertificateStore) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserCertificateStore) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserCertificateStore) },
        { },
    };

    static PyType_Spec type_spec_UserCertificateStore =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.UserCertificateStore",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserCertificateStore
    };

    // ----- Windows.Security.Cryptography.Certificates Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Security::Cryptography::Certificates");

    static PyMethodDef module_methods[] = {
        {"_register_CertificateChainPolicy", register_CertificateChainPolicy, METH_O, "registers type"},
        {"_register_ChainValidationResult", register_ChainValidationResult, METH_O, "registers type"},
        {"_register_EnrollKeyUsages", register_EnrollKeyUsages, METH_O, "registers type"},
        {"_register_ExportOption", register_ExportOption, METH_O, "registers type"},
        {"_register_InstallOptions", register_InstallOptions, METH_O, "registers type"},
        {"_register_KeyProtectionLevel", register_KeyProtectionLevel, METH_O, "registers type"},
        {"_register_KeySize", register_KeySize, METH_O, "registers type"},
        {"_register_SignatureValidationResult", register_SignatureValidationResult, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_CertificateChainPolicy);
        Py_VISIT(state->type_ChainValidationResult);
        Py_VISIT(state->type_EnrollKeyUsages);
        Py_VISIT(state->type_ExportOption);
        Py_VISIT(state->type_InstallOptions);
        Py_VISIT(state->type_KeyProtectionLevel);
        Py_VISIT(state->type_KeySize);
        Py_VISIT(state->type_SignatureValidationResult);
        Py_VISIT(state->type_Certificate);
        Py_VISIT(state->type_CertificateChain);
        Py_VISIT(state->type_CertificateEnrollmentManager);
        Py_VISIT(state->type_CertificateExtension);
        Py_VISIT(state->type_CertificateKeyUsages);
        Py_VISIT(state->type_CertificateQuery);
        Py_VISIT(state->type_CertificateRequestProperties);
        Py_VISIT(state->type_CertificateStore);
        Py_VISIT(state->type_CertificateStores);
        Py_VISIT(state->type_ChainBuildingParameters);
        Py_VISIT(state->type_ChainValidationParameters);
        Py_VISIT(state->type_CmsAttachedSignature);
        Py_VISIT(state->type_CmsDetachedSignature);
        Py_VISIT(state->type_CmsSignerInfo);
        Py_VISIT(state->type_CmsTimestampInfo);
        Py_VISIT(state->type_KeyAlgorithmNames);
        Py_VISIT(state->type_KeyAttestationHelper);
        Py_VISIT(state->type_KeyStorageProviderNames);
        Py_VISIT(state->type_PfxImportParameters);
        Py_VISIT(state->type_StandardCertificateStoreNames);
        Py_VISIT(state->type_SubjectAlternativeNameInfo);
        Py_VISIT(state->type_UserCertificateEnrollmentManager);
        Py_VISIT(state->type_UserCertificateStore);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_CertificateChainPolicy);
        Py_CLEAR(state->type_ChainValidationResult);
        Py_CLEAR(state->type_EnrollKeyUsages);
        Py_CLEAR(state->type_ExportOption);
        Py_CLEAR(state->type_InstallOptions);
        Py_CLEAR(state->type_KeyProtectionLevel);
        Py_CLEAR(state->type_KeySize);
        Py_CLEAR(state->type_SignatureValidationResult);
        Py_CLEAR(state->type_Certificate);
        Py_CLEAR(state->type_CertificateChain);
        Py_CLEAR(state->type_CertificateEnrollmentManager);
        Py_CLEAR(state->type_CertificateExtension);
        Py_CLEAR(state->type_CertificateKeyUsages);
        Py_CLEAR(state->type_CertificateQuery);
        Py_CLEAR(state->type_CertificateRequestProperties);
        Py_CLEAR(state->type_CertificateStore);
        Py_CLEAR(state->type_CertificateStores);
        Py_CLEAR(state->type_ChainBuildingParameters);
        Py_CLEAR(state->type_ChainValidationParameters);
        Py_CLEAR(state->type_CmsAttachedSignature);
        Py_CLEAR(state->type_CmsDetachedSignature);
        Py_CLEAR(state->type_CmsSignerInfo);
        Py_CLEAR(state->type_CmsTimestampInfo);
        Py_CLEAR(state->type_KeyAlgorithmNames);
        Py_CLEAR(state->type_KeyAttestationHelper);
        Py_CLEAR(state->type_KeyStorageProviderNames);
        Py_CLEAR(state->type_PfxImportParameters);
        Py_CLEAR(state->type_StandardCertificateStoreNames);
        Py_CLEAR(state->type_SubjectAlternativeNameInfo);
        Py_CLEAR(state->type_UserCertificateEnrollmentManager);
        Py_CLEAR(state->type_UserCertificateStore);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Security_Cryptography_Certificates",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Security::Cryptography::Certificates

PyMODINIT_FUNC PyInit__winsdk_Windows_Security_Cryptography_Certificates(void) noexcept
{
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_Certificate = py::register_python_type(module.get(), type_name_Certificate, &type_spec_Certificate, bases.get(), nullptr);
    if (!state->type_Certificate)
    {
        return nullptr;
    }

    state->type_CertificateChain = py::register_python_type(module.get(), type_name_CertificateChain, &type_spec_CertificateChain, bases.get(), nullptr);
    if (!state->type_CertificateChain)
    {
        return nullptr;
    }

    py::pyobj_handle type_CertificateEnrollmentManager_Meta{PyType_FromSpec(&type_spec_CertificateEnrollmentManager_Meta)};
    if (!type_CertificateEnrollmentManager_Meta)
    {
        return nullptr;
    }

    state->type_CertificateEnrollmentManager = py::register_python_type(module.get(), type_name_CertificateEnrollmentManager, &type_spec_CertificateEnrollmentManager, nullptr, reinterpret_cast<PyTypeObject*>(type_CertificateEnrollmentManager_Meta.get()));
    if (!state->type_CertificateEnrollmentManager)
    {
        return nullptr;
    }

    state->type_CertificateExtension = py::register_python_type(module.get(), type_name_CertificateExtension, &type_spec_CertificateExtension, bases.get(), nullptr);
    if (!state->type_CertificateExtension)
    {
        return nullptr;
    }

    state->type_CertificateKeyUsages = py::register_python_type(module.get(), type_name_CertificateKeyUsages, &type_spec_CertificateKeyUsages, bases.get(), nullptr);
    if (!state->type_CertificateKeyUsages)
    {
        return nullptr;
    }

    state->type_CertificateQuery = py::register_python_type(module.get(), type_name_CertificateQuery, &type_spec_CertificateQuery, bases.get(), nullptr);
    if (!state->type_CertificateQuery)
    {
        return nullptr;
    }

    state->type_CertificateRequestProperties = py::register_python_type(module.get(), type_name_CertificateRequestProperties, &type_spec_CertificateRequestProperties, bases.get(), nullptr);
    if (!state->type_CertificateRequestProperties)
    {
        return nullptr;
    }

    state->type_CertificateStore = py::register_python_type(module.get(), type_name_CertificateStore, &type_spec_CertificateStore, bases.get(), nullptr);
    if (!state->type_CertificateStore)
    {
        return nullptr;
    }

    py::pyobj_handle type_CertificateStores_Meta{PyType_FromSpec(&type_spec_CertificateStores_Meta)};
    if (!type_CertificateStores_Meta)
    {
        return nullptr;
    }

    state->type_CertificateStores = py::register_python_type(module.get(), type_name_CertificateStores, &type_spec_CertificateStores, nullptr, reinterpret_cast<PyTypeObject*>(type_CertificateStores_Meta.get()));
    if (!state->type_CertificateStores)
    {
        return nullptr;
    }

    state->type_ChainBuildingParameters = py::register_python_type(module.get(), type_name_ChainBuildingParameters, &type_spec_ChainBuildingParameters, bases.get(), nullptr);
    if (!state->type_ChainBuildingParameters)
    {
        return nullptr;
    }

    state->type_ChainValidationParameters = py::register_python_type(module.get(), type_name_ChainValidationParameters, &type_spec_ChainValidationParameters, bases.get(), nullptr);
    if (!state->type_ChainValidationParameters)
    {
        return nullptr;
    }

    state->type_CmsAttachedSignature = py::register_python_type(module.get(), type_name_CmsAttachedSignature, &type_spec_CmsAttachedSignature, bases.get(), nullptr);
    if (!state->type_CmsAttachedSignature)
    {
        return nullptr;
    }

    state->type_CmsDetachedSignature = py::register_python_type(module.get(), type_name_CmsDetachedSignature, &type_spec_CmsDetachedSignature, bases.get(), nullptr);
    if (!state->type_CmsDetachedSignature)
    {
        return nullptr;
    }

    state->type_CmsSignerInfo = py::register_python_type(module.get(), type_name_CmsSignerInfo, &type_spec_CmsSignerInfo, bases.get(), nullptr);
    if (!state->type_CmsSignerInfo)
    {
        return nullptr;
    }

    state->type_CmsTimestampInfo = py::register_python_type(module.get(), type_name_CmsTimestampInfo, &type_spec_CmsTimestampInfo, bases.get(), nullptr);
    if (!state->type_CmsTimestampInfo)
    {
        return nullptr;
    }

    py::pyobj_handle type_KeyAlgorithmNames_Meta{PyType_FromSpec(&type_spec_KeyAlgorithmNames_Meta)};
    if (!type_KeyAlgorithmNames_Meta)
    {
        return nullptr;
    }

    state->type_KeyAlgorithmNames = py::register_python_type(module.get(), type_name_KeyAlgorithmNames, &type_spec_KeyAlgorithmNames, nullptr, reinterpret_cast<PyTypeObject*>(type_KeyAlgorithmNames_Meta.get()));
    if (!state->type_KeyAlgorithmNames)
    {
        return nullptr;
    }

    state->type_KeyAttestationHelper = py::register_python_type(module.get(), type_name_KeyAttestationHelper, &type_spec_KeyAttestationHelper, nullptr, nullptr);
    if (!state->type_KeyAttestationHelper)
    {
        return nullptr;
    }

    py::pyobj_handle type_KeyStorageProviderNames_Meta{PyType_FromSpec(&type_spec_KeyStorageProviderNames_Meta)};
    if (!type_KeyStorageProviderNames_Meta)
    {
        return nullptr;
    }

    state->type_KeyStorageProviderNames = py::register_python_type(module.get(), type_name_KeyStorageProviderNames, &type_spec_KeyStorageProviderNames, nullptr, reinterpret_cast<PyTypeObject*>(type_KeyStorageProviderNames_Meta.get()));
    if (!state->type_KeyStorageProviderNames)
    {
        return nullptr;
    }

    state->type_PfxImportParameters = py::register_python_type(module.get(), type_name_PfxImportParameters, &type_spec_PfxImportParameters, bases.get(), nullptr);
    if (!state->type_PfxImportParameters)
    {
        return nullptr;
    }

    py::pyobj_handle type_StandardCertificateStoreNames_Meta{PyType_FromSpec(&type_spec_StandardCertificateStoreNames_Meta)};
    if (!type_StandardCertificateStoreNames_Meta)
    {
        return nullptr;
    }

    state->type_StandardCertificateStoreNames = py::register_python_type(module.get(), type_name_StandardCertificateStoreNames, &type_spec_StandardCertificateStoreNames, nullptr, reinterpret_cast<PyTypeObject*>(type_StandardCertificateStoreNames_Meta.get()));
    if (!state->type_StandardCertificateStoreNames)
    {
        return nullptr;
    }

    state->type_SubjectAlternativeNameInfo = py::register_python_type(module.get(), type_name_SubjectAlternativeNameInfo, &type_spec_SubjectAlternativeNameInfo, bases.get(), nullptr);
    if (!state->type_SubjectAlternativeNameInfo)
    {
        return nullptr;
    }

    state->type_UserCertificateEnrollmentManager = py::register_python_type(module.get(), type_name_UserCertificateEnrollmentManager, &type_spec_UserCertificateEnrollmentManager, bases.get(), nullptr);
    if (!state->type_UserCertificateEnrollmentManager)
    {
        return nullptr;
    }

    state->type_UserCertificateStore = py::register_python_type(module.get(), type_name_UserCertificateStore, &type_spec_UserCertificateStore, bases.get(), nullptr);
    if (!state->type_UserCertificateStore)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Security::Cryptography::Certificates::CertificateChainPolicy>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CertificateChainPolicy;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::CertificateChainPolicy is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Cryptography::Certificates::ChainValidationResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ChainValidationResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::ChainValidationResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Cryptography::Certificates::EnrollKeyUsages>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EnrollKeyUsages;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::EnrollKeyUsages is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Cryptography::Certificates::ExportOption>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ExportOption;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::ExportOption is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_InstallOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::InstallOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Cryptography::Certificates::KeyProtectionLevel>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KeyProtectionLevel;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::KeyProtectionLevel is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Cryptography::Certificates::KeySize>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KeySize;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::KeySize is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Cryptography::Certificates::SignatureValidationResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SignatureValidationResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::SignatureValidationResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::Certificate>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Certificate;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::Certificate is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateChain>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CertificateChain;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::CertificateChain is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CertificateEnrollmentManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateExtension>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CertificateExtension;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::CertificateExtension is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateKeyUsages>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CertificateKeyUsages;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::CertificateKeyUsages is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateQuery>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CertificateQuery;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::CertificateQuery is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateRequestProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CertificateRequestProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::CertificateRequestProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateStore>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CertificateStore;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::CertificateStore is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateStores>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CertificateStores;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::CertificateStores is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::ChainBuildingParameters>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ChainBuildingParameters;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::ChainBuildingParameters is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::ChainValidationParameters>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ChainValidationParameters;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::ChainValidationParameters is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CmsAttachedSignature>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CmsAttachedSignature;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::CmsAttachedSignature is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CmsDetachedSignature>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CmsDetachedSignature;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::CmsDetachedSignature is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CmsSignerInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CmsSignerInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::CmsSignerInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CmsTimestampInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CmsTimestampInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::CmsTimestampInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KeyAlgorithmNames;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::KeyAttestationHelper>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KeyAttestationHelper;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::KeyAttestationHelper is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::KeyStorageProviderNames>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KeyStorageProviderNames;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::KeyStorageProviderNames is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::PfxImportParameters>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PfxImportParameters;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::PfxImportParameters is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::StandardCertificateStoreNames>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StandardCertificateStoreNames;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::StandardCertificateStoreNames is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SubjectAlternativeNameInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UserCertificateEnrollmentManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::UserCertificateStore>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Certificates");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UserCertificateStore;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Certificates::UserCertificateStore is not registered");
        return nullptr;
    }

    return python_type;
}
