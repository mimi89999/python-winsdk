// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.Foundation.h"


static int64_t custom_get(winrt::event_token const& instance)
{
    return instance.value;
}

static void custom_set(winrt::event_token& instance, int64_t value)
{
    instance.value = value;
}

static int32_t custom_get(winrt::hresult const& instance)
{
    return instance;
}

static void custom_set(winrt::hresult& instance, int32_t value)
{
    instance = value;
}

PyObject* py::converter<winrt::event_token>::convert(winrt::event_token instance) noexcept
{
    auto type = py::get_python_type<winrt::event_token>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::event_token py::converter<winrt::event_token>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::event_token>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::event_token>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::event_token");
    throw python_exception();
}

PyObject* py::converter<winrt::hresult>::convert(winrt::hresult instance) noexcept
{
    auto type = py::get_python_type<winrt::hresult>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::hresult py::converter<winrt::hresult>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::hresult>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::hresult>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::hresult");
    throw python_exception();
}

PyObject* py::converter<winrt::Windows::Foundation::Point>::convert(winrt::Windows::Foundation::Point instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Foundation::Point>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Foundation::Point py::converter<winrt::Windows::Foundation::Point>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Foundation::Point>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Point>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Foundation::Point");
    throw python_exception();
}

PyObject* py::converter<winrt::Windows::Foundation::Rect>::convert(winrt::Windows::Foundation::Rect instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Foundation::Rect>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Foundation::Rect py::converter<winrt::Windows::Foundation::Rect>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Foundation::Rect>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Rect>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Foundation::Rect");
    throw python_exception();
}

PyObject* py::converter<winrt::Windows::Foundation::Size>::convert(winrt::Windows::Foundation::Size instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Foundation::Size>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Foundation::Size py::converter<winrt::Windows::Foundation::Size>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Foundation::Size>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Size>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Foundation::Size");
    throw python_exception();
}

namespace py::cpp::Windows::Foundation
{
    struct module_state
    {
        PyObject* type_AsyncStatus;
        PyObject* type_PropertyType;
        PyTypeObject* type_Deferral;
        PyTypeObject* type_GuidHelper;
        PyTypeObject* type_MemoryBuffer;
        PyTypeObject* type_PropertyValue;
        PyTypeObject* type_Uri;
        PyTypeObject* type_WwwFormUrlDecoder;
        PyTypeObject* type_WwwFormUrlDecoderEntry;
        PyTypeObject* type_IAsyncAction;
        PyTypeObject* type_IAsyncActionWithProgress;
        PyTypeObject* type_IAsyncInfo;
        PyTypeObject* type_IAsyncOperationWithProgress;
        PyTypeObject* type_IAsyncOperation;
        PyTypeObject* type_IClosable;
        PyTypeObject* type_IGetActivationFactory;
        PyTypeObject* type_IMemoryBuffer;
        PyTypeObject* type_IMemoryBufferReference;
        PyTypeObject* type_IPropertyValue;
        PyTypeObject* type_IReferenceArray;
        PyTypeObject* type_IReference;
        PyTypeObject* type_IStringable;
        PyTypeObject* type_IWwwFormUrlDecoderEntry;
        PyTypeObject* type_EventRegistrationToken;
        PyTypeObject* type_HResult;
        PyTypeObject* type_Point;
        PyTypeObject* type_Rect;
        PyTypeObject* type_Size;
    };

    static PyObject* register_AsyncStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AsyncStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AsyncStatus = type;
        Py_INCREF(state->type_AsyncStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_PropertyType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PropertyType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PropertyType = type;
        Py_INCREF(state->type_PropertyType);


        Py_RETURN_NONE;
    }

    // ----- Deferral class --------------------
    static constexpr const char* const type_name_Deferral = "Deferral";

    static PyObject* _new_Deferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DeferralCompletedHandler>(args, 0);

                winrt::Windows::Foundation::Deferral instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Deferral(py::wrapper::Windows::Foundation::Deferral* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Deferral_Close(py::wrapper::Windows::Foundation::Deferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Deferral", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Deferral_Complete(py::wrapper::Windows::Foundation::Deferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Deferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_Deferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Deferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Deferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Deferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_Deferral(py::wrapper::Windows::Foundation::Deferral* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_Deferral(py::wrapper::Windows::Foundation::Deferral* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Deferral[] = {
        { "close", reinterpret_cast<PyCFunction>(Deferral_Close), METH_VARARGS, nullptr },
        { "complete", reinterpret_cast<PyCFunction>(Deferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Deferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Deferral), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_Deferral), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_Deferral), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_Deferral[] = {
        { }
    };

    static PyType_Slot _type_slots_Deferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Deferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Deferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Deferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Deferral) },
        { },
    };

    static PyType_Spec type_spec_Deferral =
    {
        "_winsdk_Windows_Foundation.Deferral",
        sizeof(py::wrapper::Windows::Foundation::Deferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Deferral
    };

    // ----- GuidHelper class --------------------
    static constexpr const char* const type_name_GuidHelper = "GuidHelper";

    static PyObject* _new_GuidHelper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_GuidHelper);
        return nullptr;
    }

    static PyObject* GuidHelper_CreateNewGuid(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.GuidHelper", L"CreateNewGuid", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Foundation::GuidHelper::CreateNewGuid());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GuidHelper_Equals(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.GuidHelper", L"Equals", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);

                return py::convert(winrt::Windows::Foundation::GuidHelper::Equals(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GuidHelper_get_Empty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.GuidHelper", L"Empty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Foundation::GuidHelper::Empty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GuidHelper[] = {
        { "create_new_guid", reinterpret_cast<PyCFunction>(GuidHelper_CreateNewGuid), METH_VARARGS | METH_STATIC, nullptr },
        { "equals", reinterpret_cast<PyCFunction>(GuidHelper_Equals), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GuidHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_GuidHelper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GuidHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GuidHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GuidHelper) },
        { },
    };

    static PyType_Spec type_spec_GuidHelper =
    {
        "_winsdk_Windows_Foundation.GuidHelper",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GuidHelper
    };

    static PyGetSetDef getset_GuidHelper_Meta[] = {
        { "empty", reinterpret_cast<getter>(GuidHelper_get_Empty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_GuidHelper_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GuidHelper_Meta) },
        { }
    };

    static PyType_Spec type_spec_GuidHelper_Meta =
    {
        "_winsdk_Windows_Foundation.GuidHelper_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GuidHelper_Meta
    };

    // ----- MemoryBuffer class --------------------
    static constexpr const char* const type_name_MemoryBuffer = "MemoryBuffer";

    static PyObject* _new_MemoryBuffer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::Foundation::MemoryBuffer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MemoryBuffer(py::wrapper::Windows::Foundation::MemoryBuffer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MemoryBuffer_Close(py::wrapper::Windows::Foundation::MemoryBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.MemoryBuffer", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MemoryBuffer_CreateReference(py::wrapper::Windows::Foundation::MemoryBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.MemoryBuffer", L"CreateReference", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MemoryBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::MemoryBuffer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MemoryBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::MemoryBuffer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MemoryBuffer(py::wrapper::Windows::Foundation::MemoryBuffer* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_MemoryBuffer(py::wrapper::Windows::Foundation::MemoryBuffer* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MemoryBuffer[] = {
        { "close", reinterpret_cast<PyCFunction>(MemoryBuffer_Close), METH_VARARGS, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(MemoryBuffer_CreateReference), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MemoryBuffer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MemoryBuffer), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MemoryBuffer), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MemoryBuffer), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MemoryBuffer[] = {
        { }
    };

    static PyType_Slot _type_slots_MemoryBuffer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MemoryBuffer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MemoryBuffer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MemoryBuffer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MemoryBuffer) },
        { },
    };

    static PyType_Spec type_spec_MemoryBuffer =
    {
        "_winsdk_Windows_Foundation.MemoryBuffer",
        sizeof(py::wrapper::Windows::Foundation::MemoryBuffer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MemoryBuffer
    };

    // ----- PropertyValue class --------------------
    static constexpr const char* const type_name_PropertyValue = "PropertyValue";

    static PyObject* _new_PropertyValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PropertyValue);
        return nullptr;
    }

    static PyObject* PropertyValue_CreateBoolean(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateBoolean", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateBoolean(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateBooleanArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateBooleanArray", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<bool, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateBooleanArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateChar16(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateChar16", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<char16_t>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateChar16(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateChar16Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateChar16Array", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<char16_t, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateChar16Array(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateDateTime(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateDateTime", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateDateTime(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateDateTimeArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateDateTimeArray", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::DateTime, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateDateTimeArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateDouble(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateDouble", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateDouble(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateDoubleArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateDoubleArray", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<double, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateDoubleArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateEmpty(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateEmpty", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateEmpty());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateGuid(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateGuid", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateGuid(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateGuidArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateGuidArray", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::guid, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateGuidArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInspectable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateInspectable", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateInspectable(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInspectableArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateInspectableArray", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::IInspectable, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateInspectableArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInt16(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateInt16", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int16_t>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateInt16(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInt16Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateInt16Array", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int16_t, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateInt16Array(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInt32(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateInt32", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateInt32(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInt32Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateInt32Array", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int32_t, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateInt32Array(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInt64(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateInt64", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int64_t>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateInt64(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInt64Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateInt64Array", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateInt64Array(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreatePoint(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreatePoint", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreatePoint(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreatePointArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreatePointArray", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreatePointArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateRect(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateRect", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateRect(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateRectArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateRectArray", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Rect, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateRectArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateSingle(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateSingle", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<float>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateSingle(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateSingleArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateSingleArray", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<float, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateSingleArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateSize(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateSize", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateSize(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateSizeArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateSizeArray", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Size, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateSizeArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateString(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateString", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateStringArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateStringArray", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::hstring, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateStringArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateTimeSpan(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateTimeSpan", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateTimeSpan(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateTimeSpanArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateTimeSpanArray", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::TimeSpan, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateTimeSpanArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt16(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateUInt16", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateUInt16(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt16Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateUInt16Array", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint16_t, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateUInt16Array(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt32(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateUInt32", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateUInt32(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt32Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateUInt32Array", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint32_t, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateUInt32Array(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt64(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateUInt64", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateUInt64(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt64Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateUInt64Array", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint64_t, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateUInt64Array(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt8(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateUInt8", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateUInt8(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt8Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateUInt8Array", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateUInt8Array(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PropertyValue[] = {
        { "create_boolean", reinterpret_cast<PyCFunction>(PropertyValue_CreateBoolean), METH_VARARGS | METH_STATIC, nullptr },
        { "create_boolean_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateBooleanArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_char16", reinterpret_cast<PyCFunction>(PropertyValue_CreateChar16), METH_VARARGS | METH_STATIC, nullptr },
        { "create_char16_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateChar16Array), METH_VARARGS | METH_STATIC, nullptr },
        { "create_date_time", reinterpret_cast<PyCFunction>(PropertyValue_CreateDateTime), METH_VARARGS | METH_STATIC, nullptr },
        { "create_date_time_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateDateTimeArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_double", reinterpret_cast<PyCFunction>(PropertyValue_CreateDouble), METH_VARARGS | METH_STATIC, nullptr },
        { "create_double_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateDoubleArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_empty", reinterpret_cast<PyCFunction>(PropertyValue_CreateEmpty), METH_VARARGS | METH_STATIC, nullptr },
        { "create_guid", reinterpret_cast<PyCFunction>(PropertyValue_CreateGuid), METH_VARARGS | METH_STATIC, nullptr },
        { "create_guid_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateGuidArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_inspectable", reinterpret_cast<PyCFunction>(PropertyValue_CreateInspectable), METH_VARARGS | METH_STATIC, nullptr },
        { "create_inspectable_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateInspectableArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_int16", reinterpret_cast<PyCFunction>(PropertyValue_CreateInt16), METH_VARARGS | METH_STATIC, nullptr },
        { "create_int16_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateInt16Array), METH_VARARGS | METH_STATIC, nullptr },
        { "create_int32", reinterpret_cast<PyCFunction>(PropertyValue_CreateInt32), METH_VARARGS | METH_STATIC, nullptr },
        { "create_int32_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateInt32Array), METH_VARARGS | METH_STATIC, nullptr },
        { "create_int64", reinterpret_cast<PyCFunction>(PropertyValue_CreateInt64), METH_VARARGS | METH_STATIC, nullptr },
        { "create_int64_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateInt64Array), METH_VARARGS | METH_STATIC, nullptr },
        { "create_point", reinterpret_cast<PyCFunction>(PropertyValue_CreatePoint), METH_VARARGS | METH_STATIC, nullptr },
        { "create_point_array", reinterpret_cast<PyCFunction>(PropertyValue_CreatePointArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_rect", reinterpret_cast<PyCFunction>(PropertyValue_CreateRect), METH_VARARGS | METH_STATIC, nullptr },
        { "create_rect_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateRectArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_single", reinterpret_cast<PyCFunction>(PropertyValue_CreateSingle), METH_VARARGS | METH_STATIC, nullptr },
        { "create_single_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateSingleArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_size", reinterpret_cast<PyCFunction>(PropertyValue_CreateSize), METH_VARARGS | METH_STATIC, nullptr },
        { "create_size_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateSizeArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_string", reinterpret_cast<PyCFunction>(PropertyValue_CreateString), METH_VARARGS | METH_STATIC, nullptr },
        { "create_string_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateStringArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_time_span", reinterpret_cast<PyCFunction>(PropertyValue_CreateTimeSpan), METH_VARARGS | METH_STATIC, nullptr },
        { "create_time_span_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateTimeSpanArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_uint16", reinterpret_cast<PyCFunction>(PropertyValue_CreateUInt16), METH_VARARGS | METH_STATIC, nullptr },
        { "create_uint16_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateUInt16Array), METH_VARARGS | METH_STATIC, nullptr },
        { "create_uint32", reinterpret_cast<PyCFunction>(PropertyValue_CreateUInt32), METH_VARARGS | METH_STATIC, nullptr },
        { "create_uint32_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateUInt32Array), METH_VARARGS | METH_STATIC, nullptr },
        { "create_uint64", reinterpret_cast<PyCFunction>(PropertyValue_CreateUInt64), METH_VARARGS | METH_STATIC, nullptr },
        { "create_uint64_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateUInt64Array), METH_VARARGS | METH_STATIC, nullptr },
        { "create_uint8", reinterpret_cast<PyCFunction>(PropertyValue_CreateUInt8), METH_VARARGS | METH_STATIC, nullptr },
        { "create_uint8_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateUInt8Array), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PropertyValue[] = {
        { }
    };

    static PyType_Slot _type_slots_PropertyValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PropertyValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PropertyValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PropertyValue) },
        { },
    };

    static PyType_Spec type_spec_PropertyValue =
    {
        "_winsdk_Windows_Foundation.PropertyValue",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PropertyValue
    };

    // ----- Uri class --------------------
    static constexpr const char* const type_name_Uri = "Uri";

    static PyObject* _new_Uri(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Foundation::Uri instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Foundation::Uri instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Uri(py::wrapper::Windows::Foundation::Uri* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Uri_CombineUri(py::wrapper::Windows::Foundation::Uri* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Uri", L"CombineUri", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CombineUri(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Uri_Equals(py::wrapper::Windows::Foundation::Uri* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Uri", L"Equals", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.Equals(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Uri_EscapeComponent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Uri", L"EscapeComponent", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Foundation::Uri::EscapeComponent(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Uri_ToString(py::wrapper::Windows::Foundation::Uri* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Uri", L"ToString", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Uri_UnescapeComponent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Uri", L"UnescapeComponent", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Foundation::Uri::UnescapeComponent(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Uri_get_AbsoluteUri(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"AbsoluteUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AbsoluteUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_DisplayUri(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"DisplayUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Domain(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"Domain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Domain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Extension(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"Extension"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Extension());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Fragment(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"Fragment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Fragment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Host(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"Host"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Host());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Password(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"Password"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Password());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Path(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"Path"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Port(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"Port"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Port());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Query(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"Query"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Query());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_QueryParsed(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"QueryParsed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QueryParsed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_RawUri(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"RawUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_SchemeName(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"SchemeName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SchemeName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Suspicious(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"Suspicious"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Suspicious());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_UserName(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"UserName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UserName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_AbsoluteCanonicalUri(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"AbsoluteCanonicalUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AbsoluteCanonicalUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_DisplayIri(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"DisplayIri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayIri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Uri(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Uri>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Uri(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Uri>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_Uri(py::wrapper::Windows::Foundation::Uri* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Uri[] = {
        { "combine_uri", reinterpret_cast<PyCFunction>(Uri_CombineUri), METH_VARARGS, nullptr },
        { "equals", reinterpret_cast<PyCFunction>(Uri_Equals), METH_VARARGS, nullptr },
        { "escape_component", reinterpret_cast<PyCFunction>(Uri_EscapeComponent), METH_VARARGS | METH_STATIC, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(Uri_ToString), METH_VARARGS, nullptr },
        { "unescape_component", reinterpret_cast<PyCFunction>(Uri_UnescapeComponent), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_Uri, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Uri), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Uri[] = {
        { "absolute_uri", reinterpret_cast<getter>(Uri_get_AbsoluteUri), nullptr, nullptr, nullptr },
        { "display_uri", reinterpret_cast<getter>(Uri_get_DisplayUri), nullptr, nullptr, nullptr },
        { "domain", reinterpret_cast<getter>(Uri_get_Domain), nullptr, nullptr, nullptr },
        { "extension", reinterpret_cast<getter>(Uri_get_Extension), nullptr, nullptr, nullptr },
        { "fragment", reinterpret_cast<getter>(Uri_get_Fragment), nullptr, nullptr, nullptr },
        { "host", reinterpret_cast<getter>(Uri_get_Host), nullptr, nullptr, nullptr },
        { "password", reinterpret_cast<getter>(Uri_get_Password), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(Uri_get_Path), nullptr, nullptr, nullptr },
        { "port", reinterpret_cast<getter>(Uri_get_Port), nullptr, nullptr, nullptr },
        { "query", reinterpret_cast<getter>(Uri_get_Query), nullptr, nullptr, nullptr },
        { "query_parsed", reinterpret_cast<getter>(Uri_get_QueryParsed), nullptr, nullptr, nullptr },
        { "raw_uri", reinterpret_cast<getter>(Uri_get_RawUri), nullptr, nullptr, nullptr },
        { "scheme_name", reinterpret_cast<getter>(Uri_get_SchemeName), nullptr, nullptr, nullptr },
        { "suspicious", reinterpret_cast<getter>(Uri_get_Suspicious), nullptr, nullptr, nullptr },
        { "user_name", reinterpret_cast<getter>(Uri_get_UserName), nullptr, nullptr, nullptr },
        { "absolute_canonical_uri", reinterpret_cast<getter>(Uri_get_AbsoluteCanonicalUri), nullptr, nullptr, nullptr },
        { "display_iri", reinterpret_cast<getter>(Uri_get_DisplayIri), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Uri[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Uri) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Uri) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Uri) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Uri) },
        { Py_tp_str, reinterpret_cast<void*>(_str_Uri) },
        { },
    };

    static PyType_Spec type_spec_Uri =
    {
        "_winsdk_Windows_Foundation.Uri",
        sizeof(py::wrapper::Windows::Foundation::Uri),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Uri
    };

    // ----- WwwFormUrlDecoder class --------------------
    static constexpr const char* const type_name_WwwFormUrlDecoder = "WwwFormUrlDecoder";

    static PyObject* _new_WwwFormUrlDecoder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Foundation::WwwFormUrlDecoder instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WwwFormUrlDecoder(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WwwFormUrlDecoder_First(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.WwwFormUrlDecoder", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwwFormUrlDecoder_GetAt(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.WwwFormUrlDecoder", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwwFormUrlDecoder_GetFirstValueByName(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.WwwFormUrlDecoder", L"GetFirstValueByName", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetFirstValueByName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwwFormUrlDecoder_GetMany(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.WwwFormUrlDecoder", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwwFormUrlDecoder_IndexOf(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.WwwFormUrlDecoder", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwwFormUrlDecoder_get_Size(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.WwwFormUrlDecoder", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WwwFormUrlDecoder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::WwwFormUrlDecoder>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WwwFormUrlDecoder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::WwwFormUrlDecoder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_WwwFormUrlDecoder(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_WwwFormUrlDecoder(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_WwwFormUrlDecoder(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_WwwFormUrlDecoder(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_WwwFormUrlDecoder(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry> items(length, empty_instance<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>::get());

            auto count = self->obj.GetMany(start, items);

            if (count != length)
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WwwFormUrlDecoder_get_insert(PyObject* self) noexcept
    {
        return PyObject_GetAttrString(self, "insert_at");
    }

    static PyMethodDef _methods_WwwFormUrlDecoder[] = {
        { "first", reinterpret_cast<PyCFunction>(WwwFormUrlDecoder_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(WwwFormUrlDecoder_GetAt), METH_VARARGS, nullptr },
        { "get_first_value_by_name", reinterpret_cast<PyCFunction>(WwwFormUrlDecoder_GetFirstValueByName), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(WwwFormUrlDecoder_GetMany), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(WwwFormUrlDecoder_IndexOf), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WwwFormUrlDecoder, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WwwFormUrlDecoder), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WwwFormUrlDecoder[] = {
        { "size", reinterpret_cast<getter>(WwwFormUrlDecoder_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WwwFormUrlDecoder[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WwwFormUrlDecoder) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WwwFormUrlDecoder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WwwFormUrlDecoder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WwwFormUrlDecoder) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_WwwFormUrlDecoder) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_WwwFormUrlDecoder) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_WwwFormUrlDecoder) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_WwwFormUrlDecoder) },
        { },
    };

    static PyType_Spec type_spec_WwwFormUrlDecoder =
    {
        "_winsdk_Windows_Foundation.WwwFormUrlDecoder",
        sizeof(py::wrapper::Windows::Foundation::WwwFormUrlDecoder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WwwFormUrlDecoder
    };

    // ----- WwwFormUrlDecoderEntry class --------------------
    static constexpr const char* const type_name_WwwFormUrlDecoderEntry = "WwwFormUrlDecoderEntry";

    static PyObject* _new_WwwFormUrlDecoderEntry(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WwwFormUrlDecoderEntry);
        return nullptr;
    }

    static void _dealloc_WwwFormUrlDecoderEntry(py::wrapper::Windows::Foundation::WwwFormUrlDecoderEntry* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WwwFormUrlDecoderEntry_get_Name(py::wrapper::Windows::Foundation::WwwFormUrlDecoderEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.WwwFormUrlDecoderEntry", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WwwFormUrlDecoderEntry_get_Value(py::wrapper::Windows::Foundation::WwwFormUrlDecoderEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.WwwFormUrlDecoderEntry", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WwwFormUrlDecoderEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WwwFormUrlDecoderEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WwwFormUrlDecoderEntry[] = {
        { "_assign_array_", _assign_array_WwwFormUrlDecoderEntry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WwwFormUrlDecoderEntry), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WwwFormUrlDecoderEntry[] = {
        { "name", reinterpret_cast<getter>(WwwFormUrlDecoderEntry_get_Name), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(WwwFormUrlDecoderEntry_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WwwFormUrlDecoderEntry[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WwwFormUrlDecoderEntry) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WwwFormUrlDecoderEntry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WwwFormUrlDecoderEntry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WwwFormUrlDecoderEntry) },
        { },
    };

    static PyType_Spec type_spec_WwwFormUrlDecoderEntry =
    {
        "_winsdk_Windows_Foundation.WwwFormUrlDecoderEntry",
        sizeof(py::wrapper::Windows::Foundation::WwwFormUrlDecoderEntry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WwwFormUrlDecoderEntry
    };

    // ----- IAsyncAction interface --------------------
    static constexpr const char* const type_name_IAsyncAction = "IAsyncAction";

    static PyObject* _new_IAsyncAction(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IAsyncAction);
        return nullptr;
    }

    static void _dealloc_IAsyncAction(py::wrapper::Windows::Foundation::IAsyncAction* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAsyncAction_Cancel(py::wrapper::Windows::Foundation::IAsyncAction* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IAsyncInfo", L"Cancel", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Cancel();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAsyncAction_Close(py::wrapper::Windows::Foundation::IAsyncAction* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IAsyncInfo", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAsyncAction_GetResults(py::wrapper::Windows::Foundation::IAsyncAction* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IAsyncAction", L"GetResults", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.GetResults();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAsyncAction_get_Completed(py::wrapper::Windows::Foundation::IAsyncAction* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncAction", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Completed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAsyncAction_put_Completed(py::wrapper::Windows::Foundation::IAsyncAction* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncAction", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncActionCompletedHandler>(arg);

            self->obj.Completed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAsyncAction_get_ErrorCode(py::wrapper::Windows::Foundation::IAsyncAction* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"ErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncAction_get_Id(py::wrapper::Windows::Foundation::IAsyncAction* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncAction_get_Status(py::wrapper::Windows::Foundation::IAsyncAction* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IAsyncAction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::IAsyncAction>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAsyncAction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IAsyncAction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _await_IAsyncAction(py::wrapper::Windows::Foundation::IAsyncAction* self) noexcept
    {
        return py::dunder_await(self->obj);
    }

    static PyMethodDef _methods_IAsyncAction[] = {
        { "cancel", reinterpret_cast<PyCFunction>(IAsyncAction_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IAsyncAction_Close), METH_VARARGS, nullptr },
        { "get_results", reinterpret_cast<PyCFunction>(IAsyncAction_GetResults), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IAsyncAction, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAsyncAction), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAsyncAction[] = {
        { "completed", reinterpret_cast<getter>(IAsyncAction_get_Completed), reinterpret_cast<setter>(IAsyncAction_put_Completed), nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(IAsyncAction_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(IAsyncAction_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IAsyncAction_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAsyncAction[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAsyncAction) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAsyncAction) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAsyncAction) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAsyncAction) },
        { Py_am_await, reinterpret_cast<void*>(_await_IAsyncAction) },
        { },
    };

    static PyType_Spec type_spec_IAsyncAction =
    {
        "_winsdk_Windows_Foundation.IAsyncAction",
        sizeof(py::wrapper::Windows::Foundation::IAsyncAction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAsyncAction
    };

    // ----- IAsyncActionWithProgress interface --------------------
    static constexpr const char* const type_name_IAsyncActionWithProgress = "IAsyncActionWithProgress";

    static PyObject* _new_IAsyncActionWithProgress(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IAsyncActionWithProgress);
        return nullptr;
    }

    static void _dealloc_IAsyncActionWithProgress(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAsyncActionWithProgress_Cancel(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, PyObject* args) noexcept
    {
        return self->obj->Cancel(args);
    }

    static PyObject* IAsyncActionWithProgress_Close(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, PyObject* args) noexcept
    {
        return self->obj->Close(args);
    }

    static PyObject* IAsyncActionWithProgress_GetResults(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, PyObject* args) noexcept
    {
        return self->obj->GetResults(args);
    }

    static PyObject* IAsyncActionWithProgress_get_Progress(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncActionWithProgress`1", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        return self->obj->get_Progress();
    }

    static int IAsyncActionWithProgress_put_Progress(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncActionWithProgress`1", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        return self->obj->put_Progress(arg);
    }

    static PyObject* IAsyncActionWithProgress_get_Completed(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncActionWithProgress`1", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        return self->obj->get_Completed();
    }

    static int IAsyncActionWithProgress_put_Completed(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncActionWithProgress`1", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        return self->obj->put_Completed(arg);
    }

    static PyObject* IAsyncActionWithProgress_get_ErrorCode(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"ErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        return self->obj->get_ErrorCode();
    }

    static PyObject* IAsyncActionWithProgress_get_Id(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        return self->obj->get_Id();
    }

    static PyObject* IAsyncActionWithProgress_get_Status(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        return self->obj->get_Status();
    }

    static PyObject* _await_IAsyncActionWithProgress(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self) noexcept
    {
        return self->obj->dunder_await();
    }

    static PyMethodDef _methods_IAsyncActionWithProgress[] = {
        { "cancel", reinterpret_cast<PyCFunction>(IAsyncActionWithProgress_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IAsyncActionWithProgress_Close), METH_VARARGS, nullptr },
        { "get_results", reinterpret_cast<PyCFunction>(IAsyncActionWithProgress_GetResults), METH_VARARGS, nullptr },
        #if PY_VERSION_HEX >= 0x03090000
        { "__class_getitem__", Py_GenericAlias, METH_O | METH_CLASS, PyDoc_STR("See PEP 585") },
        #endif
        { }
    };

    static PyGetSetDef _getset_IAsyncActionWithProgress[] = {
        { "progress", reinterpret_cast<getter>(IAsyncActionWithProgress_get_Progress), reinterpret_cast<setter>(IAsyncActionWithProgress_put_Progress), nullptr, nullptr },
        { "completed", reinterpret_cast<getter>(IAsyncActionWithProgress_get_Completed), reinterpret_cast<setter>(IAsyncActionWithProgress_put_Completed), nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(IAsyncActionWithProgress_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(IAsyncActionWithProgress_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IAsyncActionWithProgress_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAsyncActionWithProgress[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAsyncActionWithProgress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAsyncActionWithProgress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAsyncActionWithProgress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAsyncActionWithProgress) },
        { Py_am_await, reinterpret_cast<void*>(_await_IAsyncActionWithProgress) },
        { },
    };

    static PyType_Spec type_spec_IAsyncActionWithProgress =
    {
        "_winsdk_Windows_Foundation.IAsyncActionWithProgress",
        sizeof(py::wrapper::Windows::Foundation::IAsyncActionWithProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAsyncActionWithProgress
    };

    // ----- IAsyncInfo interface --------------------
    static constexpr const char* const type_name_IAsyncInfo = "IAsyncInfo";

    static PyObject* _new_IAsyncInfo(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IAsyncInfo);
        return nullptr;
    }

    static void _dealloc_IAsyncInfo(py::wrapper::Windows::Foundation::IAsyncInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAsyncInfo_Cancel(py::wrapper::Windows::Foundation::IAsyncInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IAsyncInfo", L"Cancel", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Cancel();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAsyncInfo_Close(py::wrapper::Windows::Foundation::IAsyncInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IAsyncInfo", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAsyncInfo_get_ErrorCode(py::wrapper::Windows::Foundation::IAsyncInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"ErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncInfo_get_Id(py::wrapper::Windows::Foundation::IAsyncInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncInfo_get_Status(py::wrapper::Windows::Foundation::IAsyncInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IAsyncInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::IAsyncInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAsyncInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IAsyncInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAsyncInfo[] = {
        { "cancel", reinterpret_cast<PyCFunction>(IAsyncInfo_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IAsyncInfo_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IAsyncInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAsyncInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAsyncInfo[] = {
        { "error_code", reinterpret_cast<getter>(IAsyncInfo_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(IAsyncInfo_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IAsyncInfo_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAsyncInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAsyncInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAsyncInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAsyncInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAsyncInfo) },
        { },
    };

    static PyType_Spec type_spec_IAsyncInfo =
    {
        "_winsdk_Windows_Foundation.IAsyncInfo",
        sizeof(py::wrapper::Windows::Foundation::IAsyncInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAsyncInfo
    };

    // ----- IAsyncOperationWithProgress interface --------------------
    static constexpr const char* const type_name_IAsyncOperationWithProgress = "IAsyncOperationWithProgress";

    static PyObject* _new_IAsyncOperationWithProgress(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IAsyncOperationWithProgress);
        return nullptr;
    }

    static void _dealloc_IAsyncOperationWithProgress(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAsyncOperationWithProgress_Cancel(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, PyObject* args) noexcept
    {
        return self->obj->Cancel(args);
    }

    static PyObject* IAsyncOperationWithProgress_Close(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, PyObject* args) noexcept
    {
        return self->obj->Close(args);
    }

    static PyObject* IAsyncOperationWithProgress_GetResults(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, PyObject* args) noexcept
    {
        return self->obj->GetResults(args);
    }

    static PyObject* IAsyncOperationWithProgress_get_Progress(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncOperationWithProgress`2", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        return self->obj->get_Progress();
    }

    static int IAsyncOperationWithProgress_put_Progress(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncOperationWithProgress`2", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        return self->obj->put_Progress(arg);
    }

    static PyObject* IAsyncOperationWithProgress_get_Completed(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncOperationWithProgress`2", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        return self->obj->get_Completed();
    }

    static int IAsyncOperationWithProgress_put_Completed(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncOperationWithProgress`2", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        return self->obj->put_Completed(arg);
    }

    static PyObject* IAsyncOperationWithProgress_get_ErrorCode(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"ErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        return self->obj->get_ErrorCode();
    }

    static PyObject* IAsyncOperationWithProgress_get_Id(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        return self->obj->get_Id();
    }

    static PyObject* IAsyncOperationWithProgress_get_Status(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        return self->obj->get_Status();
    }

    static PyObject* _await_IAsyncOperationWithProgress(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self) noexcept
    {
        return self->obj->dunder_await();
    }

    static PyMethodDef _methods_IAsyncOperationWithProgress[] = {
        { "cancel", reinterpret_cast<PyCFunction>(IAsyncOperationWithProgress_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IAsyncOperationWithProgress_Close), METH_VARARGS, nullptr },
        { "get_results", reinterpret_cast<PyCFunction>(IAsyncOperationWithProgress_GetResults), METH_VARARGS, nullptr },
        #if PY_VERSION_HEX >= 0x03090000
        { "__class_getitem__", Py_GenericAlias, METH_O | METH_CLASS, PyDoc_STR("See PEP 585") },
        #endif
        { }
    };

    static PyGetSetDef _getset_IAsyncOperationWithProgress[] = {
        { "progress", reinterpret_cast<getter>(IAsyncOperationWithProgress_get_Progress), reinterpret_cast<setter>(IAsyncOperationWithProgress_put_Progress), nullptr, nullptr },
        { "completed", reinterpret_cast<getter>(IAsyncOperationWithProgress_get_Completed), reinterpret_cast<setter>(IAsyncOperationWithProgress_put_Completed), nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(IAsyncOperationWithProgress_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(IAsyncOperationWithProgress_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IAsyncOperationWithProgress_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAsyncOperationWithProgress[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAsyncOperationWithProgress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAsyncOperationWithProgress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAsyncOperationWithProgress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAsyncOperationWithProgress) },
        { Py_am_await, reinterpret_cast<void*>(_await_IAsyncOperationWithProgress) },
        { },
    };

    static PyType_Spec type_spec_IAsyncOperationWithProgress =
    {
        "_winsdk_Windows_Foundation.IAsyncOperationWithProgress",
        sizeof(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAsyncOperationWithProgress
    };

    // ----- IAsyncOperation interface --------------------
    static constexpr const char* const type_name_IAsyncOperation = "IAsyncOperation";

    static PyObject* _new_IAsyncOperation(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IAsyncOperation);
        return nullptr;
    }

    static void _dealloc_IAsyncOperation(py::wrapper::Windows::Foundation::IAsyncOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAsyncOperation_Cancel(py::wrapper::Windows::Foundation::IAsyncOperation* self, PyObject* args) noexcept
    {
        return self->obj->Cancel(args);
    }

    static PyObject* IAsyncOperation_Close(py::wrapper::Windows::Foundation::IAsyncOperation* self, PyObject* args) noexcept
    {
        return self->obj->Close(args);
    }

    static PyObject* IAsyncOperation_GetResults(py::wrapper::Windows::Foundation::IAsyncOperation* self, PyObject* args) noexcept
    {
        return self->obj->GetResults(args);
    }

    static PyObject* IAsyncOperation_get_Completed(py::wrapper::Windows::Foundation::IAsyncOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncOperation`1", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        return self->obj->get_Completed();
    }

    static int IAsyncOperation_put_Completed(py::wrapper::Windows::Foundation::IAsyncOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncOperation`1", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        return self->obj->put_Completed(arg);
    }

    static PyObject* IAsyncOperation_get_ErrorCode(py::wrapper::Windows::Foundation::IAsyncOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"ErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        return self->obj->get_ErrorCode();
    }

    static PyObject* IAsyncOperation_get_Id(py::wrapper::Windows::Foundation::IAsyncOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        return self->obj->get_Id();
    }

    static PyObject* IAsyncOperation_get_Status(py::wrapper::Windows::Foundation::IAsyncOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        return self->obj->get_Status();
    }

    static PyObject* _await_IAsyncOperation(py::wrapper::Windows::Foundation::IAsyncOperation* self) noexcept
    {
        return self->obj->dunder_await();
    }

    static PyMethodDef _methods_IAsyncOperation[] = {
        { "cancel", reinterpret_cast<PyCFunction>(IAsyncOperation_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IAsyncOperation_Close), METH_VARARGS, nullptr },
        { "get_results", reinterpret_cast<PyCFunction>(IAsyncOperation_GetResults), METH_VARARGS, nullptr },
        #if PY_VERSION_HEX >= 0x03090000
        { "__class_getitem__", Py_GenericAlias, METH_O | METH_CLASS, PyDoc_STR("See PEP 585") },
        #endif
        { }
    };

    static PyGetSetDef _getset_IAsyncOperation[] = {
        { "completed", reinterpret_cast<getter>(IAsyncOperation_get_Completed), reinterpret_cast<setter>(IAsyncOperation_put_Completed), nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(IAsyncOperation_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(IAsyncOperation_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IAsyncOperation_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAsyncOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAsyncOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAsyncOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAsyncOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAsyncOperation) },
        { Py_am_await, reinterpret_cast<void*>(_await_IAsyncOperation) },
        { },
    };

    static PyType_Spec type_spec_IAsyncOperation =
    {
        "_winsdk_Windows_Foundation.IAsyncOperation",
        sizeof(py::wrapper::Windows::Foundation::IAsyncOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAsyncOperation
    };

    // ----- IClosable interface --------------------
    static constexpr const char* const type_name_IClosable = "IClosable";

    static PyObject* _new_IClosable(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IClosable);
        return nullptr;
    }

    static void _dealloc_IClosable(py::wrapper::Windows::Foundation::IClosable* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IClosable_Close(py::wrapper::Windows::Foundation::IClosable* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IClosable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::IClosable>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IClosable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IClosable>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IClosable(py::wrapper::Windows::Foundation::IClosable* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_IClosable(py::wrapper::Windows::Foundation::IClosable* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IClosable[] = {
        { "close", reinterpret_cast<PyCFunction>(IClosable_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IClosable, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IClosable), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IClosable), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IClosable), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IClosable[] = {
        { }
    };

    static PyType_Slot _type_slots_IClosable[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IClosable) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IClosable) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IClosable) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IClosable) },
        { },
    };

    static PyType_Spec type_spec_IClosable =
    {
        "_winsdk_Windows_Foundation.IClosable",
        sizeof(py::wrapper::Windows::Foundation::IClosable),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IClosable
    };

    // ----- IGetActivationFactory interface --------------------
    static constexpr const char* const type_name_IGetActivationFactory = "IGetActivationFactory";

    static PyObject* _new_IGetActivationFactory(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IGetActivationFactory);
        return nullptr;
    }

    static void _dealloc_IGetActivationFactory(py::wrapper::Windows::Foundation::IGetActivationFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IGetActivationFactory_GetActivationFactory(py::wrapper::Windows::Foundation::IGetActivationFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IGetActivationFactory", L"GetActivationFactory", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetActivationFactory(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IGetActivationFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::IGetActivationFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IGetActivationFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IGetActivationFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGetActivationFactory[] = {
        { "get_activation_factory", reinterpret_cast<PyCFunction>(IGetActivationFactory_GetActivationFactory), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IGetActivationFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGetActivationFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IGetActivationFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IGetActivationFactory[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IGetActivationFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IGetActivationFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IGetActivationFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IGetActivationFactory) },
        { },
    };

    static PyType_Spec type_spec_IGetActivationFactory =
    {
        "_winsdk_Windows_Foundation.IGetActivationFactory",
        sizeof(py::wrapper::Windows::Foundation::IGetActivationFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGetActivationFactory
    };

    // ----- IMemoryBuffer interface --------------------
    static constexpr const char* const type_name_IMemoryBuffer = "IMemoryBuffer";

    static PyObject* _new_IMemoryBuffer(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IMemoryBuffer);
        return nullptr;
    }

    static void _dealloc_IMemoryBuffer(py::wrapper::Windows::Foundation::IMemoryBuffer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMemoryBuffer_Close(py::wrapper::Windows::Foundation::IMemoryBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMemoryBuffer_CreateReference(py::wrapper::Windows::Foundation::IMemoryBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IMemoryBuffer", L"CreateReference", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IMemoryBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::IMemoryBuffer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMemoryBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IMemoryBuffer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IMemoryBuffer(py::wrapper::Windows::Foundation::IMemoryBuffer* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_IMemoryBuffer(py::wrapper::Windows::Foundation::IMemoryBuffer* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMemoryBuffer[] = {
        { "close", reinterpret_cast<PyCFunction>(IMemoryBuffer_Close), METH_VARARGS, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(IMemoryBuffer_CreateReference), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IMemoryBuffer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMemoryBuffer), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IMemoryBuffer), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IMemoryBuffer), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMemoryBuffer[] = {
        { }
    };

    static PyType_Slot _type_slots_IMemoryBuffer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMemoryBuffer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMemoryBuffer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMemoryBuffer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMemoryBuffer) },
        { },
    };

    static PyType_Spec type_spec_IMemoryBuffer =
    {
        "_winsdk_Windows_Foundation.IMemoryBuffer",
        sizeof(py::wrapper::Windows::Foundation::IMemoryBuffer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMemoryBuffer
    };

    // ----- IMemoryBufferReference interface --------------------
    static constexpr const char* const type_name_IMemoryBufferReference = "IMemoryBufferReference";

    static PyObject* _new_IMemoryBufferReference(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IMemoryBufferReference);
        return nullptr;
    }

    static void _dealloc_IMemoryBufferReference(py::wrapper::Windows::Foundation::IMemoryBufferReference* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMemoryBufferReference_Close(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMemoryBufferReference_get_Capacity(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IMemoryBufferReference", L"Capacity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Capacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMemoryBufferReference_add_Closed(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Foundation.IMemoryBufferReference", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IMemoryBufferReference, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMemoryBufferReference_remove_Closed(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Foundation.IMemoryBufferReference", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IMemoryBufferReference(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::IMemoryBufferReference>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMemoryBufferReference(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IMemoryBufferReference>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IMemoryBufferReference(py::wrapper::Windows::Foundation::IMemoryBufferReference* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_IMemoryBufferReference(py::wrapper::Windows::Foundation::IMemoryBufferReference* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _get_buffer_IMemoryBufferReference(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, Py_buffer* view, int flags) noexcept
    {
        try
        {
            return PyBuffer_FillInfo(view, reinterpret_cast<PyObject*>(self), reinterpret_cast<void*>(self->obj.data()), static_cast<Py_ssize_t>(self->obj.Capacity()), 0, flags);
        }
        catch (...)
        {
            view->obj = nullptr;
            PyErr_SetNone(PyExc_BufferError);
            return -1;
        }
    }

    #if PY_VERSION_HEX < 0x03090000
    static PyBufferProcs _PyBufferProcs_IMemoryBufferReference = { reinterpret_cast<getbufferproc>(_get_buffer_IMemoryBufferReference), nullptr };
    #endif

    static PyMethodDef _methods_IMemoryBufferReference[] = {
        { "close", reinterpret_cast<PyCFunction>(IMemoryBufferReference_Close), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(IMemoryBufferReference_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(IMemoryBufferReference_remove_Closed), METH_O, nullptr },
        { "_assign_array_", _assign_array_IMemoryBufferReference, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMemoryBufferReference), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IMemoryBufferReference), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IMemoryBufferReference), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMemoryBufferReference[] = {
        { "capacity", reinterpret_cast<getter>(IMemoryBufferReference_get_Capacity), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMemoryBufferReference[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMemoryBufferReference) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMemoryBufferReference) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMemoryBufferReference) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMemoryBufferReference) },
        #if PY_VERSION_HEX >= 0x03090000
        { Py_bf_getbuffer, reinterpret_cast<void*>(_get_buffer_IMemoryBufferReference) },
        #endif
        { },
    };

    static PyType_Spec type_spec_IMemoryBufferReference =
    {
        "_winsdk_Windows_Foundation.IMemoryBufferReference",
        sizeof(py::wrapper::Windows::Foundation::IMemoryBufferReference),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMemoryBufferReference
    };

    // ----- IPropertyValue interface --------------------
    static constexpr const char* const type_name_IPropertyValue = "IPropertyValue";

    static PyObject* _new_IPropertyValue(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IPropertyValue);
        return nullptr;
    }

    static void _dealloc_IPropertyValue(py::wrapper::Windows::Foundation::IPropertyValue* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPropertyValue_GetBoolean(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetBoolean", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetBoolean());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetBooleanArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetBooleanArray", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::com_array<bool> param0 { };

                self->obj.GetBooleanArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetChar16(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetChar16", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetChar16());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetChar16Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetChar16Array", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::com_array<char16_t> param0 { };

                self->obj.GetChar16Array(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetDateTime(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetDateTime", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDateTime());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetDateTimeArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetDateTimeArray", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::com_array<winrt::Windows::Foundation::DateTime> param0 { };

                self->obj.GetDateTimeArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetDouble(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetDouble", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDouble());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetDoubleArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetDoubleArray", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::com_array<double> param0 { };

                self->obj.GetDoubleArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetGuid(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetGuid", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetGuid());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetGuidArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetGuidArray", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::com_array<winrt::guid> param0 { };

                self->obj.GetGuidArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInspectableArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInspectableArray", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::com_array<winrt::Windows::Foundation::IInspectable> param0 { };

                self->obj.GetInspectableArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInt16(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt16", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetInt16());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInt16Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt16Array", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::com_array<int16_t> param0 { };

                self->obj.GetInt16Array(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInt32(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt32", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetInt32());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInt32Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt32Array", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::com_array<int32_t> param0 { };

                self->obj.GetInt32Array(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInt64(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt64", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetInt64());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInt64Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt64Array", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::com_array<int64_t> param0 { };

                self->obj.GetInt64Array(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetPoint(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetPoint", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetPoint());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetPointArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetPointArray", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::com_array<winrt::Windows::Foundation::Point> param0 { };

                self->obj.GetPointArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetRect(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetRect", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetRect());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetRectArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetRectArray", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::com_array<winrt::Windows::Foundation::Rect> param0 { };

                self->obj.GetRectArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetSingle(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetSingle", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSingle());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetSingleArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetSingleArray", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::com_array<float> param0 { };

                self->obj.GetSingleArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetSize(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetSize", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSize());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetSizeArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetSizeArray", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::com_array<winrt::Windows::Foundation::Size> param0 { };

                self->obj.GetSizeArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetString(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetString", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetStringArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetStringArray", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::com_array<winrt::hstring> param0 { };

                self->obj.GetStringArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetTimeSpan(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetTimeSpan", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetTimeSpan());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetTimeSpanArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetTimeSpanArray", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::com_array<winrt::Windows::Foundation::TimeSpan> param0 { };

                self->obj.GetTimeSpanArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt16(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt16", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetUInt16());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt16Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt16Array", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::com_array<uint16_t> param0 { };

                self->obj.GetUInt16Array(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt32(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt32", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetUInt32());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt32Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt32Array", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::com_array<uint32_t> param0 { };

                self->obj.GetUInt32Array(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt64(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt64", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetUInt64());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt64Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt64Array", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::com_array<uint64_t> param0 { };

                self->obj.GetUInt64Array(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt8(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt8", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetUInt8());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt8Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt8Array", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::com_array<uint8_t> param0 { };

                self->obj.GetUInt8Array(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_get_IsNumericScalar(py::wrapper::Windows::Foundation::IPropertyValue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IPropertyValue", L"IsNumericScalar"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsNumericScalar());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_get_Type(py::wrapper::Windows::Foundation::IPropertyValue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IPropertyValue", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IPropertyValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::IPropertyValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPropertyValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IPropertyValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPropertyValue[] = {
        { "get_boolean", reinterpret_cast<PyCFunction>(IPropertyValue_GetBoolean), METH_VARARGS, nullptr },
        { "get_boolean_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetBooleanArray), METH_VARARGS, nullptr },
        { "get_char16", reinterpret_cast<PyCFunction>(IPropertyValue_GetChar16), METH_VARARGS, nullptr },
        { "get_char16_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetChar16Array), METH_VARARGS, nullptr },
        { "get_date_time", reinterpret_cast<PyCFunction>(IPropertyValue_GetDateTime), METH_VARARGS, nullptr },
        { "get_date_time_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetDateTimeArray), METH_VARARGS, nullptr },
        { "get_double", reinterpret_cast<PyCFunction>(IPropertyValue_GetDouble), METH_VARARGS, nullptr },
        { "get_double_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetDoubleArray), METH_VARARGS, nullptr },
        { "get_guid", reinterpret_cast<PyCFunction>(IPropertyValue_GetGuid), METH_VARARGS, nullptr },
        { "get_guid_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetGuidArray), METH_VARARGS, nullptr },
        { "get_inspectable_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetInspectableArray), METH_VARARGS, nullptr },
        { "get_int16", reinterpret_cast<PyCFunction>(IPropertyValue_GetInt16), METH_VARARGS, nullptr },
        { "get_int16_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetInt16Array), METH_VARARGS, nullptr },
        { "get_int32", reinterpret_cast<PyCFunction>(IPropertyValue_GetInt32), METH_VARARGS, nullptr },
        { "get_int32_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetInt32Array), METH_VARARGS, nullptr },
        { "get_int64", reinterpret_cast<PyCFunction>(IPropertyValue_GetInt64), METH_VARARGS, nullptr },
        { "get_int64_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetInt64Array), METH_VARARGS, nullptr },
        { "get_point", reinterpret_cast<PyCFunction>(IPropertyValue_GetPoint), METH_VARARGS, nullptr },
        { "get_point_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetPointArray), METH_VARARGS, nullptr },
        { "get_rect", reinterpret_cast<PyCFunction>(IPropertyValue_GetRect), METH_VARARGS, nullptr },
        { "get_rect_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetRectArray), METH_VARARGS, nullptr },
        { "get_single", reinterpret_cast<PyCFunction>(IPropertyValue_GetSingle), METH_VARARGS, nullptr },
        { "get_single_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetSingleArray), METH_VARARGS, nullptr },
        { "get_size", reinterpret_cast<PyCFunction>(IPropertyValue_GetSize), METH_VARARGS, nullptr },
        { "get_size_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetSizeArray), METH_VARARGS, nullptr },
        { "get_string", reinterpret_cast<PyCFunction>(IPropertyValue_GetString), METH_VARARGS, nullptr },
        { "get_string_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetStringArray), METH_VARARGS, nullptr },
        { "get_time_span", reinterpret_cast<PyCFunction>(IPropertyValue_GetTimeSpan), METH_VARARGS, nullptr },
        { "get_time_span_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetTimeSpanArray), METH_VARARGS, nullptr },
        { "get_uint16", reinterpret_cast<PyCFunction>(IPropertyValue_GetUInt16), METH_VARARGS, nullptr },
        { "get_uint16_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetUInt16Array), METH_VARARGS, nullptr },
        { "get_uint32", reinterpret_cast<PyCFunction>(IPropertyValue_GetUInt32), METH_VARARGS, nullptr },
        { "get_uint32_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetUInt32Array), METH_VARARGS, nullptr },
        { "get_uint64", reinterpret_cast<PyCFunction>(IPropertyValue_GetUInt64), METH_VARARGS, nullptr },
        { "get_uint64_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetUInt64Array), METH_VARARGS, nullptr },
        { "get_uint8", reinterpret_cast<PyCFunction>(IPropertyValue_GetUInt8), METH_VARARGS, nullptr },
        { "get_uint8_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetUInt8Array), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IPropertyValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPropertyValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPropertyValue[] = {
        { "is_numeric_scalar", reinterpret_cast<getter>(IPropertyValue_get_IsNumericScalar), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(IPropertyValue_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IPropertyValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPropertyValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPropertyValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPropertyValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPropertyValue) },
        { },
    };

    static PyType_Spec type_spec_IPropertyValue =
    {
        "_winsdk_Windows_Foundation.IPropertyValue",
        sizeof(py::wrapper::Windows::Foundation::IPropertyValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPropertyValue
    };

    // ----- IReferenceArray interface --------------------
    static constexpr const char* const type_name_IReferenceArray = "IReferenceArray";

    static PyObject* _new_IReferenceArray(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IReferenceArray);
        return nullptr;
    }

    static void _dealloc_IReferenceArray(py::wrapper::Windows::Foundation::IReferenceArray* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IReferenceArray_GetBoolean(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetBoolean(args);
    }

    static PyObject* IReferenceArray_GetBooleanArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetBooleanArray(args);
    }

    static PyObject* IReferenceArray_GetChar16(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetChar16(args);
    }

    static PyObject* IReferenceArray_GetChar16Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetChar16Array(args);
    }

    static PyObject* IReferenceArray_GetDateTime(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetDateTime(args);
    }

    static PyObject* IReferenceArray_GetDateTimeArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetDateTimeArray(args);
    }

    static PyObject* IReferenceArray_GetDouble(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetDouble(args);
    }

    static PyObject* IReferenceArray_GetDoubleArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetDoubleArray(args);
    }

    static PyObject* IReferenceArray_GetGuid(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetGuid(args);
    }

    static PyObject* IReferenceArray_GetGuidArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetGuidArray(args);
    }

    static PyObject* IReferenceArray_GetInspectableArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetInspectableArray(args);
    }

    static PyObject* IReferenceArray_GetInt16(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetInt16(args);
    }

    static PyObject* IReferenceArray_GetInt16Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetInt16Array(args);
    }

    static PyObject* IReferenceArray_GetInt32(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetInt32(args);
    }

    static PyObject* IReferenceArray_GetInt32Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetInt32Array(args);
    }

    static PyObject* IReferenceArray_GetInt64(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetInt64(args);
    }

    static PyObject* IReferenceArray_GetInt64Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetInt64Array(args);
    }

    static PyObject* IReferenceArray_GetPoint(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetPoint(args);
    }

    static PyObject* IReferenceArray_GetPointArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetPointArray(args);
    }

    static PyObject* IReferenceArray_GetRect(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetRect(args);
    }

    static PyObject* IReferenceArray_GetRectArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetRectArray(args);
    }

    static PyObject* IReferenceArray_GetSingle(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetSingle(args);
    }

    static PyObject* IReferenceArray_GetSingleArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetSingleArray(args);
    }

    static PyObject* IReferenceArray_GetSize(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetSize(args);
    }

    static PyObject* IReferenceArray_GetSizeArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetSizeArray(args);
    }

    static PyObject* IReferenceArray_GetString(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetString(args);
    }

    static PyObject* IReferenceArray_GetStringArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetStringArray(args);
    }

    static PyObject* IReferenceArray_GetTimeSpan(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetTimeSpan(args);
    }

    static PyObject* IReferenceArray_GetTimeSpanArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetTimeSpanArray(args);
    }

    static PyObject* IReferenceArray_GetUInt16(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt16(args);
    }

    static PyObject* IReferenceArray_GetUInt16Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt16Array(args);
    }

    static PyObject* IReferenceArray_GetUInt32(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt32(args);
    }

    static PyObject* IReferenceArray_GetUInt32Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt32Array(args);
    }

    static PyObject* IReferenceArray_GetUInt64(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt64(args);
    }

    static PyObject* IReferenceArray_GetUInt64Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt64Array(args);
    }

    static PyObject* IReferenceArray_GetUInt8(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt8(args);
    }

    static PyObject* IReferenceArray_GetUInt8Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt8Array(args);
    }

    static PyObject* IReferenceArray_get_Value(py::wrapper::Windows::Foundation::IReferenceArray* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IReferenceArray`1", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        return self->obj->get_Value();
    }

    static PyObject* IReferenceArray_get_IsNumericScalar(py::wrapper::Windows::Foundation::IReferenceArray* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IPropertyValue", L"IsNumericScalar"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        return self->obj->get_IsNumericScalar();
    }

    static PyObject* IReferenceArray_get_Type(py::wrapper::Windows::Foundation::IReferenceArray* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IPropertyValue", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        return self->obj->get_Type();
    }

    static PyMethodDef _methods_IReferenceArray[] = {
        { "get_boolean", reinterpret_cast<PyCFunction>(IReferenceArray_GetBoolean), METH_VARARGS, nullptr },
        { "get_boolean_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetBooleanArray), METH_VARARGS, nullptr },
        { "get_char16", reinterpret_cast<PyCFunction>(IReferenceArray_GetChar16), METH_VARARGS, nullptr },
        { "get_char16_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetChar16Array), METH_VARARGS, nullptr },
        { "get_date_time", reinterpret_cast<PyCFunction>(IReferenceArray_GetDateTime), METH_VARARGS, nullptr },
        { "get_date_time_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetDateTimeArray), METH_VARARGS, nullptr },
        { "get_double", reinterpret_cast<PyCFunction>(IReferenceArray_GetDouble), METH_VARARGS, nullptr },
        { "get_double_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetDoubleArray), METH_VARARGS, nullptr },
        { "get_guid", reinterpret_cast<PyCFunction>(IReferenceArray_GetGuid), METH_VARARGS, nullptr },
        { "get_guid_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetGuidArray), METH_VARARGS, nullptr },
        { "get_inspectable_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetInspectableArray), METH_VARARGS, nullptr },
        { "get_int16", reinterpret_cast<PyCFunction>(IReferenceArray_GetInt16), METH_VARARGS, nullptr },
        { "get_int16_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetInt16Array), METH_VARARGS, nullptr },
        { "get_int32", reinterpret_cast<PyCFunction>(IReferenceArray_GetInt32), METH_VARARGS, nullptr },
        { "get_int32_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetInt32Array), METH_VARARGS, nullptr },
        { "get_int64", reinterpret_cast<PyCFunction>(IReferenceArray_GetInt64), METH_VARARGS, nullptr },
        { "get_int64_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetInt64Array), METH_VARARGS, nullptr },
        { "get_point", reinterpret_cast<PyCFunction>(IReferenceArray_GetPoint), METH_VARARGS, nullptr },
        { "get_point_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetPointArray), METH_VARARGS, nullptr },
        { "get_rect", reinterpret_cast<PyCFunction>(IReferenceArray_GetRect), METH_VARARGS, nullptr },
        { "get_rect_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetRectArray), METH_VARARGS, nullptr },
        { "get_single", reinterpret_cast<PyCFunction>(IReferenceArray_GetSingle), METH_VARARGS, nullptr },
        { "get_single_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetSingleArray), METH_VARARGS, nullptr },
        { "get_size", reinterpret_cast<PyCFunction>(IReferenceArray_GetSize), METH_VARARGS, nullptr },
        { "get_size_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetSizeArray), METH_VARARGS, nullptr },
        { "get_string", reinterpret_cast<PyCFunction>(IReferenceArray_GetString), METH_VARARGS, nullptr },
        { "get_string_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetStringArray), METH_VARARGS, nullptr },
        { "get_time_span", reinterpret_cast<PyCFunction>(IReferenceArray_GetTimeSpan), METH_VARARGS, nullptr },
        { "get_time_span_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetTimeSpanArray), METH_VARARGS, nullptr },
        { "get_uint16", reinterpret_cast<PyCFunction>(IReferenceArray_GetUInt16), METH_VARARGS, nullptr },
        { "get_uint16_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetUInt16Array), METH_VARARGS, nullptr },
        { "get_uint32", reinterpret_cast<PyCFunction>(IReferenceArray_GetUInt32), METH_VARARGS, nullptr },
        { "get_uint32_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetUInt32Array), METH_VARARGS, nullptr },
        { "get_uint64", reinterpret_cast<PyCFunction>(IReferenceArray_GetUInt64), METH_VARARGS, nullptr },
        { "get_uint64_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetUInt64Array), METH_VARARGS, nullptr },
        { "get_uint8", reinterpret_cast<PyCFunction>(IReferenceArray_GetUInt8), METH_VARARGS, nullptr },
        { "get_uint8_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetUInt8Array), METH_VARARGS, nullptr },
        #if PY_VERSION_HEX >= 0x03090000
        { "__class_getitem__", Py_GenericAlias, METH_O | METH_CLASS, PyDoc_STR("See PEP 585") },
        #endif
        { }
    };

    static PyGetSetDef _getset_IReferenceArray[] = {
        { "value", reinterpret_cast<getter>(IReferenceArray_get_Value), nullptr, nullptr, nullptr },
        { "is_numeric_scalar", reinterpret_cast<getter>(IReferenceArray_get_IsNumericScalar), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(IReferenceArray_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IReferenceArray[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IReferenceArray) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IReferenceArray) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IReferenceArray) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IReferenceArray) },
        { },
    };

    static PyType_Spec type_spec_IReferenceArray =
    {
        "_winsdk_Windows_Foundation.IReferenceArray",
        sizeof(py::wrapper::Windows::Foundation::IReferenceArray),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IReferenceArray
    };

    // ----- IReference interface --------------------
    static constexpr const char* const type_name_IReference = "IReference";

    static PyObject* _new_IReference(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IReference);
        return nullptr;
    }

    static void _dealloc_IReference(py::wrapper::Windows::Foundation::IReference* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IReference_GetBoolean(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetBoolean(args);
    }

    static PyObject* IReference_GetBooleanArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetBooleanArray(args);
    }

    static PyObject* IReference_GetChar16(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetChar16(args);
    }

    static PyObject* IReference_GetChar16Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetChar16Array(args);
    }

    static PyObject* IReference_GetDateTime(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetDateTime(args);
    }

    static PyObject* IReference_GetDateTimeArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetDateTimeArray(args);
    }

    static PyObject* IReference_GetDouble(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetDouble(args);
    }

    static PyObject* IReference_GetDoubleArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetDoubleArray(args);
    }

    static PyObject* IReference_GetGuid(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetGuid(args);
    }

    static PyObject* IReference_GetGuidArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetGuidArray(args);
    }

    static PyObject* IReference_GetInspectableArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetInspectableArray(args);
    }

    static PyObject* IReference_GetInt16(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetInt16(args);
    }

    static PyObject* IReference_GetInt16Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetInt16Array(args);
    }

    static PyObject* IReference_GetInt32(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetInt32(args);
    }

    static PyObject* IReference_GetInt32Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetInt32Array(args);
    }

    static PyObject* IReference_GetInt64(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetInt64(args);
    }

    static PyObject* IReference_GetInt64Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetInt64Array(args);
    }

    static PyObject* IReference_GetPoint(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetPoint(args);
    }

    static PyObject* IReference_GetPointArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetPointArray(args);
    }

    static PyObject* IReference_GetRect(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetRect(args);
    }

    static PyObject* IReference_GetRectArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetRectArray(args);
    }

    static PyObject* IReference_GetSingle(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetSingle(args);
    }

    static PyObject* IReference_GetSingleArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetSingleArray(args);
    }

    static PyObject* IReference_GetSize(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetSize(args);
    }

    static PyObject* IReference_GetSizeArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetSizeArray(args);
    }

    static PyObject* IReference_GetString(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetString(args);
    }

    static PyObject* IReference_GetStringArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetStringArray(args);
    }

    static PyObject* IReference_GetTimeSpan(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetTimeSpan(args);
    }

    static PyObject* IReference_GetTimeSpanArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetTimeSpanArray(args);
    }

    static PyObject* IReference_GetUInt16(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt16(args);
    }

    static PyObject* IReference_GetUInt16Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt16Array(args);
    }

    static PyObject* IReference_GetUInt32(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt32(args);
    }

    static PyObject* IReference_GetUInt32Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt32Array(args);
    }

    static PyObject* IReference_GetUInt64(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt64(args);
    }

    static PyObject* IReference_GetUInt64Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt64Array(args);
    }

    static PyObject* IReference_GetUInt8(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt8(args);
    }

    static PyObject* IReference_GetUInt8Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt8Array(args);
    }

    static PyObject* IReference_get_Value(py::wrapper::Windows::Foundation::IReference* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IReference`1", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        return self->obj->get_Value();
    }

    static PyObject* IReference_get_IsNumericScalar(py::wrapper::Windows::Foundation::IReference* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IPropertyValue", L"IsNumericScalar"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        return self->obj->get_IsNumericScalar();
    }

    static PyObject* IReference_get_Type(py::wrapper::Windows::Foundation::IReference* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IPropertyValue", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        return self->obj->get_Type();
    }

    static PyMethodDef _methods_IReference[] = {
        { "get_boolean", reinterpret_cast<PyCFunction>(IReference_GetBoolean), METH_VARARGS, nullptr },
        { "get_boolean_array", reinterpret_cast<PyCFunction>(IReference_GetBooleanArray), METH_VARARGS, nullptr },
        { "get_char16", reinterpret_cast<PyCFunction>(IReference_GetChar16), METH_VARARGS, nullptr },
        { "get_char16_array", reinterpret_cast<PyCFunction>(IReference_GetChar16Array), METH_VARARGS, nullptr },
        { "get_date_time", reinterpret_cast<PyCFunction>(IReference_GetDateTime), METH_VARARGS, nullptr },
        { "get_date_time_array", reinterpret_cast<PyCFunction>(IReference_GetDateTimeArray), METH_VARARGS, nullptr },
        { "get_double", reinterpret_cast<PyCFunction>(IReference_GetDouble), METH_VARARGS, nullptr },
        { "get_double_array", reinterpret_cast<PyCFunction>(IReference_GetDoubleArray), METH_VARARGS, nullptr },
        { "get_guid", reinterpret_cast<PyCFunction>(IReference_GetGuid), METH_VARARGS, nullptr },
        { "get_guid_array", reinterpret_cast<PyCFunction>(IReference_GetGuidArray), METH_VARARGS, nullptr },
        { "get_inspectable_array", reinterpret_cast<PyCFunction>(IReference_GetInspectableArray), METH_VARARGS, nullptr },
        { "get_int16", reinterpret_cast<PyCFunction>(IReference_GetInt16), METH_VARARGS, nullptr },
        { "get_int16_array", reinterpret_cast<PyCFunction>(IReference_GetInt16Array), METH_VARARGS, nullptr },
        { "get_int32", reinterpret_cast<PyCFunction>(IReference_GetInt32), METH_VARARGS, nullptr },
        { "get_int32_array", reinterpret_cast<PyCFunction>(IReference_GetInt32Array), METH_VARARGS, nullptr },
        { "get_int64", reinterpret_cast<PyCFunction>(IReference_GetInt64), METH_VARARGS, nullptr },
        { "get_int64_array", reinterpret_cast<PyCFunction>(IReference_GetInt64Array), METH_VARARGS, nullptr },
        { "get_point", reinterpret_cast<PyCFunction>(IReference_GetPoint), METH_VARARGS, nullptr },
        { "get_point_array", reinterpret_cast<PyCFunction>(IReference_GetPointArray), METH_VARARGS, nullptr },
        { "get_rect", reinterpret_cast<PyCFunction>(IReference_GetRect), METH_VARARGS, nullptr },
        { "get_rect_array", reinterpret_cast<PyCFunction>(IReference_GetRectArray), METH_VARARGS, nullptr },
        { "get_single", reinterpret_cast<PyCFunction>(IReference_GetSingle), METH_VARARGS, nullptr },
        { "get_single_array", reinterpret_cast<PyCFunction>(IReference_GetSingleArray), METH_VARARGS, nullptr },
        { "get_size", reinterpret_cast<PyCFunction>(IReference_GetSize), METH_VARARGS, nullptr },
        { "get_size_array", reinterpret_cast<PyCFunction>(IReference_GetSizeArray), METH_VARARGS, nullptr },
        { "get_string", reinterpret_cast<PyCFunction>(IReference_GetString), METH_VARARGS, nullptr },
        { "get_string_array", reinterpret_cast<PyCFunction>(IReference_GetStringArray), METH_VARARGS, nullptr },
        { "get_time_span", reinterpret_cast<PyCFunction>(IReference_GetTimeSpan), METH_VARARGS, nullptr },
        { "get_time_span_array", reinterpret_cast<PyCFunction>(IReference_GetTimeSpanArray), METH_VARARGS, nullptr },
        { "get_uint16", reinterpret_cast<PyCFunction>(IReference_GetUInt16), METH_VARARGS, nullptr },
        { "get_uint16_array", reinterpret_cast<PyCFunction>(IReference_GetUInt16Array), METH_VARARGS, nullptr },
        { "get_uint32", reinterpret_cast<PyCFunction>(IReference_GetUInt32), METH_VARARGS, nullptr },
        { "get_uint32_array", reinterpret_cast<PyCFunction>(IReference_GetUInt32Array), METH_VARARGS, nullptr },
        { "get_uint64", reinterpret_cast<PyCFunction>(IReference_GetUInt64), METH_VARARGS, nullptr },
        { "get_uint64_array", reinterpret_cast<PyCFunction>(IReference_GetUInt64Array), METH_VARARGS, nullptr },
        { "get_uint8", reinterpret_cast<PyCFunction>(IReference_GetUInt8), METH_VARARGS, nullptr },
        { "get_uint8_array", reinterpret_cast<PyCFunction>(IReference_GetUInt8Array), METH_VARARGS, nullptr },
        #if PY_VERSION_HEX >= 0x03090000
        { "__class_getitem__", Py_GenericAlias, METH_O | METH_CLASS, PyDoc_STR("See PEP 585") },
        #endif
        { }
    };

    static PyGetSetDef _getset_IReference[] = {
        { "value", reinterpret_cast<getter>(IReference_get_Value), nullptr, nullptr, nullptr },
        { "is_numeric_scalar", reinterpret_cast<getter>(IReference_get_IsNumericScalar), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(IReference_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IReference[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IReference) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IReference) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IReference) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IReference) },
        { },
    };

    static PyType_Spec type_spec_IReference =
    {
        "_winsdk_Windows_Foundation.IReference",
        sizeof(py::wrapper::Windows::Foundation::IReference),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IReference
    };

    // ----- IStringable interface --------------------
    static constexpr const char* const type_name_IStringable = "IStringable";

    static PyObject* _new_IStringable(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IStringable);
        return nullptr;
    }

    static void _dealloc_IStringable(py::wrapper::Windows::Foundation::IStringable* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStringable_ToString(py::wrapper::Windows::Foundation::IStringable* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IStringable", L"ToString", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IStringable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::IStringable>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStringable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IStringable>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_IStringable(py::wrapper::Windows::Foundation::IStringable* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStringable[] = {
        { "to_string", reinterpret_cast<PyCFunction>(IStringable_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IStringable, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStringable), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStringable[] = {
        { }
    };

    static PyType_Slot _type_slots_IStringable[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStringable) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStringable) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStringable) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStringable) },
        { Py_tp_str, reinterpret_cast<void*>(_str_IStringable) },
        { },
    };

    static PyType_Spec type_spec_IStringable =
    {
        "_winsdk_Windows_Foundation.IStringable",
        sizeof(py::wrapper::Windows::Foundation::IStringable),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStringable
    };

    // ----- IWwwFormUrlDecoderEntry interface --------------------
    static constexpr const char* const type_name_IWwwFormUrlDecoderEntry = "IWwwFormUrlDecoderEntry";

    static PyObject* _new_IWwwFormUrlDecoderEntry(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IWwwFormUrlDecoderEntry);
        return nullptr;
    }

    static void _dealloc_IWwwFormUrlDecoderEntry(py::wrapper::Windows::Foundation::IWwwFormUrlDecoderEntry* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWwwFormUrlDecoderEntry_get_Name(py::wrapper::Windows::Foundation::IWwwFormUrlDecoderEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IWwwFormUrlDecoderEntry", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWwwFormUrlDecoderEntry_get_Value(py::wrapper::Windows::Foundation::IWwwFormUrlDecoderEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IWwwFormUrlDecoderEntry", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IWwwFormUrlDecoderEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWwwFormUrlDecoderEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWwwFormUrlDecoderEntry[] = {
        { "_assign_array_", _assign_array_IWwwFormUrlDecoderEntry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWwwFormUrlDecoderEntry), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWwwFormUrlDecoderEntry[] = {
        { "name", reinterpret_cast<getter>(IWwwFormUrlDecoderEntry_get_Name), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(IWwwFormUrlDecoderEntry_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IWwwFormUrlDecoderEntry[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWwwFormUrlDecoderEntry) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWwwFormUrlDecoderEntry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWwwFormUrlDecoderEntry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWwwFormUrlDecoderEntry) },
        { },
    };

    static PyType_Spec type_spec_IWwwFormUrlDecoderEntry =
    {
        "_winsdk_Windows_Foundation.IWwwFormUrlDecoderEntry",
        sizeof(py::wrapper::Windows::Foundation::IWwwFormUrlDecoderEntry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWwwFormUrlDecoderEntry
    };

    // ----- EventRegistrationToken struct --------------------
    static constexpr const char* const type_name_EventRegistrationToken = "EventRegistrationToken";

    PyObject* _new_EventRegistrationToken(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::event_token return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        int64_t _Value{};

        static const char* kwlist[] = {"value", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "L", const_cast<char**>(kwlist), &_Value))
        {
            return nullptr;
        }

        try
        {
            winrt::event_token return_value{ };
            custom_set(return_value, _Value);
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_EventRegistrationToken(py::wrapper::Windows::Foundation::EventRegistrationToken* self) noexcept
    {
    }

    static PyObject* EventRegistrationToken_get_Value(py::wrapper::Windows::Foundation::EventRegistrationToken* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(custom_get(self->obj));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EventRegistrationToken_set_Value(py::wrapper::Windows::Foundation::EventRegistrationToken* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            custom_set(self->obj, py::converter<int64_t>::convert_to(arg));
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_EventRegistrationToken[] = {
        { "value", reinterpret_cast<getter>(EventRegistrationToken_get_Value), reinterpret_cast<setter>(EventRegistrationToken_set_Value), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EventRegistrationToken[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EventRegistrationToken) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EventRegistrationToken) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EventRegistrationToken) },
        { },
    };

    static PyType_Spec type_spec_EventRegistrationToken =
    {
        "_winsdk_Windows_Foundation.EventRegistrationToken",
        sizeof(py::wrapper::Windows::Foundation::EventRegistrationToken),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EventRegistrationToken
    };

    // ----- HResult struct --------------------
    static constexpr const char* const type_name_HResult = "HResult";

    PyObject* _new_HResult(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::hresult return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        int32_t _Value{};

        static const char* kwlist[] = {"value", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "i", const_cast<char**>(kwlist), &_Value))
        {
            return nullptr;
        }

        try
        {
            winrt::hresult return_value{ };
            custom_set(return_value, _Value);
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_HResult(py::wrapper::Windows::Foundation::HResult* self) noexcept
    {
    }

    static PyObject* HResult_get_Value(py::wrapper::Windows::Foundation::HResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(custom_get(self->obj));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HResult_set_Value(py::wrapper::Windows::Foundation::HResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            custom_set(self->obj, py::converter<int32_t>::convert_to(arg));
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_HResult[] = {
        { "value", reinterpret_cast<getter>(HResult_get_Value), reinterpret_cast<setter>(HResult_set_Value), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HResult) },
        { },
    };

    static PyType_Spec type_spec_HResult =
    {
        "_winsdk_Windows_Foundation.HResult",
        sizeof(py::wrapper::Windows::Foundation::HResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HResult
    };

    // ----- Point struct --------------------
    static constexpr const char* const type_name_Point = "Point";

    PyObject* _new_Point(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Foundation::Point return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        float _X{};
        float _Y{};

        static const char* kwlist[] = {"x", "y", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ff", const_cast<char**>(kwlist), &_X, &_Y))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Foundation::Point return_value{ _X, _Y };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Point(py::wrapper::Windows::Foundation::Point* self) noexcept
    {
    }

    static PyObject* Point_get_X(py::wrapper::Windows::Foundation::Point* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.X);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Point_set_X(py::wrapper::Windows::Foundation::Point* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.X = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Point_get_Y(py::wrapper::Windows::Foundation::Point* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Point_set_Y(py::wrapper::Windows::Foundation::Point* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Y = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Point[] = {
        { "x", reinterpret_cast<getter>(Point_get_X), reinterpret_cast<setter>(Point_set_X), nullptr, nullptr },
        { "y", reinterpret_cast<getter>(Point_get_Y), reinterpret_cast<setter>(Point_set_Y), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Point[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Point) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Point) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Point) },
        { },
    };

    static PyType_Spec type_spec_Point =
    {
        "_winsdk_Windows_Foundation.Point",
        sizeof(py::wrapper::Windows::Foundation::Point),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Point
    };

    // ----- Rect struct --------------------
    static constexpr const char* const type_name_Rect = "Rect";

    PyObject* _new_Rect(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Foundation::Rect return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        float _X{};
        float _Y{};
        float _Width{};
        float _Height{};

        static const char* kwlist[] = {"x", "y", "width", "height", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ffff", const_cast<char**>(kwlist), &_X, &_Y, &_Width, &_Height))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Foundation::Rect return_value{ _X, _Y, _Width, _Height };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Rect(py::wrapper::Windows::Foundation::Rect* self) noexcept
    {
    }

    static PyObject* Rect_get_X(py::wrapper::Windows::Foundation::Rect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.X);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Rect_set_X(py::wrapper::Windows::Foundation::Rect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.X = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Rect_get_Y(py::wrapper::Windows::Foundation::Rect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Rect_set_Y(py::wrapper::Windows::Foundation::Rect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Y = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Rect_get_Width(py::wrapper::Windows::Foundation::Rect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Rect_set_Width(py::wrapper::Windows::Foundation::Rect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Width = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Rect_get_Height(py::wrapper::Windows::Foundation::Rect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Rect_set_Height(py::wrapper::Windows::Foundation::Rect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Height = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Rect[] = {
        { "x", reinterpret_cast<getter>(Rect_get_X), reinterpret_cast<setter>(Rect_set_X), nullptr, nullptr },
        { "y", reinterpret_cast<getter>(Rect_get_Y), reinterpret_cast<setter>(Rect_set_Y), nullptr, nullptr },
        { "width", reinterpret_cast<getter>(Rect_get_Width), reinterpret_cast<setter>(Rect_set_Width), nullptr, nullptr },
        { "height", reinterpret_cast<getter>(Rect_get_Height), reinterpret_cast<setter>(Rect_set_Height), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Rect[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Rect) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Rect) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Rect) },
        { },
    };

    static PyType_Spec type_spec_Rect =
    {
        "_winsdk_Windows_Foundation.Rect",
        sizeof(py::wrapper::Windows::Foundation::Rect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Rect
    };

    // ----- Size struct --------------------
    static constexpr const char* const type_name_Size = "Size";

    PyObject* _new_Size(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Foundation::Size return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        float _Width{};
        float _Height{};

        static const char* kwlist[] = {"width", "height", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ff", const_cast<char**>(kwlist), &_Width, &_Height))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Foundation::Size return_value{ _Width, _Height };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Size(py::wrapper::Windows::Foundation::Size* self) noexcept
    {
    }

    static PyObject* Size_get_Width(py::wrapper::Windows::Foundation::Size* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Size_set_Width(py::wrapper::Windows::Foundation::Size* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Width = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Size_get_Height(py::wrapper::Windows::Foundation::Size* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Size_set_Height(py::wrapper::Windows::Foundation::Size* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Height = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Size[] = {
        { "width", reinterpret_cast<getter>(Size_get_Width), reinterpret_cast<setter>(Size_set_Width), nullptr, nullptr },
        { "height", reinterpret_cast<getter>(Size_get_Height), reinterpret_cast<setter>(Size_set_Height), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Size[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Size) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Size) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Size) },
        { },
    };

    static PyType_Spec type_spec_Size =
    {
        "_winsdk_Windows_Foundation.Size",
        sizeof(py::wrapper::Windows::Foundation::Size),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Size
    };

    // ----- Windows.Foundation Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Foundation");

    static PyMethodDef module_methods[] = {
        {"_register_AsyncStatus", register_AsyncStatus, METH_O, "registers type"},
        {"_register_PropertyType", register_PropertyType, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_AsyncStatus);
        Py_VISIT(state->type_PropertyType);
        Py_VISIT(state->type_Deferral);
        Py_VISIT(state->type_GuidHelper);
        Py_VISIT(state->type_MemoryBuffer);
        Py_VISIT(state->type_PropertyValue);
        Py_VISIT(state->type_Uri);
        Py_VISIT(state->type_WwwFormUrlDecoder);
        Py_VISIT(state->type_WwwFormUrlDecoderEntry);
        Py_VISIT(state->type_IAsyncAction);
        Py_VISIT(state->type_IAsyncActionWithProgress);
        Py_VISIT(state->type_IAsyncInfo);
        Py_VISIT(state->type_IAsyncOperationWithProgress);
        Py_VISIT(state->type_IAsyncOperation);
        Py_VISIT(state->type_IClosable);
        Py_VISIT(state->type_IGetActivationFactory);
        Py_VISIT(state->type_IMemoryBuffer);
        Py_VISIT(state->type_IMemoryBufferReference);
        Py_VISIT(state->type_IPropertyValue);
        Py_VISIT(state->type_IReferenceArray);
        Py_VISIT(state->type_IReference);
        Py_VISIT(state->type_IStringable);
        Py_VISIT(state->type_IWwwFormUrlDecoderEntry);
        Py_VISIT(state->type_EventRegistrationToken);
        Py_VISIT(state->type_HResult);
        Py_VISIT(state->type_Point);
        Py_VISIT(state->type_Rect);
        Py_VISIT(state->type_Size);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_AsyncStatus);
        Py_CLEAR(state->type_PropertyType);
        Py_CLEAR(state->type_Deferral);
        Py_CLEAR(state->type_GuidHelper);
        Py_CLEAR(state->type_MemoryBuffer);
        Py_CLEAR(state->type_PropertyValue);
        Py_CLEAR(state->type_Uri);
        Py_CLEAR(state->type_WwwFormUrlDecoder);
        Py_CLEAR(state->type_WwwFormUrlDecoderEntry);
        Py_CLEAR(state->type_IAsyncAction);
        Py_CLEAR(state->type_IAsyncActionWithProgress);
        Py_CLEAR(state->type_IAsyncInfo);
        Py_CLEAR(state->type_IAsyncOperationWithProgress);
        Py_CLEAR(state->type_IAsyncOperation);
        Py_CLEAR(state->type_IClosable);
        Py_CLEAR(state->type_IGetActivationFactory);
        Py_CLEAR(state->type_IMemoryBuffer);
        Py_CLEAR(state->type_IMemoryBufferReference);
        Py_CLEAR(state->type_IPropertyValue);
        Py_CLEAR(state->type_IReferenceArray);
        Py_CLEAR(state->type_IReference);
        Py_CLEAR(state->type_IStringable);
        Py_CLEAR(state->type_IWwwFormUrlDecoderEntry);
        Py_CLEAR(state->type_EventRegistrationToken);
        Py_CLEAR(state->type_HResult);
        Py_CLEAR(state->type_Point);
        Py_CLEAR(state->type_Rect);
        Py_CLEAR(state->type_Size);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Foundation",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Foundation

PyMODINIT_FUNC PyInit__winsdk_Windows_Foundation(void) noexcept
{
    using namespace py::cpp::Windows::Foundation;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_Deferral = py::register_python_type(module.get(), type_name_Deferral, &type_spec_Deferral, bases.get(), nullptr);
    if (!state->type_Deferral)
    {
        return nullptr;
    }

    py::pyobj_handle type_GuidHelper_Meta{PyType_FromSpec(&type_spec_GuidHelper_Meta)};
    if (!type_GuidHelper_Meta)
    {
        return nullptr;
    }

    state->type_GuidHelper = py::register_python_type(module.get(), type_name_GuidHelper, &type_spec_GuidHelper, nullptr, reinterpret_cast<PyTypeObject*>(type_GuidHelper_Meta.get()));
    if (!state->type_GuidHelper)
    {
        return nullptr;
    }

    state->type_MemoryBuffer = py::register_python_type(module.get(), type_name_MemoryBuffer, &type_spec_MemoryBuffer, bases.get(), nullptr);
    if (!state->type_MemoryBuffer)
    {
        return nullptr;
    }

    state->type_PropertyValue = py::register_python_type(module.get(), type_name_PropertyValue, &type_spec_PropertyValue, nullptr, nullptr);
    if (!state->type_PropertyValue)
    {
        return nullptr;
    }

    state->type_Uri = py::register_python_type(module.get(), type_name_Uri, &type_spec_Uri, bases.get(), nullptr);
    if (!state->type_Uri)
    {
        return nullptr;
    }

    state->type_WwwFormUrlDecoder = py::register_python_type(module.get(), type_name_WwwFormUrlDecoder, &type_spec_WwwFormUrlDecoder, sequence_bases.get(), nullptr);
    if (!state->type_WwwFormUrlDecoder)
    {
        return nullptr;
    }

    state->type_WwwFormUrlDecoderEntry = py::register_python_type(module.get(), type_name_WwwFormUrlDecoderEntry, &type_spec_WwwFormUrlDecoderEntry, bases.get(), nullptr);
    if (!state->type_WwwFormUrlDecoderEntry)
    {
        return nullptr;
    }

    state->type_IAsyncAction = py::register_python_type(module.get(), type_name_IAsyncAction, &type_spec_IAsyncAction, bases.get(), nullptr);
    if (!state->type_IAsyncAction)
    {
        return nullptr;
    }

    state->type_IAsyncActionWithProgress = py::register_python_type(module.get(), type_name_IAsyncActionWithProgress, &type_spec_IAsyncActionWithProgress, bases.get(), nullptr);
    if (!state->type_IAsyncActionWithProgress)
    {
        return nullptr;
    }

    state->type_IAsyncInfo = py::register_python_type(module.get(), type_name_IAsyncInfo, &type_spec_IAsyncInfo, bases.get(), nullptr);
    if (!state->type_IAsyncInfo)
    {
        return nullptr;
    }

    state->type_IAsyncOperationWithProgress = py::register_python_type(module.get(), type_name_IAsyncOperationWithProgress, &type_spec_IAsyncOperationWithProgress, bases.get(), nullptr);
    if (!state->type_IAsyncOperationWithProgress)
    {
        return nullptr;
    }

    state->type_IAsyncOperation = py::register_python_type(module.get(), type_name_IAsyncOperation, &type_spec_IAsyncOperation, bases.get(), nullptr);
    if (!state->type_IAsyncOperation)
    {
        return nullptr;
    }

    state->type_IClosable = py::register_python_type(module.get(), type_name_IClosable, &type_spec_IClosable, bases.get(), nullptr);
    if (!state->type_IClosable)
    {
        return nullptr;
    }

    state->type_IGetActivationFactory = py::register_python_type(module.get(), type_name_IGetActivationFactory, &type_spec_IGetActivationFactory, bases.get(), nullptr);
    if (!state->type_IGetActivationFactory)
    {
        return nullptr;
    }

    state->type_IMemoryBuffer = py::register_python_type(module.get(), type_name_IMemoryBuffer, &type_spec_IMemoryBuffer, bases.get(), nullptr);
    if (!state->type_IMemoryBuffer)
    {
        return nullptr;
    }

    state->type_IMemoryBufferReference = py::register_python_type(module.get(), type_name_IMemoryBufferReference, &type_spec_IMemoryBufferReference, bases.get(), nullptr);
    if (!state->type_IMemoryBufferReference)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    state->type_IMemoryBufferReference->tp_as_buffer = &_PyBufferProcs_IMemoryBufferReference;
    #endif

    state->type_IPropertyValue = py::register_python_type(module.get(), type_name_IPropertyValue, &type_spec_IPropertyValue, bases.get(), nullptr);
    if (!state->type_IPropertyValue)
    {
        return nullptr;
    }

    state->type_IReferenceArray = py::register_python_type(module.get(), type_name_IReferenceArray, &type_spec_IReferenceArray, bases.get(), nullptr);
    if (!state->type_IReferenceArray)
    {
        return nullptr;
    }

    state->type_IReference = py::register_python_type(module.get(), type_name_IReference, &type_spec_IReference, bases.get(), nullptr);
    if (!state->type_IReference)
    {
        return nullptr;
    }

    state->type_IStringable = py::register_python_type(module.get(), type_name_IStringable, &type_spec_IStringable, bases.get(), nullptr);
    if (!state->type_IStringable)
    {
        return nullptr;
    }

    state->type_IWwwFormUrlDecoderEntry = py::register_python_type(module.get(), type_name_IWwwFormUrlDecoderEntry, &type_spec_IWwwFormUrlDecoderEntry, bases.get(), nullptr);
    if (!state->type_IWwwFormUrlDecoderEntry)
    {
        return nullptr;
    }

    state->type_EventRegistrationToken = py::register_python_type(module.get(), type_name_EventRegistrationToken, &type_spec_EventRegistrationToken, bases.get(), nullptr);
    if (!state->type_EventRegistrationToken)
    {
        return nullptr;
    }

    state->type_HResult = py::register_python_type(module.get(), type_name_HResult, &type_spec_HResult, bases.get(), nullptr);
    if (!state->type_HResult)
    {
        return nullptr;
    }

    state->type_Point = py::register_python_type(module.get(), type_name_Point, &type_spec_Point, bases.get(), nullptr);
    if (!state->type_Point)
    {
        return nullptr;
    }

    state->type_Rect = py::register_python_type(module.get(), type_name_Rect, &type_spec_Rect, bases.get(), nullptr);
    if (!state->type_Rect)
    {
        return nullptr;
    }

    state->type_Size = py::register_python_type(module.get(), type_name_Size, &type_spec_Size, bases.get(), nullptr);
    if (!state->type_Size)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Foundation::AsyncStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AsyncStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Foundation::AsyncStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Foundation::PropertyType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PropertyType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Foundation::PropertyType is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Deferral>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Deferral;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Foundation::Deferral is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::GuidHelper>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GuidHelper;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Foundation::GuidHelper is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::MemoryBuffer>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MemoryBuffer;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Foundation::MemoryBuffer is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::PropertyValue>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PropertyValue;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Foundation::PropertyValue is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Uri>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Uri;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Foundation::Uri is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::WwwFormUrlDecoder>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WwwFormUrlDecoder;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Foundation::WwwFormUrlDecoder is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WwwFormUrlDecoderEntry;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Foundation::WwwFormUrlDecoderEntry is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IAsyncAction>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IAsyncAction;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Foundation::IAsyncAction is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<py::proj::Windows::Foundation::IAsyncActionWithProgress>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IAsyncActionWithProgress;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type py::proj::Windows::Foundation::IAsyncActionWithProgress is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IAsyncInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IAsyncInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Foundation::IAsyncInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<py::proj::Windows::Foundation::IAsyncOperationWithProgress>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IAsyncOperationWithProgress;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type py::proj::Windows::Foundation::IAsyncOperationWithProgress is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<py::proj::Windows::Foundation::IAsyncOperation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IAsyncOperation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type py::proj::Windows::Foundation::IAsyncOperation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IClosable>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IClosable;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Foundation::IClosable is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IGetActivationFactory>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IGetActivationFactory;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Foundation::IGetActivationFactory is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IMemoryBuffer>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IMemoryBuffer;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Foundation::IMemoryBuffer is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IMemoryBufferReference>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IMemoryBufferReference;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Foundation::IMemoryBufferReference is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IPropertyValue>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IPropertyValue;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Foundation::IPropertyValue is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<py::proj::Windows::Foundation::IReferenceArray>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IReferenceArray;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type py::proj::Windows::Foundation::IReferenceArray is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<py::proj::Windows::Foundation::IReference>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IReference;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type py::proj::Windows::Foundation::IReference is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IStringable>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IStringable;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Foundation::IStringable is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IWwwFormUrlDecoderEntry;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Foundation::IWwwFormUrlDecoderEntry is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::event_token>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EventRegistrationToken;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::event_token is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::hresult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::hresult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Point>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Point;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Foundation::Point is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Rect>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Rect;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Foundation::Rect is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Size>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Foundation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Foundation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Size;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Foundation::Size is not registered");
        return nullptr;
    }

    return python_type;
}
