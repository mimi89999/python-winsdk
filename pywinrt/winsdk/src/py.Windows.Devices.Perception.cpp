// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.Devices.Perception.h"


namespace py::cpp::Windows::Devices::Perception
{
    struct module_state
    {
        PyObject* type_PerceptionFrameSourceAccessStatus;
        PyObject* type_PerceptionFrameSourcePropertyChangeStatus;
        PyTypeObject* type_KnownCameraIntrinsicsProperties;
        PyTypeObject* type_KnownPerceptionColorFrameSourceProperties;
        PyTypeObject* type_KnownPerceptionDepthFrameSourceProperties;
        PyTypeObject* type_KnownPerceptionFrameSourceProperties;
        PyTypeObject* type_KnownPerceptionInfraredFrameSourceProperties;
        PyTypeObject* type_KnownPerceptionVideoFrameSourceProperties;
        PyTypeObject* type_KnownPerceptionVideoProfileProperties;
        PyTypeObject* type_PerceptionColorFrame;
        PyTypeObject* type_PerceptionColorFrameArrivedEventArgs;
        PyTypeObject* type_PerceptionColorFrameReader;
        PyTypeObject* type_PerceptionColorFrameSource;
        PyTypeObject* type_PerceptionColorFrameSourceAddedEventArgs;
        PyTypeObject* type_PerceptionColorFrameSourceRemovedEventArgs;
        PyTypeObject* type_PerceptionColorFrameSourceWatcher;
        PyTypeObject* type_PerceptionControlSession;
        PyTypeObject* type_PerceptionDepthCorrelatedCameraIntrinsics;
        PyTypeObject* type_PerceptionDepthCorrelatedCoordinateMapper;
        PyTypeObject* type_PerceptionDepthFrame;
        PyTypeObject* type_PerceptionDepthFrameArrivedEventArgs;
        PyTypeObject* type_PerceptionDepthFrameReader;
        PyTypeObject* type_PerceptionDepthFrameSource;
        PyTypeObject* type_PerceptionDepthFrameSourceAddedEventArgs;
        PyTypeObject* type_PerceptionDepthFrameSourceRemovedEventArgs;
        PyTypeObject* type_PerceptionDepthFrameSourceWatcher;
        PyTypeObject* type_PerceptionFrameSourcePropertiesChangedEventArgs;
        PyTypeObject* type_PerceptionFrameSourcePropertyChangeResult;
        PyTypeObject* type_PerceptionInfraredFrame;
        PyTypeObject* type_PerceptionInfraredFrameArrivedEventArgs;
        PyTypeObject* type_PerceptionInfraredFrameReader;
        PyTypeObject* type_PerceptionInfraredFrameSource;
        PyTypeObject* type_PerceptionInfraredFrameSourceAddedEventArgs;
        PyTypeObject* type_PerceptionInfraredFrameSourceRemovedEventArgs;
        PyTypeObject* type_PerceptionInfraredFrameSourceWatcher;
        PyTypeObject* type_PerceptionVideoProfile;
    };

    static PyObject* register_PerceptionFrameSourceAccessStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PerceptionFrameSourceAccessStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PerceptionFrameSourceAccessStatus = type;
        Py_INCREF(state->type_PerceptionFrameSourceAccessStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_PerceptionFrameSourcePropertyChangeStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PerceptionFrameSourcePropertyChangeStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PerceptionFrameSourcePropertyChangeStatus = type;
        Py_INCREF(state->type_PerceptionFrameSourcePropertyChangeStatus);


        Py_RETURN_NONE;
    }

    // ----- KnownCameraIntrinsicsProperties class --------------------
    static constexpr const char* const type_name_KnownCameraIntrinsicsProperties = "KnownCameraIntrinsicsProperties";

    static PyObject* _new_KnownCameraIntrinsicsProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownCameraIntrinsicsProperties);
        return nullptr;
    }

    static PyObject* KnownCameraIntrinsicsProperties_get_FocalLength(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownCameraIntrinsicsProperties", L"FocalLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownCameraIntrinsicsProperties::FocalLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownCameraIntrinsicsProperties_get_PrincipalPoint(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownCameraIntrinsicsProperties", L"PrincipalPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownCameraIntrinsicsProperties::PrincipalPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownCameraIntrinsicsProperties_get_RadialDistortion(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownCameraIntrinsicsProperties", L"RadialDistortion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownCameraIntrinsicsProperties::RadialDistortion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownCameraIntrinsicsProperties_get_TangentialDistortion(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownCameraIntrinsicsProperties", L"TangentialDistortion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownCameraIntrinsicsProperties::TangentialDistortion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownCameraIntrinsicsProperties[] = {
        { }
    };

    static PyGetSetDef _getset_KnownCameraIntrinsicsProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownCameraIntrinsicsProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownCameraIntrinsicsProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownCameraIntrinsicsProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownCameraIntrinsicsProperties) },
        { },
    };

    static PyType_Spec type_spec_KnownCameraIntrinsicsProperties =
    {
        "_winsdk_Windows_Devices_Perception.KnownCameraIntrinsicsProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownCameraIntrinsicsProperties
    };

    static PyGetSetDef getset_KnownCameraIntrinsicsProperties_Meta[] = {
        { "focal_length", reinterpret_cast<getter>(KnownCameraIntrinsicsProperties_get_FocalLength), nullptr, nullptr, nullptr },
        { "principal_point", reinterpret_cast<getter>(KnownCameraIntrinsicsProperties_get_PrincipalPoint), nullptr, nullptr, nullptr },
        { "radial_distortion", reinterpret_cast<getter>(KnownCameraIntrinsicsProperties_get_RadialDistortion), nullptr, nullptr, nullptr },
        { "tangential_distortion", reinterpret_cast<getter>(KnownCameraIntrinsicsProperties_get_TangentialDistortion), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_KnownCameraIntrinsicsProperties_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownCameraIntrinsicsProperties_Meta) },
        { }
    };

    static PyType_Spec type_spec_KnownCameraIntrinsicsProperties_Meta =
    {
        "_winsdk_Windows_Devices_Perception.KnownCameraIntrinsicsProperties_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownCameraIntrinsicsProperties_Meta
    };

    // ----- KnownPerceptionColorFrameSourceProperties class --------------------
    static constexpr const char* const type_name_KnownPerceptionColorFrameSourceProperties = "KnownPerceptionColorFrameSourceProperties";

    static PyObject* _new_KnownPerceptionColorFrameSourceProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownPerceptionColorFrameSourceProperties);
        return nullptr;
    }

    static PyObject* KnownPerceptionColorFrameSourceProperties_get_AutoExposureEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionColorFrameSourceProperties", L"AutoExposureEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionColorFrameSourceProperties::AutoExposureEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionColorFrameSourceProperties_get_Exposure(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionColorFrameSourceProperties", L"Exposure"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionColorFrameSourceProperties::Exposure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionColorFrameSourceProperties_get_ExposureCompensation(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionColorFrameSourceProperties", L"ExposureCompensation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionColorFrameSourceProperties::ExposureCompensation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownPerceptionColorFrameSourceProperties[] = {
        { }
    };

    static PyGetSetDef _getset_KnownPerceptionColorFrameSourceProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownPerceptionColorFrameSourceProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownPerceptionColorFrameSourceProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownPerceptionColorFrameSourceProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownPerceptionColorFrameSourceProperties) },
        { },
    };

    static PyType_Spec type_spec_KnownPerceptionColorFrameSourceProperties =
    {
        "_winsdk_Windows_Devices_Perception.KnownPerceptionColorFrameSourceProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownPerceptionColorFrameSourceProperties
    };

    static PyGetSetDef getset_KnownPerceptionColorFrameSourceProperties_Meta[] = {
        { "auto_exposure_enabled", reinterpret_cast<getter>(KnownPerceptionColorFrameSourceProperties_get_AutoExposureEnabled), nullptr, nullptr, nullptr },
        { "exposure", reinterpret_cast<getter>(KnownPerceptionColorFrameSourceProperties_get_Exposure), nullptr, nullptr, nullptr },
        { "exposure_compensation", reinterpret_cast<getter>(KnownPerceptionColorFrameSourceProperties_get_ExposureCompensation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_KnownPerceptionColorFrameSourceProperties_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownPerceptionColorFrameSourceProperties_Meta) },
        { }
    };

    static PyType_Spec type_spec_KnownPerceptionColorFrameSourceProperties_Meta =
    {
        "_winsdk_Windows_Devices_Perception.KnownPerceptionColorFrameSourceProperties_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownPerceptionColorFrameSourceProperties_Meta
    };

    // ----- KnownPerceptionDepthFrameSourceProperties class --------------------
    static constexpr const char* const type_name_KnownPerceptionDepthFrameSourceProperties = "KnownPerceptionDepthFrameSourceProperties";

    static PyObject* _new_KnownPerceptionDepthFrameSourceProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownPerceptionDepthFrameSourceProperties);
        return nullptr;
    }

    static PyObject* KnownPerceptionDepthFrameSourceProperties_get_MaxDepth(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionDepthFrameSourceProperties", L"MaxDepth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionDepthFrameSourceProperties::MaxDepth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionDepthFrameSourceProperties_get_MinDepth(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionDepthFrameSourceProperties", L"MinDepth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionDepthFrameSourceProperties::MinDepth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownPerceptionDepthFrameSourceProperties[] = {
        { }
    };

    static PyGetSetDef _getset_KnownPerceptionDepthFrameSourceProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownPerceptionDepthFrameSourceProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownPerceptionDepthFrameSourceProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownPerceptionDepthFrameSourceProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownPerceptionDepthFrameSourceProperties) },
        { },
    };

    static PyType_Spec type_spec_KnownPerceptionDepthFrameSourceProperties =
    {
        "_winsdk_Windows_Devices_Perception.KnownPerceptionDepthFrameSourceProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownPerceptionDepthFrameSourceProperties
    };

    static PyGetSetDef getset_KnownPerceptionDepthFrameSourceProperties_Meta[] = {
        { "max_depth", reinterpret_cast<getter>(KnownPerceptionDepthFrameSourceProperties_get_MaxDepth), nullptr, nullptr, nullptr },
        { "min_depth", reinterpret_cast<getter>(KnownPerceptionDepthFrameSourceProperties_get_MinDepth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_KnownPerceptionDepthFrameSourceProperties_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownPerceptionDepthFrameSourceProperties_Meta) },
        { }
    };

    static PyType_Spec type_spec_KnownPerceptionDepthFrameSourceProperties_Meta =
    {
        "_winsdk_Windows_Devices_Perception.KnownPerceptionDepthFrameSourceProperties_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownPerceptionDepthFrameSourceProperties_Meta
    };

    // ----- KnownPerceptionFrameSourceProperties class --------------------
    static constexpr const char* const type_name_KnownPerceptionFrameSourceProperties = "KnownPerceptionFrameSourceProperties";

    static PyObject* _new_KnownPerceptionFrameSourceProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownPerceptionFrameSourceProperties);
        return nullptr;
    }

    static PyObject* KnownPerceptionFrameSourceProperties_get_DeviceModelVersion(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionFrameSourceProperties", L"DeviceModelVersion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionFrameSourceProperties::DeviceModelVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionFrameSourceProperties_get_EnclosureLocation(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionFrameSourceProperties", L"EnclosureLocation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionFrameSourceProperties::EnclosureLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionFrameSourceProperties_get_FrameKind(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionFrameSourceProperties", L"FrameKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionFrameSourceProperties::FrameKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionFrameSourceProperties_get_Id(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionFrameSourceProperties", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionFrameSourceProperties::Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionFrameSourceProperties_get_PhysicalDeviceIds(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionFrameSourceProperties", L"PhysicalDeviceIds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionFrameSourceProperties::PhysicalDeviceIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionFrameSourceProperties_get_DeviceId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionFrameSourceProperties", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionFrameSourceProperties::DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownPerceptionFrameSourceProperties[] = {
        { }
    };

    static PyGetSetDef _getset_KnownPerceptionFrameSourceProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownPerceptionFrameSourceProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownPerceptionFrameSourceProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownPerceptionFrameSourceProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownPerceptionFrameSourceProperties) },
        { },
    };

    static PyType_Spec type_spec_KnownPerceptionFrameSourceProperties =
    {
        "_winsdk_Windows_Devices_Perception.KnownPerceptionFrameSourceProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownPerceptionFrameSourceProperties
    };

    static PyGetSetDef getset_KnownPerceptionFrameSourceProperties_Meta[] = {
        { "device_model_version", reinterpret_cast<getter>(KnownPerceptionFrameSourceProperties_get_DeviceModelVersion), nullptr, nullptr, nullptr },
        { "enclosure_location", reinterpret_cast<getter>(KnownPerceptionFrameSourceProperties_get_EnclosureLocation), nullptr, nullptr, nullptr },
        { "frame_kind", reinterpret_cast<getter>(KnownPerceptionFrameSourceProperties_get_FrameKind), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(KnownPerceptionFrameSourceProperties_get_Id), nullptr, nullptr, nullptr },
        { "physical_device_ids", reinterpret_cast<getter>(KnownPerceptionFrameSourceProperties_get_PhysicalDeviceIds), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(KnownPerceptionFrameSourceProperties_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_KnownPerceptionFrameSourceProperties_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownPerceptionFrameSourceProperties_Meta) },
        { }
    };

    static PyType_Spec type_spec_KnownPerceptionFrameSourceProperties_Meta =
    {
        "_winsdk_Windows_Devices_Perception.KnownPerceptionFrameSourceProperties_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownPerceptionFrameSourceProperties_Meta
    };

    // ----- KnownPerceptionInfraredFrameSourceProperties class --------------------
    static constexpr const char* const type_name_KnownPerceptionInfraredFrameSourceProperties = "KnownPerceptionInfraredFrameSourceProperties";

    static PyObject* _new_KnownPerceptionInfraredFrameSourceProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownPerceptionInfraredFrameSourceProperties);
        return nullptr;
    }

    static PyObject* KnownPerceptionInfraredFrameSourceProperties_get_ActiveIlluminationEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionInfraredFrameSourceProperties", L"ActiveIlluminationEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionInfraredFrameSourceProperties::ActiveIlluminationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionInfraredFrameSourceProperties_get_AmbientSubtractionEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionInfraredFrameSourceProperties", L"AmbientSubtractionEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionInfraredFrameSourceProperties::AmbientSubtractionEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionInfraredFrameSourceProperties_get_AutoExposureEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionInfraredFrameSourceProperties", L"AutoExposureEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionInfraredFrameSourceProperties::AutoExposureEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionInfraredFrameSourceProperties_get_Exposure(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionInfraredFrameSourceProperties", L"Exposure"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionInfraredFrameSourceProperties::Exposure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionInfraredFrameSourceProperties_get_ExposureCompensation(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionInfraredFrameSourceProperties", L"ExposureCompensation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionInfraredFrameSourceProperties::ExposureCompensation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionInfraredFrameSourceProperties_get_InterleavedIlluminationEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionInfraredFrameSourceProperties", L"InterleavedIlluminationEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionInfraredFrameSourceProperties::InterleavedIlluminationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionInfraredFrameSourceProperties_get_StructureLightPatternEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionInfraredFrameSourceProperties", L"StructureLightPatternEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionInfraredFrameSourceProperties::StructureLightPatternEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownPerceptionInfraredFrameSourceProperties[] = {
        { }
    };

    static PyGetSetDef _getset_KnownPerceptionInfraredFrameSourceProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownPerceptionInfraredFrameSourceProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownPerceptionInfraredFrameSourceProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownPerceptionInfraredFrameSourceProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownPerceptionInfraredFrameSourceProperties) },
        { },
    };

    static PyType_Spec type_spec_KnownPerceptionInfraredFrameSourceProperties =
    {
        "_winsdk_Windows_Devices_Perception.KnownPerceptionInfraredFrameSourceProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownPerceptionInfraredFrameSourceProperties
    };

    static PyGetSetDef getset_KnownPerceptionInfraredFrameSourceProperties_Meta[] = {
        { "active_illumination_enabled", reinterpret_cast<getter>(KnownPerceptionInfraredFrameSourceProperties_get_ActiveIlluminationEnabled), nullptr, nullptr, nullptr },
        { "ambient_subtraction_enabled", reinterpret_cast<getter>(KnownPerceptionInfraredFrameSourceProperties_get_AmbientSubtractionEnabled), nullptr, nullptr, nullptr },
        { "auto_exposure_enabled", reinterpret_cast<getter>(KnownPerceptionInfraredFrameSourceProperties_get_AutoExposureEnabled), nullptr, nullptr, nullptr },
        { "exposure", reinterpret_cast<getter>(KnownPerceptionInfraredFrameSourceProperties_get_Exposure), nullptr, nullptr, nullptr },
        { "exposure_compensation", reinterpret_cast<getter>(KnownPerceptionInfraredFrameSourceProperties_get_ExposureCompensation), nullptr, nullptr, nullptr },
        { "interleaved_illumination_enabled", reinterpret_cast<getter>(KnownPerceptionInfraredFrameSourceProperties_get_InterleavedIlluminationEnabled), nullptr, nullptr, nullptr },
        { "structure_light_pattern_enabled", reinterpret_cast<getter>(KnownPerceptionInfraredFrameSourceProperties_get_StructureLightPatternEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_KnownPerceptionInfraredFrameSourceProperties_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownPerceptionInfraredFrameSourceProperties_Meta) },
        { }
    };

    static PyType_Spec type_spec_KnownPerceptionInfraredFrameSourceProperties_Meta =
    {
        "_winsdk_Windows_Devices_Perception.KnownPerceptionInfraredFrameSourceProperties_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownPerceptionInfraredFrameSourceProperties_Meta
    };

    // ----- KnownPerceptionVideoFrameSourceProperties class --------------------
    static constexpr const char* const type_name_KnownPerceptionVideoFrameSourceProperties = "KnownPerceptionVideoFrameSourceProperties";

    static PyObject* _new_KnownPerceptionVideoFrameSourceProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownPerceptionVideoFrameSourceProperties);
        return nullptr;
    }

    static PyObject* KnownPerceptionVideoFrameSourceProperties_get_AvailableVideoProfiles(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionVideoFrameSourceProperties", L"AvailableVideoProfiles"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoFrameSourceProperties::AvailableVideoProfiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionVideoFrameSourceProperties_get_CameraIntrinsics(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionVideoFrameSourceProperties", L"CameraIntrinsics"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoFrameSourceProperties::CameraIntrinsics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionVideoFrameSourceProperties_get_IsMirrored(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionVideoFrameSourceProperties", L"IsMirrored"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoFrameSourceProperties::IsMirrored());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionVideoFrameSourceProperties_get_SupportedVideoProfiles(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionVideoFrameSourceProperties", L"SupportedVideoProfiles"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoFrameSourceProperties::SupportedVideoProfiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionVideoFrameSourceProperties_get_VideoProfile(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionVideoFrameSourceProperties", L"VideoProfile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoFrameSourceProperties::VideoProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownPerceptionVideoFrameSourceProperties[] = {
        { }
    };

    static PyGetSetDef _getset_KnownPerceptionVideoFrameSourceProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownPerceptionVideoFrameSourceProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownPerceptionVideoFrameSourceProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownPerceptionVideoFrameSourceProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownPerceptionVideoFrameSourceProperties) },
        { },
    };

    static PyType_Spec type_spec_KnownPerceptionVideoFrameSourceProperties =
    {
        "_winsdk_Windows_Devices_Perception.KnownPerceptionVideoFrameSourceProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownPerceptionVideoFrameSourceProperties
    };

    static PyGetSetDef getset_KnownPerceptionVideoFrameSourceProperties_Meta[] = {
        { "available_video_profiles", reinterpret_cast<getter>(KnownPerceptionVideoFrameSourceProperties_get_AvailableVideoProfiles), nullptr, nullptr, nullptr },
        { "camera_intrinsics", reinterpret_cast<getter>(KnownPerceptionVideoFrameSourceProperties_get_CameraIntrinsics), nullptr, nullptr, nullptr },
        { "is_mirrored", reinterpret_cast<getter>(KnownPerceptionVideoFrameSourceProperties_get_IsMirrored), nullptr, nullptr, nullptr },
        { "supported_video_profiles", reinterpret_cast<getter>(KnownPerceptionVideoFrameSourceProperties_get_SupportedVideoProfiles), nullptr, nullptr, nullptr },
        { "video_profile", reinterpret_cast<getter>(KnownPerceptionVideoFrameSourceProperties_get_VideoProfile), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_KnownPerceptionVideoFrameSourceProperties_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownPerceptionVideoFrameSourceProperties_Meta) },
        { }
    };

    static PyType_Spec type_spec_KnownPerceptionVideoFrameSourceProperties_Meta =
    {
        "_winsdk_Windows_Devices_Perception.KnownPerceptionVideoFrameSourceProperties_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownPerceptionVideoFrameSourceProperties_Meta
    };

    // ----- KnownPerceptionVideoProfileProperties class --------------------
    static constexpr const char* const type_name_KnownPerceptionVideoProfileProperties = "KnownPerceptionVideoProfileProperties";

    static PyObject* _new_KnownPerceptionVideoProfileProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownPerceptionVideoProfileProperties);
        return nullptr;
    }

    static PyObject* KnownPerceptionVideoProfileProperties_get_BitmapAlphaMode(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionVideoProfileProperties", L"BitmapAlphaMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoProfileProperties::BitmapAlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionVideoProfileProperties_get_BitmapPixelFormat(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionVideoProfileProperties", L"BitmapPixelFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoProfileProperties::BitmapPixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionVideoProfileProperties_get_FrameDuration(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionVideoProfileProperties", L"FrameDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoProfileProperties::FrameDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionVideoProfileProperties_get_Height(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionVideoProfileProperties", L"Height"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoProfileProperties::Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionVideoProfileProperties_get_Width(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionVideoProfileProperties", L"Width"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoProfileProperties::Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownPerceptionVideoProfileProperties[] = {
        { }
    };

    static PyGetSetDef _getset_KnownPerceptionVideoProfileProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownPerceptionVideoProfileProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownPerceptionVideoProfileProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownPerceptionVideoProfileProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownPerceptionVideoProfileProperties) },
        { },
    };

    static PyType_Spec type_spec_KnownPerceptionVideoProfileProperties =
    {
        "_winsdk_Windows_Devices_Perception.KnownPerceptionVideoProfileProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownPerceptionVideoProfileProperties
    };

    static PyGetSetDef getset_KnownPerceptionVideoProfileProperties_Meta[] = {
        { "bitmap_alpha_mode", reinterpret_cast<getter>(KnownPerceptionVideoProfileProperties_get_BitmapAlphaMode), nullptr, nullptr, nullptr },
        { "bitmap_pixel_format", reinterpret_cast<getter>(KnownPerceptionVideoProfileProperties_get_BitmapPixelFormat), nullptr, nullptr, nullptr },
        { "frame_duration", reinterpret_cast<getter>(KnownPerceptionVideoProfileProperties_get_FrameDuration), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(KnownPerceptionVideoProfileProperties_get_Height), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(KnownPerceptionVideoProfileProperties_get_Width), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_KnownPerceptionVideoProfileProperties_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownPerceptionVideoProfileProperties_Meta) },
        { }
    };

    static PyType_Spec type_spec_KnownPerceptionVideoProfileProperties_Meta =
    {
        "_winsdk_Windows_Devices_Perception.KnownPerceptionVideoProfileProperties_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownPerceptionVideoProfileProperties_Meta
    };

    // ----- PerceptionColorFrame class --------------------
    static constexpr const char* const type_name_PerceptionColorFrame = "PerceptionColorFrame";

    static PyObject* _new_PerceptionColorFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionColorFrame);
        return nullptr;
    }

    static void _dealloc_PerceptionColorFrame(py::wrapper::Windows::Devices::Perception::PerceptionColorFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionColorFrame_Close(py::wrapper::Windows::Devices::Perception::PerceptionColorFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrame", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrame_get_VideoFrame(py::wrapper::Windows::Devices::Perception::PerceptionColorFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrame", L"VideoFrame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionColorFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionColorFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionColorFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionColorFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PerceptionColorFrame(py::wrapper::Windows::Devices::Perception::PerceptionColorFrame* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_PerceptionColorFrame(py::wrapper::Windows::Devices::Perception::PerceptionColorFrame* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionColorFrame[] = {
        { "close", reinterpret_cast<PyCFunction>(PerceptionColorFrame_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PerceptionColorFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionColorFrame), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_PerceptionColorFrame), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_PerceptionColorFrame), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionColorFrame[] = {
        { "video_frame", reinterpret_cast<getter>(PerceptionColorFrame_get_VideoFrame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionColorFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionColorFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionColorFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionColorFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionColorFrame) },
        { },
    };

    static PyType_Spec type_spec_PerceptionColorFrame =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionColorFrame",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionColorFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionColorFrame
    };

    // ----- PerceptionColorFrameArrivedEventArgs class --------------------
    static constexpr const char* const type_name_PerceptionColorFrameArrivedEventArgs = "PerceptionColorFrameArrivedEventArgs";

    static PyObject* _new_PerceptionColorFrameArrivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionColorFrameArrivedEventArgs);
        return nullptr;
    }

    static void _dealloc_PerceptionColorFrameArrivedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameArrivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionColorFrameArrivedEventArgs_TryOpenFrame(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameArrivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameArrivedEventArgs", L"TryOpenFrame", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryOpenFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameArrivedEventArgs_get_RelativeTime(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameArrivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameArrivedEventArgs", L"RelativeTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionColorFrameArrivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionColorFrameArrivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionColorFrameArrivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionColorFrameArrivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionColorFrameArrivedEventArgs[] = {
        { "try_open_frame", reinterpret_cast<PyCFunction>(PerceptionColorFrameArrivedEventArgs_TryOpenFrame), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PerceptionColorFrameArrivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionColorFrameArrivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionColorFrameArrivedEventArgs[] = {
        { "relative_time", reinterpret_cast<getter>(PerceptionColorFrameArrivedEventArgs_get_RelativeTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionColorFrameArrivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionColorFrameArrivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionColorFrameArrivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionColorFrameArrivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionColorFrameArrivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PerceptionColorFrameArrivedEventArgs =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionColorFrameArrivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameArrivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionColorFrameArrivedEventArgs
    };

    // ----- PerceptionColorFrameReader class --------------------
    static constexpr const char* const type_name_PerceptionColorFrameReader = "PerceptionColorFrameReader";

    static PyObject* _new_PerceptionColorFrameReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionColorFrameReader);
        return nullptr;
    }

    static void _dealloc_PerceptionColorFrameReader(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionColorFrameReader_Close(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameReader", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameReader_TryReadLatestFrame(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameReader", L"TryReadLatestFrame", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryReadLatestFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameReader_get_IsPaused(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameReader", L"IsPaused"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPaused());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PerceptionColorFrameReader_put_IsPaused(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameReader", L"IsPaused"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPaused(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PerceptionColorFrameReader_get_Source(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameReader", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameReader_add_FrameArrived(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameReader", L"FrameArrived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameReader, winrt::Windows::Devices::Perception::PerceptionColorFrameArrivedEventArgs>>(arg);

            return py::convert(self->obj.FrameArrived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameReader_remove_FrameArrived(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameReader", L"FrameArrived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FrameArrived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionColorFrameReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionColorFrameReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionColorFrameReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionColorFrameReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PerceptionColorFrameReader(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_PerceptionColorFrameReader(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionColorFrameReader[] = {
        { "close", reinterpret_cast<PyCFunction>(PerceptionColorFrameReader_Close), METH_VARARGS, nullptr },
        { "try_read_latest_frame", reinterpret_cast<PyCFunction>(PerceptionColorFrameReader_TryReadLatestFrame), METH_VARARGS, nullptr },
        { "add_frame_arrived", reinterpret_cast<PyCFunction>(PerceptionColorFrameReader_add_FrameArrived), METH_O, nullptr },
        { "remove_frame_arrived", reinterpret_cast<PyCFunction>(PerceptionColorFrameReader_remove_FrameArrived), METH_O, nullptr },
        { "_assign_array_", _assign_array_PerceptionColorFrameReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionColorFrameReader), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_PerceptionColorFrameReader), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_PerceptionColorFrameReader), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionColorFrameReader[] = {
        { "is_paused", reinterpret_cast<getter>(PerceptionColorFrameReader_get_IsPaused), reinterpret_cast<setter>(PerceptionColorFrameReader_put_IsPaused), nullptr, nullptr },
        { "source", reinterpret_cast<getter>(PerceptionColorFrameReader_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionColorFrameReader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionColorFrameReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionColorFrameReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionColorFrameReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionColorFrameReader) },
        { },
    };

    static PyType_Spec type_spec_PerceptionColorFrameReader =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionColorFrameReader",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionColorFrameReader
    };

    // ----- PerceptionColorFrameSource class --------------------
    static constexpr const char* const type_name_PerceptionColorFrameSource = "PerceptionColorFrameSource";

    static PyObject* _new_PerceptionColorFrameSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionColorFrameSource);
        return nullptr;
    }

    static void _dealloc_PerceptionColorFrameSource(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionColorFrameSource_AcquireControlSession(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"AcquireControlSession", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.AcquireControlSession());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_CanControlIndependentlyFrom(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"CanControlIndependentlyFrom", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CanControlIndependentlyFrom(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_CreateWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"CreateWatcher", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Perception::PerceptionColorFrameSource::CreateWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_FindAllAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"FindAllAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Perception::PerceptionColorFrameSource::FindAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Perception::PerceptionColorFrameSource::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_IsCorrelatedWith(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"IsCorrelatedWith", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsCorrelatedWith(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_OpenReader(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"OpenReader", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.OpenReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_RequestAccessAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"RequestAccessAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Perception::PerceptionColorFrameSource::RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_TryGetDepthCorrelatedCameraIntrinsicsAsync(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"TryGetDepthCorrelatedCameraIntrinsicsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource>(args, 0);

                return py::convert(self->obj.TryGetDepthCorrelatedCameraIntrinsicsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_TryGetDepthCorrelatedCoordinateMapperAsync(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"TryGetDepthCorrelatedCoordinateMapperAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource>(args, 1);

                return py::convert(self->obj.TryGetDepthCorrelatedCoordinateMapperAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_TryGetTransformTo(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"TryGetTransformTo", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Foundation::Numerics::float4x4 param1 {  };

                auto return_value = self->obj.TryGetTransformTo(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_TrySetVideoProfileAsync(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"TrySetVideoProfileAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionControlSession>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionVideoProfile>(args, 1);

                return py::convert(self->obj.TrySetVideoProfileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_Active(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"Active"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Active());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_Available(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"Available"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Available());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_AvailableVideoProfiles(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"AvailableVideoProfiles"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AvailableVideoProfiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_CameraIntrinsics(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"CameraIntrinsics"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CameraIntrinsics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_DeviceKind(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"DeviceKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_DisplayName(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_Id(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_IsControlled(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"IsControlled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsControlled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_Properties(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_SupportedVideoProfiles(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"SupportedVideoProfiles"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedVideoProfiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_VideoProfile(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"VideoProfile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_DeviceId(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_add_ActiveChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"ActiveChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ActiveChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_remove_ActiveChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"ActiveChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ActiveChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_add_AvailableChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"AvailableChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AvailableChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_remove_AvailableChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"AvailableChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AvailableChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_add_CameraIntrinsicsChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"CameraIntrinsicsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CameraIntrinsicsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_remove_CameraIntrinsicsChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"CameraIntrinsicsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CameraIntrinsicsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_add_PropertiesChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"PropertiesChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameSource, winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs>>(arg);

            return py::convert(self->obj.PropertiesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_remove_PropertiesChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"PropertiesChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PropertiesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_add_VideoProfileChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"VideoProfileChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VideoProfileChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_remove_VideoProfileChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"VideoProfileChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VideoProfileChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionColorFrameSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionColorFrameSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionColorFrameSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionColorFrameSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionColorFrameSource[] = {
        { "acquire_control_session", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_AcquireControlSession), METH_VARARGS, nullptr },
        { "can_control_independently_from", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_CanControlIndependentlyFrom), METH_VARARGS, nullptr },
        { "create_watcher", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_CreateWatcher), METH_VARARGS | METH_STATIC, nullptr },
        { "find_all_async", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_FindAllAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "is_correlated_with", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_IsCorrelatedWith), METH_VARARGS, nullptr },
        { "open_reader", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_OpenReader), METH_VARARGS, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_RequestAccessAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "try_get_depth_correlated_camera_intrinsics_async", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_TryGetDepthCorrelatedCameraIntrinsicsAsync), METH_VARARGS, nullptr },
        { "try_get_depth_correlated_coordinate_mapper_async", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_TryGetDepthCorrelatedCoordinateMapperAsync), METH_VARARGS, nullptr },
        { "try_get_transform_to", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_TryGetTransformTo), METH_VARARGS, nullptr },
        { "try_set_video_profile_async", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_TrySetVideoProfileAsync), METH_VARARGS, nullptr },
        { "add_active_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_add_ActiveChanged), METH_O, nullptr },
        { "remove_active_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_remove_ActiveChanged), METH_O, nullptr },
        { "add_available_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_add_AvailableChanged), METH_O, nullptr },
        { "remove_available_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_remove_AvailableChanged), METH_O, nullptr },
        { "add_camera_intrinsics_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_add_CameraIntrinsicsChanged), METH_O, nullptr },
        { "remove_camera_intrinsics_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_remove_CameraIntrinsicsChanged), METH_O, nullptr },
        { "add_properties_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_add_PropertiesChanged), METH_O, nullptr },
        { "remove_properties_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_remove_PropertiesChanged), METH_O, nullptr },
        { "add_video_profile_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_add_VideoProfileChanged), METH_O, nullptr },
        { "remove_video_profile_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_remove_VideoProfileChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_PerceptionColorFrameSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionColorFrameSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionColorFrameSource[] = {
        { "active", reinterpret_cast<getter>(PerceptionColorFrameSource_get_Active), nullptr, nullptr, nullptr },
        { "available", reinterpret_cast<getter>(PerceptionColorFrameSource_get_Available), nullptr, nullptr, nullptr },
        { "available_video_profiles", reinterpret_cast<getter>(PerceptionColorFrameSource_get_AvailableVideoProfiles), nullptr, nullptr, nullptr },
        { "camera_intrinsics", reinterpret_cast<getter>(PerceptionColorFrameSource_get_CameraIntrinsics), nullptr, nullptr, nullptr },
        { "device_kind", reinterpret_cast<getter>(PerceptionColorFrameSource_get_DeviceKind), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PerceptionColorFrameSource_get_DisplayName), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(PerceptionColorFrameSource_get_Id), nullptr, nullptr, nullptr },
        { "is_controlled", reinterpret_cast<getter>(PerceptionColorFrameSource_get_IsControlled), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(PerceptionColorFrameSource_get_Properties), nullptr, nullptr, nullptr },
        { "supported_video_profiles", reinterpret_cast<getter>(PerceptionColorFrameSource_get_SupportedVideoProfiles), nullptr, nullptr, nullptr },
        { "video_profile", reinterpret_cast<getter>(PerceptionColorFrameSource_get_VideoProfile), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(PerceptionColorFrameSource_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionColorFrameSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionColorFrameSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionColorFrameSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionColorFrameSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionColorFrameSource) },
        { },
    };

    static PyType_Spec type_spec_PerceptionColorFrameSource =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionColorFrameSource",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionColorFrameSource
    };

    // ----- PerceptionColorFrameSourceAddedEventArgs class --------------------
    static constexpr const char* const type_name_PerceptionColorFrameSourceAddedEventArgs = "PerceptionColorFrameSourceAddedEventArgs";

    static PyObject* _new_PerceptionColorFrameSourceAddedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionColorFrameSourceAddedEventArgs);
        return nullptr;
    }

    static void _dealloc_PerceptionColorFrameSourceAddedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceAddedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionColorFrameSourceAddedEventArgs_get_FrameSource(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceAddedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSourceAddedEventArgs", L"FrameSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionColorFrameSourceAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceAddedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionColorFrameSourceAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceAddedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionColorFrameSourceAddedEventArgs[] = {
        { "_assign_array_", _assign_array_PerceptionColorFrameSourceAddedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionColorFrameSourceAddedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionColorFrameSourceAddedEventArgs[] = {
        { "frame_source", reinterpret_cast<getter>(PerceptionColorFrameSourceAddedEventArgs_get_FrameSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionColorFrameSourceAddedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionColorFrameSourceAddedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionColorFrameSourceAddedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionColorFrameSourceAddedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionColorFrameSourceAddedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PerceptionColorFrameSourceAddedEventArgs =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionColorFrameSourceAddedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceAddedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionColorFrameSourceAddedEventArgs
    };

    // ----- PerceptionColorFrameSourceRemovedEventArgs class --------------------
    static constexpr const char* const type_name_PerceptionColorFrameSourceRemovedEventArgs = "PerceptionColorFrameSourceRemovedEventArgs";

    static PyObject* _new_PerceptionColorFrameSourceRemovedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionColorFrameSourceRemovedEventArgs);
        return nullptr;
    }

    static void _dealloc_PerceptionColorFrameSourceRemovedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceRemovedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionColorFrameSourceRemovedEventArgs_get_FrameSource(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceRemovedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSourceRemovedEventArgs", L"FrameSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionColorFrameSourceRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceRemovedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionColorFrameSourceRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceRemovedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionColorFrameSourceRemovedEventArgs[] = {
        { "_assign_array_", _assign_array_PerceptionColorFrameSourceRemovedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionColorFrameSourceRemovedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionColorFrameSourceRemovedEventArgs[] = {
        { "frame_source", reinterpret_cast<getter>(PerceptionColorFrameSourceRemovedEventArgs_get_FrameSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionColorFrameSourceRemovedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionColorFrameSourceRemovedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionColorFrameSourceRemovedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionColorFrameSourceRemovedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionColorFrameSourceRemovedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PerceptionColorFrameSourceRemovedEventArgs =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionColorFrameSourceRemovedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceRemovedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionColorFrameSourceRemovedEventArgs
    };

    // ----- PerceptionColorFrameSourceWatcher class --------------------
    static constexpr const char* const type_name_PerceptionColorFrameSourceWatcher = "PerceptionColorFrameSourceWatcher";

    static PyObject* _new_PerceptionColorFrameSourceWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionColorFrameSourceWatcher);
        return nullptr;
    }

    static void _dealloc_PerceptionColorFrameSourceWatcher(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionColorFrameSourceWatcher_Start(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSourceWatcher", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_Stop(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSourceWatcher", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_get_Status(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSourceWatcher", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_add_EnumerationCompleted(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSourceWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_remove_EnumerationCompleted(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSourceWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_add_SourceAdded(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSourceWatcher", L"SourceAdded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher, winrt::Windows::Devices::Perception::PerceptionColorFrameSourceAddedEventArgs>>(arg);

            return py::convert(self->obj.SourceAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_remove_SourceAdded(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSourceWatcher", L"SourceAdded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_add_SourceRemoved(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSourceWatcher", L"SourceRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher, winrt::Windows::Devices::Perception::PerceptionColorFrameSourceRemovedEventArgs>>(arg);

            return py::convert(self->obj.SourceRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_remove_SourceRemoved(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSourceWatcher", L"SourceRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_add_Stopped(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSourceWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_remove_Stopped(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSourceWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionColorFrameSourceWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionColorFrameSourceWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionColorFrameSourceWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_Stop), METH_VARARGS, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_source_added", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_add_SourceAdded), METH_O, nullptr },
        { "remove_source_added", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_remove_SourceAdded), METH_O, nullptr },
        { "add_source_removed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_add_SourceRemoved), METH_O, nullptr },
        { "remove_source_removed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_remove_SourceRemoved), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_remove_Stopped), METH_O, nullptr },
        { "_assign_array_", _assign_array_PerceptionColorFrameSourceWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionColorFrameSourceWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionColorFrameSourceWatcher[] = {
        { "status", reinterpret_cast<getter>(PerceptionColorFrameSourceWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionColorFrameSourceWatcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionColorFrameSourceWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionColorFrameSourceWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionColorFrameSourceWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionColorFrameSourceWatcher) },
        { },
    };

    static PyType_Spec type_spec_PerceptionColorFrameSourceWatcher =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionColorFrameSourceWatcher",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionColorFrameSourceWatcher
    };

    // ----- PerceptionControlSession class --------------------
    static constexpr const char* const type_name_PerceptionControlSession = "PerceptionControlSession";

    static PyObject* _new_PerceptionControlSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionControlSession);
        return nullptr;
    }

    static void _dealloc_PerceptionControlSession(py::wrapper::Windows::Devices::Perception::PerceptionControlSession* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionControlSession_Close(py::wrapper::Windows::Devices::Perception::PerceptionControlSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionControlSession", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionControlSession_TrySetPropertyAsync(py::wrapper::Windows::Devices::Perception::PerceptionControlSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionControlSession", L"TrySetPropertyAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.TrySetPropertyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionControlSession_add_ControlLost(py::wrapper::Windows::Devices::Perception::PerceptionControlSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionControlSession", L"ControlLost"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionControlSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ControlLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionControlSession_remove_ControlLost(py::wrapper::Windows::Devices::Perception::PerceptionControlSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionControlSession", L"ControlLost"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ControlLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionControlSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionControlSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionControlSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionControlSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PerceptionControlSession(py::wrapper::Windows::Devices::Perception::PerceptionControlSession* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_PerceptionControlSession(py::wrapper::Windows::Devices::Perception::PerceptionControlSession* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionControlSession[] = {
        { "close", reinterpret_cast<PyCFunction>(PerceptionControlSession_Close), METH_VARARGS, nullptr },
        { "try_set_property_async", reinterpret_cast<PyCFunction>(PerceptionControlSession_TrySetPropertyAsync), METH_VARARGS, nullptr },
        { "add_control_lost", reinterpret_cast<PyCFunction>(PerceptionControlSession_add_ControlLost), METH_O, nullptr },
        { "remove_control_lost", reinterpret_cast<PyCFunction>(PerceptionControlSession_remove_ControlLost), METH_O, nullptr },
        { "_assign_array_", _assign_array_PerceptionControlSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionControlSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_PerceptionControlSession), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_PerceptionControlSession), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionControlSession[] = {
        { }
    };

    static PyType_Slot _type_slots_PerceptionControlSession[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionControlSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionControlSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionControlSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionControlSession) },
        { },
    };

    static PyType_Spec type_spec_PerceptionControlSession =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionControlSession",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionControlSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionControlSession
    };

    // ----- PerceptionDepthCorrelatedCameraIntrinsics class --------------------
    static constexpr const char* const type_name_PerceptionDepthCorrelatedCameraIntrinsics = "PerceptionDepthCorrelatedCameraIntrinsics";

    static PyObject* _new_PerceptionDepthCorrelatedCameraIntrinsics(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionDepthCorrelatedCameraIntrinsics);
        return nullptr;
    }

    static void _dealloc_PerceptionDepthCorrelatedCameraIntrinsics(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionDepthCorrelatedCameraIntrinsics_UnprojectAllPixelsAtCorrelatedDepthAsync(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthCorrelatedCameraIntrinsics", L"UnprojectAllPixelsAtCorrelatedDepthAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrame>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Numerics::float3, true>>(args, 1);

                return py::convert(self->obj.UnprojectAllPixelsAtCorrelatedDepthAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthCorrelatedCameraIntrinsics_UnprojectPixelAtCorrelatedDepth(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthCorrelatedCameraIntrinsics", L"UnprojectPixelAtCorrelatedDepth", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrame>(args, 1);

                return py::convert(self->obj.UnprojectPixelAtCorrelatedDepth(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthCorrelatedCameraIntrinsics_UnprojectPixelsAtCorrelatedDepth(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthCorrelatedCameraIntrinsics", L"UnprojectPixelsAtCorrelatedDepth", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrame>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Numerics::float3, true>>(args, 2);

                self->obj.UnprojectPixelsAtCorrelatedDepth(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthCorrelatedCameraIntrinsics_UnprojectRegionPixelsAtCorrelatedDepthAsync(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthCorrelatedCameraIntrinsics", L"UnprojectRegionPixelsAtCorrelatedDepthAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrame>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Numerics::float3, true>>(args, 2);

                return py::convert(self->obj.UnprojectRegionPixelsAtCorrelatedDepthAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionDepthCorrelatedCameraIntrinsics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionDepthCorrelatedCameraIntrinsics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionDepthCorrelatedCameraIntrinsics[] = {
        { "unproject_all_pixels_at_correlated_depth_async", reinterpret_cast<PyCFunction>(PerceptionDepthCorrelatedCameraIntrinsics_UnprojectAllPixelsAtCorrelatedDepthAsync), METH_VARARGS, nullptr },
        { "unproject_pixel_at_correlated_depth", reinterpret_cast<PyCFunction>(PerceptionDepthCorrelatedCameraIntrinsics_UnprojectPixelAtCorrelatedDepth), METH_VARARGS, nullptr },
        { "unproject_pixels_at_correlated_depth", reinterpret_cast<PyCFunction>(PerceptionDepthCorrelatedCameraIntrinsics_UnprojectPixelsAtCorrelatedDepth), METH_VARARGS, nullptr },
        { "unproject_region_pixels_at_correlated_depth_async", reinterpret_cast<PyCFunction>(PerceptionDepthCorrelatedCameraIntrinsics_UnprojectRegionPixelsAtCorrelatedDepthAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PerceptionDepthCorrelatedCameraIntrinsics, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionDepthCorrelatedCameraIntrinsics), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionDepthCorrelatedCameraIntrinsics[] = {
        { }
    };

    static PyType_Slot _type_slots_PerceptionDepthCorrelatedCameraIntrinsics[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionDepthCorrelatedCameraIntrinsics) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionDepthCorrelatedCameraIntrinsics) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionDepthCorrelatedCameraIntrinsics) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionDepthCorrelatedCameraIntrinsics) },
        { },
    };

    static PyType_Spec type_spec_PerceptionDepthCorrelatedCameraIntrinsics =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionDepthCorrelatedCameraIntrinsics",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionDepthCorrelatedCameraIntrinsics
    };

    // ----- PerceptionDepthCorrelatedCoordinateMapper class --------------------
    static constexpr const char* const type_name_PerceptionDepthCorrelatedCoordinateMapper = "PerceptionDepthCorrelatedCoordinateMapper";

    static PyObject* _new_PerceptionDepthCorrelatedCoordinateMapper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionDepthCorrelatedCoordinateMapper);
        return nullptr;
    }

    static void _dealloc_PerceptionDepthCorrelatedCoordinateMapper(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionDepthCorrelatedCoordinateMapper_MapAllPixelsToTargetAsync(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthCorrelatedCoordinateMapper", L"MapAllPixelsToTargetAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrame>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, true>>(args, 1);

                return py::convert(self->obj.MapAllPixelsToTargetAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthCorrelatedCoordinateMapper_MapPixelToTarget(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthCorrelatedCoordinateMapper", L"MapPixelToTarget", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrame>(args, 1);

                return py::convert(self->obj.MapPixelToTarget(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthCorrelatedCoordinateMapper_MapPixelsToTarget(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthCorrelatedCoordinateMapper", L"MapPixelsToTarget", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrame>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, true>>(args, 2);

                self->obj.MapPixelsToTarget(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthCorrelatedCoordinateMapper_MapRegionOfPixelsToTargetAsync(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthCorrelatedCoordinateMapper", L"MapRegionOfPixelsToTargetAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrame>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, true>>(args, 2);

                return py::convert(self->obj.MapRegionOfPixelsToTargetAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionDepthCorrelatedCoordinateMapper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionDepthCorrelatedCoordinateMapper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionDepthCorrelatedCoordinateMapper[] = {
        { "map_all_pixels_to_target_async", reinterpret_cast<PyCFunction>(PerceptionDepthCorrelatedCoordinateMapper_MapAllPixelsToTargetAsync), METH_VARARGS, nullptr },
        { "map_pixel_to_target", reinterpret_cast<PyCFunction>(PerceptionDepthCorrelatedCoordinateMapper_MapPixelToTarget), METH_VARARGS, nullptr },
        { "map_pixels_to_target", reinterpret_cast<PyCFunction>(PerceptionDepthCorrelatedCoordinateMapper_MapPixelsToTarget), METH_VARARGS, nullptr },
        { "map_region_of_pixels_to_target_async", reinterpret_cast<PyCFunction>(PerceptionDepthCorrelatedCoordinateMapper_MapRegionOfPixelsToTargetAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PerceptionDepthCorrelatedCoordinateMapper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionDepthCorrelatedCoordinateMapper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionDepthCorrelatedCoordinateMapper[] = {
        { }
    };

    static PyType_Slot _type_slots_PerceptionDepthCorrelatedCoordinateMapper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionDepthCorrelatedCoordinateMapper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionDepthCorrelatedCoordinateMapper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionDepthCorrelatedCoordinateMapper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionDepthCorrelatedCoordinateMapper) },
        { },
    };

    static PyType_Spec type_spec_PerceptionDepthCorrelatedCoordinateMapper =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionDepthCorrelatedCoordinateMapper",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionDepthCorrelatedCoordinateMapper
    };

    // ----- PerceptionDepthFrame class --------------------
    static constexpr const char* const type_name_PerceptionDepthFrame = "PerceptionDepthFrame";

    static PyObject* _new_PerceptionDepthFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionDepthFrame);
        return nullptr;
    }

    static void _dealloc_PerceptionDepthFrame(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionDepthFrame_Close(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrame", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrame_get_VideoFrame(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrame", L"VideoFrame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionDepthFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionDepthFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionDepthFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionDepthFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PerceptionDepthFrame(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrame* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_PerceptionDepthFrame(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrame* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionDepthFrame[] = {
        { "close", reinterpret_cast<PyCFunction>(PerceptionDepthFrame_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PerceptionDepthFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionDepthFrame), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_PerceptionDepthFrame), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_PerceptionDepthFrame), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionDepthFrame[] = {
        { "video_frame", reinterpret_cast<getter>(PerceptionDepthFrame_get_VideoFrame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionDepthFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionDepthFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionDepthFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionDepthFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionDepthFrame) },
        { },
    };

    static PyType_Spec type_spec_PerceptionDepthFrame =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionDepthFrame",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionDepthFrame
    };

    // ----- PerceptionDepthFrameArrivedEventArgs class --------------------
    static constexpr const char* const type_name_PerceptionDepthFrameArrivedEventArgs = "PerceptionDepthFrameArrivedEventArgs";

    static PyObject* _new_PerceptionDepthFrameArrivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionDepthFrameArrivedEventArgs);
        return nullptr;
    }

    static void _dealloc_PerceptionDepthFrameArrivedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameArrivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionDepthFrameArrivedEventArgs_TryOpenFrame(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameArrivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameArrivedEventArgs", L"TryOpenFrame", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryOpenFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameArrivedEventArgs_get_RelativeTime(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameArrivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameArrivedEventArgs", L"RelativeTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionDepthFrameArrivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionDepthFrameArrivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionDepthFrameArrivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionDepthFrameArrivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionDepthFrameArrivedEventArgs[] = {
        { "try_open_frame", reinterpret_cast<PyCFunction>(PerceptionDepthFrameArrivedEventArgs_TryOpenFrame), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PerceptionDepthFrameArrivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionDepthFrameArrivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionDepthFrameArrivedEventArgs[] = {
        { "relative_time", reinterpret_cast<getter>(PerceptionDepthFrameArrivedEventArgs_get_RelativeTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionDepthFrameArrivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionDepthFrameArrivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionDepthFrameArrivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionDepthFrameArrivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionDepthFrameArrivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PerceptionDepthFrameArrivedEventArgs =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionDepthFrameArrivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameArrivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionDepthFrameArrivedEventArgs
    };

    // ----- PerceptionDepthFrameReader class --------------------
    static constexpr const char* const type_name_PerceptionDepthFrameReader = "PerceptionDepthFrameReader";

    static PyObject* _new_PerceptionDepthFrameReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionDepthFrameReader);
        return nullptr;
    }

    static void _dealloc_PerceptionDepthFrameReader(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionDepthFrameReader_Close(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameReader", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameReader_TryReadLatestFrame(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameReader", L"TryReadLatestFrame", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryReadLatestFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameReader_get_IsPaused(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameReader", L"IsPaused"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPaused());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PerceptionDepthFrameReader_put_IsPaused(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameReader", L"IsPaused"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPaused(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PerceptionDepthFrameReader_get_Source(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameReader", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameReader_add_FrameArrived(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameReader", L"FrameArrived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameReader, winrt::Windows::Devices::Perception::PerceptionDepthFrameArrivedEventArgs>>(arg);

            return py::convert(self->obj.FrameArrived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameReader_remove_FrameArrived(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameReader", L"FrameArrived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FrameArrived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionDepthFrameReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionDepthFrameReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionDepthFrameReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionDepthFrameReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PerceptionDepthFrameReader(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_PerceptionDepthFrameReader(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionDepthFrameReader[] = {
        { "close", reinterpret_cast<PyCFunction>(PerceptionDepthFrameReader_Close), METH_VARARGS, nullptr },
        { "try_read_latest_frame", reinterpret_cast<PyCFunction>(PerceptionDepthFrameReader_TryReadLatestFrame), METH_VARARGS, nullptr },
        { "add_frame_arrived", reinterpret_cast<PyCFunction>(PerceptionDepthFrameReader_add_FrameArrived), METH_O, nullptr },
        { "remove_frame_arrived", reinterpret_cast<PyCFunction>(PerceptionDepthFrameReader_remove_FrameArrived), METH_O, nullptr },
        { "_assign_array_", _assign_array_PerceptionDepthFrameReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionDepthFrameReader), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_PerceptionDepthFrameReader), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_PerceptionDepthFrameReader), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionDepthFrameReader[] = {
        { "is_paused", reinterpret_cast<getter>(PerceptionDepthFrameReader_get_IsPaused), reinterpret_cast<setter>(PerceptionDepthFrameReader_put_IsPaused), nullptr, nullptr },
        { "source", reinterpret_cast<getter>(PerceptionDepthFrameReader_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionDepthFrameReader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionDepthFrameReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionDepthFrameReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionDepthFrameReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionDepthFrameReader) },
        { },
    };

    static PyType_Spec type_spec_PerceptionDepthFrameReader =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionDepthFrameReader",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionDepthFrameReader
    };

    // ----- PerceptionDepthFrameSource class --------------------
    static constexpr const char* const type_name_PerceptionDepthFrameSource = "PerceptionDepthFrameSource";

    static PyObject* _new_PerceptionDepthFrameSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionDepthFrameSource);
        return nullptr;
    }

    static void _dealloc_PerceptionDepthFrameSource(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionDepthFrameSource_AcquireControlSession(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"AcquireControlSession", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.AcquireControlSession());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_CanControlIndependentlyFrom(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"CanControlIndependentlyFrom", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CanControlIndependentlyFrom(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_CreateWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"CreateWatcher", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Perception::PerceptionDepthFrameSource::CreateWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_FindAllAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"FindAllAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Perception::PerceptionDepthFrameSource::FindAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Perception::PerceptionDepthFrameSource::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_IsCorrelatedWith(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"IsCorrelatedWith", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsCorrelatedWith(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_OpenReader(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"OpenReader", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.OpenReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_RequestAccessAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"RequestAccessAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Perception::PerceptionDepthFrameSource::RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_TryGetDepthCorrelatedCameraIntrinsicsAsync(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"TryGetDepthCorrelatedCameraIntrinsicsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource>(args, 0);

                return py::convert(self->obj.TryGetDepthCorrelatedCameraIntrinsicsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_TryGetDepthCorrelatedCoordinateMapperAsync(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"TryGetDepthCorrelatedCoordinateMapperAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource>(args, 1);

                return py::convert(self->obj.TryGetDepthCorrelatedCoordinateMapperAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_TryGetTransformTo(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"TryGetTransformTo", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Foundation::Numerics::float4x4 param1 {  };

                auto return_value = self->obj.TryGetTransformTo(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_TrySetVideoProfileAsync(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"TrySetVideoProfileAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionControlSession>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionVideoProfile>(args, 1);

                return py::convert(self->obj.TrySetVideoProfileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_Active(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"Active"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Active());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_Available(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"Available"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Available());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_AvailableVideoProfiles(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"AvailableVideoProfiles"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AvailableVideoProfiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_CameraIntrinsics(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"CameraIntrinsics"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CameraIntrinsics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_DeviceKind(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"DeviceKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_DisplayName(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_Id(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_IsControlled(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"IsControlled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsControlled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_Properties(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_SupportedVideoProfiles(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"SupportedVideoProfiles"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedVideoProfiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_VideoProfile(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"VideoProfile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_DeviceId(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_add_ActiveChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"ActiveChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ActiveChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_remove_ActiveChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"ActiveChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ActiveChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_add_AvailableChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"AvailableChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AvailableChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_remove_AvailableChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"AvailableChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AvailableChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_add_CameraIntrinsicsChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"CameraIntrinsicsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CameraIntrinsicsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_remove_CameraIntrinsicsChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"CameraIntrinsicsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CameraIntrinsicsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_add_PropertiesChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"PropertiesChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource, winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs>>(arg);

            return py::convert(self->obj.PropertiesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_remove_PropertiesChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"PropertiesChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PropertiesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_add_VideoProfileChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"VideoProfileChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VideoProfileChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_remove_VideoProfileChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"VideoProfileChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VideoProfileChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionDepthFrameSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionDepthFrameSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionDepthFrameSource[] = {
        { "acquire_control_session", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_AcquireControlSession), METH_VARARGS, nullptr },
        { "can_control_independently_from", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_CanControlIndependentlyFrom), METH_VARARGS, nullptr },
        { "create_watcher", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_CreateWatcher), METH_VARARGS | METH_STATIC, nullptr },
        { "find_all_async", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_FindAllAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "is_correlated_with", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_IsCorrelatedWith), METH_VARARGS, nullptr },
        { "open_reader", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_OpenReader), METH_VARARGS, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_RequestAccessAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "try_get_depth_correlated_camera_intrinsics_async", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_TryGetDepthCorrelatedCameraIntrinsicsAsync), METH_VARARGS, nullptr },
        { "try_get_depth_correlated_coordinate_mapper_async", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_TryGetDepthCorrelatedCoordinateMapperAsync), METH_VARARGS, nullptr },
        { "try_get_transform_to", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_TryGetTransformTo), METH_VARARGS, nullptr },
        { "try_set_video_profile_async", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_TrySetVideoProfileAsync), METH_VARARGS, nullptr },
        { "add_active_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_add_ActiveChanged), METH_O, nullptr },
        { "remove_active_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_remove_ActiveChanged), METH_O, nullptr },
        { "add_available_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_add_AvailableChanged), METH_O, nullptr },
        { "remove_available_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_remove_AvailableChanged), METH_O, nullptr },
        { "add_camera_intrinsics_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_add_CameraIntrinsicsChanged), METH_O, nullptr },
        { "remove_camera_intrinsics_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_remove_CameraIntrinsicsChanged), METH_O, nullptr },
        { "add_properties_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_add_PropertiesChanged), METH_O, nullptr },
        { "remove_properties_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_remove_PropertiesChanged), METH_O, nullptr },
        { "add_video_profile_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_add_VideoProfileChanged), METH_O, nullptr },
        { "remove_video_profile_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_remove_VideoProfileChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_PerceptionDepthFrameSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionDepthFrameSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionDepthFrameSource[] = {
        { "active", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_Active), nullptr, nullptr, nullptr },
        { "available", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_Available), nullptr, nullptr, nullptr },
        { "available_video_profiles", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_AvailableVideoProfiles), nullptr, nullptr, nullptr },
        { "camera_intrinsics", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_CameraIntrinsics), nullptr, nullptr, nullptr },
        { "device_kind", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_DeviceKind), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_DisplayName), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_Id), nullptr, nullptr, nullptr },
        { "is_controlled", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_IsControlled), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_Properties), nullptr, nullptr, nullptr },
        { "supported_video_profiles", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_SupportedVideoProfiles), nullptr, nullptr, nullptr },
        { "video_profile", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_VideoProfile), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionDepthFrameSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionDepthFrameSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionDepthFrameSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionDepthFrameSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionDepthFrameSource) },
        { },
    };

    static PyType_Spec type_spec_PerceptionDepthFrameSource =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionDepthFrameSource",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionDepthFrameSource
    };

    // ----- PerceptionDepthFrameSourceAddedEventArgs class --------------------
    static constexpr const char* const type_name_PerceptionDepthFrameSourceAddedEventArgs = "PerceptionDepthFrameSourceAddedEventArgs";

    static PyObject* _new_PerceptionDepthFrameSourceAddedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionDepthFrameSourceAddedEventArgs);
        return nullptr;
    }

    static void _dealloc_PerceptionDepthFrameSourceAddedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceAddedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionDepthFrameSourceAddedEventArgs_get_FrameSource(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceAddedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSourceAddedEventArgs", L"FrameSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionDepthFrameSourceAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceAddedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionDepthFrameSourceAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceAddedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionDepthFrameSourceAddedEventArgs[] = {
        { "_assign_array_", _assign_array_PerceptionDepthFrameSourceAddedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionDepthFrameSourceAddedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionDepthFrameSourceAddedEventArgs[] = {
        { "frame_source", reinterpret_cast<getter>(PerceptionDepthFrameSourceAddedEventArgs_get_FrameSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionDepthFrameSourceAddedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionDepthFrameSourceAddedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionDepthFrameSourceAddedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionDepthFrameSourceAddedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionDepthFrameSourceAddedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PerceptionDepthFrameSourceAddedEventArgs =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionDepthFrameSourceAddedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceAddedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionDepthFrameSourceAddedEventArgs
    };

    // ----- PerceptionDepthFrameSourceRemovedEventArgs class --------------------
    static constexpr const char* const type_name_PerceptionDepthFrameSourceRemovedEventArgs = "PerceptionDepthFrameSourceRemovedEventArgs";

    static PyObject* _new_PerceptionDepthFrameSourceRemovedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionDepthFrameSourceRemovedEventArgs);
        return nullptr;
    }

    static void _dealloc_PerceptionDepthFrameSourceRemovedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceRemovedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionDepthFrameSourceRemovedEventArgs_get_FrameSource(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceRemovedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSourceRemovedEventArgs", L"FrameSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionDepthFrameSourceRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceRemovedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionDepthFrameSourceRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceRemovedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionDepthFrameSourceRemovedEventArgs[] = {
        { "_assign_array_", _assign_array_PerceptionDepthFrameSourceRemovedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionDepthFrameSourceRemovedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionDepthFrameSourceRemovedEventArgs[] = {
        { "frame_source", reinterpret_cast<getter>(PerceptionDepthFrameSourceRemovedEventArgs_get_FrameSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionDepthFrameSourceRemovedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionDepthFrameSourceRemovedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionDepthFrameSourceRemovedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionDepthFrameSourceRemovedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionDepthFrameSourceRemovedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PerceptionDepthFrameSourceRemovedEventArgs =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionDepthFrameSourceRemovedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceRemovedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionDepthFrameSourceRemovedEventArgs
    };

    // ----- PerceptionDepthFrameSourceWatcher class --------------------
    static constexpr const char* const type_name_PerceptionDepthFrameSourceWatcher = "PerceptionDepthFrameSourceWatcher";

    static PyObject* _new_PerceptionDepthFrameSourceWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionDepthFrameSourceWatcher);
        return nullptr;
    }

    static void _dealloc_PerceptionDepthFrameSourceWatcher(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_Start(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_Stop(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_get_Status(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_add_EnumerationCompleted(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_remove_EnumerationCompleted(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_add_SourceAdded(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher", L"SourceAdded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher, winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceAddedEventArgs>>(arg);

            return py::convert(self->obj.SourceAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_remove_SourceAdded(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher", L"SourceAdded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_add_SourceRemoved(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher", L"SourceRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher, winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceRemovedEventArgs>>(arg);

            return py::convert(self->obj.SourceRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_remove_SourceRemoved(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher", L"SourceRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_add_Stopped(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_remove_Stopped(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionDepthFrameSourceWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionDepthFrameSourceWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionDepthFrameSourceWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_Stop), METH_VARARGS, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_source_added", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_add_SourceAdded), METH_O, nullptr },
        { "remove_source_added", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_remove_SourceAdded), METH_O, nullptr },
        { "add_source_removed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_add_SourceRemoved), METH_O, nullptr },
        { "remove_source_removed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_remove_SourceRemoved), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_remove_Stopped), METH_O, nullptr },
        { "_assign_array_", _assign_array_PerceptionDepthFrameSourceWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionDepthFrameSourceWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionDepthFrameSourceWatcher[] = {
        { "status", reinterpret_cast<getter>(PerceptionDepthFrameSourceWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionDepthFrameSourceWatcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionDepthFrameSourceWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionDepthFrameSourceWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionDepthFrameSourceWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionDepthFrameSourceWatcher) },
        { },
    };

    static PyType_Spec type_spec_PerceptionDepthFrameSourceWatcher =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionDepthFrameSourceWatcher",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionDepthFrameSourceWatcher
    };

    // ----- PerceptionFrameSourcePropertiesChangedEventArgs class --------------------
    static constexpr const char* const type_name_PerceptionFrameSourcePropertiesChangedEventArgs = "PerceptionFrameSourcePropertiesChangedEventArgs";

    static PyObject* _new_PerceptionFrameSourcePropertiesChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionFrameSourcePropertiesChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_PerceptionFrameSourcePropertiesChangedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionFrameSourcePropertiesChangedEventArgs_get_CollectionChange(py::wrapper::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionFrameSourcePropertiesChangedEventArgs", L"CollectionChange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CollectionChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionFrameSourcePropertiesChangedEventArgs_get_Key(py::wrapper::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionFrameSourcePropertiesChangedEventArgs", L"Key"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Key());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionFrameSourcePropertiesChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionFrameSourcePropertiesChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionFrameSourcePropertiesChangedEventArgs[] = {
        { "_assign_array_", _assign_array_PerceptionFrameSourcePropertiesChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionFrameSourcePropertiesChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionFrameSourcePropertiesChangedEventArgs[] = {
        { "collection_change", reinterpret_cast<getter>(PerceptionFrameSourcePropertiesChangedEventArgs_get_CollectionChange), nullptr, nullptr, nullptr },
        { "key", reinterpret_cast<getter>(PerceptionFrameSourcePropertiesChangedEventArgs_get_Key), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionFrameSourcePropertiesChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionFrameSourcePropertiesChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionFrameSourcePropertiesChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionFrameSourcePropertiesChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionFrameSourcePropertiesChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PerceptionFrameSourcePropertiesChangedEventArgs =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionFrameSourcePropertiesChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionFrameSourcePropertiesChangedEventArgs
    };

    // ----- PerceptionFrameSourcePropertyChangeResult class --------------------
    static constexpr const char* const type_name_PerceptionFrameSourcePropertyChangeResult = "PerceptionFrameSourcePropertyChangeResult";

    static PyObject* _new_PerceptionFrameSourcePropertyChangeResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionFrameSourcePropertyChangeResult);
        return nullptr;
    }

    static void _dealloc_PerceptionFrameSourcePropertyChangeResult(py::wrapper::Windows::Devices::Perception::PerceptionFrameSourcePropertyChangeResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionFrameSourcePropertyChangeResult_get_NewValue(py::wrapper::Windows::Devices::Perception::PerceptionFrameSourcePropertyChangeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeResult", L"NewValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionFrameSourcePropertyChangeResult_get_Status(py::wrapper::Windows::Devices::Perception::PerceptionFrameSourcePropertyChangeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionFrameSourcePropertyChangeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertyChangeResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionFrameSourcePropertyChangeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertyChangeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionFrameSourcePropertyChangeResult[] = {
        { "_assign_array_", _assign_array_PerceptionFrameSourcePropertyChangeResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionFrameSourcePropertyChangeResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionFrameSourcePropertyChangeResult[] = {
        { "new_value", reinterpret_cast<getter>(PerceptionFrameSourcePropertyChangeResult_get_NewValue), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(PerceptionFrameSourcePropertyChangeResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionFrameSourcePropertyChangeResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionFrameSourcePropertyChangeResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionFrameSourcePropertyChangeResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionFrameSourcePropertyChangeResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionFrameSourcePropertyChangeResult) },
        { },
    };

    static PyType_Spec type_spec_PerceptionFrameSourcePropertyChangeResult =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionFrameSourcePropertyChangeResult",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionFrameSourcePropertyChangeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionFrameSourcePropertyChangeResult
    };

    // ----- PerceptionInfraredFrame class --------------------
    static constexpr const char* const type_name_PerceptionInfraredFrame = "PerceptionInfraredFrame";

    static PyObject* _new_PerceptionInfraredFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionInfraredFrame);
        return nullptr;
    }

    static void _dealloc_PerceptionInfraredFrame(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionInfraredFrame_Close(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrame", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrame_get_VideoFrame(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrame", L"VideoFrame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionInfraredFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionInfraredFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionInfraredFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionInfraredFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PerceptionInfraredFrame(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrame* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_PerceptionInfraredFrame(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrame* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionInfraredFrame[] = {
        { "close", reinterpret_cast<PyCFunction>(PerceptionInfraredFrame_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PerceptionInfraredFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionInfraredFrame), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_PerceptionInfraredFrame), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_PerceptionInfraredFrame), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionInfraredFrame[] = {
        { "video_frame", reinterpret_cast<getter>(PerceptionInfraredFrame_get_VideoFrame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionInfraredFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionInfraredFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionInfraredFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionInfraredFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionInfraredFrame) },
        { },
    };

    static PyType_Spec type_spec_PerceptionInfraredFrame =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionInfraredFrame",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionInfraredFrame
    };

    // ----- PerceptionInfraredFrameArrivedEventArgs class --------------------
    static constexpr const char* const type_name_PerceptionInfraredFrameArrivedEventArgs = "PerceptionInfraredFrameArrivedEventArgs";

    static PyObject* _new_PerceptionInfraredFrameArrivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionInfraredFrameArrivedEventArgs);
        return nullptr;
    }

    static void _dealloc_PerceptionInfraredFrameArrivedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameArrivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionInfraredFrameArrivedEventArgs_TryOpenFrame(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameArrivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameArrivedEventArgs", L"TryOpenFrame", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryOpenFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameArrivedEventArgs_get_RelativeTime(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameArrivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameArrivedEventArgs", L"RelativeTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionInfraredFrameArrivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionInfraredFrameArrivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionInfraredFrameArrivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionInfraredFrameArrivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionInfraredFrameArrivedEventArgs[] = {
        { "try_open_frame", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameArrivedEventArgs_TryOpenFrame), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PerceptionInfraredFrameArrivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionInfraredFrameArrivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionInfraredFrameArrivedEventArgs[] = {
        { "relative_time", reinterpret_cast<getter>(PerceptionInfraredFrameArrivedEventArgs_get_RelativeTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionInfraredFrameArrivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionInfraredFrameArrivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionInfraredFrameArrivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionInfraredFrameArrivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionInfraredFrameArrivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PerceptionInfraredFrameArrivedEventArgs =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionInfraredFrameArrivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameArrivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionInfraredFrameArrivedEventArgs
    };

    // ----- PerceptionInfraredFrameReader class --------------------
    static constexpr const char* const type_name_PerceptionInfraredFrameReader = "PerceptionInfraredFrameReader";

    static PyObject* _new_PerceptionInfraredFrameReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionInfraredFrameReader);
        return nullptr;
    }

    static void _dealloc_PerceptionInfraredFrameReader(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionInfraredFrameReader_Close(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameReader", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameReader_TryReadLatestFrame(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameReader", L"TryReadLatestFrame", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryReadLatestFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameReader_get_IsPaused(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameReader", L"IsPaused"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPaused());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PerceptionInfraredFrameReader_put_IsPaused(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameReader", L"IsPaused"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPaused(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PerceptionInfraredFrameReader_get_Source(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameReader", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameReader_add_FrameArrived(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameReader", L"FrameArrived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameReader, winrt::Windows::Devices::Perception::PerceptionInfraredFrameArrivedEventArgs>>(arg);

            return py::convert(self->obj.FrameArrived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameReader_remove_FrameArrived(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameReader", L"FrameArrived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FrameArrived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionInfraredFrameReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionInfraredFrameReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionInfraredFrameReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionInfraredFrameReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PerceptionInfraredFrameReader(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_PerceptionInfraredFrameReader(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionInfraredFrameReader[] = {
        { "close", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameReader_Close), METH_VARARGS, nullptr },
        { "try_read_latest_frame", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameReader_TryReadLatestFrame), METH_VARARGS, nullptr },
        { "add_frame_arrived", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameReader_add_FrameArrived), METH_O, nullptr },
        { "remove_frame_arrived", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameReader_remove_FrameArrived), METH_O, nullptr },
        { "_assign_array_", _assign_array_PerceptionInfraredFrameReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionInfraredFrameReader), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_PerceptionInfraredFrameReader), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_PerceptionInfraredFrameReader), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionInfraredFrameReader[] = {
        { "is_paused", reinterpret_cast<getter>(PerceptionInfraredFrameReader_get_IsPaused), reinterpret_cast<setter>(PerceptionInfraredFrameReader_put_IsPaused), nullptr, nullptr },
        { "source", reinterpret_cast<getter>(PerceptionInfraredFrameReader_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionInfraredFrameReader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionInfraredFrameReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionInfraredFrameReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionInfraredFrameReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionInfraredFrameReader) },
        { },
    };

    static PyType_Spec type_spec_PerceptionInfraredFrameReader =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionInfraredFrameReader",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionInfraredFrameReader
    };

    // ----- PerceptionInfraredFrameSource class --------------------
    static constexpr const char* const type_name_PerceptionInfraredFrameSource = "PerceptionInfraredFrameSource";

    static PyObject* _new_PerceptionInfraredFrameSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionInfraredFrameSource);
        return nullptr;
    }

    static void _dealloc_PerceptionInfraredFrameSource(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionInfraredFrameSource_AcquireControlSession(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"AcquireControlSession", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.AcquireControlSession());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_CanControlIndependentlyFrom(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"CanControlIndependentlyFrom", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CanControlIndependentlyFrom(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_CreateWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"CreateWatcher", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource::CreateWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_FindAllAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"FindAllAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource::FindAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_IsCorrelatedWith(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"IsCorrelatedWith", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsCorrelatedWith(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_OpenReader(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"OpenReader", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.OpenReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_RequestAccessAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"RequestAccessAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource::RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_TryGetDepthCorrelatedCameraIntrinsicsAsync(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"TryGetDepthCorrelatedCameraIntrinsicsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource>(args, 0);

                return py::convert(self->obj.TryGetDepthCorrelatedCameraIntrinsicsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_TryGetDepthCorrelatedCoordinateMapperAsync(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"TryGetDepthCorrelatedCoordinateMapperAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource>(args, 1);

                return py::convert(self->obj.TryGetDepthCorrelatedCoordinateMapperAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_TryGetTransformTo(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"TryGetTransformTo", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Foundation::Numerics::float4x4 param1 {  };

                auto return_value = self->obj.TryGetTransformTo(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_TrySetVideoProfileAsync(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"TrySetVideoProfileAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionControlSession>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionVideoProfile>(args, 1);

                return py::convert(self->obj.TrySetVideoProfileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_Active(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"Active"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Active());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_Available(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"Available"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Available());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_AvailableVideoProfiles(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"AvailableVideoProfiles"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AvailableVideoProfiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_CameraIntrinsics(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"CameraIntrinsics"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CameraIntrinsics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_DeviceKind(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"DeviceKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_DisplayName(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_Id(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_IsControlled(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"IsControlled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsControlled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_Properties(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_SupportedVideoProfiles(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"SupportedVideoProfiles"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedVideoProfiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_VideoProfile(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"VideoProfile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_DeviceId(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_add_ActiveChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"ActiveChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ActiveChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_remove_ActiveChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"ActiveChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ActiveChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_add_AvailableChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"AvailableChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AvailableChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_remove_AvailableChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"AvailableChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AvailableChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_add_CameraIntrinsicsChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"CameraIntrinsicsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CameraIntrinsicsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_remove_CameraIntrinsicsChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"CameraIntrinsicsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CameraIntrinsicsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_add_PropertiesChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"PropertiesChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource, winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs>>(arg);

            return py::convert(self->obj.PropertiesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_remove_PropertiesChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"PropertiesChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PropertiesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_add_VideoProfileChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"VideoProfileChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VideoProfileChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_remove_VideoProfileChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"VideoProfileChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VideoProfileChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionInfraredFrameSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionInfraredFrameSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionInfraredFrameSource[] = {
        { "acquire_control_session", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_AcquireControlSession), METH_VARARGS, nullptr },
        { "can_control_independently_from", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_CanControlIndependentlyFrom), METH_VARARGS, nullptr },
        { "create_watcher", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_CreateWatcher), METH_VARARGS | METH_STATIC, nullptr },
        { "find_all_async", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_FindAllAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "is_correlated_with", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_IsCorrelatedWith), METH_VARARGS, nullptr },
        { "open_reader", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_OpenReader), METH_VARARGS, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_RequestAccessAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "try_get_depth_correlated_camera_intrinsics_async", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_TryGetDepthCorrelatedCameraIntrinsicsAsync), METH_VARARGS, nullptr },
        { "try_get_depth_correlated_coordinate_mapper_async", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_TryGetDepthCorrelatedCoordinateMapperAsync), METH_VARARGS, nullptr },
        { "try_get_transform_to", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_TryGetTransformTo), METH_VARARGS, nullptr },
        { "try_set_video_profile_async", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_TrySetVideoProfileAsync), METH_VARARGS, nullptr },
        { "add_active_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_add_ActiveChanged), METH_O, nullptr },
        { "remove_active_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_remove_ActiveChanged), METH_O, nullptr },
        { "add_available_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_add_AvailableChanged), METH_O, nullptr },
        { "remove_available_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_remove_AvailableChanged), METH_O, nullptr },
        { "add_camera_intrinsics_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_add_CameraIntrinsicsChanged), METH_O, nullptr },
        { "remove_camera_intrinsics_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_remove_CameraIntrinsicsChanged), METH_O, nullptr },
        { "add_properties_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_add_PropertiesChanged), METH_O, nullptr },
        { "remove_properties_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_remove_PropertiesChanged), METH_O, nullptr },
        { "add_video_profile_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_add_VideoProfileChanged), METH_O, nullptr },
        { "remove_video_profile_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_remove_VideoProfileChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_PerceptionInfraredFrameSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionInfraredFrameSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionInfraredFrameSource[] = {
        { "active", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_Active), nullptr, nullptr, nullptr },
        { "available", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_Available), nullptr, nullptr, nullptr },
        { "available_video_profiles", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_AvailableVideoProfiles), nullptr, nullptr, nullptr },
        { "camera_intrinsics", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_CameraIntrinsics), nullptr, nullptr, nullptr },
        { "device_kind", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_DeviceKind), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_DisplayName), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_Id), nullptr, nullptr, nullptr },
        { "is_controlled", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_IsControlled), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_Properties), nullptr, nullptr, nullptr },
        { "supported_video_profiles", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_SupportedVideoProfiles), nullptr, nullptr, nullptr },
        { "video_profile", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_VideoProfile), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionInfraredFrameSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionInfraredFrameSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionInfraredFrameSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionInfraredFrameSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionInfraredFrameSource) },
        { },
    };

    static PyType_Spec type_spec_PerceptionInfraredFrameSource =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionInfraredFrameSource",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionInfraredFrameSource
    };

    // ----- PerceptionInfraredFrameSourceAddedEventArgs class --------------------
    static constexpr const char* const type_name_PerceptionInfraredFrameSourceAddedEventArgs = "PerceptionInfraredFrameSourceAddedEventArgs";

    static PyObject* _new_PerceptionInfraredFrameSourceAddedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionInfraredFrameSourceAddedEventArgs);
        return nullptr;
    }

    static void _dealloc_PerceptionInfraredFrameSourceAddedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceAddedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionInfraredFrameSourceAddedEventArgs_get_FrameSource(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceAddedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSourceAddedEventArgs", L"FrameSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionInfraredFrameSourceAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceAddedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionInfraredFrameSourceAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceAddedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionInfraredFrameSourceAddedEventArgs[] = {
        { "_assign_array_", _assign_array_PerceptionInfraredFrameSourceAddedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionInfraredFrameSourceAddedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionInfraredFrameSourceAddedEventArgs[] = {
        { "frame_source", reinterpret_cast<getter>(PerceptionInfraredFrameSourceAddedEventArgs_get_FrameSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionInfraredFrameSourceAddedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionInfraredFrameSourceAddedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionInfraredFrameSourceAddedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionInfraredFrameSourceAddedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionInfraredFrameSourceAddedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PerceptionInfraredFrameSourceAddedEventArgs =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionInfraredFrameSourceAddedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceAddedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionInfraredFrameSourceAddedEventArgs
    };

    // ----- PerceptionInfraredFrameSourceRemovedEventArgs class --------------------
    static constexpr const char* const type_name_PerceptionInfraredFrameSourceRemovedEventArgs = "PerceptionInfraredFrameSourceRemovedEventArgs";

    static PyObject* _new_PerceptionInfraredFrameSourceRemovedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionInfraredFrameSourceRemovedEventArgs);
        return nullptr;
    }

    static void _dealloc_PerceptionInfraredFrameSourceRemovedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceRemovedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionInfraredFrameSourceRemovedEventArgs_get_FrameSource(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceRemovedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSourceRemovedEventArgs", L"FrameSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionInfraredFrameSourceRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceRemovedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionInfraredFrameSourceRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceRemovedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionInfraredFrameSourceRemovedEventArgs[] = {
        { "_assign_array_", _assign_array_PerceptionInfraredFrameSourceRemovedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionInfraredFrameSourceRemovedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionInfraredFrameSourceRemovedEventArgs[] = {
        { "frame_source", reinterpret_cast<getter>(PerceptionInfraredFrameSourceRemovedEventArgs_get_FrameSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionInfraredFrameSourceRemovedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionInfraredFrameSourceRemovedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionInfraredFrameSourceRemovedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionInfraredFrameSourceRemovedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionInfraredFrameSourceRemovedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PerceptionInfraredFrameSourceRemovedEventArgs =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionInfraredFrameSourceRemovedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceRemovedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionInfraredFrameSourceRemovedEventArgs
    };

    // ----- PerceptionInfraredFrameSourceWatcher class --------------------
    static constexpr const char* const type_name_PerceptionInfraredFrameSourceWatcher = "PerceptionInfraredFrameSourceWatcher";

    static PyObject* _new_PerceptionInfraredFrameSourceWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionInfraredFrameSourceWatcher);
        return nullptr;
    }

    static void _dealloc_PerceptionInfraredFrameSourceWatcher(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_Start(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_Stop(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_get_Status(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_add_EnumerationCompleted(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_remove_EnumerationCompleted(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_add_SourceAdded(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher", L"SourceAdded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher, winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceAddedEventArgs>>(arg);

            return py::convert(self->obj.SourceAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_remove_SourceAdded(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher", L"SourceAdded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_add_SourceRemoved(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher", L"SourceRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher, winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceRemovedEventArgs>>(arg);

            return py::convert(self->obj.SourceRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_remove_SourceRemoved(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher", L"SourceRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_add_Stopped(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_remove_Stopped(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionInfraredFrameSourceWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionInfraredFrameSourceWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionInfraredFrameSourceWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_Stop), METH_VARARGS, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_source_added", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_add_SourceAdded), METH_O, nullptr },
        { "remove_source_added", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_remove_SourceAdded), METH_O, nullptr },
        { "add_source_removed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_add_SourceRemoved), METH_O, nullptr },
        { "remove_source_removed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_remove_SourceRemoved), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_remove_Stopped), METH_O, nullptr },
        { "_assign_array_", _assign_array_PerceptionInfraredFrameSourceWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionInfraredFrameSourceWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionInfraredFrameSourceWatcher[] = {
        { "status", reinterpret_cast<getter>(PerceptionInfraredFrameSourceWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionInfraredFrameSourceWatcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionInfraredFrameSourceWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionInfraredFrameSourceWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionInfraredFrameSourceWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionInfraredFrameSourceWatcher) },
        { },
    };

    static PyType_Spec type_spec_PerceptionInfraredFrameSourceWatcher =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionInfraredFrameSourceWatcher",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionInfraredFrameSourceWatcher
    };

    // ----- PerceptionVideoProfile class --------------------
    static constexpr const char* const type_name_PerceptionVideoProfile = "PerceptionVideoProfile";

    static PyObject* _new_PerceptionVideoProfile(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionVideoProfile);
        return nullptr;
    }

    static void _dealloc_PerceptionVideoProfile(py::wrapper::Windows::Devices::Perception::PerceptionVideoProfile* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionVideoProfile_IsEqual(py::wrapper::Windows::Devices::Perception::PerceptionVideoProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionVideoProfile", L"IsEqual", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionVideoProfile>(args, 0);

                return py::convert(self->obj.IsEqual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionVideoProfile_get_BitmapAlphaMode(py::wrapper::Windows::Devices::Perception::PerceptionVideoProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionVideoProfile", L"BitmapAlphaMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BitmapAlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionVideoProfile_get_BitmapPixelFormat(py::wrapper::Windows::Devices::Perception::PerceptionVideoProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionVideoProfile", L"BitmapPixelFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BitmapPixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionVideoProfile_get_FrameDuration(py::wrapper::Windows::Devices::Perception::PerceptionVideoProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionVideoProfile", L"FrameDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionVideoProfile_get_Height(py::wrapper::Windows::Devices::Perception::PerceptionVideoProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionVideoProfile", L"Height"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionVideoProfile_get_Width(py::wrapper::Windows::Devices::Perception::PerceptionVideoProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionVideoProfile", L"Width"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionVideoProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionVideoProfile>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionVideoProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionVideoProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionVideoProfile[] = {
        { "is_equal", reinterpret_cast<PyCFunction>(PerceptionVideoProfile_IsEqual), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PerceptionVideoProfile, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionVideoProfile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionVideoProfile[] = {
        { "bitmap_alpha_mode", reinterpret_cast<getter>(PerceptionVideoProfile_get_BitmapAlphaMode), nullptr, nullptr, nullptr },
        { "bitmap_pixel_format", reinterpret_cast<getter>(PerceptionVideoProfile_get_BitmapPixelFormat), nullptr, nullptr, nullptr },
        { "frame_duration", reinterpret_cast<getter>(PerceptionVideoProfile_get_FrameDuration), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(PerceptionVideoProfile_get_Height), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(PerceptionVideoProfile_get_Width), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionVideoProfile[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionVideoProfile) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionVideoProfile) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionVideoProfile) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionVideoProfile) },
        { },
    };

    static PyType_Spec type_spec_PerceptionVideoProfile =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionVideoProfile",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionVideoProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionVideoProfile
    };

    // ----- Windows.Devices.Perception Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Devices::Perception");

    static PyMethodDef module_methods[] = {
        {"_register_PerceptionFrameSourceAccessStatus", register_PerceptionFrameSourceAccessStatus, METH_O, "registers type"},
        {"_register_PerceptionFrameSourcePropertyChangeStatus", register_PerceptionFrameSourcePropertyChangeStatus, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_PerceptionFrameSourceAccessStatus);
        Py_VISIT(state->type_PerceptionFrameSourcePropertyChangeStatus);
        Py_VISIT(state->type_KnownCameraIntrinsicsProperties);
        Py_VISIT(state->type_KnownPerceptionColorFrameSourceProperties);
        Py_VISIT(state->type_KnownPerceptionDepthFrameSourceProperties);
        Py_VISIT(state->type_KnownPerceptionFrameSourceProperties);
        Py_VISIT(state->type_KnownPerceptionInfraredFrameSourceProperties);
        Py_VISIT(state->type_KnownPerceptionVideoFrameSourceProperties);
        Py_VISIT(state->type_KnownPerceptionVideoProfileProperties);
        Py_VISIT(state->type_PerceptionColorFrame);
        Py_VISIT(state->type_PerceptionColorFrameArrivedEventArgs);
        Py_VISIT(state->type_PerceptionColorFrameReader);
        Py_VISIT(state->type_PerceptionColorFrameSource);
        Py_VISIT(state->type_PerceptionColorFrameSourceAddedEventArgs);
        Py_VISIT(state->type_PerceptionColorFrameSourceRemovedEventArgs);
        Py_VISIT(state->type_PerceptionColorFrameSourceWatcher);
        Py_VISIT(state->type_PerceptionControlSession);
        Py_VISIT(state->type_PerceptionDepthCorrelatedCameraIntrinsics);
        Py_VISIT(state->type_PerceptionDepthCorrelatedCoordinateMapper);
        Py_VISIT(state->type_PerceptionDepthFrame);
        Py_VISIT(state->type_PerceptionDepthFrameArrivedEventArgs);
        Py_VISIT(state->type_PerceptionDepthFrameReader);
        Py_VISIT(state->type_PerceptionDepthFrameSource);
        Py_VISIT(state->type_PerceptionDepthFrameSourceAddedEventArgs);
        Py_VISIT(state->type_PerceptionDepthFrameSourceRemovedEventArgs);
        Py_VISIT(state->type_PerceptionDepthFrameSourceWatcher);
        Py_VISIT(state->type_PerceptionFrameSourcePropertiesChangedEventArgs);
        Py_VISIT(state->type_PerceptionFrameSourcePropertyChangeResult);
        Py_VISIT(state->type_PerceptionInfraredFrame);
        Py_VISIT(state->type_PerceptionInfraredFrameArrivedEventArgs);
        Py_VISIT(state->type_PerceptionInfraredFrameReader);
        Py_VISIT(state->type_PerceptionInfraredFrameSource);
        Py_VISIT(state->type_PerceptionInfraredFrameSourceAddedEventArgs);
        Py_VISIT(state->type_PerceptionInfraredFrameSourceRemovedEventArgs);
        Py_VISIT(state->type_PerceptionInfraredFrameSourceWatcher);
        Py_VISIT(state->type_PerceptionVideoProfile);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_PerceptionFrameSourceAccessStatus);
        Py_CLEAR(state->type_PerceptionFrameSourcePropertyChangeStatus);
        Py_CLEAR(state->type_KnownCameraIntrinsicsProperties);
        Py_CLEAR(state->type_KnownPerceptionColorFrameSourceProperties);
        Py_CLEAR(state->type_KnownPerceptionDepthFrameSourceProperties);
        Py_CLEAR(state->type_KnownPerceptionFrameSourceProperties);
        Py_CLEAR(state->type_KnownPerceptionInfraredFrameSourceProperties);
        Py_CLEAR(state->type_KnownPerceptionVideoFrameSourceProperties);
        Py_CLEAR(state->type_KnownPerceptionVideoProfileProperties);
        Py_CLEAR(state->type_PerceptionColorFrame);
        Py_CLEAR(state->type_PerceptionColorFrameArrivedEventArgs);
        Py_CLEAR(state->type_PerceptionColorFrameReader);
        Py_CLEAR(state->type_PerceptionColorFrameSource);
        Py_CLEAR(state->type_PerceptionColorFrameSourceAddedEventArgs);
        Py_CLEAR(state->type_PerceptionColorFrameSourceRemovedEventArgs);
        Py_CLEAR(state->type_PerceptionColorFrameSourceWatcher);
        Py_CLEAR(state->type_PerceptionControlSession);
        Py_CLEAR(state->type_PerceptionDepthCorrelatedCameraIntrinsics);
        Py_CLEAR(state->type_PerceptionDepthCorrelatedCoordinateMapper);
        Py_CLEAR(state->type_PerceptionDepthFrame);
        Py_CLEAR(state->type_PerceptionDepthFrameArrivedEventArgs);
        Py_CLEAR(state->type_PerceptionDepthFrameReader);
        Py_CLEAR(state->type_PerceptionDepthFrameSource);
        Py_CLEAR(state->type_PerceptionDepthFrameSourceAddedEventArgs);
        Py_CLEAR(state->type_PerceptionDepthFrameSourceRemovedEventArgs);
        Py_CLEAR(state->type_PerceptionDepthFrameSourceWatcher);
        Py_CLEAR(state->type_PerceptionFrameSourcePropertiesChangedEventArgs);
        Py_CLEAR(state->type_PerceptionFrameSourcePropertyChangeResult);
        Py_CLEAR(state->type_PerceptionInfraredFrame);
        Py_CLEAR(state->type_PerceptionInfraredFrameArrivedEventArgs);
        Py_CLEAR(state->type_PerceptionInfraredFrameReader);
        Py_CLEAR(state->type_PerceptionInfraredFrameSource);
        Py_CLEAR(state->type_PerceptionInfraredFrameSourceAddedEventArgs);
        Py_CLEAR(state->type_PerceptionInfraredFrameSourceRemovedEventArgs);
        Py_CLEAR(state->type_PerceptionInfraredFrameSourceWatcher);
        Py_CLEAR(state->type_PerceptionVideoProfile);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Devices_Perception",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Devices::Perception

PyMODINIT_FUNC PyInit__winsdk_Windows_Devices_Perception(void) noexcept
{
    using namespace py::cpp::Windows::Devices::Perception;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    py::pyobj_handle type_KnownCameraIntrinsicsProperties_Meta{PyType_FromSpec(&type_spec_KnownCameraIntrinsicsProperties_Meta)};
    if (!type_KnownCameraIntrinsicsProperties_Meta)
    {
        return nullptr;
    }

    state->type_KnownCameraIntrinsicsProperties = py::register_python_type(module.get(), type_name_KnownCameraIntrinsicsProperties, &type_spec_KnownCameraIntrinsicsProperties, nullptr, reinterpret_cast<PyTypeObject*>(type_KnownCameraIntrinsicsProperties_Meta.get()));
    if (!state->type_KnownCameraIntrinsicsProperties)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownPerceptionColorFrameSourceProperties_Meta{PyType_FromSpec(&type_spec_KnownPerceptionColorFrameSourceProperties_Meta)};
    if (!type_KnownPerceptionColorFrameSourceProperties_Meta)
    {
        return nullptr;
    }

    state->type_KnownPerceptionColorFrameSourceProperties = py::register_python_type(module.get(), type_name_KnownPerceptionColorFrameSourceProperties, &type_spec_KnownPerceptionColorFrameSourceProperties, nullptr, reinterpret_cast<PyTypeObject*>(type_KnownPerceptionColorFrameSourceProperties_Meta.get()));
    if (!state->type_KnownPerceptionColorFrameSourceProperties)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownPerceptionDepthFrameSourceProperties_Meta{PyType_FromSpec(&type_spec_KnownPerceptionDepthFrameSourceProperties_Meta)};
    if (!type_KnownPerceptionDepthFrameSourceProperties_Meta)
    {
        return nullptr;
    }

    state->type_KnownPerceptionDepthFrameSourceProperties = py::register_python_type(module.get(), type_name_KnownPerceptionDepthFrameSourceProperties, &type_spec_KnownPerceptionDepthFrameSourceProperties, nullptr, reinterpret_cast<PyTypeObject*>(type_KnownPerceptionDepthFrameSourceProperties_Meta.get()));
    if (!state->type_KnownPerceptionDepthFrameSourceProperties)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownPerceptionFrameSourceProperties_Meta{PyType_FromSpec(&type_spec_KnownPerceptionFrameSourceProperties_Meta)};
    if (!type_KnownPerceptionFrameSourceProperties_Meta)
    {
        return nullptr;
    }

    state->type_KnownPerceptionFrameSourceProperties = py::register_python_type(module.get(), type_name_KnownPerceptionFrameSourceProperties, &type_spec_KnownPerceptionFrameSourceProperties, nullptr, reinterpret_cast<PyTypeObject*>(type_KnownPerceptionFrameSourceProperties_Meta.get()));
    if (!state->type_KnownPerceptionFrameSourceProperties)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownPerceptionInfraredFrameSourceProperties_Meta{PyType_FromSpec(&type_spec_KnownPerceptionInfraredFrameSourceProperties_Meta)};
    if (!type_KnownPerceptionInfraredFrameSourceProperties_Meta)
    {
        return nullptr;
    }

    state->type_KnownPerceptionInfraredFrameSourceProperties = py::register_python_type(module.get(), type_name_KnownPerceptionInfraredFrameSourceProperties, &type_spec_KnownPerceptionInfraredFrameSourceProperties, nullptr, reinterpret_cast<PyTypeObject*>(type_KnownPerceptionInfraredFrameSourceProperties_Meta.get()));
    if (!state->type_KnownPerceptionInfraredFrameSourceProperties)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownPerceptionVideoFrameSourceProperties_Meta{PyType_FromSpec(&type_spec_KnownPerceptionVideoFrameSourceProperties_Meta)};
    if (!type_KnownPerceptionVideoFrameSourceProperties_Meta)
    {
        return nullptr;
    }

    state->type_KnownPerceptionVideoFrameSourceProperties = py::register_python_type(module.get(), type_name_KnownPerceptionVideoFrameSourceProperties, &type_spec_KnownPerceptionVideoFrameSourceProperties, nullptr, reinterpret_cast<PyTypeObject*>(type_KnownPerceptionVideoFrameSourceProperties_Meta.get()));
    if (!state->type_KnownPerceptionVideoFrameSourceProperties)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownPerceptionVideoProfileProperties_Meta{PyType_FromSpec(&type_spec_KnownPerceptionVideoProfileProperties_Meta)};
    if (!type_KnownPerceptionVideoProfileProperties_Meta)
    {
        return nullptr;
    }

    state->type_KnownPerceptionVideoProfileProperties = py::register_python_type(module.get(), type_name_KnownPerceptionVideoProfileProperties, &type_spec_KnownPerceptionVideoProfileProperties, nullptr, reinterpret_cast<PyTypeObject*>(type_KnownPerceptionVideoProfileProperties_Meta.get()));
    if (!state->type_KnownPerceptionVideoProfileProperties)
    {
        return nullptr;
    }

    state->type_PerceptionColorFrame = py::register_python_type(module.get(), type_name_PerceptionColorFrame, &type_spec_PerceptionColorFrame, bases.get(), nullptr);
    if (!state->type_PerceptionColorFrame)
    {
        return nullptr;
    }

    state->type_PerceptionColorFrameArrivedEventArgs = py::register_python_type(module.get(), type_name_PerceptionColorFrameArrivedEventArgs, &type_spec_PerceptionColorFrameArrivedEventArgs, bases.get(), nullptr);
    if (!state->type_PerceptionColorFrameArrivedEventArgs)
    {
        return nullptr;
    }

    state->type_PerceptionColorFrameReader = py::register_python_type(module.get(), type_name_PerceptionColorFrameReader, &type_spec_PerceptionColorFrameReader, bases.get(), nullptr);
    if (!state->type_PerceptionColorFrameReader)
    {
        return nullptr;
    }

    state->type_PerceptionColorFrameSource = py::register_python_type(module.get(), type_name_PerceptionColorFrameSource, &type_spec_PerceptionColorFrameSource, bases.get(), nullptr);
    if (!state->type_PerceptionColorFrameSource)
    {
        return nullptr;
    }

    state->type_PerceptionColorFrameSourceAddedEventArgs = py::register_python_type(module.get(), type_name_PerceptionColorFrameSourceAddedEventArgs, &type_spec_PerceptionColorFrameSourceAddedEventArgs, bases.get(), nullptr);
    if (!state->type_PerceptionColorFrameSourceAddedEventArgs)
    {
        return nullptr;
    }

    state->type_PerceptionColorFrameSourceRemovedEventArgs = py::register_python_type(module.get(), type_name_PerceptionColorFrameSourceRemovedEventArgs, &type_spec_PerceptionColorFrameSourceRemovedEventArgs, bases.get(), nullptr);
    if (!state->type_PerceptionColorFrameSourceRemovedEventArgs)
    {
        return nullptr;
    }

    state->type_PerceptionColorFrameSourceWatcher = py::register_python_type(module.get(), type_name_PerceptionColorFrameSourceWatcher, &type_spec_PerceptionColorFrameSourceWatcher, bases.get(), nullptr);
    if (!state->type_PerceptionColorFrameSourceWatcher)
    {
        return nullptr;
    }

    state->type_PerceptionControlSession = py::register_python_type(module.get(), type_name_PerceptionControlSession, &type_spec_PerceptionControlSession, bases.get(), nullptr);
    if (!state->type_PerceptionControlSession)
    {
        return nullptr;
    }

    state->type_PerceptionDepthCorrelatedCameraIntrinsics = py::register_python_type(module.get(), type_name_PerceptionDepthCorrelatedCameraIntrinsics, &type_spec_PerceptionDepthCorrelatedCameraIntrinsics, bases.get(), nullptr);
    if (!state->type_PerceptionDepthCorrelatedCameraIntrinsics)
    {
        return nullptr;
    }

    state->type_PerceptionDepthCorrelatedCoordinateMapper = py::register_python_type(module.get(), type_name_PerceptionDepthCorrelatedCoordinateMapper, &type_spec_PerceptionDepthCorrelatedCoordinateMapper, bases.get(), nullptr);
    if (!state->type_PerceptionDepthCorrelatedCoordinateMapper)
    {
        return nullptr;
    }

    state->type_PerceptionDepthFrame = py::register_python_type(module.get(), type_name_PerceptionDepthFrame, &type_spec_PerceptionDepthFrame, bases.get(), nullptr);
    if (!state->type_PerceptionDepthFrame)
    {
        return nullptr;
    }

    state->type_PerceptionDepthFrameArrivedEventArgs = py::register_python_type(module.get(), type_name_PerceptionDepthFrameArrivedEventArgs, &type_spec_PerceptionDepthFrameArrivedEventArgs, bases.get(), nullptr);
    if (!state->type_PerceptionDepthFrameArrivedEventArgs)
    {
        return nullptr;
    }

    state->type_PerceptionDepthFrameReader = py::register_python_type(module.get(), type_name_PerceptionDepthFrameReader, &type_spec_PerceptionDepthFrameReader, bases.get(), nullptr);
    if (!state->type_PerceptionDepthFrameReader)
    {
        return nullptr;
    }

    state->type_PerceptionDepthFrameSource = py::register_python_type(module.get(), type_name_PerceptionDepthFrameSource, &type_spec_PerceptionDepthFrameSource, bases.get(), nullptr);
    if (!state->type_PerceptionDepthFrameSource)
    {
        return nullptr;
    }

    state->type_PerceptionDepthFrameSourceAddedEventArgs = py::register_python_type(module.get(), type_name_PerceptionDepthFrameSourceAddedEventArgs, &type_spec_PerceptionDepthFrameSourceAddedEventArgs, bases.get(), nullptr);
    if (!state->type_PerceptionDepthFrameSourceAddedEventArgs)
    {
        return nullptr;
    }

    state->type_PerceptionDepthFrameSourceRemovedEventArgs = py::register_python_type(module.get(), type_name_PerceptionDepthFrameSourceRemovedEventArgs, &type_spec_PerceptionDepthFrameSourceRemovedEventArgs, bases.get(), nullptr);
    if (!state->type_PerceptionDepthFrameSourceRemovedEventArgs)
    {
        return nullptr;
    }

    state->type_PerceptionDepthFrameSourceWatcher = py::register_python_type(module.get(), type_name_PerceptionDepthFrameSourceWatcher, &type_spec_PerceptionDepthFrameSourceWatcher, bases.get(), nullptr);
    if (!state->type_PerceptionDepthFrameSourceWatcher)
    {
        return nullptr;
    }

    state->type_PerceptionFrameSourcePropertiesChangedEventArgs = py::register_python_type(module.get(), type_name_PerceptionFrameSourcePropertiesChangedEventArgs, &type_spec_PerceptionFrameSourcePropertiesChangedEventArgs, bases.get(), nullptr);
    if (!state->type_PerceptionFrameSourcePropertiesChangedEventArgs)
    {
        return nullptr;
    }

    state->type_PerceptionFrameSourcePropertyChangeResult = py::register_python_type(module.get(), type_name_PerceptionFrameSourcePropertyChangeResult, &type_spec_PerceptionFrameSourcePropertyChangeResult, bases.get(), nullptr);
    if (!state->type_PerceptionFrameSourcePropertyChangeResult)
    {
        return nullptr;
    }

    state->type_PerceptionInfraredFrame = py::register_python_type(module.get(), type_name_PerceptionInfraredFrame, &type_spec_PerceptionInfraredFrame, bases.get(), nullptr);
    if (!state->type_PerceptionInfraredFrame)
    {
        return nullptr;
    }

    state->type_PerceptionInfraredFrameArrivedEventArgs = py::register_python_type(module.get(), type_name_PerceptionInfraredFrameArrivedEventArgs, &type_spec_PerceptionInfraredFrameArrivedEventArgs, bases.get(), nullptr);
    if (!state->type_PerceptionInfraredFrameArrivedEventArgs)
    {
        return nullptr;
    }

    state->type_PerceptionInfraredFrameReader = py::register_python_type(module.get(), type_name_PerceptionInfraredFrameReader, &type_spec_PerceptionInfraredFrameReader, bases.get(), nullptr);
    if (!state->type_PerceptionInfraredFrameReader)
    {
        return nullptr;
    }

    state->type_PerceptionInfraredFrameSource = py::register_python_type(module.get(), type_name_PerceptionInfraredFrameSource, &type_spec_PerceptionInfraredFrameSource, bases.get(), nullptr);
    if (!state->type_PerceptionInfraredFrameSource)
    {
        return nullptr;
    }

    state->type_PerceptionInfraredFrameSourceAddedEventArgs = py::register_python_type(module.get(), type_name_PerceptionInfraredFrameSourceAddedEventArgs, &type_spec_PerceptionInfraredFrameSourceAddedEventArgs, bases.get(), nullptr);
    if (!state->type_PerceptionInfraredFrameSourceAddedEventArgs)
    {
        return nullptr;
    }

    state->type_PerceptionInfraredFrameSourceRemovedEventArgs = py::register_python_type(module.get(), type_name_PerceptionInfraredFrameSourceRemovedEventArgs, &type_spec_PerceptionInfraredFrameSourceRemovedEventArgs, bases.get(), nullptr);
    if (!state->type_PerceptionInfraredFrameSourceRemovedEventArgs)
    {
        return nullptr;
    }

    state->type_PerceptionInfraredFrameSourceWatcher = py::register_python_type(module.get(), type_name_PerceptionInfraredFrameSourceWatcher, &type_spec_PerceptionInfraredFrameSourceWatcher, bases.get(), nullptr);
    if (!state->type_PerceptionInfraredFrameSourceWatcher)
    {
        return nullptr;
    }

    state->type_PerceptionVideoProfile = py::register_python_type(module.get(), type_name_PerceptionVideoProfile, &type_spec_PerceptionVideoProfile, bases.get(), nullptr);
    if (!state->type_PerceptionVideoProfile)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Devices::Perception::PerceptionFrameSourceAccessStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionFrameSourceAccessStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionFrameSourceAccessStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertyChangeStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionFrameSourcePropertyChangeStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertyChangeStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::KnownCameraIntrinsicsProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownCameraIntrinsicsProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::KnownCameraIntrinsicsProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::KnownPerceptionColorFrameSourceProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownPerceptionColorFrameSourceProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::KnownPerceptionColorFrameSourceProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::KnownPerceptionDepthFrameSourceProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownPerceptionDepthFrameSourceProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::KnownPerceptionDepthFrameSourceProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::KnownPerceptionFrameSourceProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownPerceptionFrameSourceProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::KnownPerceptionFrameSourceProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::KnownPerceptionInfraredFrameSourceProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownPerceptionInfraredFrameSourceProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::KnownPerceptionInfraredFrameSourceProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::KnownPerceptionVideoFrameSourceProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownPerceptionVideoFrameSourceProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::KnownPerceptionVideoFrameSourceProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::KnownPerceptionVideoProfileProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownPerceptionVideoProfileProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::KnownPerceptionVideoProfileProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionColorFrame>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionColorFrame;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionColorFrame is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionColorFrameArrivedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionColorFrameArrivedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionColorFrameArrivedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionColorFrameReader>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionColorFrameReader;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionColorFrameReader is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionColorFrameSource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionColorFrameSource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionColorFrameSource is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceAddedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionColorFrameSourceAddedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionColorFrameSourceAddedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceRemovedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionColorFrameSourceRemovedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionColorFrameSourceRemovedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionColorFrameSourceWatcher;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionControlSession>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionControlSession;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionControlSession is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionDepthCorrelatedCameraIntrinsics;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionDepthCorrelatedCoordinateMapper;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionDepthFrame>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionDepthFrame;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionDepthFrame is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionDepthFrameArrivedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionDepthFrameArrivedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionDepthFrameArrivedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionDepthFrameReader>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionDepthFrameReader;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionDepthFrameReader is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionDepthFrameSource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionDepthFrameSource is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceAddedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionDepthFrameSourceAddedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceAddedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceRemovedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionDepthFrameSourceRemovedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceRemovedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionDepthFrameSourceWatcher;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionFrameSourcePropertiesChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertyChangeResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionFrameSourcePropertyChangeResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertyChangeResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrame>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionInfraredFrame;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionInfraredFrame is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrameArrivedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionInfraredFrameArrivedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionInfraredFrameArrivedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrameReader>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionInfraredFrameReader;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionInfraredFrameReader is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionInfraredFrameSource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceAddedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionInfraredFrameSourceAddedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceAddedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceRemovedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionInfraredFrameSourceRemovedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceRemovedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionInfraredFrameSourceWatcher;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionVideoProfile>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionVideoProfile;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionVideoProfile is not registered");
        return nullptr;
    }

    return python_type;
}
