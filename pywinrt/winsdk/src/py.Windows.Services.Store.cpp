// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.Services.Store.h"


PyObject* py::converter<winrt::Windows::Services::Store::StorePackageUpdateStatus>::convert(winrt::Windows::Services::Store::StorePackageUpdateStatus instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Services::Store::StorePackageUpdateStatus>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Services::Store::StorePackageUpdateStatus py::converter<winrt::Windows::Services::Store::StorePackageUpdateStatus>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Services::Store::StorePackageUpdateStatus>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Services::Store::StorePackageUpdateStatus>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Services::Store::StorePackageUpdateStatus");
    throw python_exception();
}

namespace py::cpp::Windows::Services::Store
{
    struct module_state
    {
        PyObject* type_StoreCanLicenseStatus;
        PyObject* type_StoreConsumableStatus;
        PyObject* type_StoreDurationUnit;
        PyObject* type_StorePackageUpdateState;
        PyObject* type_StorePurchaseStatus;
        PyObject* type_StoreQueueItemExtendedState;
        PyObject* type_StoreQueueItemKind;
        PyObject* type_StoreQueueItemState;
        PyObject* type_StoreRateAndReviewStatus;
        PyObject* type_StoreUninstallStorePackageStatus;
        PyTypeObject* type_StoreAcquireLicenseResult;
        PyTypeObject* type_StoreAppLicense;
        PyTypeObject* type_StoreAvailability;
        PyTypeObject* type_StoreCanAcquireLicenseResult;
        PyTypeObject* type_StoreCollectionData;
        PyTypeObject* type_StoreConsumableResult;
        PyTypeObject* type_StoreContext;
        PyTypeObject* type_StoreImage;
        PyTypeObject* type_StoreLicense;
        PyTypeObject* type_StorePackageInstallOptions;
        PyTypeObject* type_StorePackageLicense;
        PyTypeObject* type_StorePackageUpdate;
        PyTypeObject* type_StorePackageUpdateResult;
        PyTypeObject* type_StorePrice;
        PyTypeObject* type_StoreProduct;
        PyTypeObject* type_StoreProductOptions;
        PyTypeObject* type_StoreProductPagedQueryResult;
        PyTypeObject* type_StoreProductQueryResult;
        PyTypeObject* type_StoreProductResult;
        PyTypeObject* type_StorePurchaseProperties;
        PyTypeObject* type_StorePurchaseResult;
        PyTypeObject* type_StoreQueueItem;
        PyTypeObject* type_StoreQueueItemCompletedEventArgs;
        PyTypeObject* type_StoreQueueItemStatus;
        PyTypeObject* type_StoreRateAndReviewResult;
        PyTypeObject* type_StoreRequestHelper;
        PyTypeObject* type_StoreSendRequestResult;
        PyTypeObject* type_StoreSku;
        PyTypeObject* type_StoreSubscriptionInfo;
        PyTypeObject* type_StoreUninstallStorePackageResult;
        PyTypeObject* type_StoreVideo;
        PyTypeObject* type_StorePackageUpdateStatus;
    };

    static PyObject* register_StoreCanLicenseStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_StoreCanLicenseStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_StoreCanLicenseStatus = type;
        Py_INCREF(state->type_StoreCanLicenseStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_StoreConsumableStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_StoreConsumableStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_StoreConsumableStatus = type;
        Py_INCREF(state->type_StoreConsumableStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_StoreDurationUnit(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_StoreDurationUnit)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_StoreDurationUnit = type;
        Py_INCREF(state->type_StoreDurationUnit);


        Py_RETURN_NONE;
    }

    static PyObject* register_StorePackageUpdateState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_StorePackageUpdateState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_StorePackageUpdateState = type;
        Py_INCREF(state->type_StorePackageUpdateState);


        Py_RETURN_NONE;
    }

    static PyObject* register_StorePurchaseStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_StorePurchaseStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_StorePurchaseStatus = type;
        Py_INCREF(state->type_StorePurchaseStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_StoreQueueItemExtendedState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_StoreQueueItemExtendedState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_StoreQueueItemExtendedState = type;
        Py_INCREF(state->type_StoreQueueItemExtendedState);


        Py_RETURN_NONE;
    }

    static PyObject* register_StoreQueueItemKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_StoreQueueItemKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_StoreQueueItemKind = type;
        Py_INCREF(state->type_StoreQueueItemKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_StoreQueueItemState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_StoreQueueItemState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_StoreQueueItemState = type;
        Py_INCREF(state->type_StoreQueueItemState);


        Py_RETURN_NONE;
    }

    static PyObject* register_StoreRateAndReviewStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_StoreRateAndReviewStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_StoreRateAndReviewStatus = type;
        Py_INCREF(state->type_StoreRateAndReviewStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_StoreUninstallStorePackageStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_StoreUninstallStorePackageStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_StoreUninstallStorePackageStatus = type;
        Py_INCREF(state->type_StoreUninstallStorePackageStatus);


        Py_RETURN_NONE;
    }

    // ----- StoreAcquireLicenseResult class --------------------
    static constexpr const char* const type_name_StoreAcquireLicenseResult = "StoreAcquireLicenseResult";

    static PyObject* _new_StoreAcquireLicenseResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StoreAcquireLicenseResult);
        return nullptr;
    }

    static void _dealloc_StoreAcquireLicenseResult(py::wrapper::Windows::Services::Store::StoreAcquireLicenseResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreAcquireLicenseResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreAcquireLicenseResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAcquireLicenseResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAcquireLicenseResult_get_StorePackageLicense(py::wrapper::Windows::Services::Store::StoreAcquireLicenseResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAcquireLicenseResult", L"StorePackageLicense"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StorePackageLicense());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreAcquireLicenseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreAcquireLicenseResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreAcquireLicenseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreAcquireLicenseResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreAcquireLicenseResult[] = {
        { "_assign_array_", _assign_array_StoreAcquireLicenseResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreAcquireLicenseResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreAcquireLicenseResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreAcquireLicenseResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "store_package_license", reinterpret_cast<getter>(StoreAcquireLicenseResult_get_StorePackageLicense), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreAcquireLicenseResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreAcquireLicenseResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreAcquireLicenseResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreAcquireLicenseResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreAcquireLicenseResult) },
        { },
    };

    static PyType_Spec type_spec_StoreAcquireLicenseResult =
    {
        "_winsdk_Windows_Services_Store.StoreAcquireLicenseResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreAcquireLicenseResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreAcquireLicenseResult
    };

    // ----- StoreAppLicense class --------------------
    static constexpr const char* const type_name_StoreAppLicense = "StoreAppLicense";

    static PyObject* _new_StoreAppLicense(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StoreAppLicense);
        return nullptr;
    }

    static void _dealloc_StoreAppLicense(py::wrapper::Windows::Services::Store::StoreAppLicense* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreAppLicense_get_AddOnLicenses(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"AddOnLicenses"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AddOnLicenses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_ExpirationDate(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"ExpirationDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpirationDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"ExtendedJsonData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_IsActive(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"IsActive"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_IsTrial(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"IsTrial"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTrial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_IsTrialOwnedByThisUser(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"IsTrialOwnedByThisUser"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTrialOwnedByThisUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_SkuStoreId(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"SkuStoreId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SkuStoreId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_TrialTimeRemaining(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"TrialTimeRemaining"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrialTimeRemaining());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_TrialUniqueId(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"TrialUniqueId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrialUniqueId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_IsDiscLicense(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"IsDiscLicense"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDiscLicense());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreAppLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreAppLicense>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreAppLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreAppLicense>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreAppLicense[] = {
        { "_assign_array_", _assign_array_StoreAppLicense, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreAppLicense), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreAppLicense[] = {
        { "add_on_licenses", reinterpret_cast<getter>(StoreAppLicense_get_AddOnLicenses), nullptr, nullptr, nullptr },
        { "expiration_date", reinterpret_cast<getter>(StoreAppLicense_get_ExpirationDate), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreAppLicense_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "is_active", reinterpret_cast<getter>(StoreAppLicense_get_IsActive), nullptr, nullptr, nullptr },
        { "is_trial", reinterpret_cast<getter>(StoreAppLicense_get_IsTrial), nullptr, nullptr, nullptr },
        { "is_trial_owned_by_this_user", reinterpret_cast<getter>(StoreAppLicense_get_IsTrialOwnedByThisUser), nullptr, nullptr, nullptr },
        { "sku_store_id", reinterpret_cast<getter>(StoreAppLicense_get_SkuStoreId), nullptr, nullptr, nullptr },
        { "trial_time_remaining", reinterpret_cast<getter>(StoreAppLicense_get_TrialTimeRemaining), nullptr, nullptr, nullptr },
        { "trial_unique_id", reinterpret_cast<getter>(StoreAppLicense_get_TrialUniqueId), nullptr, nullptr, nullptr },
        { "is_disc_license", reinterpret_cast<getter>(StoreAppLicense_get_IsDiscLicense), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreAppLicense[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreAppLicense) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreAppLicense) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreAppLicense) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreAppLicense) },
        { },
    };

    static PyType_Spec type_spec_StoreAppLicense =
    {
        "_winsdk_Windows_Services_Store.StoreAppLicense",
        sizeof(py::wrapper::Windows::Services::Store::StoreAppLicense),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreAppLicense
    };

    // ----- StoreAvailability class --------------------
    static constexpr const char* const type_name_StoreAvailability = "StoreAvailability";

    static PyObject* _new_StoreAvailability(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StoreAvailability);
        return nullptr;
    }

    static void _dealloc_StoreAvailability(py::wrapper::Windows::Services::Store::StoreAvailability* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreAvailability_RequestPurchaseAsync(py::wrapper::Windows::Services::Store::StoreAvailability* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreAvailability", L"RequestPurchaseAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RequestPurchaseAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreAvailability", L"RequestPurchaseAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Services::Store::StorePurchaseProperties>(args, 0);

                return py::convert(self->obj.RequestPurchaseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreAvailability_get_EndDate(py::wrapper::Windows::Services::Store::StoreAvailability* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAvailability", L"EndDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAvailability_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreAvailability* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAvailability", L"ExtendedJsonData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAvailability_get_Price(py::wrapper::Windows::Services::Store::StoreAvailability* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAvailability", L"Price"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Price());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAvailability_get_StoreId(py::wrapper::Windows::Services::Store::StoreAvailability* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAvailability", L"StoreId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StoreId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreAvailability(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreAvailability>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreAvailability(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreAvailability>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreAvailability[] = {
        { "request_purchase_async", reinterpret_cast<PyCFunction>(StoreAvailability_RequestPurchaseAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StoreAvailability, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreAvailability), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreAvailability[] = {
        { "end_date", reinterpret_cast<getter>(StoreAvailability_get_EndDate), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreAvailability_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "price", reinterpret_cast<getter>(StoreAvailability_get_Price), nullptr, nullptr, nullptr },
        { "store_id", reinterpret_cast<getter>(StoreAvailability_get_StoreId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreAvailability[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreAvailability) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreAvailability) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreAvailability) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreAvailability) },
        { },
    };

    static PyType_Spec type_spec_StoreAvailability =
    {
        "_winsdk_Windows_Services_Store.StoreAvailability",
        sizeof(py::wrapper::Windows::Services::Store::StoreAvailability),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreAvailability
    };

    // ----- StoreCanAcquireLicenseResult class --------------------
    static constexpr const char* const type_name_StoreCanAcquireLicenseResult = "StoreCanAcquireLicenseResult";

    static PyObject* _new_StoreCanAcquireLicenseResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StoreCanAcquireLicenseResult);
        return nullptr;
    }

    static void _dealloc_StoreCanAcquireLicenseResult(py::wrapper::Windows::Services::Store::StoreCanAcquireLicenseResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreCanAcquireLicenseResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreCanAcquireLicenseResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCanAcquireLicenseResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCanAcquireLicenseResult_get_LicensableSku(py::wrapper::Windows::Services::Store::StoreCanAcquireLicenseResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCanAcquireLicenseResult", L"LicensableSku"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LicensableSku());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCanAcquireLicenseResult_get_Status(py::wrapper::Windows::Services::Store::StoreCanAcquireLicenseResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCanAcquireLicenseResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreCanAcquireLicenseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreCanAcquireLicenseResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreCanAcquireLicenseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreCanAcquireLicenseResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreCanAcquireLicenseResult[] = {
        { "_assign_array_", _assign_array_StoreCanAcquireLicenseResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreCanAcquireLicenseResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreCanAcquireLicenseResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreCanAcquireLicenseResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "licensable_sku", reinterpret_cast<getter>(StoreCanAcquireLicenseResult_get_LicensableSku), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(StoreCanAcquireLicenseResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreCanAcquireLicenseResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreCanAcquireLicenseResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreCanAcquireLicenseResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreCanAcquireLicenseResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreCanAcquireLicenseResult) },
        { },
    };

    static PyType_Spec type_spec_StoreCanAcquireLicenseResult =
    {
        "_winsdk_Windows_Services_Store.StoreCanAcquireLicenseResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreCanAcquireLicenseResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreCanAcquireLicenseResult
    };

    // ----- StoreCollectionData class --------------------
    static constexpr const char* const type_name_StoreCollectionData = "StoreCollectionData";

    static PyObject* _new_StoreCollectionData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StoreCollectionData);
        return nullptr;
    }

    static void _dealloc_StoreCollectionData(py::wrapper::Windows::Services::Store::StoreCollectionData* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreCollectionData_get_AcquiredDate(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCollectionData", L"AcquiredDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AcquiredDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_CampaignId(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCollectionData", L"CampaignId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CampaignId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_DeveloperOfferId(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCollectionData", L"DeveloperOfferId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeveloperOfferId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_EndDate(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCollectionData", L"EndDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCollectionData", L"ExtendedJsonData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_IsTrial(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCollectionData", L"IsTrial"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTrial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_StartDate(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCollectionData", L"StartDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_TrialTimeRemaining(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCollectionData", L"TrialTimeRemaining"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrialTimeRemaining());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreCollectionData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreCollectionData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreCollectionData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreCollectionData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreCollectionData[] = {
        { "_assign_array_", _assign_array_StoreCollectionData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreCollectionData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreCollectionData[] = {
        { "acquired_date", reinterpret_cast<getter>(StoreCollectionData_get_AcquiredDate), nullptr, nullptr, nullptr },
        { "campaign_id", reinterpret_cast<getter>(StoreCollectionData_get_CampaignId), nullptr, nullptr, nullptr },
        { "developer_offer_id", reinterpret_cast<getter>(StoreCollectionData_get_DeveloperOfferId), nullptr, nullptr, nullptr },
        { "end_date", reinterpret_cast<getter>(StoreCollectionData_get_EndDate), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreCollectionData_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "is_trial", reinterpret_cast<getter>(StoreCollectionData_get_IsTrial), nullptr, nullptr, nullptr },
        { "start_date", reinterpret_cast<getter>(StoreCollectionData_get_StartDate), nullptr, nullptr, nullptr },
        { "trial_time_remaining", reinterpret_cast<getter>(StoreCollectionData_get_TrialTimeRemaining), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreCollectionData[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreCollectionData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreCollectionData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreCollectionData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreCollectionData) },
        { },
    };

    static PyType_Spec type_spec_StoreCollectionData =
    {
        "_winsdk_Windows_Services_Store.StoreCollectionData",
        sizeof(py::wrapper::Windows::Services::Store::StoreCollectionData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreCollectionData
    };

    // ----- StoreConsumableResult class --------------------
    static constexpr const char* const type_name_StoreConsumableResult = "StoreConsumableResult";

    static PyObject* _new_StoreConsumableResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StoreConsumableResult);
        return nullptr;
    }

    static void _dealloc_StoreConsumableResult(py::wrapper::Windows::Services::Store::StoreConsumableResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreConsumableResult_get_BalanceRemaining(py::wrapper::Windows::Services::Store::StoreConsumableResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreConsumableResult", L"BalanceRemaining"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BalanceRemaining());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreConsumableResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreConsumableResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreConsumableResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreConsumableResult_get_Status(py::wrapper::Windows::Services::Store::StoreConsumableResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreConsumableResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreConsumableResult_get_TrackingId(py::wrapper::Windows::Services::Store::StoreConsumableResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreConsumableResult", L"TrackingId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrackingId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreConsumableResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreConsumableResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreConsumableResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreConsumableResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreConsumableResult[] = {
        { "_assign_array_", _assign_array_StoreConsumableResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreConsumableResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreConsumableResult[] = {
        { "balance_remaining", reinterpret_cast<getter>(StoreConsumableResult_get_BalanceRemaining), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(StoreConsumableResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(StoreConsumableResult_get_Status), nullptr, nullptr, nullptr },
        { "tracking_id", reinterpret_cast<getter>(StoreConsumableResult_get_TrackingId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreConsumableResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreConsumableResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreConsumableResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreConsumableResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreConsumableResult) },
        { },
    };

    static PyType_Spec type_spec_StoreConsumableResult =
    {
        "_winsdk_Windows_Services_Store.StoreConsumableResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreConsumableResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreConsumableResult
    };

    // ----- StoreContext class --------------------
    static constexpr const char* const type_name_StoreContext = "StoreContext";

    static PyObject* _new_StoreContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StoreContext);
        return nullptr;
    }

    static void _dealloc_StoreContext(py::wrapper::Windows::Services::Store::StoreContext* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreContext_AcquireStoreLicenseForOptionalPackageAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"AcquireStoreLicenseForOptionalPackageAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);

                return py::convert(self->obj.AcquireStoreLicenseForOptionalPackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_CanAcquireStoreLicenseAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"CanAcquireStoreLicenseAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CanAcquireStoreLicenseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_CanAcquireStoreLicenseForOptionalPackageAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"CanAcquireStoreLicenseForOptionalPackageAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);

                return py::convert(self->obj.CanAcquireStoreLicenseForOptionalPackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_DownloadAndInstallStorePackagesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"DownloadAndInstallStorePackagesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.DownloadAndInstallStorePackagesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_FindStoreProductForPackageAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"FindStoreProductForPackageAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 1);

                return py::convert(self->obj.FindStoreProductForPackageAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetAppAndOptionalStorePackageUpdatesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetAppAndOptionalStorePackageUpdatesAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAppAndOptionalStorePackageUpdatesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetAppLicenseAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetAppLicenseAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAppLicenseAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetAssociatedStoreProductsAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetAssociatedStoreProductsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetAssociatedStoreProductsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetAssociatedStoreProductsWithPagingAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetAssociatedStoreProductsWithPagingAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetAssociatedStoreProductsWithPagingAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetAssociatedStoreQueueItemsAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetAssociatedStoreQueueItemsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAssociatedStoreQueueItemsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetConsumableBalanceRemainingAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetConsumableBalanceRemainingAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetConsumableBalanceRemainingAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetCustomerCollectionsIdAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetCustomerCollectionsIdAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetCustomerCollectionsIdAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetCustomerPurchaseIdAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetCustomerPurchaseIdAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetCustomerPurchaseIdAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Services::Store::StoreContext::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetForUser", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::Services::Store::StoreContext::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetStoreProductForCurrentAppAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetStoreProductForCurrentAppAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetStoreProductForCurrentAppAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetStoreProductsAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetStoreProductsAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(self->obj.GetStoreProductsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetStoreProductsAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Services::Store::StoreProductOptions>(args, 2);

                return py::convert(self->obj.GetStoreProductsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetStoreQueueItemsAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetStoreQueueItemsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetStoreQueueItemsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetUserCollectionAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetUserCollectionAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetUserCollectionAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetUserCollectionWithPagingAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetUserCollectionWithPagingAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetUserCollectionWithPagingAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_ReportConsumableFulfillmentAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"ReportConsumableFulfillmentAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);

                return py::convert(self->obj.ReportConsumableFulfillmentAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestDownloadAndInstallStorePackageUpdatesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestDownloadAndInstallStorePackageUpdatesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Services::Store::StorePackageUpdate>>(args, 0);

                return py::convert(self->obj.RequestDownloadAndInstallStorePackageUpdatesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestDownloadAndInstallStorePackagesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestDownloadAndInstallStorePackagesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.RequestDownloadAndInstallStorePackagesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestDownloadAndInstallStorePackagesAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Services::Store::StorePackageInstallOptions>(args, 1);

                return py::convert(self->obj.RequestDownloadAndInstallStorePackagesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestDownloadStorePackageUpdatesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestDownloadStorePackageUpdatesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Services::Store::StorePackageUpdate>>(args, 0);

                return py::convert(self->obj.RequestDownloadStorePackageUpdatesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestPurchaseAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestPurchaseAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RequestPurchaseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestPurchaseAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Services::Store::StorePurchaseProperties>(args, 1);

                return py::convert(self->obj.RequestPurchaseAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestRateAndReviewAppAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestRateAndReviewAppAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RequestRateAndReviewAppAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestUninstallStorePackageAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestUninstallStorePackageAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);

                return py::convert(self->obj.RequestUninstallStorePackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestUninstallStorePackageByStoreIdAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestUninstallStorePackageByStoreIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RequestUninstallStorePackageByStoreIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_SetInstallOrderForAssociatedStoreQueueItemsAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"SetInstallOrderForAssociatedStoreQueueItemsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Services::Store::StoreQueueItem>>(args, 0);

                return py::convert(self->obj.SetInstallOrderForAssociatedStoreQueueItemsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_TrySilentDownloadAndInstallStorePackageUpdatesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"TrySilentDownloadAndInstallStorePackageUpdatesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Services::Store::StorePackageUpdate>>(args, 0);

                return py::convert(self->obj.TrySilentDownloadAndInstallStorePackageUpdatesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_TrySilentDownloadStorePackageUpdatesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"TrySilentDownloadStorePackageUpdatesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Services::Store::StorePackageUpdate>>(args, 0);

                return py::convert(self->obj.TrySilentDownloadStorePackageUpdatesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_UninstallStorePackageAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"UninstallStorePackageAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);

                return py::convert(self->obj.UninstallStorePackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_UninstallStorePackageByStoreIdAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"UninstallStorePackageByStoreIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.UninstallStorePackageByStoreIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_get_User(py::wrapper::Windows::Services::Store::StoreContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreContext", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreContext_get_CanSilentlyDownloadStorePackageUpdates(py::wrapper::Windows::Services::Store::StoreContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreContext", L"CanSilentlyDownloadStorePackageUpdates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanSilentlyDownloadStorePackageUpdates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreContext_add_OfflineLicensesChanged(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Services.Store.StoreContext", L"OfflineLicensesChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Store::StoreContext, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.OfflineLicensesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreContext_remove_OfflineLicensesChanged(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Services.Store.StoreContext", L"OfflineLicensesChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OfflineLicensesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreContext[] = {
        { "acquire_store_license_for_optional_package_async", reinterpret_cast<PyCFunction>(StoreContext_AcquireStoreLicenseForOptionalPackageAsync), METH_VARARGS, nullptr },
        { "can_acquire_store_license_async", reinterpret_cast<PyCFunction>(StoreContext_CanAcquireStoreLicenseAsync), METH_VARARGS, nullptr },
        { "can_acquire_store_license_for_optional_package_async", reinterpret_cast<PyCFunction>(StoreContext_CanAcquireStoreLicenseForOptionalPackageAsync), METH_VARARGS, nullptr },
        { "download_and_install_store_packages_async", reinterpret_cast<PyCFunction>(StoreContext_DownloadAndInstallStorePackagesAsync), METH_VARARGS, nullptr },
        { "find_store_product_for_package_async", reinterpret_cast<PyCFunction>(StoreContext_FindStoreProductForPackageAsync), METH_VARARGS, nullptr },
        { "get_app_and_optional_store_package_updates_async", reinterpret_cast<PyCFunction>(StoreContext_GetAppAndOptionalStorePackageUpdatesAsync), METH_VARARGS, nullptr },
        { "get_app_license_async", reinterpret_cast<PyCFunction>(StoreContext_GetAppLicenseAsync), METH_VARARGS, nullptr },
        { "get_associated_store_products_async", reinterpret_cast<PyCFunction>(StoreContext_GetAssociatedStoreProductsAsync), METH_VARARGS, nullptr },
        { "get_associated_store_products_with_paging_async", reinterpret_cast<PyCFunction>(StoreContext_GetAssociatedStoreProductsWithPagingAsync), METH_VARARGS, nullptr },
        { "get_associated_store_queue_items_async", reinterpret_cast<PyCFunction>(StoreContext_GetAssociatedStoreQueueItemsAsync), METH_VARARGS, nullptr },
        { "get_consumable_balance_remaining_async", reinterpret_cast<PyCFunction>(StoreContext_GetConsumableBalanceRemainingAsync), METH_VARARGS, nullptr },
        { "get_customer_collections_id_async", reinterpret_cast<PyCFunction>(StoreContext_GetCustomerCollectionsIdAsync), METH_VARARGS, nullptr },
        { "get_customer_purchase_id_async", reinterpret_cast<PyCFunction>(StoreContext_GetCustomerPurchaseIdAsync), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(StoreContext_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(StoreContext_GetForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "get_store_product_for_current_app_async", reinterpret_cast<PyCFunction>(StoreContext_GetStoreProductForCurrentAppAsync), METH_VARARGS, nullptr },
        { "get_store_products_async", reinterpret_cast<PyCFunction>(StoreContext_GetStoreProductsAsync), METH_VARARGS, nullptr },
        { "get_store_queue_items_async", reinterpret_cast<PyCFunction>(StoreContext_GetStoreQueueItemsAsync), METH_VARARGS, nullptr },
        { "get_user_collection_async", reinterpret_cast<PyCFunction>(StoreContext_GetUserCollectionAsync), METH_VARARGS, nullptr },
        { "get_user_collection_with_paging_async", reinterpret_cast<PyCFunction>(StoreContext_GetUserCollectionWithPagingAsync), METH_VARARGS, nullptr },
        { "report_consumable_fulfillment_async", reinterpret_cast<PyCFunction>(StoreContext_ReportConsumableFulfillmentAsync), METH_VARARGS, nullptr },
        { "request_download_and_install_store_package_updates_async", reinterpret_cast<PyCFunction>(StoreContext_RequestDownloadAndInstallStorePackageUpdatesAsync), METH_VARARGS, nullptr },
        { "request_download_and_install_store_packages_async", reinterpret_cast<PyCFunction>(StoreContext_RequestDownloadAndInstallStorePackagesAsync), METH_VARARGS, nullptr },
        { "request_download_store_package_updates_async", reinterpret_cast<PyCFunction>(StoreContext_RequestDownloadStorePackageUpdatesAsync), METH_VARARGS, nullptr },
        { "request_purchase_async", reinterpret_cast<PyCFunction>(StoreContext_RequestPurchaseAsync), METH_VARARGS, nullptr },
        { "request_rate_and_review_app_async", reinterpret_cast<PyCFunction>(StoreContext_RequestRateAndReviewAppAsync), METH_VARARGS, nullptr },
        { "request_uninstall_store_package_async", reinterpret_cast<PyCFunction>(StoreContext_RequestUninstallStorePackageAsync), METH_VARARGS, nullptr },
        { "request_uninstall_store_package_by_store_id_async", reinterpret_cast<PyCFunction>(StoreContext_RequestUninstallStorePackageByStoreIdAsync), METH_VARARGS, nullptr },
        { "set_install_order_for_associated_store_queue_items_async", reinterpret_cast<PyCFunction>(StoreContext_SetInstallOrderForAssociatedStoreQueueItemsAsync), METH_VARARGS, nullptr },
        { "try_silent_download_and_install_store_package_updates_async", reinterpret_cast<PyCFunction>(StoreContext_TrySilentDownloadAndInstallStorePackageUpdatesAsync), METH_VARARGS, nullptr },
        { "try_silent_download_store_package_updates_async", reinterpret_cast<PyCFunction>(StoreContext_TrySilentDownloadStorePackageUpdatesAsync), METH_VARARGS, nullptr },
        { "uninstall_store_package_async", reinterpret_cast<PyCFunction>(StoreContext_UninstallStorePackageAsync), METH_VARARGS, nullptr },
        { "uninstall_store_package_by_store_id_async", reinterpret_cast<PyCFunction>(StoreContext_UninstallStorePackageByStoreIdAsync), METH_VARARGS, nullptr },
        { "add_offline_licenses_changed", reinterpret_cast<PyCFunction>(StoreContext_add_OfflineLicensesChanged), METH_O, nullptr },
        { "remove_offline_licenses_changed", reinterpret_cast<PyCFunction>(StoreContext_remove_OfflineLicensesChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_StoreContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreContext[] = {
        { "user", reinterpret_cast<getter>(StoreContext_get_User), nullptr, nullptr, nullptr },
        { "can_silently_download_store_package_updates", reinterpret_cast<getter>(StoreContext_get_CanSilentlyDownloadStorePackageUpdates), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreContext[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreContext) },
        { },
    };

    static PyType_Spec type_spec_StoreContext =
    {
        "_winsdk_Windows_Services_Store.StoreContext",
        sizeof(py::wrapper::Windows::Services::Store::StoreContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreContext
    };

    // ----- StoreImage class --------------------
    static constexpr const char* const type_name_StoreImage = "StoreImage";

    static PyObject* _new_StoreImage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StoreImage);
        return nullptr;
    }

    static void _dealloc_StoreImage(py::wrapper::Windows::Services::Store::StoreImage* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreImage_get_Caption(py::wrapper::Windows::Services::Store::StoreImage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreImage", L"Caption"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Caption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreImage_get_Height(py::wrapper::Windows::Services::Store::StoreImage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreImage", L"Height"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreImage_get_ImagePurposeTag(py::wrapper::Windows::Services::Store::StoreImage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreImage", L"ImagePurposeTag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ImagePurposeTag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreImage_get_Uri(py::wrapper::Windows::Services::Store::StoreImage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreImage", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreImage_get_Width(py::wrapper::Windows::Services::Store::StoreImage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreImage", L"Width"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreImage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreImage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreImage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreImage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreImage[] = {
        { "_assign_array_", _assign_array_StoreImage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreImage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreImage[] = {
        { "caption", reinterpret_cast<getter>(StoreImage_get_Caption), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(StoreImage_get_Height), nullptr, nullptr, nullptr },
        { "image_purpose_tag", reinterpret_cast<getter>(StoreImage_get_ImagePurposeTag), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(StoreImage_get_Uri), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(StoreImage_get_Width), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreImage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreImage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreImage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreImage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreImage) },
        { },
    };

    static PyType_Spec type_spec_StoreImage =
    {
        "_winsdk_Windows_Services_Store.StoreImage",
        sizeof(py::wrapper::Windows::Services::Store::StoreImage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreImage
    };

    // ----- StoreLicense class --------------------
    static constexpr const char* const type_name_StoreLicense = "StoreLicense";

    static PyObject* _new_StoreLicense(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StoreLicense);
        return nullptr;
    }

    static void _dealloc_StoreLicense(py::wrapper::Windows::Services::Store::StoreLicense* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreLicense_get_ExpirationDate(py::wrapper::Windows::Services::Store::StoreLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreLicense", L"ExpirationDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpirationDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreLicense_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreLicense", L"ExtendedJsonData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreLicense_get_InAppOfferToken(py::wrapper::Windows::Services::Store::StoreLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreLicense", L"InAppOfferToken"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InAppOfferToken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreLicense_get_IsActive(py::wrapper::Windows::Services::Store::StoreLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreLicense", L"IsActive"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreLicense_get_SkuStoreId(py::wrapper::Windows::Services::Store::StoreLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreLicense", L"SkuStoreId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SkuStoreId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreLicense>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreLicense>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreLicense[] = {
        { "_assign_array_", _assign_array_StoreLicense, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreLicense), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreLicense[] = {
        { "expiration_date", reinterpret_cast<getter>(StoreLicense_get_ExpirationDate), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreLicense_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "in_app_offer_token", reinterpret_cast<getter>(StoreLicense_get_InAppOfferToken), nullptr, nullptr, nullptr },
        { "is_active", reinterpret_cast<getter>(StoreLicense_get_IsActive), nullptr, nullptr, nullptr },
        { "sku_store_id", reinterpret_cast<getter>(StoreLicense_get_SkuStoreId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreLicense[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreLicense) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreLicense) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreLicense) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreLicense) },
        { },
    };

    static PyType_Spec type_spec_StoreLicense =
    {
        "_winsdk_Windows_Services_Store.StoreLicense",
        sizeof(py::wrapper::Windows::Services::Store::StoreLicense),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreLicense
    };

    // ----- StorePackageInstallOptions class --------------------
    static constexpr const char* const type_name_StorePackageInstallOptions = "StorePackageInstallOptions";

    static PyObject* _new_StorePackageInstallOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Services::Store::StorePackageInstallOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorePackageInstallOptions(py::wrapper::Windows::Services::Store::StorePackageInstallOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorePackageInstallOptions_get_AllowForcedAppRestart(py::wrapper::Windows::Services::Store::StorePackageInstallOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePackageInstallOptions", L"AllowForcedAppRestart"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowForcedAppRestart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageInstallOptions_put_AllowForcedAppRestart(py::wrapper::Windows::Services::Store::StorePackageInstallOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePackageInstallOptions", L"AllowForcedAppRestart"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowForcedAppRestart(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StorePackageInstallOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StorePackageInstallOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorePackageInstallOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePackageInstallOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePackageInstallOptions[] = {
        { "_assign_array_", _assign_array_StorePackageInstallOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePackageInstallOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorePackageInstallOptions[] = {
        { "allow_forced_app_restart", reinterpret_cast<getter>(StorePackageInstallOptions_get_AllowForcedAppRestart), reinterpret_cast<setter>(StorePackageInstallOptions_put_AllowForcedAppRestart), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorePackageInstallOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorePackageInstallOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorePackageInstallOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorePackageInstallOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorePackageInstallOptions) },
        { },
    };

    static PyType_Spec type_spec_StorePackageInstallOptions =
    {
        "_winsdk_Windows_Services_Store.StorePackageInstallOptions",
        sizeof(py::wrapper::Windows::Services::Store::StorePackageInstallOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePackageInstallOptions
    };

    // ----- StorePackageLicense class --------------------
    static constexpr const char* const type_name_StorePackageLicense = "StorePackageLicense";

    static PyObject* _new_StorePackageLicense(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StorePackageLicense);
        return nullptr;
    }

    static void _dealloc_StorePackageLicense(py::wrapper::Windows::Services::Store::StorePackageLicense* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorePackageLicense_Close(py::wrapper::Windows::Services::Store::StorePackageLicense* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StorePackageLicense", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorePackageLicense_ReleaseLicense(py::wrapper::Windows::Services::Store::StorePackageLicense* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StorePackageLicense", L"ReleaseLicense", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ReleaseLicense();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorePackageLicense_get_IsValid(py::wrapper::Windows::Services::Store::StorePackageLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePackageLicense", L"IsValid"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsValid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageLicense_get_Package(py::wrapper::Windows::Services::Store::StorePackageLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePackageLicense", L"Package"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageLicense_add_LicenseLost(py::wrapper::Windows::Services::Store::StorePackageLicense* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Services.Store.StorePackageLicense", L"LicenseLost"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Store::StorePackageLicense, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.LicenseLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageLicense_remove_LicenseLost(py::wrapper::Windows::Services::Store::StorePackageLicense* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Services.Store.StorePackageLicense", L"LicenseLost"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LicenseLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorePackageLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StorePackageLicense>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorePackageLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePackageLicense>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_StorePackageLicense(py::wrapper::Windows::Services::Store::StorePackageLicense* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_StorePackageLicense(py::wrapper::Windows::Services::Store::StorePackageLicense* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePackageLicense[] = {
        { "close", reinterpret_cast<PyCFunction>(StorePackageLicense_Close), METH_VARARGS, nullptr },
        { "release_license", reinterpret_cast<PyCFunction>(StorePackageLicense_ReleaseLicense), METH_VARARGS, nullptr },
        { "add_license_lost", reinterpret_cast<PyCFunction>(StorePackageLicense_add_LicenseLost), METH_O, nullptr },
        { "remove_license_lost", reinterpret_cast<PyCFunction>(StorePackageLicense_remove_LicenseLost), METH_O, nullptr },
        { "_assign_array_", _assign_array_StorePackageLicense, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePackageLicense), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_StorePackageLicense), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_StorePackageLicense), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorePackageLicense[] = {
        { "is_valid", reinterpret_cast<getter>(StorePackageLicense_get_IsValid), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(StorePackageLicense_get_Package), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorePackageLicense[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorePackageLicense) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorePackageLicense) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorePackageLicense) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorePackageLicense) },
        { },
    };

    static PyType_Spec type_spec_StorePackageLicense =
    {
        "_winsdk_Windows_Services_Store.StorePackageLicense",
        sizeof(py::wrapper::Windows::Services::Store::StorePackageLicense),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePackageLicense
    };

    // ----- StorePackageUpdate class --------------------
    static constexpr const char* const type_name_StorePackageUpdate = "StorePackageUpdate";

    static PyObject* _new_StorePackageUpdate(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StorePackageUpdate);
        return nullptr;
    }

    static void _dealloc_StorePackageUpdate(py::wrapper::Windows::Services::Store::StorePackageUpdate* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorePackageUpdate_get_Mandatory(py::wrapper::Windows::Services::Store::StorePackageUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePackageUpdate", L"Mandatory"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Mandatory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageUpdate_get_Package(py::wrapper::Windows::Services::Store::StorePackageUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePackageUpdate", L"Package"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorePackageUpdate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StorePackageUpdate>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorePackageUpdate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePackageUpdate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePackageUpdate[] = {
        { "_assign_array_", _assign_array_StorePackageUpdate, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePackageUpdate), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorePackageUpdate[] = {
        { "mandatory", reinterpret_cast<getter>(StorePackageUpdate_get_Mandatory), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(StorePackageUpdate_get_Package), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorePackageUpdate[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorePackageUpdate) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorePackageUpdate) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorePackageUpdate) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorePackageUpdate) },
        { },
    };

    static PyType_Spec type_spec_StorePackageUpdate =
    {
        "_winsdk_Windows_Services_Store.StorePackageUpdate",
        sizeof(py::wrapper::Windows::Services::Store::StorePackageUpdate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePackageUpdate
    };

    // ----- StorePackageUpdateResult class --------------------
    static constexpr const char* const type_name_StorePackageUpdateResult = "StorePackageUpdateResult";

    static PyObject* _new_StorePackageUpdateResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StorePackageUpdateResult);
        return nullptr;
    }

    static void _dealloc_StorePackageUpdateResult(py::wrapper::Windows::Services::Store::StorePackageUpdateResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorePackageUpdateResult_get_OverallState(py::wrapper::Windows::Services::Store::StorePackageUpdateResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePackageUpdateResult", L"OverallState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OverallState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageUpdateResult_get_StorePackageUpdateStatuses(py::wrapper::Windows::Services::Store::StorePackageUpdateResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePackageUpdateResult", L"StorePackageUpdateStatuses"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StorePackageUpdateStatuses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageUpdateResult_get_StoreQueueItems(py::wrapper::Windows::Services::Store::StorePackageUpdateResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePackageUpdateResult", L"StoreQueueItems"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StoreQueueItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorePackageUpdateResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StorePackageUpdateResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorePackageUpdateResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePackageUpdateResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePackageUpdateResult[] = {
        { "_assign_array_", _assign_array_StorePackageUpdateResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePackageUpdateResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorePackageUpdateResult[] = {
        { "overall_state", reinterpret_cast<getter>(StorePackageUpdateResult_get_OverallState), nullptr, nullptr, nullptr },
        { "store_package_update_statuses", reinterpret_cast<getter>(StorePackageUpdateResult_get_StorePackageUpdateStatuses), nullptr, nullptr, nullptr },
        { "store_queue_items", reinterpret_cast<getter>(StorePackageUpdateResult_get_StoreQueueItems), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorePackageUpdateResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorePackageUpdateResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorePackageUpdateResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorePackageUpdateResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorePackageUpdateResult) },
        { },
    };

    static PyType_Spec type_spec_StorePackageUpdateResult =
    {
        "_winsdk_Windows_Services_Store.StorePackageUpdateResult",
        sizeof(py::wrapper::Windows::Services::Store::StorePackageUpdateResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePackageUpdateResult
    };

    // ----- StorePrice class --------------------
    static constexpr const char* const type_name_StorePrice = "StorePrice";

    static PyObject* _new_StorePrice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StorePrice);
        return nullptr;
    }

    static void _dealloc_StorePrice(py::wrapper::Windows::Services::Store::StorePrice* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorePrice_get_CurrencyCode(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePrice", L"CurrencyCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrencyCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_FormattedBasePrice(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePrice", L"FormattedBasePrice"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FormattedBasePrice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_FormattedPrice(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePrice", L"FormattedPrice"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FormattedPrice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_FormattedRecurrencePrice(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePrice", L"FormattedRecurrencePrice"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FormattedRecurrencePrice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_IsOnSale(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePrice", L"IsOnSale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsOnSale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_SaleEndDate(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePrice", L"SaleEndDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SaleEndDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorePrice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StorePrice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorePrice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePrice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePrice[] = {
        { "_assign_array_", _assign_array_StorePrice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePrice), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorePrice[] = {
        { "currency_code", reinterpret_cast<getter>(StorePrice_get_CurrencyCode), nullptr, nullptr, nullptr },
        { "formatted_base_price", reinterpret_cast<getter>(StorePrice_get_FormattedBasePrice), nullptr, nullptr, nullptr },
        { "formatted_price", reinterpret_cast<getter>(StorePrice_get_FormattedPrice), nullptr, nullptr, nullptr },
        { "formatted_recurrence_price", reinterpret_cast<getter>(StorePrice_get_FormattedRecurrencePrice), nullptr, nullptr, nullptr },
        { "is_on_sale", reinterpret_cast<getter>(StorePrice_get_IsOnSale), nullptr, nullptr, nullptr },
        { "sale_end_date", reinterpret_cast<getter>(StorePrice_get_SaleEndDate), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorePrice[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorePrice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorePrice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorePrice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorePrice) },
        { },
    };

    static PyType_Spec type_spec_StorePrice =
    {
        "_winsdk_Windows_Services_Store.StorePrice",
        sizeof(py::wrapper::Windows::Services::Store::StorePrice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePrice
    };

    // ----- StoreProduct class --------------------
    static constexpr const char* const type_name_StoreProduct = "StoreProduct";

    static PyObject* _new_StoreProduct(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StoreProduct);
        return nullptr;
    }

    static void _dealloc_StoreProduct(py::wrapper::Windows::Services::Store::StoreProduct* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreProduct_GetIsAnySkuInstalledAsync(py::wrapper::Windows::Services::Store::StoreProduct* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreProduct", L"GetIsAnySkuInstalledAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetIsAnySkuInstalledAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreProduct_RequestPurchaseAsync(py::wrapper::Windows::Services::Store::StoreProduct* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreProduct", L"RequestPurchaseAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RequestPurchaseAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreProduct", L"RequestPurchaseAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Services::Store::StorePurchaseProperties>(args, 0);

                return py::convert(self->obj.RequestPurchaseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Description(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"ExtendedJsonData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_HasDigitalDownload(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"HasDigitalDownload"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasDigitalDownload());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Images(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"Images"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Images());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_InAppOfferToken(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"InAppOfferToken"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InAppOfferToken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_IsInUserCollection(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"IsInUserCollection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInUserCollection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Keywords(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"Keywords"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Keywords());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Language(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_LinkUri(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"LinkUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LinkUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Price(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"Price"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Price());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_ProductKind(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"ProductKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProductKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Skus(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"Skus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Skus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_StoreId(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"StoreId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StoreId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Title(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Videos(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"Videos"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Videos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreProduct(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreProduct>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreProduct(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreProduct>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreProduct[] = {
        { "get_is_any_sku_installed_async", reinterpret_cast<PyCFunction>(StoreProduct_GetIsAnySkuInstalledAsync), METH_VARARGS, nullptr },
        { "request_purchase_async", reinterpret_cast<PyCFunction>(StoreProduct_RequestPurchaseAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StoreProduct, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreProduct), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreProduct[] = {
        { "description", reinterpret_cast<getter>(StoreProduct_get_Description), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreProduct_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "has_digital_download", reinterpret_cast<getter>(StoreProduct_get_HasDigitalDownload), nullptr, nullptr, nullptr },
        { "images", reinterpret_cast<getter>(StoreProduct_get_Images), nullptr, nullptr, nullptr },
        { "in_app_offer_token", reinterpret_cast<getter>(StoreProduct_get_InAppOfferToken), nullptr, nullptr, nullptr },
        { "is_in_user_collection", reinterpret_cast<getter>(StoreProduct_get_IsInUserCollection), nullptr, nullptr, nullptr },
        { "keywords", reinterpret_cast<getter>(StoreProduct_get_Keywords), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(StoreProduct_get_Language), nullptr, nullptr, nullptr },
        { "link_uri", reinterpret_cast<getter>(StoreProduct_get_LinkUri), nullptr, nullptr, nullptr },
        { "price", reinterpret_cast<getter>(StoreProduct_get_Price), nullptr, nullptr, nullptr },
        { "product_kind", reinterpret_cast<getter>(StoreProduct_get_ProductKind), nullptr, nullptr, nullptr },
        { "skus", reinterpret_cast<getter>(StoreProduct_get_Skus), nullptr, nullptr, nullptr },
        { "store_id", reinterpret_cast<getter>(StoreProduct_get_StoreId), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(StoreProduct_get_Title), nullptr, nullptr, nullptr },
        { "videos", reinterpret_cast<getter>(StoreProduct_get_Videos), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreProduct[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreProduct) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreProduct) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreProduct) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreProduct) },
        { },
    };

    static PyType_Spec type_spec_StoreProduct =
    {
        "_winsdk_Windows_Services_Store.StoreProduct",
        sizeof(py::wrapper::Windows::Services::Store::StoreProduct),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreProduct
    };

    // ----- StoreProductOptions class --------------------
    static constexpr const char* const type_name_StoreProductOptions = "StoreProductOptions";

    static PyObject* _new_StoreProductOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Services::Store::StoreProductOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StoreProductOptions(py::wrapper::Windows::Services::Store::StoreProductOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreProductOptions_get_ActionFilters(py::wrapper::Windows::Services::Store::StoreProductOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProductOptions", L"ActionFilters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActionFilters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreProductOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreProductOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreProductOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreProductOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreProductOptions[] = {
        { "_assign_array_", _assign_array_StoreProductOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreProductOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreProductOptions[] = {
        { "action_filters", reinterpret_cast<getter>(StoreProductOptions_get_ActionFilters), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreProductOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreProductOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreProductOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreProductOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreProductOptions) },
        { },
    };

    static PyType_Spec type_spec_StoreProductOptions =
    {
        "_winsdk_Windows_Services_Store.StoreProductOptions",
        sizeof(py::wrapper::Windows::Services::Store::StoreProductOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreProductOptions
    };

    // ----- StoreProductPagedQueryResult class --------------------
    static constexpr const char* const type_name_StoreProductPagedQueryResult = "StoreProductPagedQueryResult";

    static PyObject* _new_StoreProductPagedQueryResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StoreProductPagedQueryResult);
        return nullptr;
    }

    static void _dealloc_StoreProductPagedQueryResult(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreProductPagedQueryResult_GetNextAsync(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreProductPagedQueryResult", L"GetNextAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetNextAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreProductPagedQueryResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProductPagedQueryResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProductPagedQueryResult_get_HasMoreResults(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProductPagedQueryResult", L"HasMoreResults"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasMoreResults());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProductPagedQueryResult_get_Products(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProductPagedQueryResult", L"Products"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Products());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreProductPagedQueryResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreProductPagedQueryResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreProductPagedQueryResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreProductPagedQueryResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreProductPagedQueryResult[] = {
        { "get_next_async", reinterpret_cast<PyCFunction>(StoreProductPagedQueryResult_GetNextAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StoreProductPagedQueryResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreProductPagedQueryResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreProductPagedQueryResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreProductPagedQueryResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "has_more_results", reinterpret_cast<getter>(StoreProductPagedQueryResult_get_HasMoreResults), nullptr, nullptr, nullptr },
        { "products", reinterpret_cast<getter>(StoreProductPagedQueryResult_get_Products), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreProductPagedQueryResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreProductPagedQueryResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreProductPagedQueryResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreProductPagedQueryResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreProductPagedQueryResult) },
        { },
    };

    static PyType_Spec type_spec_StoreProductPagedQueryResult =
    {
        "_winsdk_Windows_Services_Store.StoreProductPagedQueryResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreProductPagedQueryResult
    };

    // ----- StoreProductQueryResult class --------------------
    static constexpr const char* const type_name_StoreProductQueryResult = "StoreProductQueryResult";

    static PyObject* _new_StoreProductQueryResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StoreProductQueryResult);
        return nullptr;
    }

    static void _dealloc_StoreProductQueryResult(py::wrapper::Windows::Services::Store::StoreProductQueryResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreProductQueryResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreProductQueryResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProductQueryResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProductQueryResult_get_Products(py::wrapper::Windows::Services::Store::StoreProductQueryResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProductQueryResult", L"Products"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Products());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreProductQueryResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreProductQueryResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreProductQueryResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreProductQueryResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreProductQueryResult[] = {
        { "_assign_array_", _assign_array_StoreProductQueryResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreProductQueryResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreProductQueryResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreProductQueryResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "products", reinterpret_cast<getter>(StoreProductQueryResult_get_Products), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreProductQueryResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreProductQueryResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreProductQueryResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreProductQueryResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreProductQueryResult) },
        { },
    };

    static PyType_Spec type_spec_StoreProductQueryResult =
    {
        "_winsdk_Windows_Services_Store.StoreProductQueryResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreProductQueryResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreProductQueryResult
    };

    // ----- StoreProductResult class --------------------
    static constexpr const char* const type_name_StoreProductResult = "StoreProductResult";

    static PyObject* _new_StoreProductResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StoreProductResult);
        return nullptr;
    }

    static void _dealloc_StoreProductResult(py::wrapper::Windows::Services::Store::StoreProductResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreProductResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreProductResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProductResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProductResult_get_Product(py::wrapper::Windows::Services::Store::StoreProductResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProductResult", L"Product"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Product());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreProductResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreProductResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreProductResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreProductResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreProductResult[] = {
        { "_assign_array_", _assign_array_StoreProductResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreProductResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreProductResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreProductResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "product", reinterpret_cast<getter>(StoreProductResult_get_Product), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreProductResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreProductResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreProductResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreProductResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreProductResult) },
        { },
    };

    static PyType_Spec type_spec_StoreProductResult =
    {
        "_winsdk_Windows_Services_Store.StoreProductResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreProductResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreProductResult
    };

    // ----- StorePurchaseProperties class --------------------
    static constexpr const char* const type_name_StorePurchaseProperties = "StorePurchaseProperties";

    static PyObject* _new_StorePurchaseProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Services::Store::StorePurchaseProperties instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Services::Store::StorePurchaseProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorePurchaseProperties(py::wrapper::Windows::Services::Store::StorePurchaseProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorePurchaseProperties_get_Name(py::wrapper::Windows::Services::Store::StorePurchaseProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePurchaseProperties", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePurchaseProperties_put_Name(py::wrapper::Windows::Services::Store::StorePurchaseProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePurchaseProperties", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorePurchaseProperties_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StorePurchaseProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePurchaseProperties", L"ExtendedJsonData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePurchaseProperties_put_ExtendedJsonData(py::wrapper::Windows::Services::Store::StorePurchaseProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePurchaseProperties", L"ExtendedJsonData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ExtendedJsonData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StorePurchaseProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StorePurchaseProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorePurchaseProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePurchaseProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePurchaseProperties[] = {
        { "_assign_array_", _assign_array_StorePurchaseProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePurchaseProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorePurchaseProperties[] = {
        { "name", reinterpret_cast<getter>(StorePurchaseProperties_get_Name), reinterpret_cast<setter>(StorePurchaseProperties_put_Name), nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StorePurchaseProperties_get_ExtendedJsonData), reinterpret_cast<setter>(StorePurchaseProperties_put_ExtendedJsonData), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorePurchaseProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorePurchaseProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorePurchaseProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorePurchaseProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorePurchaseProperties) },
        { },
    };

    static PyType_Spec type_spec_StorePurchaseProperties =
    {
        "_winsdk_Windows_Services_Store.StorePurchaseProperties",
        sizeof(py::wrapper::Windows::Services::Store::StorePurchaseProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePurchaseProperties
    };

    // ----- StorePurchaseResult class --------------------
    static constexpr const char* const type_name_StorePurchaseResult = "StorePurchaseResult";

    static PyObject* _new_StorePurchaseResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StorePurchaseResult);
        return nullptr;
    }

    static void _dealloc_StorePurchaseResult(py::wrapper::Windows::Services::Store::StorePurchaseResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorePurchaseResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StorePurchaseResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePurchaseResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePurchaseResult_get_Status(py::wrapper::Windows::Services::Store::StorePurchaseResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePurchaseResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorePurchaseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StorePurchaseResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorePurchaseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePurchaseResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePurchaseResult[] = {
        { "_assign_array_", _assign_array_StorePurchaseResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePurchaseResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorePurchaseResult[] = {
        { "extended_error", reinterpret_cast<getter>(StorePurchaseResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(StorePurchaseResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorePurchaseResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorePurchaseResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorePurchaseResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorePurchaseResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorePurchaseResult) },
        { },
    };

    static PyType_Spec type_spec_StorePurchaseResult =
    {
        "_winsdk_Windows_Services_Store.StorePurchaseResult",
        sizeof(py::wrapper::Windows::Services::Store::StorePurchaseResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePurchaseResult
    };

    // ----- StoreQueueItem class --------------------
    static constexpr const char* const type_name_StoreQueueItem = "StoreQueueItem";

    static PyObject* _new_StoreQueueItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StoreQueueItem);
        return nullptr;
    }

    static void _dealloc_StoreQueueItem(py::wrapper::Windows::Services::Store::StoreQueueItem* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreQueueItem_CancelInstallAsync(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreQueueItem", L"CancelInstallAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CancelInstallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_GetCurrentStatus(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreQueueItem", L"GetCurrentStatus", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentStatus());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_PauseInstallAsync(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreQueueItem", L"PauseInstallAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.PauseInstallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_ResumeInstallAsync(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreQueueItem", L"ResumeInstallAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ResumeInstallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_get_InstallKind(py::wrapper::Windows::Services::Store::StoreQueueItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreQueueItem", L"InstallKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstallKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_get_PackageFamilyName(py::wrapper::Windows::Services::Store::StoreQueueItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreQueueItem", L"PackageFamilyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_get_ProductId(py::wrapper::Windows::Services::Store::StoreQueueItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreQueueItem", L"ProductId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_add_Completed(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Services.Store.StoreQueueItem", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Store::StoreQueueItem, winrt::Windows::Services::Store::StoreQueueItemCompletedEventArgs>>(arg);

            return py::convert(self->obj.Completed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_remove_Completed(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Services.Store.StoreQueueItem", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_add_StatusChanged(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Services.Store.StoreQueueItem", L"StatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Store::StoreQueueItem, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_remove_StatusChanged(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Services.Store.StoreQueueItem", L"StatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreQueueItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreQueueItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreQueueItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreQueueItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreQueueItem[] = {
        { "cancel_install_async", reinterpret_cast<PyCFunction>(StoreQueueItem_CancelInstallAsync), METH_VARARGS, nullptr },
        { "get_current_status", reinterpret_cast<PyCFunction>(StoreQueueItem_GetCurrentStatus), METH_VARARGS, nullptr },
        { "pause_install_async", reinterpret_cast<PyCFunction>(StoreQueueItem_PauseInstallAsync), METH_VARARGS, nullptr },
        { "resume_install_async", reinterpret_cast<PyCFunction>(StoreQueueItem_ResumeInstallAsync), METH_VARARGS, nullptr },
        { "add_completed", reinterpret_cast<PyCFunction>(StoreQueueItem_add_Completed), METH_O, nullptr },
        { "remove_completed", reinterpret_cast<PyCFunction>(StoreQueueItem_remove_Completed), METH_O, nullptr },
        { "add_status_changed", reinterpret_cast<PyCFunction>(StoreQueueItem_add_StatusChanged), METH_O, nullptr },
        { "remove_status_changed", reinterpret_cast<PyCFunction>(StoreQueueItem_remove_StatusChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_StoreQueueItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreQueueItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreQueueItem[] = {
        { "install_kind", reinterpret_cast<getter>(StoreQueueItem_get_InstallKind), nullptr, nullptr, nullptr },
        { "package_family_name", reinterpret_cast<getter>(StoreQueueItem_get_PackageFamilyName), nullptr, nullptr, nullptr },
        { "product_id", reinterpret_cast<getter>(StoreQueueItem_get_ProductId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreQueueItem[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreQueueItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreQueueItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreQueueItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreQueueItem) },
        { },
    };

    static PyType_Spec type_spec_StoreQueueItem =
    {
        "_winsdk_Windows_Services_Store.StoreQueueItem",
        sizeof(py::wrapper::Windows::Services::Store::StoreQueueItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreQueueItem
    };

    // ----- StoreQueueItemCompletedEventArgs class --------------------
    static constexpr const char* const type_name_StoreQueueItemCompletedEventArgs = "StoreQueueItemCompletedEventArgs";

    static PyObject* _new_StoreQueueItemCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StoreQueueItemCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_StoreQueueItemCompletedEventArgs(py::wrapper::Windows::Services::Store::StoreQueueItemCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreQueueItemCompletedEventArgs_get_Status(py::wrapper::Windows::Services::Store::StoreQueueItemCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreQueueItemCompletedEventArgs", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreQueueItemCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreQueueItemCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreQueueItemCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreQueueItemCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreQueueItemCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_StoreQueueItemCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreQueueItemCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreQueueItemCompletedEventArgs[] = {
        { "status", reinterpret_cast<getter>(StoreQueueItemCompletedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreQueueItemCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreQueueItemCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreQueueItemCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreQueueItemCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreQueueItemCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_StoreQueueItemCompletedEventArgs =
    {
        "_winsdk_Windows_Services_Store.StoreQueueItemCompletedEventArgs",
        sizeof(py::wrapper::Windows::Services::Store::StoreQueueItemCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreQueueItemCompletedEventArgs
    };

    // ----- StoreQueueItemStatus class --------------------
    static constexpr const char* const type_name_StoreQueueItemStatus = "StoreQueueItemStatus";

    static PyObject* _new_StoreQueueItemStatus(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StoreQueueItemStatus);
        return nullptr;
    }

    static void _dealloc_StoreQueueItemStatus(py::wrapper::Windows::Services::Store::StoreQueueItemStatus* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreQueueItemStatus_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreQueueItemStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreQueueItemStatus", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItemStatus_get_PackageInstallExtendedState(py::wrapper::Windows::Services::Store::StoreQueueItemStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreQueueItemStatus", L"PackageInstallExtendedState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PackageInstallExtendedState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItemStatus_get_PackageInstallState(py::wrapper::Windows::Services::Store::StoreQueueItemStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreQueueItemStatus", L"PackageInstallState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PackageInstallState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItemStatus_get_UpdateStatus(py::wrapper::Windows::Services::Store::StoreQueueItemStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreQueueItemStatus", L"UpdateStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UpdateStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreQueueItemStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreQueueItemStatus>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreQueueItemStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreQueueItemStatus>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreQueueItemStatus[] = {
        { "_assign_array_", _assign_array_StoreQueueItemStatus, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreQueueItemStatus), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreQueueItemStatus[] = {
        { "extended_error", reinterpret_cast<getter>(StoreQueueItemStatus_get_ExtendedError), nullptr, nullptr, nullptr },
        { "package_install_extended_state", reinterpret_cast<getter>(StoreQueueItemStatus_get_PackageInstallExtendedState), nullptr, nullptr, nullptr },
        { "package_install_state", reinterpret_cast<getter>(StoreQueueItemStatus_get_PackageInstallState), nullptr, nullptr, nullptr },
        { "update_status", reinterpret_cast<getter>(StoreQueueItemStatus_get_UpdateStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreQueueItemStatus[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreQueueItemStatus) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreQueueItemStatus) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreQueueItemStatus) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreQueueItemStatus) },
        { },
    };

    static PyType_Spec type_spec_StoreQueueItemStatus =
    {
        "_winsdk_Windows_Services_Store.StoreQueueItemStatus",
        sizeof(py::wrapper::Windows::Services::Store::StoreQueueItemStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreQueueItemStatus
    };

    // ----- StoreRateAndReviewResult class --------------------
    static constexpr const char* const type_name_StoreRateAndReviewResult = "StoreRateAndReviewResult";

    static PyObject* _new_StoreRateAndReviewResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StoreRateAndReviewResult);
        return nullptr;
    }

    static void _dealloc_StoreRateAndReviewResult(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreRateAndReviewResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreRateAndReviewResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreRateAndReviewResult_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreRateAndReviewResult", L"ExtendedJsonData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreRateAndReviewResult_get_Status(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreRateAndReviewResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreRateAndReviewResult_get_WasUpdated(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreRateAndReviewResult", L"WasUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WasUpdated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreRateAndReviewResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreRateAndReviewResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreRateAndReviewResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreRateAndReviewResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreRateAndReviewResult[] = {
        { "_assign_array_", _assign_array_StoreRateAndReviewResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreRateAndReviewResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreRateAndReviewResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreRateAndReviewResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreRateAndReviewResult_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(StoreRateAndReviewResult_get_Status), nullptr, nullptr, nullptr },
        { "was_updated", reinterpret_cast<getter>(StoreRateAndReviewResult_get_WasUpdated), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreRateAndReviewResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreRateAndReviewResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreRateAndReviewResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreRateAndReviewResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreRateAndReviewResult) },
        { },
    };

    static PyType_Spec type_spec_StoreRateAndReviewResult =
    {
        "_winsdk_Windows_Services_Store.StoreRateAndReviewResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreRateAndReviewResult
    };

    // ----- StoreRequestHelper class --------------------
    static constexpr const char* const type_name_StoreRequestHelper = "StoreRequestHelper";

    static PyObject* _new_StoreRequestHelper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StoreRequestHelper);
        return nullptr;
    }

    static PyObject* StoreRequestHelper_SendRequestAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreRequestHelper", L"SendRequestAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Services::Store::StoreContext>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(winrt::Windows::Services::Store::StoreRequestHelper::SendRequestAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreRequestHelper[] = {
        { "send_request_async", reinterpret_cast<PyCFunction>(StoreRequestHelper_SendRequestAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreRequestHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_StoreRequestHelper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreRequestHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreRequestHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreRequestHelper) },
        { },
    };

    static PyType_Spec type_spec_StoreRequestHelper =
    {
        "_winsdk_Windows_Services_Store.StoreRequestHelper",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreRequestHelper
    };

    // ----- StoreSendRequestResult class --------------------
    static constexpr const char* const type_name_StoreSendRequestResult = "StoreSendRequestResult";

    static PyObject* _new_StoreSendRequestResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StoreSendRequestResult);
        return nullptr;
    }

    static void _dealloc_StoreSendRequestResult(py::wrapper::Windows::Services::Store::StoreSendRequestResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreSendRequestResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreSendRequestResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSendRequestResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSendRequestResult_get_Response(py::wrapper::Windows::Services::Store::StoreSendRequestResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSendRequestResult", L"Response"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Response());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSendRequestResult_get_HttpStatusCode(py::wrapper::Windows::Services::Store::StoreSendRequestResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSendRequestResult", L"HttpStatusCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HttpStatusCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreSendRequestResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreSendRequestResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreSendRequestResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreSendRequestResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreSendRequestResult[] = {
        { "_assign_array_", _assign_array_StoreSendRequestResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreSendRequestResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreSendRequestResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreSendRequestResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "response", reinterpret_cast<getter>(StoreSendRequestResult_get_Response), nullptr, nullptr, nullptr },
        { "http_status_code", reinterpret_cast<getter>(StoreSendRequestResult_get_HttpStatusCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreSendRequestResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreSendRequestResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreSendRequestResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreSendRequestResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreSendRequestResult) },
        { },
    };

    static PyType_Spec type_spec_StoreSendRequestResult =
    {
        "_winsdk_Windows_Services_Store.StoreSendRequestResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreSendRequestResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreSendRequestResult
    };

    // ----- StoreSku class --------------------
    static constexpr const char* const type_name_StoreSku = "StoreSku";

    static PyObject* _new_StoreSku(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StoreSku);
        return nullptr;
    }

    static void _dealloc_StoreSku(py::wrapper::Windows::Services::Store::StoreSku* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreSku_GetIsInstalledAsync(py::wrapper::Windows::Services::Store::StoreSku* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreSku", L"GetIsInstalledAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetIsInstalledAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreSku_RequestPurchaseAsync(py::wrapper::Windows::Services::Store::StoreSku* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreSku", L"RequestPurchaseAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RequestPurchaseAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreSku", L"RequestPurchaseAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Services::Store::StorePurchaseProperties>(args, 0);

                return py::convert(self->obj.RequestPurchaseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Availabilities(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"Availabilities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Availabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_BundledSkus(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"BundledSkus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BundledSkus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_CollectionData(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"CollectionData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CollectionData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_CustomDeveloperData(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"CustomDeveloperData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CustomDeveloperData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Description(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"ExtendedJsonData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Images(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"Images"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Images());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_IsInUserCollection(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"IsInUserCollection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInUserCollection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_IsSubscription(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"IsSubscription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSubscription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_IsTrial(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"IsTrial"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTrial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Language(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Price(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"Price"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Price());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_StoreId(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"StoreId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StoreId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_SubscriptionInfo(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"SubscriptionInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SubscriptionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Title(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Videos(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"Videos"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Videos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreSku(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreSku>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreSku(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreSku>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreSku[] = {
        { "get_is_installed_async", reinterpret_cast<PyCFunction>(StoreSku_GetIsInstalledAsync), METH_VARARGS, nullptr },
        { "request_purchase_async", reinterpret_cast<PyCFunction>(StoreSku_RequestPurchaseAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StoreSku, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreSku), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreSku[] = {
        { "availabilities", reinterpret_cast<getter>(StoreSku_get_Availabilities), nullptr, nullptr, nullptr },
        { "bundled_skus", reinterpret_cast<getter>(StoreSku_get_BundledSkus), nullptr, nullptr, nullptr },
        { "collection_data", reinterpret_cast<getter>(StoreSku_get_CollectionData), nullptr, nullptr, nullptr },
        { "custom_developer_data", reinterpret_cast<getter>(StoreSku_get_CustomDeveloperData), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(StoreSku_get_Description), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreSku_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "images", reinterpret_cast<getter>(StoreSku_get_Images), nullptr, nullptr, nullptr },
        { "is_in_user_collection", reinterpret_cast<getter>(StoreSku_get_IsInUserCollection), nullptr, nullptr, nullptr },
        { "is_subscription", reinterpret_cast<getter>(StoreSku_get_IsSubscription), nullptr, nullptr, nullptr },
        { "is_trial", reinterpret_cast<getter>(StoreSku_get_IsTrial), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(StoreSku_get_Language), nullptr, nullptr, nullptr },
        { "price", reinterpret_cast<getter>(StoreSku_get_Price), nullptr, nullptr, nullptr },
        { "store_id", reinterpret_cast<getter>(StoreSku_get_StoreId), nullptr, nullptr, nullptr },
        { "subscription_info", reinterpret_cast<getter>(StoreSku_get_SubscriptionInfo), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(StoreSku_get_Title), nullptr, nullptr, nullptr },
        { "videos", reinterpret_cast<getter>(StoreSku_get_Videos), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreSku[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreSku) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreSku) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreSku) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreSku) },
        { },
    };

    static PyType_Spec type_spec_StoreSku =
    {
        "_winsdk_Windows_Services_Store.StoreSku",
        sizeof(py::wrapper::Windows::Services::Store::StoreSku),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreSku
    };

    // ----- StoreSubscriptionInfo class --------------------
    static constexpr const char* const type_name_StoreSubscriptionInfo = "StoreSubscriptionInfo";

    static PyObject* _new_StoreSubscriptionInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StoreSubscriptionInfo);
        return nullptr;
    }

    static void _dealloc_StoreSubscriptionInfo(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreSubscriptionInfo_get_BillingPeriod(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSubscriptionInfo", L"BillingPeriod"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BillingPeriod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSubscriptionInfo_get_BillingPeriodUnit(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSubscriptionInfo", L"BillingPeriodUnit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BillingPeriodUnit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSubscriptionInfo_get_HasTrialPeriod(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSubscriptionInfo", L"HasTrialPeriod"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasTrialPeriod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSubscriptionInfo_get_TrialPeriod(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSubscriptionInfo", L"TrialPeriod"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrialPeriod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSubscriptionInfo_get_TrialPeriodUnit(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSubscriptionInfo", L"TrialPeriodUnit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrialPeriodUnit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreSubscriptionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreSubscriptionInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreSubscriptionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreSubscriptionInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreSubscriptionInfo[] = {
        { "_assign_array_", _assign_array_StoreSubscriptionInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreSubscriptionInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreSubscriptionInfo[] = {
        { "billing_period", reinterpret_cast<getter>(StoreSubscriptionInfo_get_BillingPeriod), nullptr, nullptr, nullptr },
        { "billing_period_unit", reinterpret_cast<getter>(StoreSubscriptionInfo_get_BillingPeriodUnit), nullptr, nullptr, nullptr },
        { "has_trial_period", reinterpret_cast<getter>(StoreSubscriptionInfo_get_HasTrialPeriod), nullptr, nullptr, nullptr },
        { "trial_period", reinterpret_cast<getter>(StoreSubscriptionInfo_get_TrialPeriod), nullptr, nullptr, nullptr },
        { "trial_period_unit", reinterpret_cast<getter>(StoreSubscriptionInfo_get_TrialPeriodUnit), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreSubscriptionInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreSubscriptionInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreSubscriptionInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreSubscriptionInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreSubscriptionInfo) },
        { },
    };

    static PyType_Spec type_spec_StoreSubscriptionInfo =
    {
        "_winsdk_Windows_Services_Store.StoreSubscriptionInfo",
        sizeof(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreSubscriptionInfo
    };

    // ----- StoreUninstallStorePackageResult class --------------------
    static constexpr const char* const type_name_StoreUninstallStorePackageResult = "StoreUninstallStorePackageResult";

    static PyObject* _new_StoreUninstallStorePackageResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StoreUninstallStorePackageResult);
        return nullptr;
    }

    static void _dealloc_StoreUninstallStorePackageResult(py::wrapper::Windows::Services::Store::StoreUninstallStorePackageResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreUninstallStorePackageResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreUninstallStorePackageResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreUninstallStorePackageResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreUninstallStorePackageResult_get_Status(py::wrapper::Windows::Services::Store::StoreUninstallStorePackageResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreUninstallStorePackageResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreUninstallStorePackageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreUninstallStorePackageResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreUninstallStorePackageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreUninstallStorePackageResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreUninstallStorePackageResult[] = {
        { "_assign_array_", _assign_array_StoreUninstallStorePackageResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreUninstallStorePackageResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreUninstallStorePackageResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreUninstallStorePackageResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(StoreUninstallStorePackageResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreUninstallStorePackageResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreUninstallStorePackageResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreUninstallStorePackageResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreUninstallStorePackageResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreUninstallStorePackageResult) },
        { },
    };

    static PyType_Spec type_spec_StoreUninstallStorePackageResult =
    {
        "_winsdk_Windows_Services_Store.StoreUninstallStorePackageResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreUninstallStorePackageResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreUninstallStorePackageResult
    };

    // ----- StoreVideo class --------------------
    static constexpr const char* const type_name_StoreVideo = "StoreVideo";

    static PyObject* _new_StoreVideo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StoreVideo);
        return nullptr;
    }

    static void _dealloc_StoreVideo(py::wrapper::Windows::Services::Store::StoreVideo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreVideo_get_Caption(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreVideo", L"Caption"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Caption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreVideo_get_Height(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreVideo", L"Height"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreVideo_get_PreviewImage(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreVideo", L"PreviewImage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviewImage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreVideo_get_Uri(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreVideo", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreVideo_get_VideoPurposeTag(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreVideo", L"VideoPurposeTag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoPurposeTag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreVideo_get_Width(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreVideo", L"Width"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreVideo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreVideo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreVideo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreVideo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreVideo[] = {
        { "_assign_array_", _assign_array_StoreVideo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreVideo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreVideo[] = {
        { "caption", reinterpret_cast<getter>(StoreVideo_get_Caption), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(StoreVideo_get_Height), nullptr, nullptr, nullptr },
        { "preview_image", reinterpret_cast<getter>(StoreVideo_get_PreviewImage), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(StoreVideo_get_Uri), nullptr, nullptr, nullptr },
        { "video_purpose_tag", reinterpret_cast<getter>(StoreVideo_get_VideoPurposeTag), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(StoreVideo_get_Width), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreVideo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreVideo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreVideo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreVideo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreVideo) },
        { },
    };

    static PyType_Spec type_spec_StoreVideo =
    {
        "_winsdk_Windows_Services_Store.StoreVideo",
        sizeof(py::wrapper::Windows::Services::Store::StoreVideo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreVideo
    };

    // ----- StorePackageUpdateStatus struct --------------------
    static constexpr const char* const type_name_StorePackageUpdateStatus = "StorePackageUpdateStatus";

    PyObject* _new_StorePackageUpdateStatus(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Services::Store::StorePackageUpdateStatus return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        winrt::hstring _PackageFamilyName{};
        uint64_t _PackageDownloadSizeInBytes{};
        uint64_t _PackageBytesDownloaded{};
        double _PackageDownloadProgress{};
        double _TotalDownloadProgress{};
        int32_t _PackageUpdateState{};

        static const char* kwlist[] = {"package_family_name", "package_download_size_in_bytes", "package_bytes_downloaded", "package_download_progress", "total_download_progress", "package_update_state", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "uKKddi", const_cast<char**>(kwlist), &_PackageFamilyName, &_PackageDownloadSizeInBytes, &_PackageBytesDownloaded, &_PackageDownloadProgress, &_TotalDownloadProgress, &_PackageUpdateState))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Services::Store::StorePackageUpdateStatus return_value{ _PackageFamilyName, _PackageDownloadSizeInBytes, _PackageBytesDownloaded, _PackageDownloadProgress, _TotalDownloadProgress, static_cast<winrt::Windows::Services::Store::StorePackageUpdateState>(_PackageUpdateState) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_StorePackageUpdateStatus(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self) noexcept
    {
    }

    static PyObject* StorePackageUpdateStatus_get_PackageFamilyName(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageFamilyName);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageUpdateStatus_set_PackageFamilyName(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PackageFamilyName = py::converter<winrt::hstring>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorePackageUpdateStatus_get_PackageDownloadSizeInBytes(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageDownloadSizeInBytes);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageUpdateStatus_set_PackageDownloadSizeInBytes(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PackageDownloadSizeInBytes = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorePackageUpdateStatus_get_PackageBytesDownloaded(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageBytesDownloaded);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageUpdateStatus_set_PackageBytesDownloaded(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PackageBytesDownloaded = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorePackageUpdateStatus_get_PackageDownloadProgress(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageDownloadProgress);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageUpdateStatus_set_PackageDownloadProgress(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PackageDownloadProgress = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorePackageUpdateStatus_get_TotalDownloadProgress(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalDownloadProgress);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageUpdateStatus_set_TotalDownloadProgress(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.TotalDownloadProgress = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorePackageUpdateStatus_get_PackageUpdateState(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageUpdateState);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageUpdateStatus_set_PackageUpdateState(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PackageUpdateState = py::converter<winrt::Windows::Services::Store::StorePackageUpdateState>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_StorePackageUpdateStatus[] = {
        { "package_family_name", reinterpret_cast<getter>(StorePackageUpdateStatus_get_PackageFamilyName), reinterpret_cast<setter>(StorePackageUpdateStatus_set_PackageFamilyName), nullptr, nullptr },
        { "package_download_size_in_bytes", reinterpret_cast<getter>(StorePackageUpdateStatus_get_PackageDownloadSizeInBytes), reinterpret_cast<setter>(StorePackageUpdateStatus_set_PackageDownloadSizeInBytes), nullptr, nullptr },
        { "package_bytes_downloaded", reinterpret_cast<getter>(StorePackageUpdateStatus_get_PackageBytesDownloaded), reinterpret_cast<setter>(StorePackageUpdateStatus_set_PackageBytesDownloaded), nullptr, nullptr },
        { "package_download_progress", reinterpret_cast<getter>(StorePackageUpdateStatus_get_PackageDownloadProgress), reinterpret_cast<setter>(StorePackageUpdateStatus_set_PackageDownloadProgress), nullptr, nullptr },
        { "total_download_progress", reinterpret_cast<getter>(StorePackageUpdateStatus_get_TotalDownloadProgress), reinterpret_cast<setter>(StorePackageUpdateStatus_set_TotalDownloadProgress), nullptr, nullptr },
        { "package_update_state", reinterpret_cast<getter>(StorePackageUpdateStatus_get_PackageUpdateState), reinterpret_cast<setter>(StorePackageUpdateStatus_set_PackageUpdateState), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorePackageUpdateStatus[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorePackageUpdateStatus) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorePackageUpdateStatus) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorePackageUpdateStatus) },
        { },
    };

    static PyType_Spec type_spec_StorePackageUpdateStatus =
    {
        "_winsdk_Windows_Services_Store.StorePackageUpdateStatus",
        sizeof(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePackageUpdateStatus
    };

    // ----- Windows.Services.Store Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Services::Store");

    static PyMethodDef module_methods[] = {
        {"_register_StoreCanLicenseStatus", register_StoreCanLicenseStatus, METH_O, "registers type"},
        {"_register_StoreConsumableStatus", register_StoreConsumableStatus, METH_O, "registers type"},
        {"_register_StoreDurationUnit", register_StoreDurationUnit, METH_O, "registers type"},
        {"_register_StorePackageUpdateState", register_StorePackageUpdateState, METH_O, "registers type"},
        {"_register_StorePurchaseStatus", register_StorePurchaseStatus, METH_O, "registers type"},
        {"_register_StoreQueueItemExtendedState", register_StoreQueueItemExtendedState, METH_O, "registers type"},
        {"_register_StoreQueueItemKind", register_StoreQueueItemKind, METH_O, "registers type"},
        {"_register_StoreQueueItemState", register_StoreQueueItemState, METH_O, "registers type"},
        {"_register_StoreRateAndReviewStatus", register_StoreRateAndReviewStatus, METH_O, "registers type"},
        {"_register_StoreUninstallStorePackageStatus", register_StoreUninstallStorePackageStatus, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_StoreCanLicenseStatus);
        Py_VISIT(state->type_StoreConsumableStatus);
        Py_VISIT(state->type_StoreDurationUnit);
        Py_VISIT(state->type_StorePackageUpdateState);
        Py_VISIT(state->type_StorePurchaseStatus);
        Py_VISIT(state->type_StoreQueueItemExtendedState);
        Py_VISIT(state->type_StoreQueueItemKind);
        Py_VISIT(state->type_StoreQueueItemState);
        Py_VISIT(state->type_StoreRateAndReviewStatus);
        Py_VISIT(state->type_StoreUninstallStorePackageStatus);
        Py_VISIT(state->type_StoreAcquireLicenseResult);
        Py_VISIT(state->type_StoreAppLicense);
        Py_VISIT(state->type_StoreAvailability);
        Py_VISIT(state->type_StoreCanAcquireLicenseResult);
        Py_VISIT(state->type_StoreCollectionData);
        Py_VISIT(state->type_StoreConsumableResult);
        Py_VISIT(state->type_StoreContext);
        Py_VISIT(state->type_StoreImage);
        Py_VISIT(state->type_StoreLicense);
        Py_VISIT(state->type_StorePackageInstallOptions);
        Py_VISIT(state->type_StorePackageLicense);
        Py_VISIT(state->type_StorePackageUpdate);
        Py_VISIT(state->type_StorePackageUpdateResult);
        Py_VISIT(state->type_StorePrice);
        Py_VISIT(state->type_StoreProduct);
        Py_VISIT(state->type_StoreProductOptions);
        Py_VISIT(state->type_StoreProductPagedQueryResult);
        Py_VISIT(state->type_StoreProductQueryResult);
        Py_VISIT(state->type_StoreProductResult);
        Py_VISIT(state->type_StorePurchaseProperties);
        Py_VISIT(state->type_StorePurchaseResult);
        Py_VISIT(state->type_StoreQueueItem);
        Py_VISIT(state->type_StoreQueueItemCompletedEventArgs);
        Py_VISIT(state->type_StoreQueueItemStatus);
        Py_VISIT(state->type_StoreRateAndReviewResult);
        Py_VISIT(state->type_StoreRequestHelper);
        Py_VISIT(state->type_StoreSendRequestResult);
        Py_VISIT(state->type_StoreSku);
        Py_VISIT(state->type_StoreSubscriptionInfo);
        Py_VISIT(state->type_StoreUninstallStorePackageResult);
        Py_VISIT(state->type_StoreVideo);
        Py_VISIT(state->type_StorePackageUpdateStatus);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_StoreCanLicenseStatus);
        Py_CLEAR(state->type_StoreConsumableStatus);
        Py_CLEAR(state->type_StoreDurationUnit);
        Py_CLEAR(state->type_StorePackageUpdateState);
        Py_CLEAR(state->type_StorePurchaseStatus);
        Py_CLEAR(state->type_StoreQueueItemExtendedState);
        Py_CLEAR(state->type_StoreQueueItemKind);
        Py_CLEAR(state->type_StoreQueueItemState);
        Py_CLEAR(state->type_StoreRateAndReviewStatus);
        Py_CLEAR(state->type_StoreUninstallStorePackageStatus);
        Py_CLEAR(state->type_StoreAcquireLicenseResult);
        Py_CLEAR(state->type_StoreAppLicense);
        Py_CLEAR(state->type_StoreAvailability);
        Py_CLEAR(state->type_StoreCanAcquireLicenseResult);
        Py_CLEAR(state->type_StoreCollectionData);
        Py_CLEAR(state->type_StoreConsumableResult);
        Py_CLEAR(state->type_StoreContext);
        Py_CLEAR(state->type_StoreImage);
        Py_CLEAR(state->type_StoreLicense);
        Py_CLEAR(state->type_StorePackageInstallOptions);
        Py_CLEAR(state->type_StorePackageLicense);
        Py_CLEAR(state->type_StorePackageUpdate);
        Py_CLEAR(state->type_StorePackageUpdateResult);
        Py_CLEAR(state->type_StorePrice);
        Py_CLEAR(state->type_StoreProduct);
        Py_CLEAR(state->type_StoreProductOptions);
        Py_CLEAR(state->type_StoreProductPagedQueryResult);
        Py_CLEAR(state->type_StoreProductQueryResult);
        Py_CLEAR(state->type_StoreProductResult);
        Py_CLEAR(state->type_StorePurchaseProperties);
        Py_CLEAR(state->type_StorePurchaseResult);
        Py_CLEAR(state->type_StoreQueueItem);
        Py_CLEAR(state->type_StoreQueueItemCompletedEventArgs);
        Py_CLEAR(state->type_StoreQueueItemStatus);
        Py_CLEAR(state->type_StoreRateAndReviewResult);
        Py_CLEAR(state->type_StoreRequestHelper);
        Py_CLEAR(state->type_StoreSendRequestResult);
        Py_CLEAR(state->type_StoreSku);
        Py_CLEAR(state->type_StoreSubscriptionInfo);
        Py_CLEAR(state->type_StoreUninstallStorePackageResult);
        Py_CLEAR(state->type_StoreVideo);
        Py_CLEAR(state->type_StorePackageUpdateStatus);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Services_Store",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Services::Store

PyMODINIT_FUNC PyInit__winsdk_Windows_Services_Store(void) noexcept
{
    using namespace py::cpp::Windows::Services::Store;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_StoreAcquireLicenseResult = py::register_python_type(module.get(), type_name_StoreAcquireLicenseResult, &type_spec_StoreAcquireLicenseResult, bases.get(), nullptr);
    if (!state->type_StoreAcquireLicenseResult)
    {
        return nullptr;
    }

    state->type_StoreAppLicense = py::register_python_type(module.get(), type_name_StoreAppLicense, &type_spec_StoreAppLicense, bases.get(), nullptr);
    if (!state->type_StoreAppLicense)
    {
        return nullptr;
    }

    state->type_StoreAvailability = py::register_python_type(module.get(), type_name_StoreAvailability, &type_spec_StoreAvailability, bases.get(), nullptr);
    if (!state->type_StoreAvailability)
    {
        return nullptr;
    }

    state->type_StoreCanAcquireLicenseResult = py::register_python_type(module.get(), type_name_StoreCanAcquireLicenseResult, &type_spec_StoreCanAcquireLicenseResult, bases.get(), nullptr);
    if (!state->type_StoreCanAcquireLicenseResult)
    {
        return nullptr;
    }

    state->type_StoreCollectionData = py::register_python_type(module.get(), type_name_StoreCollectionData, &type_spec_StoreCollectionData, bases.get(), nullptr);
    if (!state->type_StoreCollectionData)
    {
        return nullptr;
    }

    state->type_StoreConsumableResult = py::register_python_type(module.get(), type_name_StoreConsumableResult, &type_spec_StoreConsumableResult, bases.get(), nullptr);
    if (!state->type_StoreConsumableResult)
    {
        return nullptr;
    }

    state->type_StoreContext = py::register_python_type(module.get(), type_name_StoreContext, &type_spec_StoreContext, bases.get(), nullptr);
    if (!state->type_StoreContext)
    {
        return nullptr;
    }

    state->type_StoreImage = py::register_python_type(module.get(), type_name_StoreImage, &type_spec_StoreImage, bases.get(), nullptr);
    if (!state->type_StoreImage)
    {
        return nullptr;
    }

    state->type_StoreLicense = py::register_python_type(module.get(), type_name_StoreLicense, &type_spec_StoreLicense, bases.get(), nullptr);
    if (!state->type_StoreLicense)
    {
        return nullptr;
    }

    state->type_StorePackageInstallOptions = py::register_python_type(module.get(), type_name_StorePackageInstallOptions, &type_spec_StorePackageInstallOptions, bases.get(), nullptr);
    if (!state->type_StorePackageInstallOptions)
    {
        return nullptr;
    }

    state->type_StorePackageLicense = py::register_python_type(module.get(), type_name_StorePackageLicense, &type_spec_StorePackageLicense, bases.get(), nullptr);
    if (!state->type_StorePackageLicense)
    {
        return nullptr;
    }

    state->type_StorePackageUpdate = py::register_python_type(module.get(), type_name_StorePackageUpdate, &type_spec_StorePackageUpdate, bases.get(), nullptr);
    if (!state->type_StorePackageUpdate)
    {
        return nullptr;
    }

    state->type_StorePackageUpdateResult = py::register_python_type(module.get(), type_name_StorePackageUpdateResult, &type_spec_StorePackageUpdateResult, bases.get(), nullptr);
    if (!state->type_StorePackageUpdateResult)
    {
        return nullptr;
    }

    state->type_StorePrice = py::register_python_type(module.get(), type_name_StorePrice, &type_spec_StorePrice, bases.get(), nullptr);
    if (!state->type_StorePrice)
    {
        return nullptr;
    }

    state->type_StoreProduct = py::register_python_type(module.get(), type_name_StoreProduct, &type_spec_StoreProduct, bases.get(), nullptr);
    if (!state->type_StoreProduct)
    {
        return nullptr;
    }

    state->type_StoreProductOptions = py::register_python_type(module.get(), type_name_StoreProductOptions, &type_spec_StoreProductOptions, bases.get(), nullptr);
    if (!state->type_StoreProductOptions)
    {
        return nullptr;
    }

    state->type_StoreProductPagedQueryResult = py::register_python_type(module.get(), type_name_StoreProductPagedQueryResult, &type_spec_StoreProductPagedQueryResult, bases.get(), nullptr);
    if (!state->type_StoreProductPagedQueryResult)
    {
        return nullptr;
    }

    state->type_StoreProductQueryResult = py::register_python_type(module.get(), type_name_StoreProductQueryResult, &type_spec_StoreProductQueryResult, bases.get(), nullptr);
    if (!state->type_StoreProductQueryResult)
    {
        return nullptr;
    }

    state->type_StoreProductResult = py::register_python_type(module.get(), type_name_StoreProductResult, &type_spec_StoreProductResult, bases.get(), nullptr);
    if (!state->type_StoreProductResult)
    {
        return nullptr;
    }

    state->type_StorePurchaseProperties = py::register_python_type(module.get(), type_name_StorePurchaseProperties, &type_spec_StorePurchaseProperties, bases.get(), nullptr);
    if (!state->type_StorePurchaseProperties)
    {
        return nullptr;
    }

    state->type_StorePurchaseResult = py::register_python_type(module.get(), type_name_StorePurchaseResult, &type_spec_StorePurchaseResult, bases.get(), nullptr);
    if (!state->type_StorePurchaseResult)
    {
        return nullptr;
    }

    state->type_StoreQueueItem = py::register_python_type(module.get(), type_name_StoreQueueItem, &type_spec_StoreQueueItem, bases.get(), nullptr);
    if (!state->type_StoreQueueItem)
    {
        return nullptr;
    }

    state->type_StoreQueueItemCompletedEventArgs = py::register_python_type(module.get(), type_name_StoreQueueItemCompletedEventArgs, &type_spec_StoreQueueItemCompletedEventArgs, bases.get(), nullptr);
    if (!state->type_StoreQueueItemCompletedEventArgs)
    {
        return nullptr;
    }

    state->type_StoreQueueItemStatus = py::register_python_type(module.get(), type_name_StoreQueueItemStatus, &type_spec_StoreQueueItemStatus, bases.get(), nullptr);
    if (!state->type_StoreQueueItemStatus)
    {
        return nullptr;
    }

    state->type_StoreRateAndReviewResult = py::register_python_type(module.get(), type_name_StoreRateAndReviewResult, &type_spec_StoreRateAndReviewResult, bases.get(), nullptr);
    if (!state->type_StoreRateAndReviewResult)
    {
        return nullptr;
    }

    state->type_StoreRequestHelper = py::register_python_type(module.get(), type_name_StoreRequestHelper, &type_spec_StoreRequestHelper, nullptr, nullptr);
    if (!state->type_StoreRequestHelper)
    {
        return nullptr;
    }

    state->type_StoreSendRequestResult = py::register_python_type(module.get(), type_name_StoreSendRequestResult, &type_spec_StoreSendRequestResult, bases.get(), nullptr);
    if (!state->type_StoreSendRequestResult)
    {
        return nullptr;
    }

    state->type_StoreSku = py::register_python_type(module.get(), type_name_StoreSku, &type_spec_StoreSku, bases.get(), nullptr);
    if (!state->type_StoreSku)
    {
        return nullptr;
    }

    state->type_StoreSubscriptionInfo = py::register_python_type(module.get(), type_name_StoreSubscriptionInfo, &type_spec_StoreSubscriptionInfo, bases.get(), nullptr);
    if (!state->type_StoreSubscriptionInfo)
    {
        return nullptr;
    }

    state->type_StoreUninstallStorePackageResult = py::register_python_type(module.get(), type_name_StoreUninstallStorePackageResult, &type_spec_StoreUninstallStorePackageResult, bases.get(), nullptr);
    if (!state->type_StoreUninstallStorePackageResult)
    {
        return nullptr;
    }

    state->type_StoreVideo = py::register_python_type(module.get(), type_name_StoreVideo, &type_spec_StoreVideo, bases.get(), nullptr);
    if (!state->type_StoreVideo)
    {
        return nullptr;
    }

    state->type_StorePackageUpdateStatus = py::register_python_type(module.get(), type_name_StorePackageUpdateStatus, &type_spec_StorePackageUpdateStatus, bases.get(), nullptr);
    if (!state->type_StorePackageUpdateStatus)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Services::Store::StoreCanLicenseStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreCanLicenseStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreCanLicenseStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Services::Store::StoreConsumableStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreConsumableStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreConsumableStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Services::Store::StoreDurationUnit>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreDurationUnit;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreDurationUnit is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Services::Store::StorePackageUpdateState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorePackageUpdateState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StorePackageUpdateState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Services::Store::StorePurchaseStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorePurchaseStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StorePurchaseStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Services::Store::StoreQueueItemExtendedState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreQueueItemExtendedState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreQueueItemExtendedState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Services::Store::StoreQueueItemKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreQueueItemKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreQueueItemKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Services::Store::StoreQueueItemState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreQueueItemState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreQueueItemState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Services::Store::StoreRateAndReviewStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreRateAndReviewStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreRateAndReviewStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Services::Store::StoreUninstallStorePackageStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreUninstallStorePackageStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreUninstallStorePackageStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreAcquireLicenseResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreAcquireLicenseResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreAcquireLicenseResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreAppLicense>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreAppLicense;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreAppLicense is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreAvailability>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreAvailability;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreAvailability is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreCanAcquireLicenseResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreCanAcquireLicenseResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreCanAcquireLicenseResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreCollectionData>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreCollectionData;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreCollectionData is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreConsumableResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreConsumableResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreConsumableResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreContext>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreContext;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreContext is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreImage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreImage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreImage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreLicense>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreLicense;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreLicense is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StorePackageInstallOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorePackageInstallOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StorePackageInstallOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StorePackageLicense>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorePackageLicense;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StorePackageLicense is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StorePackageUpdate>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorePackageUpdate;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StorePackageUpdate is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StorePackageUpdateResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorePackageUpdateResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StorePackageUpdateResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StorePrice>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorePrice;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StorePrice is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreProduct>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreProduct;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreProduct is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreProductOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreProductOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreProductOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreProductPagedQueryResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreProductPagedQueryResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreProductPagedQueryResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreProductQueryResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreProductQueryResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreProductQueryResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreProductResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreProductResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreProductResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StorePurchaseProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorePurchaseProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StorePurchaseProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StorePurchaseResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorePurchaseResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StorePurchaseResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreQueueItem>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreQueueItem;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreQueueItem is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreQueueItemCompletedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreQueueItemCompletedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreQueueItemCompletedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreQueueItemStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreQueueItemStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreQueueItemStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreRateAndReviewResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreRateAndReviewResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreRateAndReviewResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreRequestHelper>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreRequestHelper;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreRequestHelper is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreSendRequestResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreSendRequestResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreSendRequestResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreSku>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreSku;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreSku is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreSubscriptionInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreSubscriptionInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreSubscriptionInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreUninstallStorePackageResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreUninstallStorePackageResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreUninstallStorePackageResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreVideo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoreVideo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StoreVideo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StorePackageUpdateStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Services::Store;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Services::Store");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorePackageUpdateStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Services::Store::StorePackageUpdateStatus is not registered");
        return nullptr;
    }

    return python_type;
}
