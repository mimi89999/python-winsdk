// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.ApplicationModel.h"


PyObject* py::converter<winrt::Windows::ApplicationModel::PackageInstallProgress>::convert(winrt::Windows::ApplicationModel::PackageInstallProgress instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::ApplicationModel::PackageInstallProgress>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::ApplicationModel::PackageInstallProgress py::converter<winrt::Windows::ApplicationModel::PackageInstallProgress>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::ApplicationModel::PackageInstallProgress>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::ApplicationModel::PackageInstallProgress>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::ApplicationModel::PackageInstallProgress");
    throw python_exception();
}

PyObject* py::converter<winrt::Windows::ApplicationModel::PackageVersion>::convert(winrt::Windows::ApplicationModel::PackageVersion instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::ApplicationModel::PackageVersion>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::ApplicationModel::PackageVersion py::converter<winrt::Windows::ApplicationModel::PackageVersion>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::ApplicationModel::PackageVersion>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::ApplicationModel::PackageVersion>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::ApplicationModel::PackageVersion");
    throw python_exception();
}

namespace py::cpp::Windows::ApplicationModel
{
    struct module_state
    {
        PyObject* type_AddResourcePackageOptions;
        PyObject* type_AppExecutionContext;
        PyObject* type_AppInstallerPolicySource;
        PyObject* type_FullTrustLaunchResult;
        PyObject* type_LimitedAccessFeatureStatus;
        PyObject* type_PackageContentGroupState;
        PyObject* type_PackageRelationship;
        PyObject* type_PackageSignatureKind;
        PyObject* type_PackageUpdateAvailability;
        PyObject* type_StartupTaskState;
        PyTypeObject* type_AppDisplayInfo;
        PyTypeObject* type_AppInfo;
        PyTypeObject* type_AppInstallerInfo;
        PyTypeObject* type_AppInstance;
        PyTypeObject* type_CameraApplicationManager;
        PyTypeObject* type_DesignMode;
        PyTypeObject* type_EnteredBackgroundEventArgs;
        PyTypeObject* type_FindRelatedPackagesOptions;
        PyTypeObject* type_FullTrustProcessLaunchResult;
        PyTypeObject* type_FullTrustProcessLauncher;
        PyTypeObject* type_LeavingBackgroundEventArgs;
        PyTypeObject* type_LimitedAccessFeatureRequestResult;
        PyTypeObject* type_LimitedAccessFeatures;
        PyTypeObject* type_Package;
        PyTypeObject* type_PackageCatalog;
        PyTypeObject* type_PackageCatalogAddOptionalPackageResult;
        PyTypeObject* type_PackageCatalogAddResourcePackageResult;
        PyTypeObject* type_PackageCatalogRemoveOptionalPackagesResult;
        PyTypeObject* type_PackageCatalogRemoveResourcePackagesResult;
        PyTypeObject* type_PackageContentGroup;
        PyTypeObject* type_PackageContentGroupStagingEventArgs;
        PyTypeObject* type_PackageId;
        PyTypeObject* type_PackageInstallingEventArgs;
        PyTypeObject* type_PackageStagingEventArgs;
        PyTypeObject* type_PackageStatus;
        PyTypeObject* type_PackageStatusChangedEventArgs;
        PyTypeObject* type_PackageUninstallingEventArgs;
        PyTypeObject* type_PackageUpdateAvailabilityResult;
        PyTypeObject* type_PackageUpdatingEventArgs;
        PyTypeObject* type_StartupTask;
        PyTypeObject* type_SuspendingDeferral;
        PyTypeObject* type_SuspendingEventArgs;
        PyTypeObject* type_SuspendingOperation;
        PyTypeObject* type_IEnteredBackgroundEventArgs;
        PyTypeObject* type_ILeavingBackgroundEventArgs;
        PyTypeObject* type_IPackageCatalogStatics2;
        PyTypeObject* type_ISuspendingDeferral;
        PyTypeObject* type_ISuspendingEventArgs;
        PyTypeObject* type_ISuspendingOperation;
        PyTypeObject* type_PackageInstallProgress;
        PyTypeObject* type_PackageVersion;
    };

    static PyObject* register_AddResourcePackageOptions(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AddResourcePackageOptions)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AddResourcePackageOptions = type;
        Py_INCREF(state->type_AddResourcePackageOptions);


        Py_RETURN_NONE;
    }

    static PyObject* register_AppExecutionContext(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AppExecutionContext)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AppExecutionContext = type;
        Py_INCREF(state->type_AppExecutionContext);


        Py_RETURN_NONE;
    }

    static PyObject* register_AppInstallerPolicySource(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AppInstallerPolicySource)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AppInstallerPolicySource = type;
        Py_INCREF(state->type_AppInstallerPolicySource);


        Py_RETURN_NONE;
    }

    static PyObject* register_FullTrustLaunchResult(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_FullTrustLaunchResult)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_FullTrustLaunchResult = type;
        Py_INCREF(state->type_FullTrustLaunchResult);


        Py_RETURN_NONE;
    }

    static PyObject* register_LimitedAccessFeatureStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_LimitedAccessFeatureStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_LimitedAccessFeatureStatus = type;
        Py_INCREF(state->type_LimitedAccessFeatureStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_PackageContentGroupState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PackageContentGroupState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PackageContentGroupState = type;
        Py_INCREF(state->type_PackageContentGroupState);


        Py_RETURN_NONE;
    }

    static PyObject* register_PackageRelationship(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PackageRelationship)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PackageRelationship = type;
        Py_INCREF(state->type_PackageRelationship);


        Py_RETURN_NONE;
    }

    static PyObject* register_PackageSignatureKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PackageSignatureKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PackageSignatureKind = type;
        Py_INCREF(state->type_PackageSignatureKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_PackageUpdateAvailability(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PackageUpdateAvailability)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PackageUpdateAvailability = type;
        Py_INCREF(state->type_PackageUpdateAvailability);


        Py_RETURN_NONE;
    }

    static PyObject* register_StartupTaskState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_StartupTaskState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_StartupTaskState = type;
        Py_INCREF(state->type_StartupTaskState);


        Py_RETURN_NONE;
    }

    // ----- AppDisplayInfo class --------------------
    static constexpr const char* const type_name_AppDisplayInfo = "AppDisplayInfo";

    static PyObject* _new_AppDisplayInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppDisplayInfo);
        return nullptr;
    }

    static void _dealloc_AppDisplayInfo(py::wrapper::Windows::ApplicationModel::AppDisplayInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppDisplayInfo_GetLogo(py::wrapper::Windows::ApplicationModel::AppDisplayInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.AppDisplayInfo", L"GetLogo", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

                return py::convert(self->obj.GetLogo(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDisplayInfo_get_Description(py::wrapper::Windows::ApplicationModel::AppDisplayInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppDisplayInfo", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDisplayInfo_get_DisplayName(py::wrapper::Windows::ApplicationModel::AppDisplayInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppDisplayInfo", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppDisplayInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::AppDisplayInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppDisplayInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::AppDisplayInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppDisplayInfo[] = {
        { "get_logo", reinterpret_cast<PyCFunction>(AppDisplayInfo_GetLogo), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppDisplayInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppDisplayInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppDisplayInfo[] = {
        { "description", reinterpret_cast<getter>(AppDisplayInfo_get_Description), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(AppDisplayInfo_get_DisplayName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppDisplayInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppDisplayInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppDisplayInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppDisplayInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppDisplayInfo) },
        { },
    };

    static PyType_Spec type_spec_AppDisplayInfo =
    {
        "_winsdk_Windows_ApplicationModel.AppDisplayInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::AppDisplayInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppDisplayInfo
    };

    // ----- AppInfo class --------------------
    static constexpr const char* const type_name_AppInfo = "AppInfo";

    static PyObject* _new_AppInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppInfo);
        return nullptr;
    }

    static void _dealloc_AppInfo(py::wrapper::Windows::ApplicationModel::AppInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppInfo_GetFromAppUserModelId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.AppInfo", L"GetFromAppUserModelId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::AppInfo::GetFromAppUserModelId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInfo_GetFromAppUserModelIdForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.AppInfo", L"GetFromAppUserModelIdForUser", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::AppInfo::GetFromAppUserModelIdForUser(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_AppUserModelId(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInfo", L"AppUserModelId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppUserModelId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_DisplayInfo(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInfo", L"DisplayInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_Id(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInfo", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_PackageFamilyName(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInfo", L"PackageFamilyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_Package(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInfo", L"Package"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_ExecutionContext(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInfo", L"ExecutionContext"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExecutionContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_SupportedFileExtensions(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInfo", L"SupportedFileExtensions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedFileExtensions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_Current(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInfo", L"Current"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::AppInfo::Current());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::AppInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::AppInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppInfo[] = {
        { "get_from_app_user_model_id", reinterpret_cast<PyCFunction>(AppInfo_GetFromAppUserModelId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_from_app_user_model_id_for_user", reinterpret_cast<PyCFunction>(AppInfo_GetFromAppUserModelIdForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_AppInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppInfo[] = {
        { "app_user_model_id", reinterpret_cast<getter>(AppInfo_get_AppUserModelId), nullptr, nullptr, nullptr },
        { "display_info", reinterpret_cast<getter>(AppInfo_get_DisplayInfo), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(AppInfo_get_Id), nullptr, nullptr, nullptr },
        { "package_family_name", reinterpret_cast<getter>(AppInfo_get_PackageFamilyName), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(AppInfo_get_Package), nullptr, nullptr, nullptr },
        { "execution_context", reinterpret_cast<getter>(AppInfo_get_ExecutionContext), nullptr, nullptr, nullptr },
        { "supported_file_extensions", reinterpret_cast<getter>(AppInfo_get_SupportedFileExtensions), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppInfo) },
        { },
    };

    static PyType_Spec type_spec_AppInfo =
    {
        "_winsdk_Windows_ApplicationModel.AppInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::AppInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppInfo
    };

    static PyGetSetDef getset_AppInfo_Meta[] = {
        { "current", reinterpret_cast<getter>(AppInfo_get_Current), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_AppInfo_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppInfo_Meta) },
        { }
    };

    static PyType_Spec type_spec_AppInfo_Meta =
    {
        "_winsdk_Windows_ApplicationModel.AppInfo_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppInfo_Meta
    };

    // ----- AppInstallerInfo class --------------------
    static constexpr const char* const type_name_AppInstallerInfo = "AppInstallerInfo";

    static PyObject* _new_AppInstallerInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppInstallerInfo);
        return nullptr;
    }

    static void _dealloc_AppInstallerInfo(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppInstallerInfo_get_Uri(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_AutomaticBackgroundTask(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"AutomaticBackgroundTask"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutomaticBackgroundTask());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_DependencyPackageUris(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"DependencyPackageUris"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DependencyPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_ForceUpdateFromAnyVersion(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"ForceUpdateFromAnyVersion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ForceUpdateFromAnyVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_HoursBetweenUpdateChecks(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"HoursBetweenUpdateChecks"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HoursBetweenUpdateChecks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_IsAutoRepairEnabled(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"IsAutoRepairEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsAutoRepairEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_LastChecked(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"LastChecked"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LastChecked());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_OnLaunch(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"OnLaunch"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OnLaunch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_OptionalPackageUris(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"OptionalPackageUris"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionalPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_PausedUntil(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"PausedUntil"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PausedUntil());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_PolicySource(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"PolicySource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PolicySource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_RepairUris(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"RepairUris"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RepairUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_ShowPrompt(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"ShowPrompt"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShowPrompt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_UpdateBlocksActivation(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"UpdateBlocksActivation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UpdateBlocksActivation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_UpdateUris(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"UpdateUris"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UpdateUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_Version(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"Version"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppInstallerInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::AppInstallerInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppInstallerInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::AppInstallerInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppInstallerInfo[] = {
        { "_assign_array_", _assign_array_AppInstallerInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppInstallerInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppInstallerInfo[] = {
        { "uri", reinterpret_cast<getter>(AppInstallerInfo_get_Uri), nullptr, nullptr, nullptr },
        { "automatic_background_task", reinterpret_cast<getter>(AppInstallerInfo_get_AutomaticBackgroundTask), nullptr, nullptr, nullptr },
        { "dependency_package_uris", reinterpret_cast<getter>(AppInstallerInfo_get_DependencyPackageUris), nullptr, nullptr, nullptr },
        { "force_update_from_any_version", reinterpret_cast<getter>(AppInstallerInfo_get_ForceUpdateFromAnyVersion), nullptr, nullptr, nullptr },
        { "hours_between_update_checks", reinterpret_cast<getter>(AppInstallerInfo_get_HoursBetweenUpdateChecks), nullptr, nullptr, nullptr },
        { "is_auto_repair_enabled", reinterpret_cast<getter>(AppInstallerInfo_get_IsAutoRepairEnabled), nullptr, nullptr, nullptr },
        { "last_checked", reinterpret_cast<getter>(AppInstallerInfo_get_LastChecked), nullptr, nullptr, nullptr },
        { "on_launch", reinterpret_cast<getter>(AppInstallerInfo_get_OnLaunch), nullptr, nullptr, nullptr },
        { "optional_package_uris", reinterpret_cast<getter>(AppInstallerInfo_get_OptionalPackageUris), nullptr, nullptr, nullptr },
        { "paused_until", reinterpret_cast<getter>(AppInstallerInfo_get_PausedUntil), nullptr, nullptr, nullptr },
        { "policy_source", reinterpret_cast<getter>(AppInstallerInfo_get_PolicySource), nullptr, nullptr, nullptr },
        { "repair_uris", reinterpret_cast<getter>(AppInstallerInfo_get_RepairUris), nullptr, nullptr, nullptr },
        { "show_prompt", reinterpret_cast<getter>(AppInstallerInfo_get_ShowPrompt), nullptr, nullptr, nullptr },
        { "update_blocks_activation", reinterpret_cast<getter>(AppInstallerInfo_get_UpdateBlocksActivation), nullptr, nullptr, nullptr },
        { "update_uris", reinterpret_cast<getter>(AppInstallerInfo_get_UpdateUris), nullptr, nullptr, nullptr },
        { "version", reinterpret_cast<getter>(AppInstallerInfo_get_Version), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppInstallerInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppInstallerInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppInstallerInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppInstallerInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppInstallerInfo) },
        { },
    };

    static PyType_Spec type_spec_AppInstallerInfo =
    {
        "_winsdk_Windows_ApplicationModel.AppInstallerInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::AppInstallerInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppInstallerInfo
    };

    // ----- AppInstance class --------------------
    static constexpr const char* const type_name_AppInstance = "AppInstance";

    static PyObject* _new_AppInstance(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppInstance);
        return nullptr;
    }

    static void _dealloc_AppInstance(py::wrapper::Windows::ApplicationModel::AppInstance* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppInstance_FindOrRegisterInstanceForKey(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.AppInstance", L"FindOrRegisterInstanceForKey", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::AppInstance::FindOrRegisterInstanceForKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstance_GetActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.AppInstance", L"GetActivatedEventArgs", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::AppInstance::GetActivatedEventArgs());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstance_GetInstances(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.AppInstance", L"GetInstances", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::AppInstance::GetInstances());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstance_RedirectActivationTo(py::wrapper::Windows::ApplicationModel::AppInstance* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.AppInstance", L"RedirectActivationTo", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RedirectActivationTo();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstance_Unregister(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.AppInstance", L"Unregister", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::Windows::ApplicationModel::AppInstance::Unregister();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstance_get_IsCurrentInstance(py::wrapper::Windows::ApplicationModel::AppInstance* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstance", L"IsCurrentInstance"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCurrentInstance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstance_get_Key(py::wrapper::Windows::ApplicationModel::AppInstance* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstance", L"Key"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Key());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstance_get_RecommendedInstance(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstance", L"RecommendedInstance"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::AppInstance::RecommendedInstance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppInstance(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::AppInstance>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppInstance(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::AppInstance>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppInstance[] = {
        { "find_or_register_instance_for_key", reinterpret_cast<PyCFunction>(AppInstance_FindOrRegisterInstanceForKey), METH_VARARGS | METH_STATIC, nullptr },
        { "get_activated_event_args", reinterpret_cast<PyCFunction>(AppInstance_GetActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { "get_instances", reinterpret_cast<PyCFunction>(AppInstance_GetInstances), METH_VARARGS | METH_STATIC, nullptr },
        { "redirect_activation_to", reinterpret_cast<PyCFunction>(AppInstance_RedirectActivationTo), METH_VARARGS, nullptr },
        { "unregister", reinterpret_cast<PyCFunction>(AppInstance_Unregister), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_AppInstance, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppInstance), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppInstance[] = {
        { "is_current_instance", reinterpret_cast<getter>(AppInstance_get_IsCurrentInstance), nullptr, nullptr, nullptr },
        { "key", reinterpret_cast<getter>(AppInstance_get_Key), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppInstance[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppInstance) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppInstance) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppInstance) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppInstance) },
        { },
    };

    static PyType_Spec type_spec_AppInstance =
    {
        "_winsdk_Windows_ApplicationModel.AppInstance",
        sizeof(py::wrapper::Windows::ApplicationModel::AppInstance),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppInstance
    };

    static PyGetSetDef getset_AppInstance_Meta[] = {
        { "recommended_instance", reinterpret_cast<getter>(AppInstance_get_RecommendedInstance), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_AppInstance_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppInstance_Meta) },
        { }
    };

    static PyType_Spec type_spec_AppInstance_Meta =
    {
        "_winsdk_Windows_ApplicationModel.AppInstance_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppInstance_Meta
    };

    // ----- CameraApplicationManager class --------------------
    static constexpr const char* const type_name_CameraApplicationManager = "CameraApplicationManager";

    static PyObject* _new_CameraApplicationManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CameraApplicationManager);
        return nullptr;
    }

    static PyObject* CameraApplicationManager_ShowInstalledApplicationsUI(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.CameraApplicationManager", L"ShowInstalledApplicationsUI", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::Windows::ApplicationModel::CameraApplicationManager::ShowInstalledApplicationsUI();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraApplicationManager[] = {
        { "show_installed_applications_u_i", reinterpret_cast<PyCFunction>(CameraApplicationManager_ShowInstalledApplicationsUI), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CameraApplicationManager[] = {
        { }
    };

    static PyType_Slot _type_slots_CameraApplicationManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CameraApplicationManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CameraApplicationManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CameraApplicationManager) },
        { },
    };

    static PyType_Spec type_spec_CameraApplicationManager =
    {
        "_winsdk_Windows_ApplicationModel.CameraApplicationManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraApplicationManager
    };

    // ----- DesignMode class --------------------
    static constexpr const char* const type_name_DesignMode = "DesignMode";

    static PyObject* _new_DesignMode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DesignMode);
        return nullptr;
    }

    static PyObject* DesignMode_get_DesignModeEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DesignMode", L"DesignModeEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::DesignMode::DesignModeEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DesignMode_get_DesignMode2Enabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DesignMode", L"DesignMode2Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::DesignMode::DesignMode2Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DesignMode[] = {
        { }
    };

    static PyGetSetDef _getset_DesignMode[] = {
        { }
    };

    static PyType_Slot _type_slots_DesignMode[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DesignMode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DesignMode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DesignMode) },
        { },
    };

    static PyType_Spec type_spec_DesignMode =
    {
        "_winsdk_Windows_ApplicationModel.DesignMode",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DesignMode
    };

    static PyGetSetDef getset_DesignMode_Meta[] = {
        { "design_mode_enabled", reinterpret_cast<getter>(DesignMode_get_DesignModeEnabled), nullptr, nullptr, nullptr },
        { "design_mode2_enabled", reinterpret_cast<getter>(DesignMode_get_DesignMode2Enabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_DesignMode_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DesignMode_Meta) },
        { }
    };

    static PyType_Spec type_spec_DesignMode_Meta =
    {
        "_winsdk_Windows_ApplicationModel.DesignMode_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DesignMode_Meta
    };

    // ----- EnteredBackgroundEventArgs class --------------------
    static constexpr const char* const type_name_EnteredBackgroundEventArgs = "EnteredBackgroundEventArgs";

    static PyObject* _new_EnteredBackgroundEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EnteredBackgroundEventArgs);
        return nullptr;
    }

    static void _dealloc_EnteredBackgroundEventArgs(py::wrapper::Windows::ApplicationModel::EnteredBackgroundEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EnteredBackgroundEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::EnteredBackgroundEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.EnteredBackgroundEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_EnteredBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::EnteredBackgroundEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EnteredBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::EnteredBackgroundEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EnteredBackgroundEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EnteredBackgroundEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EnteredBackgroundEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EnteredBackgroundEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EnteredBackgroundEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_EnteredBackgroundEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EnteredBackgroundEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EnteredBackgroundEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EnteredBackgroundEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EnteredBackgroundEventArgs) },
        { },
    };

    static PyType_Spec type_spec_EnteredBackgroundEventArgs =
    {
        "_winsdk_Windows_ApplicationModel.EnteredBackgroundEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::EnteredBackgroundEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EnteredBackgroundEventArgs
    };

    // ----- FindRelatedPackagesOptions class --------------------
    static constexpr const char* const type_name_FindRelatedPackagesOptions = "FindRelatedPackagesOptions";

    static PyObject* _new_FindRelatedPackagesOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::PackageRelationship>(args, 0);

                winrt::Windows::ApplicationModel::FindRelatedPackagesOptions instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FindRelatedPackagesOptions(py::wrapper::Windows::ApplicationModel::FindRelatedPackagesOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FindRelatedPackagesOptions_get_Relationship(py::wrapper::Windows::ApplicationModel::FindRelatedPackagesOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.FindRelatedPackagesOptions", L"Relationship"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Relationship());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FindRelatedPackagesOptions_put_Relationship(py::wrapper::Windows::ApplicationModel::FindRelatedPackagesOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.FindRelatedPackagesOptions", L"Relationship"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::PackageRelationship>(arg);

            self->obj.Relationship(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FindRelatedPackagesOptions_get_IncludeResources(py::wrapper::Windows::ApplicationModel::FindRelatedPackagesOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.FindRelatedPackagesOptions", L"IncludeResources"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IncludeResources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FindRelatedPackagesOptions_put_IncludeResources(py::wrapper::Windows::ApplicationModel::FindRelatedPackagesOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.FindRelatedPackagesOptions", L"IncludeResources"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IncludeResources(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FindRelatedPackagesOptions_get_IncludeOptionals(py::wrapper::Windows::ApplicationModel::FindRelatedPackagesOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.FindRelatedPackagesOptions", L"IncludeOptionals"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IncludeOptionals());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FindRelatedPackagesOptions_put_IncludeOptionals(py::wrapper::Windows::ApplicationModel::FindRelatedPackagesOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.FindRelatedPackagesOptions", L"IncludeOptionals"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IncludeOptionals(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FindRelatedPackagesOptions_get_IncludeHostRuntimes(py::wrapper::Windows::ApplicationModel::FindRelatedPackagesOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.FindRelatedPackagesOptions", L"IncludeHostRuntimes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IncludeHostRuntimes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FindRelatedPackagesOptions_put_IncludeHostRuntimes(py::wrapper::Windows::ApplicationModel::FindRelatedPackagesOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.FindRelatedPackagesOptions", L"IncludeHostRuntimes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IncludeHostRuntimes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FindRelatedPackagesOptions_get_IncludeFrameworks(py::wrapper::Windows::ApplicationModel::FindRelatedPackagesOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.FindRelatedPackagesOptions", L"IncludeFrameworks"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IncludeFrameworks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FindRelatedPackagesOptions_put_IncludeFrameworks(py::wrapper::Windows::ApplicationModel::FindRelatedPackagesOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.FindRelatedPackagesOptions", L"IncludeFrameworks"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IncludeFrameworks(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FindRelatedPackagesOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::FindRelatedPackagesOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FindRelatedPackagesOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::FindRelatedPackagesOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FindRelatedPackagesOptions[] = {
        { "_assign_array_", _assign_array_FindRelatedPackagesOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FindRelatedPackagesOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FindRelatedPackagesOptions[] = {
        { "relationship", reinterpret_cast<getter>(FindRelatedPackagesOptions_get_Relationship), reinterpret_cast<setter>(FindRelatedPackagesOptions_put_Relationship), nullptr, nullptr },
        { "include_resources", reinterpret_cast<getter>(FindRelatedPackagesOptions_get_IncludeResources), reinterpret_cast<setter>(FindRelatedPackagesOptions_put_IncludeResources), nullptr, nullptr },
        { "include_optionals", reinterpret_cast<getter>(FindRelatedPackagesOptions_get_IncludeOptionals), reinterpret_cast<setter>(FindRelatedPackagesOptions_put_IncludeOptionals), nullptr, nullptr },
        { "include_host_runtimes", reinterpret_cast<getter>(FindRelatedPackagesOptions_get_IncludeHostRuntimes), reinterpret_cast<setter>(FindRelatedPackagesOptions_put_IncludeHostRuntimes), nullptr, nullptr },
        { "include_frameworks", reinterpret_cast<getter>(FindRelatedPackagesOptions_get_IncludeFrameworks), reinterpret_cast<setter>(FindRelatedPackagesOptions_put_IncludeFrameworks), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FindRelatedPackagesOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FindRelatedPackagesOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FindRelatedPackagesOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FindRelatedPackagesOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FindRelatedPackagesOptions) },
        { },
    };

    static PyType_Spec type_spec_FindRelatedPackagesOptions =
    {
        "_winsdk_Windows_ApplicationModel.FindRelatedPackagesOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::FindRelatedPackagesOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FindRelatedPackagesOptions
    };

    // ----- FullTrustProcessLaunchResult class --------------------
    static constexpr const char* const type_name_FullTrustProcessLaunchResult = "FullTrustProcessLaunchResult";

    static PyObject* _new_FullTrustProcessLaunchResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FullTrustProcessLaunchResult);
        return nullptr;
    }

    static void _dealloc_FullTrustProcessLaunchResult(py::wrapper::Windows::ApplicationModel::FullTrustProcessLaunchResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FullTrustProcessLaunchResult_get_ExtendedError(py::wrapper::Windows::ApplicationModel::FullTrustProcessLaunchResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.FullTrustProcessLaunchResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FullTrustProcessLaunchResult_get_LaunchResult(py::wrapper::Windows::ApplicationModel::FullTrustProcessLaunchResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.FullTrustProcessLaunchResult", L"LaunchResult"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LaunchResult());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FullTrustProcessLaunchResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::FullTrustProcessLaunchResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FullTrustProcessLaunchResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::FullTrustProcessLaunchResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FullTrustProcessLaunchResult[] = {
        { "_assign_array_", _assign_array_FullTrustProcessLaunchResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FullTrustProcessLaunchResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FullTrustProcessLaunchResult[] = {
        { "extended_error", reinterpret_cast<getter>(FullTrustProcessLaunchResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "launch_result", reinterpret_cast<getter>(FullTrustProcessLaunchResult_get_LaunchResult), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FullTrustProcessLaunchResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FullTrustProcessLaunchResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FullTrustProcessLaunchResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FullTrustProcessLaunchResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FullTrustProcessLaunchResult) },
        { },
    };

    static PyType_Spec type_spec_FullTrustProcessLaunchResult =
    {
        "_winsdk_Windows_ApplicationModel.FullTrustProcessLaunchResult",
        sizeof(py::wrapper::Windows::ApplicationModel::FullTrustProcessLaunchResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FullTrustProcessLaunchResult
    };

    // ----- FullTrustProcessLauncher class --------------------
    static constexpr const char* const type_name_FullTrustProcessLauncher = "FullTrustProcessLauncher";

    static PyObject* _new_FullTrustProcessLauncher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FullTrustProcessLauncher);
        return nullptr;
    }

    static PyObject* FullTrustProcessLauncher_LaunchFullTrustProcessForAppAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.FullTrustProcessLauncher", L"LaunchFullTrustProcessForAppAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::FullTrustProcessLauncher::LaunchFullTrustProcessForAppAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.FullTrustProcessLauncher", L"LaunchFullTrustProcessForAppAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::FullTrustProcessLauncher::LaunchFullTrustProcessForAppAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FullTrustProcessLauncher_LaunchFullTrustProcessForAppWithArgumentsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.FullTrustProcessLauncher", L"LaunchFullTrustProcessForAppWithArgumentsAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::FullTrustProcessLauncher::LaunchFullTrustProcessForAppWithArgumentsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FullTrustProcessLauncher_LaunchFullTrustProcessForCurrentAppAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.FullTrustProcessLauncher", L"LaunchFullTrustProcessForCurrentAppAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::FullTrustProcessLauncher::LaunchFullTrustProcessForCurrentAppAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.FullTrustProcessLauncher", L"LaunchFullTrustProcessForCurrentAppAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::FullTrustProcessLauncher::LaunchFullTrustProcessForCurrentAppAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FullTrustProcessLauncher_LaunchFullTrustProcessForCurrentAppWithArgumentsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.FullTrustProcessLauncher", L"LaunchFullTrustProcessForCurrentAppWithArgumentsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::FullTrustProcessLauncher::LaunchFullTrustProcessForCurrentAppWithArgumentsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_FullTrustProcessLauncher[] = {
        { "launch_full_trust_process_for_app_async", reinterpret_cast<PyCFunction>(FullTrustProcessLauncher_LaunchFullTrustProcessForAppAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "launch_full_trust_process_for_app_with_arguments_async", reinterpret_cast<PyCFunction>(FullTrustProcessLauncher_LaunchFullTrustProcessForAppWithArgumentsAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "launch_full_trust_process_for_current_app_async", reinterpret_cast<PyCFunction>(FullTrustProcessLauncher_LaunchFullTrustProcessForCurrentAppAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "launch_full_trust_process_for_current_app_with_arguments_async", reinterpret_cast<PyCFunction>(FullTrustProcessLauncher_LaunchFullTrustProcessForCurrentAppWithArgumentsAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FullTrustProcessLauncher[] = {
        { }
    };

    static PyType_Slot _type_slots_FullTrustProcessLauncher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FullTrustProcessLauncher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FullTrustProcessLauncher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FullTrustProcessLauncher) },
        { },
    };

    static PyType_Spec type_spec_FullTrustProcessLauncher =
    {
        "_winsdk_Windows_ApplicationModel.FullTrustProcessLauncher",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FullTrustProcessLauncher
    };

    // ----- LeavingBackgroundEventArgs class --------------------
    static constexpr const char* const type_name_LeavingBackgroundEventArgs = "LeavingBackgroundEventArgs";

    static PyObject* _new_LeavingBackgroundEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LeavingBackgroundEventArgs);
        return nullptr;
    }

    static void _dealloc_LeavingBackgroundEventArgs(py::wrapper::Windows::ApplicationModel::LeavingBackgroundEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LeavingBackgroundEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::LeavingBackgroundEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.LeavingBackgroundEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_LeavingBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::LeavingBackgroundEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LeavingBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::LeavingBackgroundEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LeavingBackgroundEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(LeavingBackgroundEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LeavingBackgroundEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LeavingBackgroundEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LeavingBackgroundEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_LeavingBackgroundEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LeavingBackgroundEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LeavingBackgroundEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LeavingBackgroundEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LeavingBackgroundEventArgs) },
        { },
    };

    static PyType_Spec type_spec_LeavingBackgroundEventArgs =
    {
        "_winsdk_Windows_ApplicationModel.LeavingBackgroundEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::LeavingBackgroundEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LeavingBackgroundEventArgs
    };

    // ----- LimitedAccessFeatureRequestResult class --------------------
    static constexpr const char* const type_name_LimitedAccessFeatureRequestResult = "LimitedAccessFeatureRequestResult";

    static PyObject* _new_LimitedAccessFeatureRequestResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LimitedAccessFeatureRequestResult);
        return nullptr;
    }

    static void _dealloc_LimitedAccessFeatureRequestResult(py::wrapper::Windows::ApplicationModel::LimitedAccessFeatureRequestResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LimitedAccessFeatureRequestResult_get_EstimatedRemovalDate(py::wrapper::Windows::ApplicationModel::LimitedAccessFeatureRequestResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.LimitedAccessFeatureRequestResult", L"EstimatedRemovalDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EstimatedRemovalDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LimitedAccessFeatureRequestResult_get_FeatureId(py::wrapper::Windows::ApplicationModel::LimitedAccessFeatureRequestResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.LimitedAccessFeatureRequestResult", L"FeatureId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FeatureId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LimitedAccessFeatureRequestResult_get_Status(py::wrapper::Windows::ApplicationModel::LimitedAccessFeatureRequestResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.LimitedAccessFeatureRequestResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LimitedAccessFeatureRequestResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::LimitedAccessFeatureRequestResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LimitedAccessFeatureRequestResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::LimitedAccessFeatureRequestResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LimitedAccessFeatureRequestResult[] = {
        { "_assign_array_", _assign_array_LimitedAccessFeatureRequestResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LimitedAccessFeatureRequestResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LimitedAccessFeatureRequestResult[] = {
        { "estimated_removal_date", reinterpret_cast<getter>(LimitedAccessFeatureRequestResult_get_EstimatedRemovalDate), nullptr, nullptr, nullptr },
        { "feature_id", reinterpret_cast<getter>(LimitedAccessFeatureRequestResult_get_FeatureId), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(LimitedAccessFeatureRequestResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LimitedAccessFeatureRequestResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LimitedAccessFeatureRequestResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LimitedAccessFeatureRequestResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LimitedAccessFeatureRequestResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LimitedAccessFeatureRequestResult) },
        { },
    };

    static PyType_Spec type_spec_LimitedAccessFeatureRequestResult =
    {
        "_winsdk_Windows_ApplicationModel.LimitedAccessFeatureRequestResult",
        sizeof(py::wrapper::Windows::ApplicationModel::LimitedAccessFeatureRequestResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LimitedAccessFeatureRequestResult
    };

    // ----- LimitedAccessFeatures class --------------------
    static constexpr const char* const type_name_LimitedAccessFeatures = "LimitedAccessFeatures";

    static PyObject* _new_LimitedAccessFeatures(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LimitedAccessFeatures);
        return nullptr;
    }

    static PyObject* LimitedAccessFeatures_TryUnlockFeature(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.LimitedAccessFeatures", L"TryUnlockFeature", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(winrt::Windows::ApplicationModel::LimitedAccessFeatures::TryUnlockFeature(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_LimitedAccessFeatures[] = {
        { "try_unlock_feature", reinterpret_cast<PyCFunction>(LimitedAccessFeatures_TryUnlockFeature), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LimitedAccessFeatures[] = {
        { }
    };

    static PyType_Slot _type_slots_LimitedAccessFeatures[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LimitedAccessFeatures) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LimitedAccessFeatures) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LimitedAccessFeatures) },
        { },
    };

    static PyType_Spec type_spec_LimitedAccessFeatures =
    {
        "_winsdk_Windows_ApplicationModel.LimitedAccessFeatures",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LimitedAccessFeatures
    };

    // ----- Package class --------------------
    static constexpr const char* const type_name_Package = "Package";

    static PyObject* _new_Package(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_Package);
        return nullptr;
    }

    static void _dealloc_Package(py::wrapper::Windows::ApplicationModel::Package* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Package_CheckUpdateAvailabilityAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"CheckUpdateAvailabilityAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CheckUpdateAvailabilityAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_FindRelatedPackages(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"FindRelatedPackages", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::FindRelatedPackagesOptions>(args, 0);

                return py::convert(self->obj.FindRelatedPackages(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetAppInstallerInfo(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"GetAppInstallerInfo", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAppInstallerInfo());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetAppListEntries(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"GetAppListEntries", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAppListEntries());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetAppListEntriesAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"GetAppListEntriesAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAppListEntriesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetContentGroupAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"GetContentGroupAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetContentGroupAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetContentGroupsAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"GetContentGroupsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetContentGroupsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetLogoAsRandomAccessStreamReference(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"GetLogoAsRandomAccessStreamReference", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

                return py::convert(self->obj.GetLogoAsRandomAccessStreamReference(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetThumbnailToken(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"GetThumbnailToken", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetThumbnailToken());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_Launch(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"Launch", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Launch(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_SetInUseAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"SetInUseAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.SetInUseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_StageContentGroupsAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"StageContentGroupsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.StageContentGroupsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"StageContentGroupsAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.StageContentGroupsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_VerifyContentIntegrityAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"VerifyContentIntegrityAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.VerifyContentIntegrityAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_get_Dependencies(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"Dependencies"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Dependencies());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_Id(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_InstalledLocation(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"InstalledLocation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstalledLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_IsFramework(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"IsFramework"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsFramework());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_Description(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_DisplayName(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_IsBundle(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"IsBundle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsBundle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_IsDevelopmentMode(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"IsDevelopmentMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDevelopmentMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_IsResourcePackage(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"IsResourcePackage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsResourcePackage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_Logo(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Logo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_PublisherDisplayName(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"PublisherDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PublisherDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_InstalledDate(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"InstalledDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstalledDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_Status(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_IsOptional(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"IsOptional"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsOptional());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_SignatureKind(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"SignatureKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SignatureKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_EffectiveLocation(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"EffectiveLocation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectiveLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_MutableLocation(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"MutableLocation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MutableLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_EffectiveExternalLocation(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"EffectiveExternalLocation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectiveExternalLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_EffectiveExternalPath(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"EffectiveExternalPath"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectiveExternalPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_EffectivePath(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"EffectivePath"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectivePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_InstalledPath(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"InstalledPath"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstalledPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_IsStub(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"IsStub"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStub());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_MachineExternalLocation(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"MachineExternalLocation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MachineExternalLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_MachineExternalPath(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"MachineExternalPath"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MachineExternalPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_MutablePath(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"MutablePath"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MutablePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_UserExternalLocation(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"UserExternalLocation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UserExternalLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_UserExternalPath(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"UserExternalPath"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UserExternalPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_SourceUriSchemeName(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"SourceUriSchemeName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceUriSchemeName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_InstallDate(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"InstallDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstallDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_Current(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"Current"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Package::Current());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Package(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Package>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Package(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Package>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Package[] = {
        { "check_update_availability_async", reinterpret_cast<PyCFunction>(Package_CheckUpdateAvailabilityAsync), METH_VARARGS, nullptr },
        { "find_related_packages", reinterpret_cast<PyCFunction>(Package_FindRelatedPackages), METH_VARARGS, nullptr },
        { "get_app_installer_info", reinterpret_cast<PyCFunction>(Package_GetAppInstallerInfo), METH_VARARGS, nullptr },
        { "get_app_list_entries", reinterpret_cast<PyCFunction>(Package_GetAppListEntries), METH_VARARGS, nullptr },
        { "get_app_list_entries_async", reinterpret_cast<PyCFunction>(Package_GetAppListEntriesAsync), METH_VARARGS, nullptr },
        { "get_content_group_async", reinterpret_cast<PyCFunction>(Package_GetContentGroupAsync), METH_VARARGS, nullptr },
        { "get_content_groups_async", reinterpret_cast<PyCFunction>(Package_GetContentGroupsAsync), METH_VARARGS, nullptr },
        { "get_logo_as_random_access_stream_reference", reinterpret_cast<PyCFunction>(Package_GetLogoAsRandomAccessStreamReference), METH_VARARGS, nullptr },
        { "get_thumbnail_token", reinterpret_cast<PyCFunction>(Package_GetThumbnailToken), METH_VARARGS, nullptr },
        { "launch", reinterpret_cast<PyCFunction>(Package_Launch), METH_VARARGS, nullptr },
        { "set_in_use_async", reinterpret_cast<PyCFunction>(Package_SetInUseAsync), METH_VARARGS, nullptr },
        { "stage_content_groups_async", reinterpret_cast<PyCFunction>(Package_StageContentGroupsAsync), METH_VARARGS, nullptr },
        { "verify_content_integrity_async", reinterpret_cast<PyCFunction>(Package_VerifyContentIntegrityAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Package, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Package), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Package[] = {
        { "dependencies", reinterpret_cast<getter>(Package_get_Dependencies), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(Package_get_Id), nullptr, nullptr, nullptr },
        { "installed_location", reinterpret_cast<getter>(Package_get_InstalledLocation), nullptr, nullptr, nullptr },
        { "is_framework", reinterpret_cast<getter>(Package_get_IsFramework), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(Package_get_Description), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(Package_get_DisplayName), nullptr, nullptr, nullptr },
        { "is_bundle", reinterpret_cast<getter>(Package_get_IsBundle), nullptr, nullptr, nullptr },
        { "is_development_mode", reinterpret_cast<getter>(Package_get_IsDevelopmentMode), nullptr, nullptr, nullptr },
        { "is_resource_package", reinterpret_cast<getter>(Package_get_IsResourcePackage), nullptr, nullptr, nullptr },
        { "logo", reinterpret_cast<getter>(Package_get_Logo), nullptr, nullptr, nullptr },
        { "publisher_display_name", reinterpret_cast<getter>(Package_get_PublisherDisplayName), nullptr, nullptr, nullptr },
        { "installed_date", reinterpret_cast<getter>(Package_get_InstalledDate), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(Package_get_Status), nullptr, nullptr, nullptr },
        { "is_optional", reinterpret_cast<getter>(Package_get_IsOptional), nullptr, nullptr, nullptr },
        { "signature_kind", reinterpret_cast<getter>(Package_get_SignatureKind), nullptr, nullptr, nullptr },
        { "effective_location", reinterpret_cast<getter>(Package_get_EffectiveLocation), nullptr, nullptr, nullptr },
        { "mutable_location", reinterpret_cast<getter>(Package_get_MutableLocation), nullptr, nullptr, nullptr },
        { "effective_external_location", reinterpret_cast<getter>(Package_get_EffectiveExternalLocation), nullptr, nullptr, nullptr },
        { "effective_external_path", reinterpret_cast<getter>(Package_get_EffectiveExternalPath), nullptr, nullptr, nullptr },
        { "effective_path", reinterpret_cast<getter>(Package_get_EffectivePath), nullptr, nullptr, nullptr },
        { "installed_path", reinterpret_cast<getter>(Package_get_InstalledPath), nullptr, nullptr, nullptr },
        { "is_stub", reinterpret_cast<getter>(Package_get_IsStub), nullptr, nullptr, nullptr },
        { "machine_external_location", reinterpret_cast<getter>(Package_get_MachineExternalLocation), nullptr, nullptr, nullptr },
        { "machine_external_path", reinterpret_cast<getter>(Package_get_MachineExternalPath), nullptr, nullptr, nullptr },
        { "mutable_path", reinterpret_cast<getter>(Package_get_MutablePath), nullptr, nullptr, nullptr },
        { "user_external_location", reinterpret_cast<getter>(Package_get_UserExternalLocation), nullptr, nullptr, nullptr },
        { "user_external_path", reinterpret_cast<getter>(Package_get_UserExternalPath), nullptr, nullptr, nullptr },
        { "source_uri_scheme_name", reinterpret_cast<getter>(Package_get_SourceUriSchemeName), nullptr, nullptr, nullptr },
        { "install_date", reinterpret_cast<getter>(Package_get_InstallDate), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Package[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Package) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Package) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Package) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Package) },
        { },
    };

    static PyType_Spec type_spec_Package =
    {
        "_winsdk_Windows_ApplicationModel.Package",
        sizeof(py::wrapper::Windows::ApplicationModel::Package),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Package
    };

    static PyGetSetDef getset_Package_Meta[] = {
        { "current", reinterpret_cast<getter>(Package_get_Current), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_Package_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Package_Meta) },
        { }
    };

    static PyType_Spec type_spec_Package_Meta =
    {
        "_winsdk_Windows_ApplicationModel.Package_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Package_Meta
    };

    // ----- PackageCatalog class --------------------
    static constexpr const char* const type_name_PackageCatalog = "PackageCatalog";

    static PyObject* _new_PackageCatalog(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PackageCatalog);
        return nullptr;
    }

    static void _dealloc_PackageCatalog(py::wrapper::Windows::ApplicationModel::PackageCatalog* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageCatalog_AddOptionalPackageAsync(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.PackageCatalog", L"AddOptionalPackageAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.AddOptionalPackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_AddResourcePackageAsync(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.PackageCatalog", L"AddResourcePackageAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::AddResourcePackageOptions>(args, 2);

                return py::convert(self->obj.AddResourcePackageAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_OpenForCurrentPackage(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.PackageCatalog", L"OpenForCurrentPackage", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::PackageCatalog::OpenForCurrentPackage());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_OpenForCurrentUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.PackageCatalog", L"OpenForCurrentUser", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::PackageCatalog::OpenForCurrentUser());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_OpenForPackage(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.PackageCatalog", L"OpenForPackage", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::PackageCatalog::OpenForPackage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_RemoveOptionalPackagesAsync(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.PackageCatalog", L"RemoveOptionalPackagesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.RemoveOptionalPackagesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_RemoveResourcePackagesAsync(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.PackageCatalog", L"RemoveResourcePackagesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Package>>(args, 0);

                return py::convert(self->obj.RemoveResourcePackagesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_add_PackageInstalling(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.PackageCatalog", L"PackageInstalling"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::PackageCatalog, winrt::Windows::ApplicationModel::PackageInstallingEventArgs>>(arg);

            return py::convert(self->obj.PackageInstalling(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_remove_PackageInstalling(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.PackageCatalog", L"PackageInstalling"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PackageInstalling(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_add_PackageStaging(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.PackageCatalog", L"PackageStaging"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::PackageCatalog, winrt::Windows::ApplicationModel::PackageStagingEventArgs>>(arg);

            return py::convert(self->obj.PackageStaging(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_remove_PackageStaging(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.PackageCatalog", L"PackageStaging"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PackageStaging(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_add_PackageStatusChanged(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.PackageCatalog", L"PackageStatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::PackageCatalog, winrt::Windows::ApplicationModel::PackageStatusChangedEventArgs>>(arg);

            return py::convert(self->obj.PackageStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_remove_PackageStatusChanged(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.PackageCatalog", L"PackageStatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PackageStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_add_PackageUninstalling(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.PackageCatalog", L"PackageUninstalling"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::PackageCatalog, winrt::Windows::ApplicationModel::PackageUninstallingEventArgs>>(arg);

            return py::convert(self->obj.PackageUninstalling(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_remove_PackageUninstalling(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.PackageCatalog", L"PackageUninstalling"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PackageUninstalling(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_add_PackageUpdating(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.PackageCatalog", L"PackageUpdating"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::PackageCatalog, winrt::Windows::ApplicationModel::PackageUpdatingEventArgs>>(arg);

            return py::convert(self->obj.PackageUpdating(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_remove_PackageUpdating(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.PackageCatalog", L"PackageUpdating"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PackageUpdating(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_add_PackageContentGroupStaging(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.PackageCatalog", L"PackageContentGroupStaging"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::PackageCatalog, winrt::Windows::ApplicationModel::PackageContentGroupStagingEventArgs>>(arg);

            return py::convert(self->obj.PackageContentGroupStaging(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_remove_PackageContentGroupStaging(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.PackageCatalog", L"PackageContentGroupStaging"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PackageContentGroupStaging(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageCatalog(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageCatalog>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageCatalog(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageCatalog>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageCatalog[] = {
        { "add_optional_package_async", reinterpret_cast<PyCFunction>(PackageCatalog_AddOptionalPackageAsync), METH_VARARGS, nullptr },
        { "add_resource_package_async", reinterpret_cast<PyCFunction>(PackageCatalog_AddResourcePackageAsync), METH_VARARGS, nullptr },
        { "open_for_current_package", reinterpret_cast<PyCFunction>(PackageCatalog_OpenForCurrentPackage), METH_VARARGS | METH_STATIC, nullptr },
        { "open_for_current_user", reinterpret_cast<PyCFunction>(PackageCatalog_OpenForCurrentUser), METH_VARARGS | METH_STATIC, nullptr },
        { "open_for_package", reinterpret_cast<PyCFunction>(PackageCatalog_OpenForPackage), METH_VARARGS | METH_STATIC, nullptr },
        { "remove_optional_packages_async", reinterpret_cast<PyCFunction>(PackageCatalog_RemoveOptionalPackagesAsync), METH_VARARGS, nullptr },
        { "remove_resource_packages_async", reinterpret_cast<PyCFunction>(PackageCatalog_RemoveResourcePackagesAsync), METH_VARARGS, nullptr },
        { "add_package_installing", reinterpret_cast<PyCFunction>(PackageCatalog_add_PackageInstalling), METH_O, nullptr },
        { "remove_package_installing", reinterpret_cast<PyCFunction>(PackageCatalog_remove_PackageInstalling), METH_O, nullptr },
        { "add_package_staging", reinterpret_cast<PyCFunction>(PackageCatalog_add_PackageStaging), METH_O, nullptr },
        { "remove_package_staging", reinterpret_cast<PyCFunction>(PackageCatalog_remove_PackageStaging), METH_O, nullptr },
        { "add_package_status_changed", reinterpret_cast<PyCFunction>(PackageCatalog_add_PackageStatusChanged), METH_O, nullptr },
        { "remove_package_status_changed", reinterpret_cast<PyCFunction>(PackageCatalog_remove_PackageStatusChanged), METH_O, nullptr },
        { "add_package_uninstalling", reinterpret_cast<PyCFunction>(PackageCatalog_add_PackageUninstalling), METH_O, nullptr },
        { "remove_package_uninstalling", reinterpret_cast<PyCFunction>(PackageCatalog_remove_PackageUninstalling), METH_O, nullptr },
        { "add_package_updating", reinterpret_cast<PyCFunction>(PackageCatalog_add_PackageUpdating), METH_O, nullptr },
        { "remove_package_updating", reinterpret_cast<PyCFunction>(PackageCatalog_remove_PackageUpdating), METH_O, nullptr },
        { "add_package_content_group_staging", reinterpret_cast<PyCFunction>(PackageCatalog_add_PackageContentGroupStaging), METH_O, nullptr },
        { "remove_package_content_group_staging", reinterpret_cast<PyCFunction>(PackageCatalog_remove_PackageContentGroupStaging), METH_O, nullptr },
        { "_assign_array_", _assign_array_PackageCatalog, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageCatalog), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageCatalog[] = {
        { }
    };

    static PyType_Slot _type_slots_PackageCatalog[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageCatalog) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageCatalog) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageCatalog) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageCatalog) },
        { },
    };

    static PyType_Spec type_spec_PackageCatalog =
    {
        "_winsdk_Windows_ApplicationModel.PackageCatalog",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageCatalog),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageCatalog
    };

    // ----- PackageCatalogAddOptionalPackageResult class --------------------
    static constexpr const char* const type_name_PackageCatalogAddOptionalPackageResult = "PackageCatalogAddOptionalPackageResult";

    static PyObject* _new_PackageCatalogAddOptionalPackageResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PackageCatalogAddOptionalPackageResult);
        return nullptr;
    }

    static void _dealloc_PackageCatalogAddOptionalPackageResult(py::wrapper::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageCatalogAddOptionalPackageResult_get_ExtendedError(py::wrapper::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageCatalogAddOptionalPackageResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalogAddOptionalPackageResult_get_Package(py::wrapper::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageCatalogAddOptionalPackageResult", L"Package"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageCatalogAddOptionalPackageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageCatalogAddOptionalPackageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageCatalogAddOptionalPackageResult[] = {
        { "_assign_array_", _assign_array_PackageCatalogAddOptionalPackageResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageCatalogAddOptionalPackageResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageCatalogAddOptionalPackageResult[] = {
        { "extended_error", reinterpret_cast<getter>(PackageCatalogAddOptionalPackageResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(PackageCatalogAddOptionalPackageResult_get_Package), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageCatalogAddOptionalPackageResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageCatalogAddOptionalPackageResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageCatalogAddOptionalPackageResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageCatalogAddOptionalPackageResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageCatalogAddOptionalPackageResult) },
        { },
    };

    static PyType_Spec type_spec_PackageCatalogAddOptionalPackageResult =
    {
        "_winsdk_Windows_ApplicationModel.PackageCatalogAddOptionalPackageResult",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageCatalogAddOptionalPackageResult
    };

    // ----- PackageCatalogAddResourcePackageResult class --------------------
    static constexpr const char* const type_name_PackageCatalogAddResourcePackageResult = "PackageCatalogAddResourcePackageResult";

    static PyObject* _new_PackageCatalogAddResourcePackageResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PackageCatalogAddResourcePackageResult);
        return nullptr;
    }

    static void _dealloc_PackageCatalogAddResourcePackageResult(py::wrapper::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageCatalogAddResourcePackageResult_get_ExtendedError(py::wrapper::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageCatalogAddResourcePackageResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalogAddResourcePackageResult_get_IsComplete(py::wrapper::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageCatalogAddResourcePackageResult", L"IsComplete"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalogAddResourcePackageResult_get_Package(py::wrapper::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageCatalogAddResourcePackageResult", L"Package"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageCatalogAddResourcePackageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageCatalogAddResourcePackageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageCatalogAddResourcePackageResult[] = {
        { "_assign_array_", _assign_array_PackageCatalogAddResourcePackageResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageCatalogAddResourcePackageResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageCatalogAddResourcePackageResult[] = {
        { "extended_error", reinterpret_cast<getter>(PackageCatalogAddResourcePackageResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "is_complete", reinterpret_cast<getter>(PackageCatalogAddResourcePackageResult_get_IsComplete), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(PackageCatalogAddResourcePackageResult_get_Package), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageCatalogAddResourcePackageResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageCatalogAddResourcePackageResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageCatalogAddResourcePackageResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageCatalogAddResourcePackageResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageCatalogAddResourcePackageResult) },
        { },
    };

    static PyType_Spec type_spec_PackageCatalogAddResourcePackageResult =
    {
        "_winsdk_Windows_ApplicationModel.PackageCatalogAddResourcePackageResult",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageCatalogAddResourcePackageResult
    };

    // ----- PackageCatalogRemoveOptionalPackagesResult class --------------------
    static constexpr const char* const type_name_PackageCatalogRemoveOptionalPackagesResult = "PackageCatalogRemoveOptionalPackagesResult";

    static PyObject* _new_PackageCatalogRemoveOptionalPackagesResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PackageCatalogRemoveOptionalPackagesResult);
        return nullptr;
    }

    static void _dealloc_PackageCatalogRemoveOptionalPackagesResult(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageCatalogRemoveOptionalPackagesResult_get_ExtendedError(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageCatalogRemoveOptionalPackagesResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalogRemoveOptionalPackagesResult_get_PackagesRemoved(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageCatalogRemoveOptionalPackagesResult", L"PackagesRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PackagesRemoved());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageCatalogRemoveOptionalPackagesResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageCatalogRemoveOptionalPackagesResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageCatalogRemoveOptionalPackagesResult[] = {
        { "_assign_array_", _assign_array_PackageCatalogRemoveOptionalPackagesResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageCatalogRemoveOptionalPackagesResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageCatalogRemoveOptionalPackagesResult[] = {
        { "extended_error", reinterpret_cast<getter>(PackageCatalogRemoveOptionalPackagesResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "packages_removed", reinterpret_cast<getter>(PackageCatalogRemoveOptionalPackagesResult_get_PackagesRemoved), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageCatalogRemoveOptionalPackagesResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageCatalogRemoveOptionalPackagesResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageCatalogRemoveOptionalPackagesResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageCatalogRemoveOptionalPackagesResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageCatalogRemoveOptionalPackagesResult) },
        { },
    };

    static PyType_Spec type_spec_PackageCatalogRemoveOptionalPackagesResult =
    {
        "_winsdk_Windows_ApplicationModel.PackageCatalogRemoveOptionalPackagesResult",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageCatalogRemoveOptionalPackagesResult
    };

    // ----- PackageCatalogRemoveResourcePackagesResult class --------------------
    static constexpr const char* const type_name_PackageCatalogRemoveResourcePackagesResult = "PackageCatalogRemoveResourcePackagesResult";

    static PyObject* _new_PackageCatalogRemoveResourcePackagesResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PackageCatalogRemoveResourcePackagesResult);
        return nullptr;
    }

    static void _dealloc_PackageCatalogRemoveResourcePackagesResult(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageCatalogRemoveResourcePackagesResult_get_ExtendedError(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageCatalogRemoveResourcePackagesResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalogRemoveResourcePackagesResult_get_PackagesRemoved(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageCatalogRemoveResourcePackagesResult", L"PackagesRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PackagesRemoved());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageCatalogRemoveResourcePackagesResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageCatalogRemoveResourcePackagesResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageCatalogRemoveResourcePackagesResult[] = {
        { "_assign_array_", _assign_array_PackageCatalogRemoveResourcePackagesResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageCatalogRemoveResourcePackagesResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageCatalogRemoveResourcePackagesResult[] = {
        { "extended_error", reinterpret_cast<getter>(PackageCatalogRemoveResourcePackagesResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "packages_removed", reinterpret_cast<getter>(PackageCatalogRemoveResourcePackagesResult_get_PackagesRemoved), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageCatalogRemoveResourcePackagesResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageCatalogRemoveResourcePackagesResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageCatalogRemoveResourcePackagesResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageCatalogRemoveResourcePackagesResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageCatalogRemoveResourcePackagesResult) },
        { },
    };

    static PyType_Spec type_spec_PackageCatalogRemoveResourcePackagesResult =
    {
        "_winsdk_Windows_ApplicationModel.PackageCatalogRemoveResourcePackagesResult",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageCatalogRemoveResourcePackagesResult
    };

    // ----- PackageContentGroup class --------------------
    static constexpr const char* const type_name_PackageContentGroup = "PackageContentGroup";

    static PyObject* _new_PackageContentGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PackageContentGroup);
        return nullptr;
    }

    static void _dealloc_PackageContentGroup(py::wrapper::Windows::ApplicationModel::PackageContentGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageContentGroup_get_IsRequired(py::wrapper::Windows::ApplicationModel::PackageContentGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageContentGroup", L"IsRequired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroup_get_Name(py::wrapper::Windows::ApplicationModel::PackageContentGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageContentGroup", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroup_get_Package(py::wrapper::Windows::ApplicationModel::PackageContentGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageContentGroup", L"Package"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroup_get_State(py::wrapper::Windows::ApplicationModel::PackageContentGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageContentGroup", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroup_get_RequiredGroupName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageContentGroup", L"RequiredGroupName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::PackageContentGroup::RequiredGroupName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageContentGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageContentGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageContentGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageContentGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageContentGroup[] = {
        { "_assign_array_", _assign_array_PackageContentGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageContentGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageContentGroup[] = {
        { "is_required", reinterpret_cast<getter>(PackageContentGroup_get_IsRequired), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(PackageContentGroup_get_Name), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(PackageContentGroup_get_Package), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(PackageContentGroup_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageContentGroup[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageContentGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageContentGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageContentGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageContentGroup) },
        { },
    };

    static PyType_Spec type_spec_PackageContentGroup =
    {
        "_winsdk_Windows_ApplicationModel.PackageContentGroup",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageContentGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageContentGroup
    };

    static PyGetSetDef getset_PackageContentGroup_Meta[] = {
        { "required_group_name", reinterpret_cast<getter>(PackageContentGroup_get_RequiredGroupName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_PackageContentGroup_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PackageContentGroup_Meta) },
        { }
    };

    static PyType_Spec type_spec_PackageContentGroup_Meta =
    {
        "_winsdk_Windows_ApplicationModel.PackageContentGroup_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PackageContentGroup_Meta
    };

    // ----- PackageContentGroupStagingEventArgs class --------------------
    static constexpr const char* const type_name_PackageContentGroupStagingEventArgs = "PackageContentGroupStagingEventArgs";

    static PyObject* _new_PackageContentGroupStagingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PackageContentGroupStagingEventArgs);
        return nullptr;
    }

    static void _dealloc_PackageContentGroupStagingEventArgs(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_ActivityId(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageContentGroupStagingEventArgs", L"ActivityId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_ContentGroupName(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageContentGroupStagingEventArgs", L"ContentGroupName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContentGroupName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_ErrorCode(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageContentGroupStagingEventArgs", L"ErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_IsComplete(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageContentGroupStagingEventArgs", L"IsComplete"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_IsContentGroupRequired(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageContentGroupStagingEventArgs", L"IsContentGroupRequired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsContentGroupRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_Package(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageContentGroupStagingEventArgs", L"Package"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_Progress(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageContentGroupStagingEventArgs", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageContentGroupStagingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageContentGroupStagingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageContentGroupStagingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageContentGroupStagingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageContentGroupStagingEventArgs[] = {
        { "_assign_array_", _assign_array_PackageContentGroupStagingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageContentGroupStagingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageContentGroupStagingEventArgs[] = {
        { "activity_id", reinterpret_cast<getter>(PackageContentGroupStagingEventArgs_get_ActivityId), nullptr, nullptr, nullptr },
        { "content_group_name", reinterpret_cast<getter>(PackageContentGroupStagingEventArgs_get_ContentGroupName), nullptr, nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(PackageContentGroupStagingEventArgs_get_ErrorCode), nullptr, nullptr, nullptr },
        { "is_complete", reinterpret_cast<getter>(PackageContentGroupStagingEventArgs_get_IsComplete), nullptr, nullptr, nullptr },
        { "is_content_group_required", reinterpret_cast<getter>(PackageContentGroupStagingEventArgs_get_IsContentGroupRequired), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(PackageContentGroupStagingEventArgs_get_Package), nullptr, nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(PackageContentGroupStagingEventArgs_get_Progress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageContentGroupStagingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageContentGroupStagingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageContentGroupStagingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageContentGroupStagingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageContentGroupStagingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PackageContentGroupStagingEventArgs =
    {
        "_winsdk_Windows_ApplicationModel.PackageContentGroupStagingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageContentGroupStagingEventArgs
    };

    // ----- PackageId class --------------------
    static constexpr const char* const type_name_PackageId = "PackageId";

    static PyObject* _new_PackageId(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PackageId);
        return nullptr;
    }

    static void _dealloc_PackageId(py::wrapper::Windows::ApplicationModel::PackageId* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageId_get_Architecture(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageId", L"Architecture"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Architecture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_FamilyName(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageId", L"FamilyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_FullName(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageId", L"FullName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FullName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_Name(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageId", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_Publisher(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageId", L"Publisher"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Publisher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_PublisherId(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageId", L"PublisherId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PublisherId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_ResourceId(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageId", L"ResourceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ResourceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_Version(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageId", L"Version"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_Author(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageId", L"Author"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Author());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_ProductId(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageId", L"ProductId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageId>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageId>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageId[] = {
        { "_assign_array_", _assign_array_PackageId, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageId), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageId[] = {
        { "architecture", reinterpret_cast<getter>(PackageId_get_Architecture), nullptr, nullptr, nullptr },
        { "family_name", reinterpret_cast<getter>(PackageId_get_FamilyName), nullptr, nullptr, nullptr },
        { "full_name", reinterpret_cast<getter>(PackageId_get_FullName), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(PackageId_get_Name), nullptr, nullptr, nullptr },
        { "publisher", reinterpret_cast<getter>(PackageId_get_Publisher), nullptr, nullptr, nullptr },
        { "publisher_id", reinterpret_cast<getter>(PackageId_get_PublisherId), nullptr, nullptr, nullptr },
        { "resource_id", reinterpret_cast<getter>(PackageId_get_ResourceId), nullptr, nullptr, nullptr },
        { "version", reinterpret_cast<getter>(PackageId_get_Version), nullptr, nullptr, nullptr },
        { "author", reinterpret_cast<getter>(PackageId_get_Author), nullptr, nullptr, nullptr },
        { "product_id", reinterpret_cast<getter>(PackageId_get_ProductId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageId[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageId) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageId) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageId) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageId) },
        { },
    };

    static PyType_Spec type_spec_PackageId =
    {
        "_winsdk_Windows_ApplicationModel.PackageId",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageId
    };

    // ----- PackageInstallingEventArgs class --------------------
    static constexpr const char* const type_name_PackageInstallingEventArgs = "PackageInstallingEventArgs";

    static PyObject* _new_PackageInstallingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PackageInstallingEventArgs);
        return nullptr;
    }

    static void _dealloc_PackageInstallingEventArgs(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageInstallingEventArgs_get_ActivityId(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageInstallingEventArgs", L"ActivityId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageInstallingEventArgs_get_ErrorCode(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageInstallingEventArgs", L"ErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageInstallingEventArgs_get_IsComplete(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageInstallingEventArgs", L"IsComplete"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageInstallingEventArgs_get_Package(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageInstallingEventArgs", L"Package"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageInstallingEventArgs_get_Progress(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageInstallingEventArgs", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageInstallingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageInstallingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageInstallingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageInstallingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageInstallingEventArgs[] = {
        { "_assign_array_", _assign_array_PackageInstallingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageInstallingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageInstallingEventArgs[] = {
        { "activity_id", reinterpret_cast<getter>(PackageInstallingEventArgs_get_ActivityId), nullptr, nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(PackageInstallingEventArgs_get_ErrorCode), nullptr, nullptr, nullptr },
        { "is_complete", reinterpret_cast<getter>(PackageInstallingEventArgs_get_IsComplete), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(PackageInstallingEventArgs_get_Package), nullptr, nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(PackageInstallingEventArgs_get_Progress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageInstallingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageInstallingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageInstallingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageInstallingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageInstallingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PackageInstallingEventArgs =
    {
        "_winsdk_Windows_ApplicationModel.PackageInstallingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageInstallingEventArgs
    };

    // ----- PackageStagingEventArgs class --------------------
    static constexpr const char* const type_name_PackageStagingEventArgs = "PackageStagingEventArgs";

    static PyObject* _new_PackageStagingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PackageStagingEventArgs);
        return nullptr;
    }

    static void _dealloc_PackageStagingEventArgs(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageStagingEventArgs_get_ActivityId(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStagingEventArgs", L"ActivityId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStagingEventArgs_get_ErrorCode(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStagingEventArgs", L"ErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStagingEventArgs_get_IsComplete(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStagingEventArgs", L"IsComplete"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStagingEventArgs_get_Package(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStagingEventArgs", L"Package"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStagingEventArgs_get_Progress(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStagingEventArgs", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageStagingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageStagingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageStagingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageStagingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageStagingEventArgs[] = {
        { "_assign_array_", _assign_array_PackageStagingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageStagingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageStagingEventArgs[] = {
        { "activity_id", reinterpret_cast<getter>(PackageStagingEventArgs_get_ActivityId), nullptr, nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(PackageStagingEventArgs_get_ErrorCode), nullptr, nullptr, nullptr },
        { "is_complete", reinterpret_cast<getter>(PackageStagingEventArgs_get_IsComplete), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(PackageStagingEventArgs_get_Package), nullptr, nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(PackageStagingEventArgs_get_Progress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageStagingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageStagingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageStagingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageStagingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageStagingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PackageStagingEventArgs =
    {
        "_winsdk_Windows_ApplicationModel.PackageStagingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageStagingEventArgs
    };

    // ----- PackageStatus class --------------------
    static constexpr const char* const type_name_PackageStatus = "PackageStatus";

    static PyObject* _new_PackageStatus(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PackageStatus);
        return nullptr;
    }

    static void _dealloc_PackageStatus(py::wrapper::Windows::ApplicationModel::PackageStatus* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageStatus_VerifyIsOK(py::wrapper::Windows::ApplicationModel::PackageStatus* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.PackageStatus", L"VerifyIsOK", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.VerifyIsOK());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_DataOffline(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStatus", L"DataOffline"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DataOffline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_DependencyIssue(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStatus", L"DependencyIssue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DependencyIssue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_DeploymentInProgress(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStatus", L"DeploymentInProgress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeploymentInProgress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_Disabled(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStatus", L"Disabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Disabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_LicenseIssue(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStatus", L"LicenseIssue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LicenseIssue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_Modified(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStatus", L"Modified"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Modified());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_NeedsRemediation(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStatus", L"NeedsRemediation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NeedsRemediation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_NotAvailable(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStatus", L"NotAvailable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NotAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_PackageOffline(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStatus", L"PackageOffline"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PackageOffline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_Servicing(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStatus", L"Servicing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Servicing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_Tampered(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStatus", L"Tampered"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tampered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_IsPartiallyStaged(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStatus", L"IsPartiallyStaged"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPartiallyStaged());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageStatus>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageStatus>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageStatus[] = {
        { "verify_is_o_k", reinterpret_cast<PyCFunction>(PackageStatus_VerifyIsOK), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PackageStatus, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageStatus), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageStatus[] = {
        { "data_offline", reinterpret_cast<getter>(PackageStatus_get_DataOffline), nullptr, nullptr, nullptr },
        { "dependency_issue", reinterpret_cast<getter>(PackageStatus_get_DependencyIssue), nullptr, nullptr, nullptr },
        { "deployment_in_progress", reinterpret_cast<getter>(PackageStatus_get_DeploymentInProgress), nullptr, nullptr, nullptr },
        { "disabled", reinterpret_cast<getter>(PackageStatus_get_Disabled), nullptr, nullptr, nullptr },
        { "license_issue", reinterpret_cast<getter>(PackageStatus_get_LicenseIssue), nullptr, nullptr, nullptr },
        { "modified", reinterpret_cast<getter>(PackageStatus_get_Modified), nullptr, nullptr, nullptr },
        { "needs_remediation", reinterpret_cast<getter>(PackageStatus_get_NeedsRemediation), nullptr, nullptr, nullptr },
        { "not_available", reinterpret_cast<getter>(PackageStatus_get_NotAvailable), nullptr, nullptr, nullptr },
        { "package_offline", reinterpret_cast<getter>(PackageStatus_get_PackageOffline), nullptr, nullptr, nullptr },
        { "servicing", reinterpret_cast<getter>(PackageStatus_get_Servicing), nullptr, nullptr, nullptr },
        { "tampered", reinterpret_cast<getter>(PackageStatus_get_Tampered), nullptr, nullptr, nullptr },
        { "is_partially_staged", reinterpret_cast<getter>(PackageStatus_get_IsPartiallyStaged), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageStatus[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageStatus) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageStatus) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageStatus) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageStatus) },
        { },
    };

    static PyType_Spec type_spec_PackageStatus =
    {
        "_winsdk_Windows_ApplicationModel.PackageStatus",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageStatus
    };

    // ----- PackageStatusChangedEventArgs class --------------------
    static constexpr const char* const type_name_PackageStatusChangedEventArgs = "PackageStatusChangedEventArgs";

    static PyObject* _new_PackageStatusChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PackageStatusChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_PackageStatusChangedEventArgs(py::wrapper::Windows::ApplicationModel::PackageStatusChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageStatusChangedEventArgs_get_Package(py::wrapper::Windows::ApplicationModel::PackageStatusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStatusChangedEventArgs", L"Package"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageStatusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageStatusChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageStatusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageStatusChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageStatusChangedEventArgs[] = {
        { "_assign_array_", _assign_array_PackageStatusChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageStatusChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageStatusChangedEventArgs[] = {
        { "package", reinterpret_cast<getter>(PackageStatusChangedEventArgs_get_Package), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageStatusChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageStatusChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageStatusChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageStatusChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageStatusChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PackageStatusChangedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel.PackageStatusChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageStatusChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageStatusChangedEventArgs
    };

    // ----- PackageUninstallingEventArgs class --------------------
    static constexpr const char* const type_name_PackageUninstallingEventArgs = "PackageUninstallingEventArgs";

    static PyObject* _new_PackageUninstallingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PackageUninstallingEventArgs);
        return nullptr;
    }

    static void _dealloc_PackageUninstallingEventArgs(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageUninstallingEventArgs_get_ActivityId(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageUninstallingEventArgs", L"ActivityId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUninstallingEventArgs_get_ErrorCode(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageUninstallingEventArgs", L"ErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUninstallingEventArgs_get_IsComplete(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageUninstallingEventArgs", L"IsComplete"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUninstallingEventArgs_get_Package(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageUninstallingEventArgs", L"Package"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUninstallingEventArgs_get_Progress(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageUninstallingEventArgs", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageUninstallingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageUninstallingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageUninstallingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageUninstallingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageUninstallingEventArgs[] = {
        { "_assign_array_", _assign_array_PackageUninstallingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageUninstallingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageUninstallingEventArgs[] = {
        { "activity_id", reinterpret_cast<getter>(PackageUninstallingEventArgs_get_ActivityId), nullptr, nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(PackageUninstallingEventArgs_get_ErrorCode), nullptr, nullptr, nullptr },
        { "is_complete", reinterpret_cast<getter>(PackageUninstallingEventArgs_get_IsComplete), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(PackageUninstallingEventArgs_get_Package), nullptr, nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(PackageUninstallingEventArgs_get_Progress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageUninstallingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageUninstallingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageUninstallingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageUninstallingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageUninstallingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PackageUninstallingEventArgs =
    {
        "_winsdk_Windows_ApplicationModel.PackageUninstallingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageUninstallingEventArgs
    };

    // ----- PackageUpdateAvailabilityResult class --------------------
    static constexpr const char* const type_name_PackageUpdateAvailabilityResult = "PackageUpdateAvailabilityResult";

    static PyObject* _new_PackageUpdateAvailabilityResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PackageUpdateAvailabilityResult);
        return nullptr;
    }

    static void _dealloc_PackageUpdateAvailabilityResult(py::wrapper::Windows::ApplicationModel::PackageUpdateAvailabilityResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageUpdateAvailabilityResult_get_Availability(py::wrapper::Windows::ApplicationModel::PackageUpdateAvailabilityResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageUpdateAvailabilityResult", L"Availability"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Availability());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUpdateAvailabilityResult_get_ExtendedError(py::wrapper::Windows::ApplicationModel::PackageUpdateAvailabilityResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageUpdateAvailabilityResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageUpdateAvailabilityResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageUpdateAvailabilityResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageUpdateAvailabilityResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageUpdateAvailabilityResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageUpdateAvailabilityResult[] = {
        { "_assign_array_", _assign_array_PackageUpdateAvailabilityResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageUpdateAvailabilityResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageUpdateAvailabilityResult[] = {
        { "availability", reinterpret_cast<getter>(PackageUpdateAvailabilityResult_get_Availability), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(PackageUpdateAvailabilityResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageUpdateAvailabilityResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageUpdateAvailabilityResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageUpdateAvailabilityResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageUpdateAvailabilityResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageUpdateAvailabilityResult) },
        { },
    };

    static PyType_Spec type_spec_PackageUpdateAvailabilityResult =
    {
        "_winsdk_Windows_ApplicationModel.PackageUpdateAvailabilityResult",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageUpdateAvailabilityResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageUpdateAvailabilityResult
    };

    // ----- PackageUpdatingEventArgs class --------------------
    static constexpr const char* const type_name_PackageUpdatingEventArgs = "PackageUpdatingEventArgs";

    static PyObject* _new_PackageUpdatingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PackageUpdatingEventArgs);
        return nullptr;
    }

    static void _dealloc_PackageUpdatingEventArgs(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageUpdatingEventArgs_get_ActivityId(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageUpdatingEventArgs", L"ActivityId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUpdatingEventArgs_get_ErrorCode(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageUpdatingEventArgs", L"ErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUpdatingEventArgs_get_IsComplete(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageUpdatingEventArgs", L"IsComplete"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUpdatingEventArgs_get_Progress(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageUpdatingEventArgs", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUpdatingEventArgs_get_SourcePackage(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageUpdatingEventArgs", L"SourcePackage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourcePackage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUpdatingEventArgs_get_TargetPackage(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageUpdatingEventArgs", L"TargetPackage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetPackage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageUpdatingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageUpdatingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageUpdatingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageUpdatingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageUpdatingEventArgs[] = {
        { "_assign_array_", _assign_array_PackageUpdatingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageUpdatingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageUpdatingEventArgs[] = {
        { "activity_id", reinterpret_cast<getter>(PackageUpdatingEventArgs_get_ActivityId), nullptr, nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(PackageUpdatingEventArgs_get_ErrorCode), nullptr, nullptr, nullptr },
        { "is_complete", reinterpret_cast<getter>(PackageUpdatingEventArgs_get_IsComplete), nullptr, nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(PackageUpdatingEventArgs_get_Progress), nullptr, nullptr, nullptr },
        { "source_package", reinterpret_cast<getter>(PackageUpdatingEventArgs_get_SourcePackage), nullptr, nullptr, nullptr },
        { "target_package", reinterpret_cast<getter>(PackageUpdatingEventArgs_get_TargetPackage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageUpdatingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageUpdatingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageUpdatingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageUpdatingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageUpdatingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PackageUpdatingEventArgs =
    {
        "_winsdk_Windows_ApplicationModel.PackageUpdatingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageUpdatingEventArgs
    };

    // ----- StartupTask class --------------------
    static constexpr const char* const type_name_StartupTask = "StartupTask";

    static PyObject* _new_StartupTask(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StartupTask);
        return nullptr;
    }

    static void _dealloc_StartupTask(py::wrapper::Windows::ApplicationModel::StartupTask* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StartupTask_Disable(py::wrapper::Windows::ApplicationModel::StartupTask* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.StartupTask", L"Disable", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Disable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartupTask_GetAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.StartupTask", L"GetAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::StartupTask::GetAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartupTask_GetForCurrentPackageAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.StartupTask", L"GetForCurrentPackageAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::StartupTask::GetForCurrentPackageAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartupTask_RequestEnableAsync(py::wrapper::Windows::ApplicationModel::StartupTask* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.StartupTask", L"RequestEnableAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RequestEnableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartupTask_get_State(py::wrapper::Windows::ApplicationModel::StartupTask* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.StartupTask", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StartupTask_get_TaskId(py::wrapper::Windows::ApplicationModel::StartupTask* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.StartupTask", L"TaskId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StartupTask(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::StartupTask>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StartupTask(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::StartupTask>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StartupTask[] = {
        { "disable", reinterpret_cast<PyCFunction>(StartupTask_Disable), METH_VARARGS, nullptr },
        { "get_async", reinterpret_cast<PyCFunction>(StartupTask_GetAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_current_package_async", reinterpret_cast<PyCFunction>(StartupTask_GetForCurrentPackageAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "request_enable_async", reinterpret_cast<PyCFunction>(StartupTask_RequestEnableAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StartupTask, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StartupTask), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StartupTask[] = {
        { "state", reinterpret_cast<getter>(StartupTask_get_State), nullptr, nullptr, nullptr },
        { "task_id", reinterpret_cast<getter>(StartupTask_get_TaskId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StartupTask[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StartupTask) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StartupTask) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StartupTask) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StartupTask) },
        { },
    };

    static PyType_Spec type_spec_StartupTask =
    {
        "_winsdk_Windows_ApplicationModel.StartupTask",
        sizeof(py::wrapper::Windows::ApplicationModel::StartupTask),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StartupTask
    };

    // ----- SuspendingDeferral class --------------------
    static constexpr const char* const type_name_SuspendingDeferral = "SuspendingDeferral";

    static PyObject* _new_SuspendingDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SuspendingDeferral);
        return nullptr;
    }

    static void _dealloc_SuspendingDeferral(py::wrapper::Windows::ApplicationModel::SuspendingDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SuspendingDeferral_Complete(py::wrapper::Windows::ApplicationModel::SuspendingDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.SuspendingDeferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SuspendingDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::SuspendingDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SuspendingDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::SuspendingDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SuspendingDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(SuspendingDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SuspendingDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SuspendingDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SuspendingDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_SuspendingDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SuspendingDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SuspendingDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SuspendingDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SuspendingDeferral) },
        { },
    };

    static PyType_Spec type_spec_SuspendingDeferral =
    {
        "_winsdk_Windows_ApplicationModel.SuspendingDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::SuspendingDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SuspendingDeferral
    };

    // ----- SuspendingEventArgs class --------------------
    static constexpr const char* const type_name_SuspendingEventArgs = "SuspendingEventArgs";

    static PyObject* _new_SuspendingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SuspendingEventArgs);
        return nullptr;
    }

    static void _dealloc_SuspendingEventArgs(py::wrapper::Windows::ApplicationModel::SuspendingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SuspendingEventArgs_get_SuspendingOperation(py::wrapper::Windows::ApplicationModel::SuspendingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.SuspendingEventArgs", L"SuspendingOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SuspendingOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SuspendingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::SuspendingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SuspendingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::SuspendingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SuspendingEventArgs[] = {
        { "_assign_array_", _assign_array_SuspendingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SuspendingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SuspendingEventArgs[] = {
        { "suspending_operation", reinterpret_cast<getter>(SuspendingEventArgs_get_SuspendingOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SuspendingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SuspendingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SuspendingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SuspendingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SuspendingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SuspendingEventArgs =
    {
        "_winsdk_Windows_ApplicationModel.SuspendingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::SuspendingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SuspendingEventArgs
    };

    // ----- SuspendingOperation class --------------------
    static constexpr const char* const type_name_SuspendingOperation = "SuspendingOperation";

    static PyObject* _new_SuspendingOperation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SuspendingOperation);
        return nullptr;
    }

    static void _dealloc_SuspendingOperation(py::wrapper::Windows::ApplicationModel::SuspendingOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SuspendingOperation_GetDeferral(py::wrapper::Windows::ApplicationModel::SuspendingOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.SuspendingOperation", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SuspendingOperation_get_Deadline(py::wrapper::Windows::ApplicationModel::SuspendingOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.SuspendingOperation", L"Deadline"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Deadline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SuspendingOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::SuspendingOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SuspendingOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::SuspendingOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SuspendingOperation[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(SuspendingOperation_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SuspendingOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SuspendingOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SuspendingOperation[] = {
        { "deadline", reinterpret_cast<getter>(SuspendingOperation_get_Deadline), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SuspendingOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SuspendingOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SuspendingOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SuspendingOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SuspendingOperation) },
        { },
    };

    static PyType_Spec type_spec_SuspendingOperation =
    {
        "_winsdk_Windows_ApplicationModel.SuspendingOperation",
        sizeof(py::wrapper::Windows::ApplicationModel::SuspendingOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SuspendingOperation
    };

    // ----- IEnteredBackgroundEventArgs interface --------------------
    static constexpr const char* const type_name_IEnteredBackgroundEventArgs = "IEnteredBackgroundEventArgs";

    static PyObject* _new_IEnteredBackgroundEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IEnteredBackgroundEventArgs);
        return nullptr;
    }

    static void _dealloc_IEnteredBackgroundEventArgs(py::wrapper::Windows::ApplicationModel::IEnteredBackgroundEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IEnteredBackgroundEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::IEnteredBackgroundEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.IEnteredBackgroundEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IEnteredBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::IEnteredBackgroundEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IEnteredBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::IEnteredBackgroundEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IEnteredBackgroundEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(IEnteredBackgroundEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IEnteredBackgroundEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IEnteredBackgroundEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IEnteredBackgroundEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_IEnteredBackgroundEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IEnteredBackgroundEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IEnteredBackgroundEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IEnteredBackgroundEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IEnteredBackgroundEventArgs) },
        { },
    };

    static PyType_Spec type_spec_IEnteredBackgroundEventArgs =
    {
        "_winsdk_Windows_ApplicationModel.IEnteredBackgroundEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::IEnteredBackgroundEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IEnteredBackgroundEventArgs
    };

    // ----- ILeavingBackgroundEventArgs interface --------------------
    static constexpr const char* const type_name_ILeavingBackgroundEventArgs = "ILeavingBackgroundEventArgs";

    static PyObject* _new_ILeavingBackgroundEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_ILeavingBackgroundEventArgs);
        return nullptr;
    }

    static void _dealloc_ILeavingBackgroundEventArgs(py::wrapper::Windows::ApplicationModel::ILeavingBackgroundEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ILeavingBackgroundEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::ILeavingBackgroundEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ILeavingBackgroundEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ILeavingBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::ILeavingBackgroundEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ILeavingBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ILeavingBackgroundEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILeavingBackgroundEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(ILeavingBackgroundEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ILeavingBackgroundEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ILeavingBackgroundEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILeavingBackgroundEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ILeavingBackgroundEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ILeavingBackgroundEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ILeavingBackgroundEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ILeavingBackgroundEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ILeavingBackgroundEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ILeavingBackgroundEventArgs =
    {
        "_winsdk_Windows_ApplicationModel.ILeavingBackgroundEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::ILeavingBackgroundEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILeavingBackgroundEventArgs
    };

    // ----- IPackageCatalogStatics2 interface --------------------
    static constexpr const char* const type_name_IPackageCatalogStatics2 = "IPackageCatalogStatics2";

    static PyObject* _new_IPackageCatalogStatics2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IPackageCatalogStatics2);
        return nullptr;
    }

    static void _dealloc_IPackageCatalogStatics2(py::wrapper::Windows::ApplicationModel::IPackageCatalogStatics2* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPackageCatalogStatics2_OpenForPackage(py::wrapper::Windows::ApplicationModel::IPackageCatalogStatics2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.IPackageCatalogStatics2", L"OpenForPackage", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);

                return py::convert(self->obj.OpenForPackage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IPackageCatalogStatics2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::IPackageCatalogStatics2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPackageCatalogStatics2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::IPackageCatalogStatics2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPackageCatalogStatics2[] = {
        { "open_for_package", reinterpret_cast<PyCFunction>(IPackageCatalogStatics2_OpenForPackage), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IPackageCatalogStatics2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPackageCatalogStatics2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPackageCatalogStatics2[] = {
        { }
    };

    static PyType_Slot _type_slots_IPackageCatalogStatics2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPackageCatalogStatics2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPackageCatalogStatics2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPackageCatalogStatics2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPackageCatalogStatics2) },
        { },
    };

    static PyType_Spec type_spec_IPackageCatalogStatics2 =
    {
        "_winsdk_Windows_ApplicationModel.IPackageCatalogStatics2",
        sizeof(py::wrapper::Windows::ApplicationModel::IPackageCatalogStatics2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPackageCatalogStatics2
    };

    // ----- ISuspendingDeferral interface --------------------
    static constexpr const char* const type_name_ISuspendingDeferral = "ISuspendingDeferral";

    static PyObject* _new_ISuspendingDeferral(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_ISuspendingDeferral);
        return nullptr;
    }

    static void _dealloc_ISuspendingDeferral(py::wrapper::Windows::ApplicationModel::ISuspendingDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISuspendingDeferral_Complete(py::wrapper::Windows::ApplicationModel::ISuspendingDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ISuspendingDeferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ISuspendingDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::ISuspendingDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISuspendingDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ISuspendingDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISuspendingDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(ISuspendingDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ISuspendingDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISuspendingDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISuspendingDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_ISuspendingDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISuspendingDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISuspendingDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISuspendingDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISuspendingDeferral) },
        { },
    };

    static PyType_Spec type_spec_ISuspendingDeferral =
    {
        "_winsdk_Windows_ApplicationModel.ISuspendingDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::ISuspendingDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISuspendingDeferral
    };

    // ----- ISuspendingEventArgs interface --------------------
    static constexpr const char* const type_name_ISuspendingEventArgs = "ISuspendingEventArgs";

    static PyObject* _new_ISuspendingEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_ISuspendingEventArgs);
        return nullptr;
    }

    static void _dealloc_ISuspendingEventArgs(py::wrapper::Windows::ApplicationModel::ISuspendingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISuspendingEventArgs_get_SuspendingOperation(py::wrapper::Windows::ApplicationModel::ISuspendingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ISuspendingEventArgs", L"SuspendingOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SuspendingOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ISuspendingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::ISuspendingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISuspendingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ISuspendingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISuspendingEventArgs[] = {
        { "_assign_array_", _assign_array_ISuspendingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISuspendingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISuspendingEventArgs[] = {
        { "suspending_operation", reinterpret_cast<getter>(ISuspendingEventArgs_get_SuspendingOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISuspendingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISuspendingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISuspendingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISuspendingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISuspendingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ISuspendingEventArgs =
    {
        "_winsdk_Windows_ApplicationModel.ISuspendingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::ISuspendingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISuspendingEventArgs
    };

    // ----- ISuspendingOperation interface --------------------
    static constexpr const char* const type_name_ISuspendingOperation = "ISuspendingOperation";

    static PyObject* _new_ISuspendingOperation(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_ISuspendingOperation);
        return nullptr;
    }

    static void _dealloc_ISuspendingOperation(py::wrapper::Windows::ApplicationModel::ISuspendingOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISuspendingOperation_GetDeferral(py::wrapper::Windows::ApplicationModel::ISuspendingOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ISuspendingOperation", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISuspendingOperation_get_Deadline(py::wrapper::Windows::ApplicationModel::ISuspendingOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ISuspendingOperation", L"Deadline"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Deadline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ISuspendingOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::ISuspendingOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISuspendingOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ISuspendingOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISuspendingOperation[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(ISuspendingOperation_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ISuspendingOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISuspendingOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISuspendingOperation[] = {
        { "deadline", reinterpret_cast<getter>(ISuspendingOperation_get_Deadline), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISuspendingOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISuspendingOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISuspendingOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISuspendingOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISuspendingOperation) },
        { },
    };

    static PyType_Spec type_spec_ISuspendingOperation =
    {
        "_winsdk_Windows_ApplicationModel.ISuspendingOperation",
        sizeof(py::wrapper::Windows::ApplicationModel::ISuspendingOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISuspendingOperation
    };

    // ----- PackageInstallProgress struct --------------------
    static constexpr const char* const type_name_PackageInstallProgress = "PackageInstallProgress";

    PyObject* _new_PackageInstallProgress(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::ApplicationModel::PackageInstallProgress return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        uint32_t _PercentComplete{};

        static const char* kwlist[] = {"percent_complete", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "I", const_cast<char**>(kwlist), &_PercentComplete))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::ApplicationModel::PackageInstallProgress return_value{ _PercentComplete };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_PackageInstallProgress(py::wrapper::Windows::ApplicationModel::PackageInstallProgress* self) noexcept
    {
    }

    static PyObject* PackageInstallProgress_get_PercentComplete(py::wrapper::Windows::ApplicationModel::PackageInstallProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PercentComplete);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageInstallProgress_set_PercentComplete(py::wrapper::Windows::ApplicationModel::PackageInstallProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PercentComplete = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_PackageInstallProgress[] = {
        { "percent_complete", reinterpret_cast<getter>(PackageInstallProgress_get_PercentComplete), reinterpret_cast<setter>(PackageInstallProgress_set_PercentComplete), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageInstallProgress[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageInstallProgress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageInstallProgress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageInstallProgress) },
        { },
    };

    static PyType_Spec type_spec_PackageInstallProgress =
    {
        "_winsdk_Windows_ApplicationModel.PackageInstallProgress",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageInstallProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageInstallProgress
    };

    // ----- PackageVersion struct --------------------
    static constexpr const char* const type_name_PackageVersion = "PackageVersion";

    PyObject* _new_PackageVersion(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::ApplicationModel::PackageVersion return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        uint16_t _Major{};
        uint16_t _Minor{};
        uint16_t _Build{};
        uint16_t _Revision{};

        static const char* kwlist[] = {"major", "minor", "build", "revision", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "HHHH", const_cast<char**>(kwlist), &_Major, &_Minor, &_Build, &_Revision))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::ApplicationModel::PackageVersion return_value{ _Major, _Minor, _Build, _Revision };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_PackageVersion(py::wrapper::Windows::ApplicationModel::PackageVersion* self) noexcept
    {
    }

    static PyObject* PackageVersion_get_Major(py::wrapper::Windows::ApplicationModel::PackageVersion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Major);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageVersion_set_Major(py::wrapper::Windows::ApplicationModel::PackageVersion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Major = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PackageVersion_get_Minor(py::wrapper::Windows::ApplicationModel::PackageVersion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Minor);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageVersion_set_Minor(py::wrapper::Windows::ApplicationModel::PackageVersion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Minor = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PackageVersion_get_Build(py::wrapper::Windows::ApplicationModel::PackageVersion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Build);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageVersion_set_Build(py::wrapper::Windows::ApplicationModel::PackageVersion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Build = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PackageVersion_get_Revision(py::wrapper::Windows::ApplicationModel::PackageVersion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Revision);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageVersion_set_Revision(py::wrapper::Windows::ApplicationModel::PackageVersion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Revision = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_PackageVersion[] = {
        { "major", reinterpret_cast<getter>(PackageVersion_get_Major), reinterpret_cast<setter>(PackageVersion_set_Major), nullptr, nullptr },
        { "minor", reinterpret_cast<getter>(PackageVersion_get_Minor), reinterpret_cast<setter>(PackageVersion_set_Minor), nullptr, nullptr },
        { "build", reinterpret_cast<getter>(PackageVersion_get_Build), reinterpret_cast<setter>(PackageVersion_set_Build), nullptr, nullptr },
        { "revision", reinterpret_cast<getter>(PackageVersion_get_Revision), reinterpret_cast<setter>(PackageVersion_set_Revision), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageVersion[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageVersion) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageVersion) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageVersion) },
        { },
    };

    static PyType_Spec type_spec_PackageVersion =
    {
        "_winsdk_Windows_ApplicationModel.PackageVersion",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageVersion),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageVersion
    };

    // ----- Windows.ApplicationModel Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::ApplicationModel");

    static PyMethodDef module_methods[] = {
        {"_register_AddResourcePackageOptions", register_AddResourcePackageOptions, METH_O, "registers type"},
        {"_register_AppExecutionContext", register_AppExecutionContext, METH_O, "registers type"},
        {"_register_AppInstallerPolicySource", register_AppInstallerPolicySource, METH_O, "registers type"},
        {"_register_FullTrustLaunchResult", register_FullTrustLaunchResult, METH_O, "registers type"},
        {"_register_LimitedAccessFeatureStatus", register_LimitedAccessFeatureStatus, METH_O, "registers type"},
        {"_register_PackageContentGroupState", register_PackageContentGroupState, METH_O, "registers type"},
        {"_register_PackageRelationship", register_PackageRelationship, METH_O, "registers type"},
        {"_register_PackageSignatureKind", register_PackageSignatureKind, METH_O, "registers type"},
        {"_register_PackageUpdateAvailability", register_PackageUpdateAvailability, METH_O, "registers type"},
        {"_register_StartupTaskState", register_StartupTaskState, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_AddResourcePackageOptions);
        Py_VISIT(state->type_AppExecutionContext);
        Py_VISIT(state->type_AppInstallerPolicySource);
        Py_VISIT(state->type_FullTrustLaunchResult);
        Py_VISIT(state->type_LimitedAccessFeatureStatus);
        Py_VISIT(state->type_PackageContentGroupState);
        Py_VISIT(state->type_PackageRelationship);
        Py_VISIT(state->type_PackageSignatureKind);
        Py_VISIT(state->type_PackageUpdateAvailability);
        Py_VISIT(state->type_StartupTaskState);
        Py_VISIT(state->type_AppDisplayInfo);
        Py_VISIT(state->type_AppInfo);
        Py_VISIT(state->type_AppInstallerInfo);
        Py_VISIT(state->type_AppInstance);
        Py_VISIT(state->type_CameraApplicationManager);
        Py_VISIT(state->type_DesignMode);
        Py_VISIT(state->type_EnteredBackgroundEventArgs);
        Py_VISIT(state->type_FindRelatedPackagesOptions);
        Py_VISIT(state->type_FullTrustProcessLaunchResult);
        Py_VISIT(state->type_FullTrustProcessLauncher);
        Py_VISIT(state->type_LeavingBackgroundEventArgs);
        Py_VISIT(state->type_LimitedAccessFeatureRequestResult);
        Py_VISIT(state->type_LimitedAccessFeatures);
        Py_VISIT(state->type_Package);
        Py_VISIT(state->type_PackageCatalog);
        Py_VISIT(state->type_PackageCatalogAddOptionalPackageResult);
        Py_VISIT(state->type_PackageCatalogAddResourcePackageResult);
        Py_VISIT(state->type_PackageCatalogRemoveOptionalPackagesResult);
        Py_VISIT(state->type_PackageCatalogRemoveResourcePackagesResult);
        Py_VISIT(state->type_PackageContentGroup);
        Py_VISIT(state->type_PackageContentGroupStagingEventArgs);
        Py_VISIT(state->type_PackageId);
        Py_VISIT(state->type_PackageInstallingEventArgs);
        Py_VISIT(state->type_PackageStagingEventArgs);
        Py_VISIT(state->type_PackageStatus);
        Py_VISIT(state->type_PackageStatusChangedEventArgs);
        Py_VISIT(state->type_PackageUninstallingEventArgs);
        Py_VISIT(state->type_PackageUpdateAvailabilityResult);
        Py_VISIT(state->type_PackageUpdatingEventArgs);
        Py_VISIT(state->type_StartupTask);
        Py_VISIT(state->type_SuspendingDeferral);
        Py_VISIT(state->type_SuspendingEventArgs);
        Py_VISIT(state->type_SuspendingOperation);
        Py_VISIT(state->type_IEnteredBackgroundEventArgs);
        Py_VISIT(state->type_ILeavingBackgroundEventArgs);
        Py_VISIT(state->type_IPackageCatalogStatics2);
        Py_VISIT(state->type_ISuspendingDeferral);
        Py_VISIT(state->type_ISuspendingEventArgs);
        Py_VISIT(state->type_ISuspendingOperation);
        Py_VISIT(state->type_PackageInstallProgress);
        Py_VISIT(state->type_PackageVersion);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_AddResourcePackageOptions);
        Py_CLEAR(state->type_AppExecutionContext);
        Py_CLEAR(state->type_AppInstallerPolicySource);
        Py_CLEAR(state->type_FullTrustLaunchResult);
        Py_CLEAR(state->type_LimitedAccessFeatureStatus);
        Py_CLEAR(state->type_PackageContentGroupState);
        Py_CLEAR(state->type_PackageRelationship);
        Py_CLEAR(state->type_PackageSignatureKind);
        Py_CLEAR(state->type_PackageUpdateAvailability);
        Py_CLEAR(state->type_StartupTaskState);
        Py_CLEAR(state->type_AppDisplayInfo);
        Py_CLEAR(state->type_AppInfo);
        Py_CLEAR(state->type_AppInstallerInfo);
        Py_CLEAR(state->type_AppInstance);
        Py_CLEAR(state->type_CameraApplicationManager);
        Py_CLEAR(state->type_DesignMode);
        Py_CLEAR(state->type_EnteredBackgroundEventArgs);
        Py_CLEAR(state->type_FindRelatedPackagesOptions);
        Py_CLEAR(state->type_FullTrustProcessLaunchResult);
        Py_CLEAR(state->type_FullTrustProcessLauncher);
        Py_CLEAR(state->type_LeavingBackgroundEventArgs);
        Py_CLEAR(state->type_LimitedAccessFeatureRequestResult);
        Py_CLEAR(state->type_LimitedAccessFeatures);
        Py_CLEAR(state->type_Package);
        Py_CLEAR(state->type_PackageCatalog);
        Py_CLEAR(state->type_PackageCatalogAddOptionalPackageResult);
        Py_CLEAR(state->type_PackageCatalogAddResourcePackageResult);
        Py_CLEAR(state->type_PackageCatalogRemoveOptionalPackagesResult);
        Py_CLEAR(state->type_PackageCatalogRemoveResourcePackagesResult);
        Py_CLEAR(state->type_PackageContentGroup);
        Py_CLEAR(state->type_PackageContentGroupStagingEventArgs);
        Py_CLEAR(state->type_PackageId);
        Py_CLEAR(state->type_PackageInstallingEventArgs);
        Py_CLEAR(state->type_PackageStagingEventArgs);
        Py_CLEAR(state->type_PackageStatus);
        Py_CLEAR(state->type_PackageStatusChangedEventArgs);
        Py_CLEAR(state->type_PackageUninstallingEventArgs);
        Py_CLEAR(state->type_PackageUpdateAvailabilityResult);
        Py_CLEAR(state->type_PackageUpdatingEventArgs);
        Py_CLEAR(state->type_StartupTask);
        Py_CLEAR(state->type_SuspendingDeferral);
        Py_CLEAR(state->type_SuspendingEventArgs);
        Py_CLEAR(state->type_SuspendingOperation);
        Py_CLEAR(state->type_IEnteredBackgroundEventArgs);
        Py_CLEAR(state->type_ILeavingBackgroundEventArgs);
        Py_CLEAR(state->type_IPackageCatalogStatics2);
        Py_CLEAR(state->type_ISuspendingDeferral);
        Py_CLEAR(state->type_ISuspendingEventArgs);
        Py_CLEAR(state->type_ISuspendingOperation);
        Py_CLEAR(state->type_PackageInstallProgress);
        Py_CLEAR(state->type_PackageVersion);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_ApplicationModel",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::ApplicationModel

PyMODINIT_FUNC PyInit__winsdk_Windows_ApplicationModel(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_AppDisplayInfo = py::register_python_type(module.get(), type_name_AppDisplayInfo, &type_spec_AppDisplayInfo, bases.get(), nullptr);
    if (!state->type_AppDisplayInfo)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppInfo_Meta{PyType_FromSpec(&type_spec_AppInfo_Meta)};
    if (!type_AppInfo_Meta)
    {
        return nullptr;
    }

    state->type_AppInfo = py::register_python_type(module.get(), type_name_AppInfo, &type_spec_AppInfo, bases.get(), reinterpret_cast<PyTypeObject*>(type_AppInfo_Meta.get()));
    if (!state->type_AppInfo)
    {
        return nullptr;
    }

    state->type_AppInstallerInfo = py::register_python_type(module.get(), type_name_AppInstallerInfo, &type_spec_AppInstallerInfo, bases.get(), nullptr);
    if (!state->type_AppInstallerInfo)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppInstance_Meta{PyType_FromSpec(&type_spec_AppInstance_Meta)};
    if (!type_AppInstance_Meta)
    {
        return nullptr;
    }

    state->type_AppInstance = py::register_python_type(module.get(), type_name_AppInstance, &type_spec_AppInstance, bases.get(), reinterpret_cast<PyTypeObject*>(type_AppInstance_Meta.get()));
    if (!state->type_AppInstance)
    {
        return nullptr;
    }

    state->type_CameraApplicationManager = py::register_python_type(module.get(), type_name_CameraApplicationManager, &type_spec_CameraApplicationManager, nullptr, nullptr);
    if (!state->type_CameraApplicationManager)
    {
        return nullptr;
    }

    py::pyobj_handle type_DesignMode_Meta{PyType_FromSpec(&type_spec_DesignMode_Meta)};
    if (!type_DesignMode_Meta)
    {
        return nullptr;
    }

    state->type_DesignMode = py::register_python_type(module.get(), type_name_DesignMode, &type_spec_DesignMode, nullptr, reinterpret_cast<PyTypeObject*>(type_DesignMode_Meta.get()));
    if (!state->type_DesignMode)
    {
        return nullptr;
    }

    state->type_EnteredBackgroundEventArgs = py::register_python_type(module.get(), type_name_EnteredBackgroundEventArgs, &type_spec_EnteredBackgroundEventArgs, bases.get(), nullptr);
    if (!state->type_EnteredBackgroundEventArgs)
    {
        return nullptr;
    }

    state->type_FindRelatedPackagesOptions = py::register_python_type(module.get(), type_name_FindRelatedPackagesOptions, &type_spec_FindRelatedPackagesOptions, bases.get(), nullptr);
    if (!state->type_FindRelatedPackagesOptions)
    {
        return nullptr;
    }

    state->type_FullTrustProcessLaunchResult = py::register_python_type(module.get(), type_name_FullTrustProcessLaunchResult, &type_spec_FullTrustProcessLaunchResult, bases.get(), nullptr);
    if (!state->type_FullTrustProcessLaunchResult)
    {
        return nullptr;
    }

    state->type_FullTrustProcessLauncher = py::register_python_type(module.get(), type_name_FullTrustProcessLauncher, &type_spec_FullTrustProcessLauncher, nullptr, nullptr);
    if (!state->type_FullTrustProcessLauncher)
    {
        return nullptr;
    }

    state->type_LeavingBackgroundEventArgs = py::register_python_type(module.get(), type_name_LeavingBackgroundEventArgs, &type_spec_LeavingBackgroundEventArgs, bases.get(), nullptr);
    if (!state->type_LeavingBackgroundEventArgs)
    {
        return nullptr;
    }

    state->type_LimitedAccessFeatureRequestResult = py::register_python_type(module.get(), type_name_LimitedAccessFeatureRequestResult, &type_spec_LimitedAccessFeatureRequestResult, bases.get(), nullptr);
    if (!state->type_LimitedAccessFeatureRequestResult)
    {
        return nullptr;
    }

    state->type_LimitedAccessFeatures = py::register_python_type(module.get(), type_name_LimitedAccessFeatures, &type_spec_LimitedAccessFeatures, nullptr, nullptr);
    if (!state->type_LimitedAccessFeatures)
    {
        return nullptr;
    }

    py::pyobj_handle type_Package_Meta{PyType_FromSpec(&type_spec_Package_Meta)};
    if (!type_Package_Meta)
    {
        return nullptr;
    }

    state->type_Package = py::register_python_type(module.get(), type_name_Package, &type_spec_Package, bases.get(), reinterpret_cast<PyTypeObject*>(type_Package_Meta.get()));
    if (!state->type_Package)
    {
        return nullptr;
    }

    state->type_PackageCatalog = py::register_python_type(module.get(), type_name_PackageCatalog, &type_spec_PackageCatalog, bases.get(), nullptr);
    if (!state->type_PackageCatalog)
    {
        return nullptr;
    }

    state->type_PackageCatalogAddOptionalPackageResult = py::register_python_type(module.get(), type_name_PackageCatalogAddOptionalPackageResult, &type_spec_PackageCatalogAddOptionalPackageResult, bases.get(), nullptr);
    if (!state->type_PackageCatalogAddOptionalPackageResult)
    {
        return nullptr;
    }

    state->type_PackageCatalogAddResourcePackageResult = py::register_python_type(module.get(), type_name_PackageCatalogAddResourcePackageResult, &type_spec_PackageCatalogAddResourcePackageResult, bases.get(), nullptr);
    if (!state->type_PackageCatalogAddResourcePackageResult)
    {
        return nullptr;
    }

    state->type_PackageCatalogRemoveOptionalPackagesResult = py::register_python_type(module.get(), type_name_PackageCatalogRemoveOptionalPackagesResult, &type_spec_PackageCatalogRemoveOptionalPackagesResult, bases.get(), nullptr);
    if (!state->type_PackageCatalogRemoveOptionalPackagesResult)
    {
        return nullptr;
    }

    state->type_PackageCatalogRemoveResourcePackagesResult = py::register_python_type(module.get(), type_name_PackageCatalogRemoveResourcePackagesResult, &type_spec_PackageCatalogRemoveResourcePackagesResult, bases.get(), nullptr);
    if (!state->type_PackageCatalogRemoveResourcePackagesResult)
    {
        return nullptr;
    }

    py::pyobj_handle type_PackageContentGroup_Meta{PyType_FromSpec(&type_spec_PackageContentGroup_Meta)};
    if (!type_PackageContentGroup_Meta)
    {
        return nullptr;
    }

    state->type_PackageContentGroup = py::register_python_type(module.get(), type_name_PackageContentGroup, &type_spec_PackageContentGroup, bases.get(), reinterpret_cast<PyTypeObject*>(type_PackageContentGroup_Meta.get()));
    if (!state->type_PackageContentGroup)
    {
        return nullptr;
    }

    state->type_PackageContentGroupStagingEventArgs = py::register_python_type(module.get(), type_name_PackageContentGroupStagingEventArgs, &type_spec_PackageContentGroupStagingEventArgs, bases.get(), nullptr);
    if (!state->type_PackageContentGroupStagingEventArgs)
    {
        return nullptr;
    }

    state->type_PackageId = py::register_python_type(module.get(), type_name_PackageId, &type_spec_PackageId, bases.get(), nullptr);
    if (!state->type_PackageId)
    {
        return nullptr;
    }

    state->type_PackageInstallingEventArgs = py::register_python_type(module.get(), type_name_PackageInstallingEventArgs, &type_spec_PackageInstallingEventArgs, bases.get(), nullptr);
    if (!state->type_PackageInstallingEventArgs)
    {
        return nullptr;
    }

    state->type_PackageStagingEventArgs = py::register_python_type(module.get(), type_name_PackageStagingEventArgs, &type_spec_PackageStagingEventArgs, bases.get(), nullptr);
    if (!state->type_PackageStagingEventArgs)
    {
        return nullptr;
    }

    state->type_PackageStatus = py::register_python_type(module.get(), type_name_PackageStatus, &type_spec_PackageStatus, bases.get(), nullptr);
    if (!state->type_PackageStatus)
    {
        return nullptr;
    }

    state->type_PackageStatusChangedEventArgs = py::register_python_type(module.get(), type_name_PackageStatusChangedEventArgs, &type_spec_PackageStatusChangedEventArgs, bases.get(), nullptr);
    if (!state->type_PackageStatusChangedEventArgs)
    {
        return nullptr;
    }

    state->type_PackageUninstallingEventArgs = py::register_python_type(module.get(), type_name_PackageUninstallingEventArgs, &type_spec_PackageUninstallingEventArgs, bases.get(), nullptr);
    if (!state->type_PackageUninstallingEventArgs)
    {
        return nullptr;
    }

    state->type_PackageUpdateAvailabilityResult = py::register_python_type(module.get(), type_name_PackageUpdateAvailabilityResult, &type_spec_PackageUpdateAvailabilityResult, bases.get(), nullptr);
    if (!state->type_PackageUpdateAvailabilityResult)
    {
        return nullptr;
    }

    state->type_PackageUpdatingEventArgs = py::register_python_type(module.get(), type_name_PackageUpdatingEventArgs, &type_spec_PackageUpdatingEventArgs, bases.get(), nullptr);
    if (!state->type_PackageUpdatingEventArgs)
    {
        return nullptr;
    }

    state->type_StartupTask = py::register_python_type(module.get(), type_name_StartupTask, &type_spec_StartupTask, bases.get(), nullptr);
    if (!state->type_StartupTask)
    {
        return nullptr;
    }

    state->type_SuspendingDeferral = py::register_python_type(module.get(), type_name_SuspendingDeferral, &type_spec_SuspendingDeferral, bases.get(), nullptr);
    if (!state->type_SuspendingDeferral)
    {
        return nullptr;
    }

    state->type_SuspendingEventArgs = py::register_python_type(module.get(), type_name_SuspendingEventArgs, &type_spec_SuspendingEventArgs, bases.get(), nullptr);
    if (!state->type_SuspendingEventArgs)
    {
        return nullptr;
    }

    state->type_SuspendingOperation = py::register_python_type(module.get(), type_name_SuspendingOperation, &type_spec_SuspendingOperation, bases.get(), nullptr);
    if (!state->type_SuspendingOperation)
    {
        return nullptr;
    }

    state->type_IEnteredBackgroundEventArgs = py::register_python_type(module.get(), type_name_IEnteredBackgroundEventArgs, &type_spec_IEnteredBackgroundEventArgs, bases.get(), nullptr);
    if (!state->type_IEnteredBackgroundEventArgs)
    {
        return nullptr;
    }

    state->type_ILeavingBackgroundEventArgs = py::register_python_type(module.get(), type_name_ILeavingBackgroundEventArgs, &type_spec_ILeavingBackgroundEventArgs, bases.get(), nullptr);
    if (!state->type_ILeavingBackgroundEventArgs)
    {
        return nullptr;
    }

    state->type_IPackageCatalogStatics2 = py::register_python_type(module.get(), type_name_IPackageCatalogStatics2, &type_spec_IPackageCatalogStatics2, bases.get(), nullptr);
    if (!state->type_IPackageCatalogStatics2)
    {
        return nullptr;
    }

    state->type_ISuspendingDeferral = py::register_python_type(module.get(), type_name_ISuspendingDeferral, &type_spec_ISuspendingDeferral, bases.get(), nullptr);
    if (!state->type_ISuspendingDeferral)
    {
        return nullptr;
    }

    state->type_ISuspendingEventArgs = py::register_python_type(module.get(), type_name_ISuspendingEventArgs, &type_spec_ISuspendingEventArgs, bases.get(), nullptr);
    if (!state->type_ISuspendingEventArgs)
    {
        return nullptr;
    }

    state->type_ISuspendingOperation = py::register_python_type(module.get(), type_name_ISuspendingOperation, &type_spec_ISuspendingOperation, bases.get(), nullptr);
    if (!state->type_ISuspendingOperation)
    {
        return nullptr;
    }

    state->type_PackageInstallProgress = py::register_python_type(module.get(), type_name_PackageInstallProgress, &type_spec_PackageInstallProgress, bases.get(), nullptr);
    if (!state->type_PackageInstallProgress)
    {
        return nullptr;
    }

    state->type_PackageVersion = py::register_python_type(module.get(), type_name_PackageVersion, &type_spec_PackageVersion, bases.get(), nullptr);
    if (!state->type_PackageVersion)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::AddResourcePackageOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AddResourcePackageOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::AddResourcePackageOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::AppExecutionContext>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppExecutionContext;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::AppExecutionContext is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::AppInstallerPolicySource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppInstallerPolicySource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::AppInstallerPolicySource is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::FullTrustLaunchResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FullTrustLaunchResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::FullTrustLaunchResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::LimitedAccessFeatureStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LimitedAccessFeatureStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::LimitedAccessFeatureStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::PackageContentGroupState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PackageContentGroupState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::PackageContentGroupState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::PackageRelationship>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PackageRelationship;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::PackageRelationship is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::PackageSignatureKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PackageSignatureKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::PackageSignatureKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::PackageUpdateAvailability>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PackageUpdateAvailability;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::PackageUpdateAvailability is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::StartupTaskState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StartupTaskState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::StartupTaskState is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::AppDisplayInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppDisplayInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::AppDisplayInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::AppInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::AppInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::AppInstallerInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppInstallerInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::AppInstallerInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::AppInstance>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppInstance;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::AppInstance is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::CameraApplicationManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CameraApplicationManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::CameraApplicationManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DesignMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DesignMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::DesignMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::EnteredBackgroundEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EnteredBackgroundEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::EnteredBackgroundEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::FindRelatedPackagesOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FindRelatedPackagesOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::FindRelatedPackagesOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::FullTrustProcessLaunchResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FullTrustProcessLaunchResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::FullTrustProcessLaunchResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::FullTrustProcessLauncher>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FullTrustProcessLauncher;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::FullTrustProcessLauncher is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::LeavingBackgroundEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LeavingBackgroundEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::LeavingBackgroundEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::LimitedAccessFeatureRequestResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LimitedAccessFeatureRequestResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::LimitedAccessFeatureRequestResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::LimitedAccessFeatures>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LimitedAccessFeatures;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::LimitedAccessFeatures is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Package>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Package;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Package is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageCatalog>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PackageCatalog;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::PackageCatalog is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PackageCatalogAddOptionalPackageResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PackageCatalogAddResourcePackageResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PackageCatalogRemoveOptionalPackagesResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PackageCatalogRemoveResourcePackagesResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageContentGroup>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PackageContentGroup;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::PackageContentGroup is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageContentGroupStagingEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PackageContentGroupStagingEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::PackageContentGroupStagingEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageId>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PackageId;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::PackageId is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageInstallingEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PackageInstallingEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::PackageInstallingEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageStagingEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PackageStagingEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::PackageStagingEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PackageStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::PackageStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageStatusChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PackageStatusChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::PackageStatusChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageUninstallingEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PackageUninstallingEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::PackageUninstallingEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageUpdateAvailabilityResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PackageUpdateAvailabilityResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::PackageUpdateAvailabilityResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageUpdatingEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PackageUpdatingEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::PackageUpdatingEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::StartupTask>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StartupTask;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::StartupTask is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::SuspendingDeferral>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SuspendingDeferral;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::SuspendingDeferral is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::SuspendingEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SuspendingEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::SuspendingEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::SuspendingOperation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SuspendingOperation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::SuspendingOperation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::IEnteredBackgroundEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IEnteredBackgroundEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::IEnteredBackgroundEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ILeavingBackgroundEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ILeavingBackgroundEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ILeavingBackgroundEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::IPackageCatalogStatics2>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IPackageCatalogStatics2;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::IPackageCatalogStatics2 is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ISuspendingDeferral>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ISuspendingDeferral;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ISuspendingDeferral is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ISuspendingEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ISuspendingEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ISuspendingEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ISuspendingOperation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ISuspendingOperation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ISuspendingOperation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageInstallProgress>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PackageInstallProgress;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::PackageInstallProgress is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageVersion>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PackageVersion;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::PackageVersion is not registered");
        return nullptr;
    }

    return python_type;
}
