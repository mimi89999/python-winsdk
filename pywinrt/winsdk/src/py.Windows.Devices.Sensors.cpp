// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.Devices.Sensors.h"


namespace py::cpp::Windows::Devices::Sensors
{
    struct module_state
    {
        PyObject* type_AccelerometerReadingType;
        PyObject* type_ActivitySensorReadingConfidence;
        PyObject* type_ActivityType;
        PyObject* type_HumanEngagement;
        PyObject* type_HumanPresence;
        PyObject* type_MagnetometerAccuracy;
        PyObject* type_PedometerStepKind;
        PyObject* type_SensorOptimizationGoal;
        PyObject* type_SensorReadingType;
        PyObject* type_SensorType;
        PyObject* type_SimpleOrientation;
        PyTypeObject* type_Accelerometer;
        PyTypeObject* type_AccelerometerDataThreshold;
        PyTypeObject* type_AccelerometerReading;
        PyTypeObject* type_AccelerometerReadingChangedEventArgs;
        PyTypeObject* type_AccelerometerShakenEventArgs;
        PyTypeObject* type_ActivitySensor;
        PyTypeObject* type_ActivitySensorReading;
        PyTypeObject* type_ActivitySensorReadingChangeReport;
        PyTypeObject* type_ActivitySensorReadingChangedEventArgs;
        PyTypeObject* type_ActivitySensorTriggerDetails;
        PyTypeObject* type_Altimeter;
        PyTypeObject* type_AltimeterReading;
        PyTypeObject* type_AltimeterReadingChangedEventArgs;
        PyTypeObject* type_Barometer;
        PyTypeObject* type_BarometerDataThreshold;
        PyTypeObject* type_BarometerReading;
        PyTypeObject* type_BarometerReadingChangedEventArgs;
        PyTypeObject* type_Compass;
        PyTypeObject* type_CompassDataThreshold;
        PyTypeObject* type_CompassReading;
        PyTypeObject* type_CompassReadingChangedEventArgs;
        PyTypeObject* type_Gyrometer;
        PyTypeObject* type_GyrometerDataThreshold;
        PyTypeObject* type_GyrometerReading;
        PyTypeObject* type_GyrometerReadingChangedEventArgs;
        PyTypeObject* type_HingeAngleReading;
        PyTypeObject* type_HingeAngleSensor;
        PyTypeObject* type_HingeAngleSensorReadingChangedEventArgs;
        PyTypeObject* type_HumanPresenceFeatures;
        PyTypeObject* type_HumanPresenceSensor;
        PyTypeObject* type_HumanPresenceSensorReading;
        PyTypeObject* type_HumanPresenceSensorReadingChangedEventArgs;
        PyTypeObject* type_HumanPresenceSettings;
        PyTypeObject* type_Inclinometer;
        PyTypeObject* type_InclinometerDataThreshold;
        PyTypeObject* type_InclinometerReading;
        PyTypeObject* type_InclinometerReadingChangedEventArgs;
        PyTypeObject* type_LightSensor;
        PyTypeObject* type_LightSensorDataThreshold;
        PyTypeObject* type_LightSensorReading;
        PyTypeObject* type_LightSensorReadingChangedEventArgs;
        PyTypeObject* type_Magnetometer;
        PyTypeObject* type_MagnetometerDataThreshold;
        PyTypeObject* type_MagnetometerReading;
        PyTypeObject* type_MagnetometerReadingChangedEventArgs;
        PyTypeObject* type_OrientationSensor;
        PyTypeObject* type_OrientationSensorReading;
        PyTypeObject* type_OrientationSensorReadingChangedEventArgs;
        PyTypeObject* type_Pedometer;
        PyTypeObject* type_PedometerDataThreshold;
        PyTypeObject* type_PedometerReading;
        PyTypeObject* type_PedometerReadingChangedEventArgs;
        PyTypeObject* type_ProximitySensor;
        PyTypeObject* type_ProximitySensorDataThreshold;
        PyTypeObject* type_ProximitySensorDisplayOnOffController;
        PyTypeObject* type_ProximitySensorReading;
        PyTypeObject* type_ProximitySensorReadingChangedEventArgs;
        PyTypeObject* type_SensorDataThresholdTriggerDetails;
        PyTypeObject* type_SensorQuaternion;
        PyTypeObject* type_SensorRotationMatrix;
        PyTypeObject* type_SimpleOrientationSensor;
        PyTypeObject* type_SimpleOrientationSensorOrientationChangedEventArgs;
        PyTypeObject* type_ISensorDataThreshold;
    };

    static PyObject* register_AccelerometerReadingType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AccelerometerReadingType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AccelerometerReadingType = type;
        Py_INCREF(state->type_AccelerometerReadingType);


        Py_RETURN_NONE;
    }

    static PyObject* register_ActivitySensorReadingConfidence(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ActivitySensorReadingConfidence)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ActivitySensorReadingConfidence = type;
        Py_INCREF(state->type_ActivitySensorReadingConfidence);


        Py_RETURN_NONE;
    }

    static PyObject* register_ActivityType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ActivityType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ActivityType = type;
        Py_INCREF(state->type_ActivityType);


        Py_RETURN_NONE;
    }

    static PyObject* register_HumanEngagement(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_HumanEngagement)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_HumanEngagement = type;
        Py_INCREF(state->type_HumanEngagement);


        Py_RETURN_NONE;
    }

    static PyObject* register_HumanPresence(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_HumanPresence)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_HumanPresence = type;
        Py_INCREF(state->type_HumanPresence);


        Py_RETURN_NONE;
    }

    static PyObject* register_MagnetometerAccuracy(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MagnetometerAccuracy)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MagnetometerAccuracy = type;
        Py_INCREF(state->type_MagnetometerAccuracy);


        Py_RETURN_NONE;
    }

    static PyObject* register_PedometerStepKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PedometerStepKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PedometerStepKind = type;
        Py_INCREF(state->type_PedometerStepKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_SensorOptimizationGoal(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SensorOptimizationGoal)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SensorOptimizationGoal = type;
        Py_INCREF(state->type_SensorOptimizationGoal);


        Py_RETURN_NONE;
    }

    static PyObject* register_SensorReadingType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SensorReadingType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SensorReadingType = type;
        Py_INCREF(state->type_SensorReadingType);


        Py_RETURN_NONE;
    }

    static PyObject* register_SensorType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SensorType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SensorType = type;
        Py_INCREF(state->type_SensorType);


        Py_RETURN_NONE;
    }

    static PyObject* register_SimpleOrientation(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SimpleOrientation)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SimpleOrientation = type;
        Py_INCREF(state->type_SimpleOrientation);


        Py_RETURN_NONE;
    }

    // ----- Accelerometer class --------------------
    static constexpr const char* const type_name_Accelerometer = "Accelerometer";

    static PyObject* _new_Accelerometer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_Accelerometer);
        return nullptr;
    }

    static void _dealloc_Accelerometer(py::wrapper::Windows::Devices::Sensors::Accelerometer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Accelerometer_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Accelerometer", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Accelerometer::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Accelerometer_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Accelerometer", L"GetCurrentReading", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Accelerometer_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Accelerometer", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Accelerometer::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Accelerometer", L"GetDefault", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::AccelerometerReadingType>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Accelerometer::GetDefault(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Accelerometer_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Accelerometer", L"GetDeviceSelector", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::AccelerometerReadingType>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Accelerometer::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Accelerometer_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Accelerometer", L"ReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Accelerometer_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Accelerometer", L"ReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Accelerometer_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Accelerometer", L"MinimumReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Accelerometer_get_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Accelerometer", L"ReadingTransform"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReadingTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Accelerometer_put_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Accelerometer", L"ReadingTransform"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Display::DisplayOrientations>(arg);

            self->obj.ReadingTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Accelerometer_get_ReportLatency(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Accelerometer", L"ReportLatency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Accelerometer_put_ReportLatency(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Accelerometer", L"ReportLatency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportLatency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Accelerometer_get_MaxBatchSize(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Accelerometer", L"MaxBatchSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Accelerometer_get_ReadingType(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Accelerometer", L"ReadingType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReadingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Accelerometer_get_ReportThreshold(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Accelerometer", L"ReportThreshold"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportThreshold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Accelerometer_get_DeviceId(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Accelerometer", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Accelerometer_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Accelerometer", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Accelerometer, winrt::Windows::Devices::Sensors::AccelerometerReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Accelerometer_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Accelerometer", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Accelerometer_add_Shaken(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Accelerometer", L"Shaken"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Accelerometer, winrt::Windows::Devices::Sensors::AccelerometerShakenEventArgs>>(arg);

            return py::convert(self->obj.Shaken(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Accelerometer_remove_Shaken(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Accelerometer", L"Shaken"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Shaken(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Accelerometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::Accelerometer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Accelerometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::Accelerometer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Accelerometer[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(Accelerometer_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(Accelerometer_GetCurrentReading), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(Accelerometer_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(Accelerometer_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(Accelerometer_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(Accelerometer_remove_ReadingChanged), METH_O, nullptr },
        { "add_shaken", reinterpret_cast<PyCFunction>(Accelerometer_add_Shaken), METH_O, nullptr },
        { "remove_shaken", reinterpret_cast<PyCFunction>(Accelerometer_remove_Shaken), METH_O, nullptr },
        { "_assign_array_", _assign_array_Accelerometer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Accelerometer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Accelerometer[] = {
        { "report_interval", reinterpret_cast<getter>(Accelerometer_get_ReportInterval), reinterpret_cast<setter>(Accelerometer_put_ReportInterval), nullptr, nullptr },
        { "minimum_report_interval", reinterpret_cast<getter>(Accelerometer_get_MinimumReportInterval), nullptr, nullptr, nullptr },
        { "reading_transform", reinterpret_cast<getter>(Accelerometer_get_ReadingTransform), reinterpret_cast<setter>(Accelerometer_put_ReadingTransform), nullptr, nullptr },
        { "report_latency", reinterpret_cast<getter>(Accelerometer_get_ReportLatency), reinterpret_cast<setter>(Accelerometer_put_ReportLatency), nullptr, nullptr },
        { "max_batch_size", reinterpret_cast<getter>(Accelerometer_get_MaxBatchSize), nullptr, nullptr, nullptr },
        { "reading_type", reinterpret_cast<getter>(Accelerometer_get_ReadingType), nullptr, nullptr, nullptr },
        { "report_threshold", reinterpret_cast<getter>(Accelerometer_get_ReportThreshold), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(Accelerometer_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Accelerometer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Accelerometer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Accelerometer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Accelerometer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Accelerometer) },
        { },
    };

    static PyType_Spec type_spec_Accelerometer =
    {
        "_winsdk_Windows_Devices_Sensors.Accelerometer",
        sizeof(py::wrapper::Windows::Devices::Sensors::Accelerometer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Accelerometer
    };

    // ----- AccelerometerDataThreshold class --------------------
    static constexpr const char* const type_name_AccelerometerDataThreshold = "AccelerometerDataThreshold";

    static PyObject* _new_AccelerometerDataThreshold(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AccelerometerDataThreshold);
        return nullptr;
    }

    static void _dealloc_AccelerometerDataThreshold(py::wrapper::Windows::Devices::Sensors::AccelerometerDataThreshold* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AccelerometerDataThreshold_get_ZAxisInGForce(py::wrapper::Windows::Devices::Sensors::AccelerometerDataThreshold* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerDataThreshold", L"ZAxisInGForce"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZAxisInGForce());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AccelerometerDataThreshold_put_ZAxisInGForce(py::wrapper::Windows::Devices::Sensors::AccelerometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerDataThreshold", L"ZAxisInGForce"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ZAxisInGForce(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AccelerometerDataThreshold_get_YAxisInGForce(py::wrapper::Windows::Devices::Sensors::AccelerometerDataThreshold* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerDataThreshold", L"YAxisInGForce"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.YAxisInGForce());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AccelerometerDataThreshold_put_YAxisInGForce(py::wrapper::Windows::Devices::Sensors::AccelerometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerDataThreshold", L"YAxisInGForce"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.YAxisInGForce(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AccelerometerDataThreshold_get_XAxisInGForce(py::wrapper::Windows::Devices::Sensors::AccelerometerDataThreshold* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerDataThreshold", L"XAxisInGForce"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.XAxisInGForce());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AccelerometerDataThreshold_put_XAxisInGForce(py::wrapper::Windows::Devices::Sensors::AccelerometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerDataThreshold", L"XAxisInGForce"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.XAxisInGForce(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AccelerometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::AccelerometerDataThreshold>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AccelerometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::AccelerometerDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AccelerometerDataThreshold[] = {
        { "_assign_array_", _assign_array_AccelerometerDataThreshold, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AccelerometerDataThreshold), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AccelerometerDataThreshold[] = {
        { "z_axis_in_g_force", reinterpret_cast<getter>(AccelerometerDataThreshold_get_ZAxisInGForce), reinterpret_cast<setter>(AccelerometerDataThreshold_put_ZAxisInGForce), nullptr, nullptr },
        { "y_axis_in_g_force", reinterpret_cast<getter>(AccelerometerDataThreshold_get_YAxisInGForce), reinterpret_cast<setter>(AccelerometerDataThreshold_put_YAxisInGForce), nullptr, nullptr },
        { "x_axis_in_g_force", reinterpret_cast<getter>(AccelerometerDataThreshold_get_XAxisInGForce), reinterpret_cast<setter>(AccelerometerDataThreshold_put_XAxisInGForce), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AccelerometerDataThreshold[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AccelerometerDataThreshold) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AccelerometerDataThreshold) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AccelerometerDataThreshold) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AccelerometerDataThreshold) },
        { },
    };

    static PyType_Spec type_spec_AccelerometerDataThreshold =
    {
        "_winsdk_Windows_Devices_Sensors.AccelerometerDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::AccelerometerDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AccelerometerDataThreshold
    };

    // ----- AccelerometerReading class --------------------
    static constexpr const char* const type_name_AccelerometerReading = "AccelerometerReading";

    static PyObject* _new_AccelerometerReading(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AccelerometerReading);
        return nullptr;
    }

    static void _dealloc_AccelerometerReading(py::wrapper::Windows::Devices::Sensors::AccelerometerReading* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AccelerometerReading_get_AccelerationX(py::wrapper::Windows::Devices::Sensors::AccelerometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerReading", L"AccelerationX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccelerationX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccelerometerReading_get_AccelerationY(py::wrapper::Windows::Devices::Sensors::AccelerometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerReading", L"AccelerationY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccelerationY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccelerometerReading_get_AccelerationZ(py::wrapper::Windows::Devices::Sensors::AccelerometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerReading", L"AccelerationZ"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccelerationZ());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccelerometerReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::AccelerometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerReading", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccelerometerReading_get_PerformanceCount(py::wrapper::Windows::Devices::Sensors::AccelerometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerReading", L"PerformanceCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccelerometerReading_get_Properties(py::wrapper::Windows::Devices::Sensors::AccelerometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerReading", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AccelerometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::AccelerometerReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AccelerometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::AccelerometerReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AccelerometerReading[] = {
        { "_assign_array_", _assign_array_AccelerometerReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AccelerometerReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AccelerometerReading[] = {
        { "acceleration_x", reinterpret_cast<getter>(AccelerometerReading_get_AccelerationX), nullptr, nullptr, nullptr },
        { "acceleration_y", reinterpret_cast<getter>(AccelerometerReading_get_AccelerationY), nullptr, nullptr, nullptr },
        { "acceleration_z", reinterpret_cast<getter>(AccelerometerReading_get_AccelerationZ), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(AccelerometerReading_get_Timestamp), nullptr, nullptr, nullptr },
        { "performance_count", reinterpret_cast<getter>(AccelerometerReading_get_PerformanceCount), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(AccelerometerReading_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AccelerometerReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AccelerometerReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AccelerometerReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AccelerometerReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AccelerometerReading) },
        { },
    };

    static PyType_Spec type_spec_AccelerometerReading =
    {
        "_winsdk_Windows_Devices_Sensors.AccelerometerReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::AccelerometerReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AccelerometerReading
    };

    // ----- AccelerometerReadingChangedEventArgs class --------------------
    static constexpr const char* const type_name_AccelerometerReadingChangedEventArgs = "AccelerometerReadingChangedEventArgs";

    static PyObject* _new_AccelerometerReadingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AccelerometerReadingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_AccelerometerReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::AccelerometerReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AccelerometerReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::AccelerometerReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerReadingChangedEventArgs", L"Reading"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AccelerometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::AccelerometerReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AccelerometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::AccelerometerReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AccelerometerReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AccelerometerReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AccelerometerReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AccelerometerReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(AccelerometerReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AccelerometerReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AccelerometerReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AccelerometerReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AccelerometerReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AccelerometerReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AccelerometerReadingChangedEventArgs =
    {
        "_winsdk_Windows_Devices_Sensors.AccelerometerReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::AccelerometerReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AccelerometerReadingChangedEventArgs
    };

    // ----- AccelerometerShakenEventArgs class --------------------
    static constexpr const char* const type_name_AccelerometerShakenEventArgs = "AccelerometerShakenEventArgs";

    static PyObject* _new_AccelerometerShakenEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AccelerometerShakenEventArgs);
        return nullptr;
    }

    static void _dealloc_AccelerometerShakenEventArgs(py::wrapper::Windows::Devices::Sensors::AccelerometerShakenEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AccelerometerShakenEventArgs_get_Timestamp(py::wrapper::Windows::Devices::Sensors::AccelerometerShakenEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerShakenEventArgs", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AccelerometerShakenEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::AccelerometerShakenEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AccelerometerShakenEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::AccelerometerShakenEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AccelerometerShakenEventArgs[] = {
        { "_assign_array_", _assign_array_AccelerometerShakenEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AccelerometerShakenEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AccelerometerShakenEventArgs[] = {
        { "timestamp", reinterpret_cast<getter>(AccelerometerShakenEventArgs_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AccelerometerShakenEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AccelerometerShakenEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AccelerometerShakenEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AccelerometerShakenEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AccelerometerShakenEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AccelerometerShakenEventArgs =
    {
        "_winsdk_Windows_Devices_Sensors.AccelerometerShakenEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::AccelerometerShakenEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AccelerometerShakenEventArgs
    };

    // ----- ActivitySensor class --------------------
    static constexpr const char* const type_name_ActivitySensor = "ActivitySensor";

    static PyObject* _new_ActivitySensor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ActivitySensor);
        return nullptr;
    }

    static void _dealloc_ActivitySensor(py::wrapper::Windows::Devices::Sensors::ActivitySensor* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActivitySensor_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.ActivitySensor", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::ActivitySensor::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_GetCurrentReadingAsync(py::wrapper::Windows::Devices::Sensors::ActivitySensor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.ActivitySensor", L"GetCurrentReadingAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentReadingAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.ActivitySensor", L"GetDefaultAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::ActivitySensor::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.ActivitySensor", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::ActivitySensor::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_GetSystemHistoryAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.ActivitySensor", L"GetSystemHistoryAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::ActivitySensor::GetSystemHistoryAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.ActivitySensor", L"GetSystemHistoryAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(winrt::Windows::Devices::Sensors::ActivitySensor::GetSystemHistoryAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_get_DeviceId(py::wrapper::Windows::Devices::Sensors::ActivitySensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ActivitySensor", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::ActivitySensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ActivitySensor", L"MinimumReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_get_PowerInMilliwatts(py::wrapper::Windows::Devices::Sensors::ActivitySensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ActivitySensor", L"PowerInMilliwatts"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PowerInMilliwatts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_get_SubscribedActivities(py::wrapper::Windows::Devices::Sensors::ActivitySensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ActivitySensor", L"SubscribedActivities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SubscribedActivities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_get_SupportedActivities(py::wrapper::Windows::Devices::Sensors::ActivitySensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ActivitySensor", L"SupportedActivities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedActivities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::ActivitySensor* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.ActivitySensor", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::ActivitySensor, winrt::Windows::Devices::Sensors::ActivitySensorReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::ActivitySensor* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.ActivitySensor", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ActivitySensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::ActivitySensor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ActivitySensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ActivitySensor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivitySensor[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(ActivitySensor_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_reading_async", reinterpret_cast<PyCFunction>(ActivitySensor_GetCurrentReadingAsync), METH_VARARGS, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(ActivitySensor_GetDefaultAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(ActivitySensor_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_system_history_async", reinterpret_cast<PyCFunction>(ActivitySensor_GetSystemHistoryAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(ActivitySensor_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(ActivitySensor_remove_ReadingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ActivitySensor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActivitySensor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ActivitySensor[] = {
        { "device_id", reinterpret_cast<getter>(ActivitySensor_get_DeviceId), nullptr, nullptr, nullptr },
        { "minimum_report_interval", reinterpret_cast<getter>(ActivitySensor_get_MinimumReportInterval), nullptr, nullptr, nullptr },
        { "power_in_milliwatts", reinterpret_cast<getter>(ActivitySensor_get_PowerInMilliwatts), nullptr, nullptr, nullptr },
        { "subscribed_activities", reinterpret_cast<getter>(ActivitySensor_get_SubscribedActivities), nullptr, nullptr, nullptr },
        { "supported_activities", reinterpret_cast<getter>(ActivitySensor_get_SupportedActivities), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ActivitySensor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ActivitySensor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ActivitySensor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ActivitySensor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ActivitySensor) },
        { },
    };

    static PyType_Spec type_spec_ActivitySensor =
    {
        "_winsdk_Windows_Devices_Sensors.ActivitySensor",
        sizeof(py::wrapper::Windows::Devices::Sensors::ActivitySensor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivitySensor
    };

    // ----- ActivitySensorReading class --------------------
    static constexpr const char* const type_name_ActivitySensorReading = "ActivitySensorReading";

    static PyObject* _new_ActivitySensorReading(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ActivitySensorReading);
        return nullptr;
    }

    static void _dealloc_ActivitySensorReading(py::wrapper::Windows::Devices::Sensors::ActivitySensorReading* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActivitySensorReading_get_Activity(py::wrapper::Windows::Devices::Sensors::ActivitySensorReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ActivitySensorReading", L"Activity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Activity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensorReading_get_Confidence(py::wrapper::Windows::Devices::Sensors::ActivitySensorReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ActivitySensorReading", L"Confidence"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Confidence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensorReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::ActivitySensorReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ActivitySensorReading", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ActivitySensorReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::ActivitySensorReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ActivitySensorReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ActivitySensorReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivitySensorReading[] = {
        { "_assign_array_", _assign_array_ActivitySensorReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActivitySensorReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ActivitySensorReading[] = {
        { "activity", reinterpret_cast<getter>(ActivitySensorReading_get_Activity), nullptr, nullptr, nullptr },
        { "confidence", reinterpret_cast<getter>(ActivitySensorReading_get_Confidence), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(ActivitySensorReading_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ActivitySensorReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ActivitySensorReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ActivitySensorReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ActivitySensorReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ActivitySensorReading) },
        { },
    };

    static PyType_Spec type_spec_ActivitySensorReading =
    {
        "_winsdk_Windows_Devices_Sensors.ActivitySensorReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::ActivitySensorReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivitySensorReading
    };

    // ----- ActivitySensorReadingChangeReport class --------------------
    static constexpr const char* const type_name_ActivitySensorReadingChangeReport = "ActivitySensorReadingChangeReport";

    static PyObject* _new_ActivitySensorReadingChangeReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ActivitySensorReadingChangeReport);
        return nullptr;
    }

    static void _dealloc_ActivitySensorReadingChangeReport(py::wrapper::Windows::Devices::Sensors::ActivitySensorReadingChangeReport* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActivitySensorReadingChangeReport_get_Reading(py::wrapper::Windows::Devices::Sensors::ActivitySensorReadingChangeReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ActivitySensorReadingChangeReport", L"Reading"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ActivitySensorReadingChangeReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::ActivitySensorReadingChangeReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ActivitySensorReadingChangeReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ActivitySensorReadingChangeReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivitySensorReadingChangeReport[] = {
        { "_assign_array_", _assign_array_ActivitySensorReadingChangeReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActivitySensorReadingChangeReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ActivitySensorReadingChangeReport[] = {
        { "reading", reinterpret_cast<getter>(ActivitySensorReadingChangeReport_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ActivitySensorReadingChangeReport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ActivitySensorReadingChangeReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ActivitySensorReadingChangeReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ActivitySensorReadingChangeReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ActivitySensorReadingChangeReport) },
        { },
    };

    static PyType_Spec type_spec_ActivitySensorReadingChangeReport =
    {
        "_winsdk_Windows_Devices_Sensors.ActivitySensorReadingChangeReport",
        sizeof(py::wrapper::Windows::Devices::Sensors::ActivitySensorReadingChangeReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivitySensorReadingChangeReport
    };

    // ----- ActivitySensorReadingChangedEventArgs class --------------------
    static constexpr const char* const type_name_ActivitySensorReadingChangedEventArgs = "ActivitySensorReadingChangedEventArgs";

    static PyObject* _new_ActivitySensorReadingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ActivitySensorReadingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_ActivitySensorReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::ActivitySensorReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActivitySensorReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::ActivitySensorReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ActivitySensorReadingChangedEventArgs", L"Reading"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ActivitySensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::ActivitySensorReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ActivitySensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ActivitySensorReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivitySensorReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_ActivitySensorReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActivitySensorReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ActivitySensorReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(ActivitySensorReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ActivitySensorReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ActivitySensorReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ActivitySensorReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ActivitySensorReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ActivitySensorReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ActivitySensorReadingChangedEventArgs =
    {
        "_winsdk_Windows_Devices_Sensors.ActivitySensorReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::ActivitySensorReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivitySensorReadingChangedEventArgs
    };

    // ----- ActivitySensorTriggerDetails class --------------------
    static constexpr const char* const type_name_ActivitySensorTriggerDetails = "ActivitySensorTriggerDetails";

    static PyObject* _new_ActivitySensorTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ActivitySensorTriggerDetails);
        return nullptr;
    }

    static void _dealloc_ActivitySensorTriggerDetails(py::wrapper::Windows::Devices::Sensors::ActivitySensorTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActivitySensorTriggerDetails_ReadReports(py::wrapper::Windows::Devices::Sensors::ActivitySensorTriggerDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.ActivitySensorTriggerDetails", L"ReadReports", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadReports());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ActivitySensorTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::ActivitySensorTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ActivitySensorTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ActivitySensorTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivitySensorTriggerDetails[] = {
        { "read_reports", reinterpret_cast<PyCFunction>(ActivitySensorTriggerDetails_ReadReports), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ActivitySensorTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActivitySensorTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ActivitySensorTriggerDetails[] = {
        { }
    };

    static PyType_Slot _type_slots_ActivitySensorTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ActivitySensorTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ActivitySensorTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ActivitySensorTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ActivitySensorTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_ActivitySensorTriggerDetails =
    {
        "_winsdk_Windows_Devices_Sensors.ActivitySensorTriggerDetails",
        sizeof(py::wrapper::Windows::Devices::Sensors::ActivitySensorTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivitySensorTriggerDetails
    };

    // ----- Altimeter class --------------------
    static constexpr const char* const type_name_Altimeter = "Altimeter";

    static PyObject* _new_Altimeter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_Altimeter);
        return nullptr;
    }

    static void _dealloc_Altimeter(py::wrapper::Windows::Devices::Sensors::Altimeter* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Altimeter_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::Altimeter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Altimeter", L"GetCurrentReading", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Altimeter_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Altimeter", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Altimeter::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Altimeter_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::Altimeter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Altimeter", L"ReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Altimeter_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::Altimeter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Altimeter", L"ReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Altimeter_get_DeviceId(py::wrapper::Windows::Devices::Sensors::Altimeter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Altimeter", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Altimeter_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::Altimeter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Altimeter", L"MinimumReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Altimeter_get_ReportLatency(py::wrapper::Windows::Devices::Sensors::Altimeter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Altimeter", L"ReportLatency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Altimeter_put_ReportLatency(py::wrapper::Windows::Devices::Sensors::Altimeter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Altimeter", L"ReportLatency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportLatency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Altimeter_get_MaxBatchSize(py::wrapper::Windows::Devices::Sensors::Altimeter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Altimeter", L"MaxBatchSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Altimeter_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Altimeter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Altimeter", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Altimeter, winrt::Windows::Devices::Sensors::AltimeterReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Altimeter_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Altimeter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Altimeter", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Altimeter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::Altimeter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Altimeter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::Altimeter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Altimeter[] = {
        { "get_current_reading", reinterpret_cast<PyCFunction>(Altimeter_GetCurrentReading), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(Altimeter_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(Altimeter_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(Altimeter_remove_ReadingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_Altimeter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Altimeter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Altimeter[] = {
        { "report_interval", reinterpret_cast<getter>(Altimeter_get_ReportInterval), reinterpret_cast<setter>(Altimeter_put_ReportInterval), nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(Altimeter_get_DeviceId), nullptr, nullptr, nullptr },
        { "minimum_report_interval", reinterpret_cast<getter>(Altimeter_get_MinimumReportInterval), nullptr, nullptr, nullptr },
        { "report_latency", reinterpret_cast<getter>(Altimeter_get_ReportLatency), reinterpret_cast<setter>(Altimeter_put_ReportLatency), nullptr, nullptr },
        { "max_batch_size", reinterpret_cast<getter>(Altimeter_get_MaxBatchSize), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Altimeter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Altimeter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Altimeter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Altimeter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Altimeter) },
        { },
    };

    static PyType_Spec type_spec_Altimeter =
    {
        "_winsdk_Windows_Devices_Sensors.Altimeter",
        sizeof(py::wrapper::Windows::Devices::Sensors::Altimeter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Altimeter
    };

    // ----- AltimeterReading class --------------------
    static constexpr const char* const type_name_AltimeterReading = "AltimeterReading";

    static PyObject* _new_AltimeterReading(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AltimeterReading);
        return nullptr;
    }

    static void _dealloc_AltimeterReading(py::wrapper::Windows::Devices::Sensors::AltimeterReading* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AltimeterReading_get_AltitudeChangeInMeters(py::wrapper::Windows::Devices::Sensors::AltimeterReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AltimeterReading", L"AltitudeChangeInMeters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AltitudeChangeInMeters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AltimeterReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::AltimeterReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AltimeterReading", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AltimeterReading_get_PerformanceCount(py::wrapper::Windows::Devices::Sensors::AltimeterReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AltimeterReading", L"PerformanceCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AltimeterReading_get_Properties(py::wrapper::Windows::Devices::Sensors::AltimeterReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AltimeterReading", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AltimeterReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::AltimeterReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AltimeterReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::AltimeterReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AltimeterReading[] = {
        { "_assign_array_", _assign_array_AltimeterReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AltimeterReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AltimeterReading[] = {
        { "altitude_change_in_meters", reinterpret_cast<getter>(AltimeterReading_get_AltitudeChangeInMeters), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(AltimeterReading_get_Timestamp), nullptr, nullptr, nullptr },
        { "performance_count", reinterpret_cast<getter>(AltimeterReading_get_PerformanceCount), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(AltimeterReading_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AltimeterReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AltimeterReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AltimeterReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AltimeterReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AltimeterReading) },
        { },
    };

    static PyType_Spec type_spec_AltimeterReading =
    {
        "_winsdk_Windows_Devices_Sensors.AltimeterReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::AltimeterReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AltimeterReading
    };

    // ----- AltimeterReadingChangedEventArgs class --------------------
    static constexpr const char* const type_name_AltimeterReadingChangedEventArgs = "AltimeterReadingChangedEventArgs";

    static PyObject* _new_AltimeterReadingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AltimeterReadingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_AltimeterReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::AltimeterReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AltimeterReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::AltimeterReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AltimeterReadingChangedEventArgs", L"Reading"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AltimeterReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::AltimeterReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AltimeterReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::AltimeterReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AltimeterReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AltimeterReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AltimeterReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AltimeterReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(AltimeterReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AltimeterReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AltimeterReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AltimeterReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AltimeterReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AltimeterReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AltimeterReadingChangedEventArgs =
    {
        "_winsdk_Windows_Devices_Sensors.AltimeterReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::AltimeterReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AltimeterReadingChangedEventArgs
    };

    // ----- Barometer class --------------------
    static constexpr const char* const type_name_Barometer = "Barometer";

    static PyObject* _new_Barometer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_Barometer);
        return nullptr;
    }

    static void _dealloc_Barometer(py::wrapper::Windows::Devices::Sensors::Barometer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Barometer_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Barometer", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Barometer::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Barometer_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::Barometer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Barometer", L"GetCurrentReading", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Barometer_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Barometer", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Barometer::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Barometer_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Barometer", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Barometer::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Barometer_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::Barometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Barometer", L"ReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Barometer_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::Barometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Barometer", L"ReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Barometer_get_DeviceId(py::wrapper::Windows::Devices::Sensors::Barometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Barometer", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Barometer_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::Barometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Barometer", L"MinimumReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Barometer_get_ReportLatency(py::wrapper::Windows::Devices::Sensors::Barometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Barometer", L"ReportLatency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Barometer_put_ReportLatency(py::wrapper::Windows::Devices::Sensors::Barometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Barometer", L"ReportLatency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportLatency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Barometer_get_MaxBatchSize(py::wrapper::Windows::Devices::Sensors::Barometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Barometer", L"MaxBatchSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Barometer_get_ReportThreshold(py::wrapper::Windows::Devices::Sensors::Barometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Barometer", L"ReportThreshold"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportThreshold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Barometer_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Barometer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Barometer", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Barometer, winrt::Windows::Devices::Sensors::BarometerReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Barometer_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Barometer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Barometer", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Barometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::Barometer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Barometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::Barometer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Barometer[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(Barometer_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(Barometer_GetCurrentReading), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(Barometer_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(Barometer_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(Barometer_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(Barometer_remove_ReadingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_Barometer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Barometer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Barometer[] = {
        { "report_interval", reinterpret_cast<getter>(Barometer_get_ReportInterval), reinterpret_cast<setter>(Barometer_put_ReportInterval), nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(Barometer_get_DeviceId), nullptr, nullptr, nullptr },
        { "minimum_report_interval", reinterpret_cast<getter>(Barometer_get_MinimumReportInterval), nullptr, nullptr, nullptr },
        { "report_latency", reinterpret_cast<getter>(Barometer_get_ReportLatency), reinterpret_cast<setter>(Barometer_put_ReportLatency), nullptr, nullptr },
        { "max_batch_size", reinterpret_cast<getter>(Barometer_get_MaxBatchSize), nullptr, nullptr, nullptr },
        { "report_threshold", reinterpret_cast<getter>(Barometer_get_ReportThreshold), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Barometer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Barometer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Barometer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Barometer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Barometer) },
        { },
    };

    static PyType_Spec type_spec_Barometer =
    {
        "_winsdk_Windows_Devices_Sensors.Barometer",
        sizeof(py::wrapper::Windows::Devices::Sensors::Barometer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Barometer
    };

    // ----- BarometerDataThreshold class --------------------
    static constexpr const char* const type_name_BarometerDataThreshold = "BarometerDataThreshold";

    static PyObject* _new_BarometerDataThreshold(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BarometerDataThreshold);
        return nullptr;
    }

    static void _dealloc_BarometerDataThreshold(py::wrapper::Windows::Devices::Sensors::BarometerDataThreshold* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BarometerDataThreshold_get_Hectopascals(py::wrapper::Windows::Devices::Sensors::BarometerDataThreshold* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.BarometerDataThreshold", L"Hectopascals"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Hectopascals());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BarometerDataThreshold_put_Hectopascals(py::wrapper::Windows::Devices::Sensors::BarometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.BarometerDataThreshold", L"Hectopascals"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Hectopascals(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_BarometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::BarometerDataThreshold>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BarometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::BarometerDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarometerDataThreshold[] = {
        { "_assign_array_", _assign_array_BarometerDataThreshold, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BarometerDataThreshold), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarometerDataThreshold[] = {
        { "hectopascals", reinterpret_cast<getter>(BarometerDataThreshold_get_Hectopascals), reinterpret_cast<setter>(BarometerDataThreshold_put_Hectopascals), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarometerDataThreshold[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BarometerDataThreshold) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BarometerDataThreshold) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BarometerDataThreshold) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BarometerDataThreshold) },
        { },
    };

    static PyType_Spec type_spec_BarometerDataThreshold =
    {
        "_winsdk_Windows_Devices_Sensors.BarometerDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::BarometerDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarometerDataThreshold
    };

    // ----- BarometerReading class --------------------
    static constexpr const char* const type_name_BarometerReading = "BarometerReading";

    static PyObject* _new_BarometerReading(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BarometerReading);
        return nullptr;
    }

    static void _dealloc_BarometerReading(py::wrapper::Windows::Devices::Sensors::BarometerReading* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BarometerReading_get_StationPressureInHectopascals(py::wrapper::Windows::Devices::Sensors::BarometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.BarometerReading", L"StationPressureInHectopascals"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StationPressureInHectopascals());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarometerReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::BarometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.BarometerReading", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarometerReading_get_PerformanceCount(py::wrapper::Windows::Devices::Sensors::BarometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.BarometerReading", L"PerformanceCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarometerReading_get_Properties(py::wrapper::Windows::Devices::Sensors::BarometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.BarometerReading", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BarometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::BarometerReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BarometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::BarometerReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarometerReading[] = {
        { "_assign_array_", _assign_array_BarometerReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BarometerReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarometerReading[] = {
        { "station_pressure_in_hectopascals", reinterpret_cast<getter>(BarometerReading_get_StationPressureInHectopascals), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(BarometerReading_get_Timestamp), nullptr, nullptr, nullptr },
        { "performance_count", reinterpret_cast<getter>(BarometerReading_get_PerformanceCount), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(BarometerReading_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarometerReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BarometerReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BarometerReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BarometerReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BarometerReading) },
        { },
    };

    static PyType_Spec type_spec_BarometerReading =
    {
        "_winsdk_Windows_Devices_Sensors.BarometerReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::BarometerReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarometerReading
    };

    // ----- BarometerReadingChangedEventArgs class --------------------
    static constexpr const char* const type_name_BarometerReadingChangedEventArgs = "BarometerReadingChangedEventArgs";

    static PyObject* _new_BarometerReadingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BarometerReadingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_BarometerReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::BarometerReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BarometerReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::BarometerReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.BarometerReadingChangedEventArgs", L"Reading"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BarometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::BarometerReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BarometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::BarometerReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarometerReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_BarometerReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BarometerReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarometerReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(BarometerReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarometerReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BarometerReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BarometerReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BarometerReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BarometerReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_BarometerReadingChangedEventArgs =
    {
        "_winsdk_Windows_Devices_Sensors.BarometerReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::BarometerReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarometerReadingChangedEventArgs
    };

    // ----- Compass class --------------------
    static constexpr const char* const type_name_Compass = "Compass";

    static PyObject* _new_Compass(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_Compass);
        return nullptr;
    }

    static void _dealloc_Compass(py::wrapper::Windows::Devices::Sensors::Compass* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Compass_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Compass", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Compass::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compass_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::Compass* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Compass", L"GetCurrentReading", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compass_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Compass", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Compass::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compass_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Compass", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Compass::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compass_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::Compass* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Compass", L"ReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Compass_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::Compass* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Compass", L"ReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Compass_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::Compass* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Compass", L"MinimumReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Compass_get_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Compass* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Compass", L"ReadingTransform"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReadingTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Compass_put_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Compass* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Compass", L"ReadingTransform"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Display::DisplayOrientations>(arg);

            self->obj.ReadingTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Compass_get_ReportLatency(py::wrapper::Windows::Devices::Sensors::Compass* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Compass", L"ReportLatency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Compass_put_ReportLatency(py::wrapper::Windows::Devices::Sensors::Compass* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Compass", L"ReportLatency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportLatency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Compass_get_MaxBatchSize(py::wrapper::Windows::Devices::Sensors::Compass* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Compass", L"MaxBatchSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Compass_get_ReportThreshold(py::wrapper::Windows::Devices::Sensors::Compass* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Compass", L"ReportThreshold"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportThreshold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Compass_get_DeviceId(py::wrapper::Windows::Devices::Sensors::Compass* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Compass", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Compass_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Compass* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Compass", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Compass, winrt::Windows::Devices::Sensors::CompassReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Compass_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Compass* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Compass", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Compass(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::Compass>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Compass(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::Compass>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Compass[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(Compass_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(Compass_GetCurrentReading), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(Compass_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(Compass_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(Compass_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(Compass_remove_ReadingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_Compass, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Compass), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Compass[] = {
        { "report_interval", reinterpret_cast<getter>(Compass_get_ReportInterval), reinterpret_cast<setter>(Compass_put_ReportInterval), nullptr, nullptr },
        { "minimum_report_interval", reinterpret_cast<getter>(Compass_get_MinimumReportInterval), nullptr, nullptr, nullptr },
        { "reading_transform", reinterpret_cast<getter>(Compass_get_ReadingTransform), reinterpret_cast<setter>(Compass_put_ReadingTransform), nullptr, nullptr },
        { "report_latency", reinterpret_cast<getter>(Compass_get_ReportLatency), reinterpret_cast<setter>(Compass_put_ReportLatency), nullptr, nullptr },
        { "max_batch_size", reinterpret_cast<getter>(Compass_get_MaxBatchSize), nullptr, nullptr, nullptr },
        { "report_threshold", reinterpret_cast<getter>(Compass_get_ReportThreshold), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(Compass_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Compass[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Compass) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Compass) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Compass) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Compass) },
        { },
    };

    static PyType_Spec type_spec_Compass =
    {
        "_winsdk_Windows_Devices_Sensors.Compass",
        sizeof(py::wrapper::Windows::Devices::Sensors::Compass),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Compass
    };

    // ----- CompassDataThreshold class --------------------
    static constexpr const char* const type_name_CompassDataThreshold = "CompassDataThreshold";

    static PyObject* _new_CompassDataThreshold(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CompassDataThreshold);
        return nullptr;
    }

    static void _dealloc_CompassDataThreshold(py::wrapper::Windows::Devices::Sensors::CompassDataThreshold* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompassDataThreshold_get_Degrees(py::wrapper::Windows::Devices::Sensors::CompassDataThreshold* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.CompassDataThreshold", L"Degrees"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Degrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompassDataThreshold_put_Degrees(py::wrapper::Windows::Devices::Sensors::CompassDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.CompassDataThreshold", L"Degrees"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Degrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CompassDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::CompassDataThreshold>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompassDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::CompassDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompassDataThreshold[] = {
        { "_assign_array_", _assign_array_CompassDataThreshold, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompassDataThreshold), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompassDataThreshold[] = {
        { "degrees", reinterpret_cast<getter>(CompassDataThreshold_get_Degrees), reinterpret_cast<setter>(CompassDataThreshold_put_Degrees), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompassDataThreshold[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompassDataThreshold) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompassDataThreshold) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompassDataThreshold) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompassDataThreshold) },
        { },
    };

    static PyType_Spec type_spec_CompassDataThreshold =
    {
        "_winsdk_Windows_Devices_Sensors.CompassDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::CompassDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompassDataThreshold
    };

    // ----- CompassReading class --------------------
    static constexpr const char* const type_name_CompassReading = "CompassReading";

    static PyObject* _new_CompassReading(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CompassReading);
        return nullptr;
    }

    static void _dealloc_CompassReading(py::wrapper::Windows::Devices::Sensors::CompassReading* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompassReading_get_HeadingMagneticNorth(py::wrapper::Windows::Devices::Sensors::CompassReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.CompassReading", L"HeadingMagneticNorth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HeadingMagneticNorth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompassReading_get_HeadingTrueNorth(py::wrapper::Windows::Devices::Sensors::CompassReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.CompassReading", L"HeadingTrueNorth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HeadingTrueNorth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompassReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::CompassReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.CompassReading", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompassReading_get_PerformanceCount(py::wrapper::Windows::Devices::Sensors::CompassReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.CompassReading", L"PerformanceCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompassReading_get_Properties(py::wrapper::Windows::Devices::Sensors::CompassReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.CompassReading", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompassReading_get_HeadingAccuracy(py::wrapper::Windows::Devices::Sensors::CompassReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.CompassReading", L"HeadingAccuracy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HeadingAccuracy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompassReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::CompassReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompassReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::CompassReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompassReading[] = {
        { "_assign_array_", _assign_array_CompassReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompassReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompassReading[] = {
        { "heading_magnetic_north", reinterpret_cast<getter>(CompassReading_get_HeadingMagneticNorth), nullptr, nullptr, nullptr },
        { "heading_true_north", reinterpret_cast<getter>(CompassReading_get_HeadingTrueNorth), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(CompassReading_get_Timestamp), nullptr, nullptr, nullptr },
        { "performance_count", reinterpret_cast<getter>(CompassReading_get_PerformanceCount), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(CompassReading_get_Properties), nullptr, nullptr, nullptr },
        { "heading_accuracy", reinterpret_cast<getter>(CompassReading_get_HeadingAccuracy), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompassReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompassReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompassReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompassReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompassReading) },
        { },
    };

    static PyType_Spec type_spec_CompassReading =
    {
        "_winsdk_Windows_Devices_Sensors.CompassReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::CompassReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompassReading
    };

    // ----- CompassReadingChangedEventArgs class --------------------
    static constexpr const char* const type_name_CompassReadingChangedEventArgs = "CompassReadingChangedEventArgs";

    static PyObject* _new_CompassReadingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CompassReadingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_CompassReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::CompassReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompassReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::CompassReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.CompassReadingChangedEventArgs", L"Reading"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompassReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::CompassReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompassReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::CompassReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompassReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_CompassReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompassReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompassReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(CompassReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompassReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompassReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompassReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompassReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompassReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CompassReadingChangedEventArgs =
    {
        "_winsdk_Windows_Devices_Sensors.CompassReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::CompassReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompassReadingChangedEventArgs
    };

    // ----- Gyrometer class --------------------
    static constexpr const char* const type_name_Gyrometer = "Gyrometer";

    static PyObject* _new_Gyrometer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_Gyrometer);
        return nullptr;
    }

    static void _dealloc_Gyrometer(py::wrapper::Windows::Devices::Sensors::Gyrometer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Gyrometer_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Gyrometer", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Gyrometer::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gyrometer_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Gyrometer", L"GetCurrentReading", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gyrometer_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Gyrometer", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Gyrometer::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gyrometer_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Gyrometer", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Gyrometer::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gyrometer_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Gyrometer", L"ReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Gyrometer_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Gyrometer", L"ReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Gyrometer_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Gyrometer", L"MinimumReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gyrometer_get_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Gyrometer", L"ReadingTransform"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReadingTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Gyrometer_put_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Gyrometer", L"ReadingTransform"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Display::DisplayOrientations>(arg);

            self->obj.ReadingTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Gyrometer_get_ReportLatency(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Gyrometer", L"ReportLatency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Gyrometer_put_ReportLatency(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Gyrometer", L"ReportLatency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportLatency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Gyrometer_get_MaxBatchSize(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Gyrometer", L"MaxBatchSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gyrometer_get_ReportThreshold(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Gyrometer", L"ReportThreshold"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportThreshold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gyrometer_get_DeviceId(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Gyrometer", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gyrometer_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Gyrometer", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Gyrometer, winrt::Windows::Devices::Sensors::GyrometerReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gyrometer_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Gyrometer", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Gyrometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::Gyrometer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Gyrometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::Gyrometer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Gyrometer[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(Gyrometer_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(Gyrometer_GetCurrentReading), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(Gyrometer_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(Gyrometer_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(Gyrometer_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(Gyrometer_remove_ReadingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_Gyrometer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Gyrometer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Gyrometer[] = {
        { "report_interval", reinterpret_cast<getter>(Gyrometer_get_ReportInterval), reinterpret_cast<setter>(Gyrometer_put_ReportInterval), nullptr, nullptr },
        { "minimum_report_interval", reinterpret_cast<getter>(Gyrometer_get_MinimumReportInterval), nullptr, nullptr, nullptr },
        { "reading_transform", reinterpret_cast<getter>(Gyrometer_get_ReadingTransform), reinterpret_cast<setter>(Gyrometer_put_ReadingTransform), nullptr, nullptr },
        { "report_latency", reinterpret_cast<getter>(Gyrometer_get_ReportLatency), reinterpret_cast<setter>(Gyrometer_put_ReportLatency), nullptr, nullptr },
        { "max_batch_size", reinterpret_cast<getter>(Gyrometer_get_MaxBatchSize), nullptr, nullptr, nullptr },
        { "report_threshold", reinterpret_cast<getter>(Gyrometer_get_ReportThreshold), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(Gyrometer_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Gyrometer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Gyrometer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Gyrometer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Gyrometer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Gyrometer) },
        { },
    };

    static PyType_Spec type_spec_Gyrometer =
    {
        "_winsdk_Windows_Devices_Sensors.Gyrometer",
        sizeof(py::wrapper::Windows::Devices::Sensors::Gyrometer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Gyrometer
    };

    // ----- GyrometerDataThreshold class --------------------
    static constexpr const char* const type_name_GyrometerDataThreshold = "GyrometerDataThreshold";

    static PyObject* _new_GyrometerDataThreshold(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_GyrometerDataThreshold);
        return nullptr;
    }

    static void _dealloc_GyrometerDataThreshold(py::wrapper::Windows::Devices::Sensors::GyrometerDataThreshold* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GyrometerDataThreshold_get_ZAxisInDegreesPerSecond(py::wrapper::Windows::Devices::Sensors::GyrometerDataThreshold* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.GyrometerDataThreshold", L"ZAxisInDegreesPerSecond"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZAxisInDegreesPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GyrometerDataThreshold_put_ZAxisInDegreesPerSecond(py::wrapper::Windows::Devices::Sensors::GyrometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.GyrometerDataThreshold", L"ZAxisInDegreesPerSecond"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ZAxisInDegreesPerSecond(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GyrometerDataThreshold_get_YAxisInDegreesPerSecond(py::wrapper::Windows::Devices::Sensors::GyrometerDataThreshold* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.GyrometerDataThreshold", L"YAxisInDegreesPerSecond"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.YAxisInDegreesPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GyrometerDataThreshold_put_YAxisInDegreesPerSecond(py::wrapper::Windows::Devices::Sensors::GyrometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.GyrometerDataThreshold", L"YAxisInDegreesPerSecond"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.YAxisInDegreesPerSecond(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GyrometerDataThreshold_get_XAxisInDegreesPerSecond(py::wrapper::Windows::Devices::Sensors::GyrometerDataThreshold* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.GyrometerDataThreshold", L"XAxisInDegreesPerSecond"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.XAxisInDegreesPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GyrometerDataThreshold_put_XAxisInDegreesPerSecond(py::wrapper::Windows::Devices::Sensors::GyrometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.GyrometerDataThreshold", L"XAxisInDegreesPerSecond"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.XAxisInDegreesPerSecond(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_GyrometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::GyrometerDataThreshold>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GyrometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::GyrometerDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GyrometerDataThreshold[] = {
        { "_assign_array_", _assign_array_GyrometerDataThreshold, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GyrometerDataThreshold), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GyrometerDataThreshold[] = {
        { "z_axis_in_degrees_per_second", reinterpret_cast<getter>(GyrometerDataThreshold_get_ZAxisInDegreesPerSecond), reinterpret_cast<setter>(GyrometerDataThreshold_put_ZAxisInDegreesPerSecond), nullptr, nullptr },
        { "y_axis_in_degrees_per_second", reinterpret_cast<getter>(GyrometerDataThreshold_get_YAxisInDegreesPerSecond), reinterpret_cast<setter>(GyrometerDataThreshold_put_YAxisInDegreesPerSecond), nullptr, nullptr },
        { "x_axis_in_degrees_per_second", reinterpret_cast<getter>(GyrometerDataThreshold_get_XAxisInDegreesPerSecond), reinterpret_cast<setter>(GyrometerDataThreshold_put_XAxisInDegreesPerSecond), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GyrometerDataThreshold[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GyrometerDataThreshold) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GyrometerDataThreshold) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GyrometerDataThreshold) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GyrometerDataThreshold) },
        { },
    };

    static PyType_Spec type_spec_GyrometerDataThreshold =
    {
        "_winsdk_Windows_Devices_Sensors.GyrometerDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::GyrometerDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GyrometerDataThreshold
    };

    // ----- GyrometerReading class --------------------
    static constexpr const char* const type_name_GyrometerReading = "GyrometerReading";

    static PyObject* _new_GyrometerReading(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_GyrometerReading);
        return nullptr;
    }

    static void _dealloc_GyrometerReading(py::wrapper::Windows::Devices::Sensors::GyrometerReading* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GyrometerReading_get_AngularVelocityX(py::wrapper::Windows::Devices::Sensors::GyrometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.GyrometerReading", L"AngularVelocityX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AngularVelocityX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GyrometerReading_get_AngularVelocityY(py::wrapper::Windows::Devices::Sensors::GyrometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.GyrometerReading", L"AngularVelocityY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AngularVelocityY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GyrometerReading_get_AngularVelocityZ(py::wrapper::Windows::Devices::Sensors::GyrometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.GyrometerReading", L"AngularVelocityZ"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AngularVelocityZ());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GyrometerReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::GyrometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.GyrometerReading", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GyrometerReading_get_PerformanceCount(py::wrapper::Windows::Devices::Sensors::GyrometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.GyrometerReading", L"PerformanceCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GyrometerReading_get_Properties(py::wrapper::Windows::Devices::Sensors::GyrometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.GyrometerReading", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GyrometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::GyrometerReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GyrometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::GyrometerReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GyrometerReading[] = {
        { "_assign_array_", _assign_array_GyrometerReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GyrometerReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GyrometerReading[] = {
        { "angular_velocity_x", reinterpret_cast<getter>(GyrometerReading_get_AngularVelocityX), nullptr, nullptr, nullptr },
        { "angular_velocity_y", reinterpret_cast<getter>(GyrometerReading_get_AngularVelocityY), nullptr, nullptr, nullptr },
        { "angular_velocity_z", reinterpret_cast<getter>(GyrometerReading_get_AngularVelocityZ), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(GyrometerReading_get_Timestamp), nullptr, nullptr, nullptr },
        { "performance_count", reinterpret_cast<getter>(GyrometerReading_get_PerformanceCount), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(GyrometerReading_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GyrometerReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GyrometerReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GyrometerReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GyrometerReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GyrometerReading) },
        { },
    };

    static PyType_Spec type_spec_GyrometerReading =
    {
        "_winsdk_Windows_Devices_Sensors.GyrometerReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::GyrometerReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GyrometerReading
    };

    // ----- GyrometerReadingChangedEventArgs class --------------------
    static constexpr const char* const type_name_GyrometerReadingChangedEventArgs = "GyrometerReadingChangedEventArgs";

    static PyObject* _new_GyrometerReadingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_GyrometerReadingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_GyrometerReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::GyrometerReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GyrometerReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::GyrometerReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.GyrometerReadingChangedEventArgs", L"Reading"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GyrometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::GyrometerReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GyrometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::GyrometerReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GyrometerReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_GyrometerReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GyrometerReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GyrometerReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(GyrometerReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GyrometerReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GyrometerReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GyrometerReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GyrometerReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GyrometerReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_GyrometerReadingChangedEventArgs =
    {
        "_winsdk_Windows_Devices_Sensors.GyrometerReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::GyrometerReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GyrometerReadingChangedEventArgs
    };

    // ----- HingeAngleReading class --------------------
    static constexpr const char* const type_name_HingeAngleReading = "HingeAngleReading";

    static PyObject* _new_HingeAngleReading(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HingeAngleReading);
        return nullptr;
    }

    static void _dealloc_HingeAngleReading(py::wrapper::Windows::Devices::Sensors::HingeAngleReading* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HingeAngleReading_get_AngleInDegrees(py::wrapper::Windows::Devices::Sensors::HingeAngleReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HingeAngleReading", L"AngleInDegrees"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AngleInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HingeAngleReading_get_Properties(py::wrapper::Windows::Devices::Sensors::HingeAngleReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HingeAngleReading", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HingeAngleReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::HingeAngleReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HingeAngleReading", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HingeAngleReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::HingeAngleReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HingeAngleReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::HingeAngleReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HingeAngleReading[] = {
        { "_assign_array_", _assign_array_HingeAngleReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HingeAngleReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HingeAngleReading[] = {
        { "angle_in_degrees", reinterpret_cast<getter>(HingeAngleReading_get_AngleInDegrees), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(HingeAngleReading_get_Properties), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(HingeAngleReading_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HingeAngleReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HingeAngleReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HingeAngleReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HingeAngleReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HingeAngleReading) },
        { },
    };

    static PyType_Spec type_spec_HingeAngleReading =
    {
        "_winsdk_Windows_Devices_Sensors.HingeAngleReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::HingeAngleReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HingeAngleReading
    };

    // ----- HingeAngleSensor class --------------------
    static constexpr const char* const type_name_HingeAngleSensor = "HingeAngleSensor";

    static PyObject* _new_HingeAngleSensor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HingeAngleSensor);
        return nullptr;
    }

    static void _dealloc_HingeAngleSensor(py::wrapper::Windows::Devices::Sensors::HingeAngleSensor* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HingeAngleSensor_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HingeAngleSensor", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::HingeAngleSensor::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HingeAngleSensor_GetCurrentReadingAsync(py::wrapper::Windows::Devices::Sensors::HingeAngleSensor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HingeAngleSensor", L"GetCurrentReadingAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentReadingAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HingeAngleSensor_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HingeAngleSensor", L"GetDefaultAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::HingeAngleSensor::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HingeAngleSensor_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HingeAngleSensor", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::HingeAngleSensor::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HingeAngleSensor_GetRelatedToAdjacentPanelsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HingeAngleSensor", L"GetRelatedToAdjacentPanelsAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Devices::Sensors::HingeAngleSensor::GetRelatedToAdjacentPanelsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HingeAngleSensor_get_ReportThresholdInDegrees(py::wrapper::Windows::Devices::Sensors::HingeAngleSensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HingeAngleSensor", L"ReportThresholdInDegrees"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportThresholdInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HingeAngleSensor_put_ReportThresholdInDegrees(py::wrapper::Windows::Devices::Sensors::HingeAngleSensor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HingeAngleSensor", L"ReportThresholdInDegrees"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ReportThresholdInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HingeAngleSensor_get_DeviceId(py::wrapper::Windows::Devices::Sensors::HingeAngleSensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HingeAngleSensor", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HingeAngleSensor_get_MinReportThresholdInDegrees(py::wrapper::Windows::Devices::Sensors::HingeAngleSensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HingeAngleSensor", L"MinReportThresholdInDegrees"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinReportThresholdInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HingeAngleSensor_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::HingeAngleSensor* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.HingeAngleSensor", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::HingeAngleSensor, winrt::Windows::Devices::Sensors::HingeAngleSensorReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HingeAngleSensor_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::HingeAngleSensor* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.HingeAngleSensor", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HingeAngleSensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::HingeAngleSensor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HingeAngleSensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::HingeAngleSensor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HingeAngleSensor[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(HingeAngleSensor_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_reading_async", reinterpret_cast<PyCFunction>(HingeAngleSensor_GetCurrentReadingAsync), METH_VARARGS, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(HingeAngleSensor_GetDefaultAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(HingeAngleSensor_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_related_to_adjacent_panels_async", reinterpret_cast<PyCFunction>(HingeAngleSensor_GetRelatedToAdjacentPanelsAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(HingeAngleSensor_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(HingeAngleSensor_remove_ReadingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_HingeAngleSensor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HingeAngleSensor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HingeAngleSensor[] = {
        { "report_threshold_in_degrees", reinterpret_cast<getter>(HingeAngleSensor_get_ReportThresholdInDegrees), reinterpret_cast<setter>(HingeAngleSensor_put_ReportThresholdInDegrees), nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(HingeAngleSensor_get_DeviceId), nullptr, nullptr, nullptr },
        { "min_report_threshold_in_degrees", reinterpret_cast<getter>(HingeAngleSensor_get_MinReportThresholdInDegrees), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HingeAngleSensor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HingeAngleSensor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HingeAngleSensor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HingeAngleSensor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HingeAngleSensor) },
        { },
    };

    static PyType_Spec type_spec_HingeAngleSensor =
    {
        "_winsdk_Windows_Devices_Sensors.HingeAngleSensor",
        sizeof(py::wrapper::Windows::Devices::Sensors::HingeAngleSensor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HingeAngleSensor
    };

    // ----- HingeAngleSensorReadingChangedEventArgs class --------------------
    static constexpr const char* const type_name_HingeAngleSensorReadingChangedEventArgs = "HingeAngleSensorReadingChangedEventArgs";

    static PyObject* _new_HingeAngleSensorReadingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HingeAngleSensorReadingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_HingeAngleSensorReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::HingeAngleSensorReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HingeAngleSensorReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::HingeAngleSensorReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HingeAngleSensorReadingChangedEventArgs", L"Reading"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HingeAngleSensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::HingeAngleSensorReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HingeAngleSensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::HingeAngleSensorReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HingeAngleSensorReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_HingeAngleSensorReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HingeAngleSensorReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HingeAngleSensorReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(HingeAngleSensorReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HingeAngleSensorReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HingeAngleSensorReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HingeAngleSensorReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HingeAngleSensorReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HingeAngleSensorReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_HingeAngleSensorReadingChangedEventArgs =
    {
        "_winsdk_Windows_Devices_Sensors.HingeAngleSensorReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::HingeAngleSensorReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HingeAngleSensorReadingChangedEventArgs
    };

    // ----- HumanPresenceFeatures class --------------------
    static constexpr const char* const type_name_HumanPresenceFeatures = "HumanPresenceFeatures";

    static PyObject* _new_HumanPresenceFeatures(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HumanPresenceFeatures);
        return nullptr;
    }

    static void _dealloc_HumanPresenceFeatures(py::wrapper::Windows::Devices::Sensors::HumanPresenceFeatures* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HumanPresenceFeatures_get_IsAttentionAwareDimmingSupported(py::wrapper::Windows::Devices::Sensors::HumanPresenceFeatures* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceFeatures", L"IsAttentionAwareDimmingSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsAttentionAwareDimmingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceFeatures_get_IsLockOnLeaveSupported(py::wrapper::Windows::Devices::Sensors::HumanPresenceFeatures* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceFeatures", L"IsLockOnLeaveSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsLockOnLeaveSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceFeatures_get_IsWakeOnApproachSupported(py::wrapper::Windows::Devices::Sensors::HumanPresenceFeatures* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceFeatures", L"IsWakeOnApproachSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsWakeOnApproachSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceFeatures_get_SensorId(py::wrapper::Windows::Devices::Sensors::HumanPresenceFeatures* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceFeatures", L"SensorId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SensorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceFeatures_get_SupportedWakeOrLockDistancesInMillimeters(py::wrapper::Windows::Devices::Sensors::HumanPresenceFeatures* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceFeatures", L"SupportedWakeOrLockDistancesInMillimeters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedWakeOrLockDistancesInMillimeters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HumanPresenceFeatures(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::HumanPresenceFeatures>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HumanPresenceFeatures(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::HumanPresenceFeatures>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HumanPresenceFeatures[] = {
        { "_assign_array_", _assign_array_HumanPresenceFeatures, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HumanPresenceFeatures), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HumanPresenceFeatures[] = {
        { "is_attention_aware_dimming_supported", reinterpret_cast<getter>(HumanPresenceFeatures_get_IsAttentionAwareDimmingSupported), nullptr, nullptr, nullptr },
        { "is_lock_on_leave_supported", reinterpret_cast<getter>(HumanPresenceFeatures_get_IsLockOnLeaveSupported), nullptr, nullptr, nullptr },
        { "is_wake_on_approach_supported", reinterpret_cast<getter>(HumanPresenceFeatures_get_IsWakeOnApproachSupported), nullptr, nullptr, nullptr },
        { "sensor_id", reinterpret_cast<getter>(HumanPresenceFeatures_get_SensorId), nullptr, nullptr, nullptr },
        { "supported_wake_or_lock_distances_in_millimeters", reinterpret_cast<getter>(HumanPresenceFeatures_get_SupportedWakeOrLockDistancesInMillimeters), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HumanPresenceFeatures[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HumanPresenceFeatures) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HumanPresenceFeatures) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HumanPresenceFeatures) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HumanPresenceFeatures) },
        { },
    };

    static PyType_Spec type_spec_HumanPresenceFeatures =
    {
        "_winsdk_Windows_Devices_Sensors.HumanPresenceFeatures",
        sizeof(py::wrapper::Windows::Devices::Sensors::HumanPresenceFeatures),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HumanPresenceFeatures
    };

    // ----- HumanPresenceSensor class --------------------
    static constexpr const char* const type_name_HumanPresenceSensor = "HumanPresenceSensor";

    static PyObject* _new_HumanPresenceSensor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HumanPresenceSensor);
        return nullptr;
    }

    static void _dealloc_HumanPresenceSensor(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensor* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HumanPresenceSensor_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HumanPresenceSensor", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::HumanPresenceSensor::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSensor_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HumanPresenceSensor", L"GetCurrentReading", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSensor_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HumanPresenceSensor", L"GetDefaultAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::HumanPresenceSensor::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSensor_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HumanPresenceSensor", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::HumanPresenceSensor::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSensor_get_DeviceId(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSensor", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSensor_get_MaxDetectableDistanceInMillimeters(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSensor", L"MaxDetectableDistanceInMillimeters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxDetectableDistanceInMillimeters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSensor_get_MinDetectableDistanceInMillimeters(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSensor", L"MinDetectableDistanceInMillimeters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinDetectableDistanceInMillimeters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSensor_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensor* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.HumanPresenceSensor", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::HumanPresenceSensor, winrt::Windows::Devices::Sensors::HumanPresenceSensorReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSensor_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensor* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.HumanPresenceSensor", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HumanPresenceSensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::HumanPresenceSensor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HumanPresenceSensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::HumanPresenceSensor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HumanPresenceSensor[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(HumanPresenceSensor_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(HumanPresenceSensor_GetCurrentReading), METH_VARARGS, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(HumanPresenceSensor_GetDefaultAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(HumanPresenceSensor_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(HumanPresenceSensor_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(HumanPresenceSensor_remove_ReadingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_HumanPresenceSensor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HumanPresenceSensor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HumanPresenceSensor[] = {
        { "device_id", reinterpret_cast<getter>(HumanPresenceSensor_get_DeviceId), nullptr, nullptr, nullptr },
        { "max_detectable_distance_in_millimeters", reinterpret_cast<getter>(HumanPresenceSensor_get_MaxDetectableDistanceInMillimeters), nullptr, nullptr, nullptr },
        { "min_detectable_distance_in_millimeters", reinterpret_cast<getter>(HumanPresenceSensor_get_MinDetectableDistanceInMillimeters), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HumanPresenceSensor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HumanPresenceSensor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HumanPresenceSensor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HumanPresenceSensor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HumanPresenceSensor) },
        { },
    };

    static PyType_Spec type_spec_HumanPresenceSensor =
    {
        "_winsdk_Windows_Devices_Sensors.HumanPresenceSensor",
        sizeof(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HumanPresenceSensor
    };

    // ----- HumanPresenceSensorReading class --------------------
    static constexpr const char* const type_name_HumanPresenceSensorReading = "HumanPresenceSensorReading";

    static PyObject* _new_HumanPresenceSensorReading(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HumanPresenceSensorReading);
        return nullptr;
    }

    static void _dealloc_HumanPresenceSensorReading(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReading* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HumanPresenceSensorReading_get_DistanceInMillimeters(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSensorReading", L"DistanceInMillimeters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DistanceInMillimeters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSensorReading_get_Engagement(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSensorReading", L"Engagement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Engagement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSensorReading_get_Presence(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSensorReading", L"Presence"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Presence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSensorReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSensorReading", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HumanPresenceSensorReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::HumanPresenceSensorReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HumanPresenceSensorReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::HumanPresenceSensorReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HumanPresenceSensorReading[] = {
        { "_assign_array_", _assign_array_HumanPresenceSensorReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HumanPresenceSensorReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HumanPresenceSensorReading[] = {
        { "distance_in_millimeters", reinterpret_cast<getter>(HumanPresenceSensorReading_get_DistanceInMillimeters), nullptr, nullptr, nullptr },
        { "engagement", reinterpret_cast<getter>(HumanPresenceSensorReading_get_Engagement), nullptr, nullptr, nullptr },
        { "presence", reinterpret_cast<getter>(HumanPresenceSensorReading_get_Presence), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(HumanPresenceSensorReading_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HumanPresenceSensorReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HumanPresenceSensorReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HumanPresenceSensorReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HumanPresenceSensorReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HumanPresenceSensorReading) },
        { },
    };

    static PyType_Spec type_spec_HumanPresenceSensorReading =
    {
        "_winsdk_Windows_Devices_Sensors.HumanPresenceSensorReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HumanPresenceSensorReading
    };

    // ----- HumanPresenceSensorReadingChangedEventArgs class --------------------
    static constexpr const char* const type_name_HumanPresenceSensorReadingChangedEventArgs = "HumanPresenceSensorReadingChangedEventArgs";

    static PyObject* _new_HumanPresenceSensorReadingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HumanPresenceSensorReadingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_HumanPresenceSensorReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HumanPresenceSensorReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSensorReadingChangedEventArgs", L"Reading"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HumanPresenceSensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::HumanPresenceSensorReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HumanPresenceSensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::HumanPresenceSensorReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HumanPresenceSensorReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_HumanPresenceSensorReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HumanPresenceSensorReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HumanPresenceSensorReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(HumanPresenceSensorReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HumanPresenceSensorReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HumanPresenceSensorReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HumanPresenceSensorReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HumanPresenceSensorReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HumanPresenceSensorReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_HumanPresenceSensorReadingChangedEventArgs =
    {
        "_winsdk_Windows_Devices_Sensors.HumanPresenceSensorReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HumanPresenceSensorReadingChangedEventArgs
    };

    // ----- HumanPresenceSettings class --------------------
    static constexpr const char* const type_name_HumanPresenceSettings = "HumanPresenceSettings";

    static PyObject* _new_HumanPresenceSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HumanPresenceSettings);
        return nullptr;
    }

    static void _dealloc_HumanPresenceSettings(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HumanPresenceSettings_GetCurrentSettings(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"GetCurrentSettings", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::HumanPresenceSettings::GetCurrentSettings());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSettings_GetCurrentSettingsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"GetCurrentSettingsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::HumanPresenceSettings::GetCurrentSettingsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSettings_GetSupportedFeaturesForSensorId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"GetSupportedFeaturesForSensorId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::HumanPresenceSettings::GetSupportedFeaturesForSensorId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSettings_GetSupportedFeaturesForSensorIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"GetSupportedFeaturesForSensorIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::HumanPresenceSettings::GetSupportedFeaturesForSensorIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSettings_GetSupportedLockOnLeaveTimeouts(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"GetSupportedLockOnLeaveTimeouts", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::HumanPresenceSettings::GetSupportedLockOnLeaveTimeouts());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSettings_UpdateSettings(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"UpdateSettings", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::HumanPresenceSettings>(args, 0);

                winrt::Windows::Devices::Sensors::HumanPresenceSettings::UpdateSettings(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSettings_UpdateSettingsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"UpdateSettingsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::HumanPresenceSettings>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::HumanPresenceSettings::UpdateSettingsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSettings_get_WakeOnApproachDistanceInMillimeters(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"WakeOnApproachDistanceInMillimeters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WakeOnApproachDistanceInMillimeters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HumanPresenceSettings_put_WakeOnApproachDistanceInMillimeters(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"WakeOnApproachDistanceInMillimeters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.WakeOnApproachDistanceInMillimeters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HumanPresenceSettings_get_SensorId(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"SensorId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SensorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HumanPresenceSettings_put_SensorId(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"SensorId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SensorId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HumanPresenceSettings_get_LockOnLeaveTimeout(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"LockOnLeaveTimeout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LockOnLeaveTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HumanPresenceSettings_put_LockOnLeaveTimeout(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"LockOnLeaveTimeout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.LockOnLeaveTimeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HumanPresenceSettings_get_LockOnLeaveDistanceInMillimeters(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"LockOnLeaveDistanceInMillimeters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LockOnLeaveDistanceInMillimeters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HumanPresenceSettings_put_LockOnLeaveDistanceInMillimeters(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"LockOnLeaveDistanceInMillimeters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.LockOnLeaveDistanceInMillimeters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HumanPresenceSettings_get_IsWakeOnApproachEnabled(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"IsWakeOnApproachEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsWakeOnApproachEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HumanPresenceSettings_put_IsWakeOnApproachEnabled(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"IsWakeOnApproachEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsWakeOnApproachEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HumanPresenceSettings_get_IsLockOnLeaveEnabled(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"IsLockOnLeaveEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsLockOnLeaveEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HumanPresenceSettings_put_IsLockOnLeaveEnabled(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"IsLockOnLeaveEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLockOnLeaveEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HumanPresenceSettings_get_IsAttentionAwareDimmingEnabled(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"IsAttentionAwareDimmingEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsAttentionAwareDimmingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HumanPresenceSettings_put_IsAttentionAwareDimmingEnabled(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"IsAttentionAwareDimmingEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAttentionAwareDimmingEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HumanPresenceSettings_add_SettingsChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"SettingsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::Devices::Sensors::HumanPresenceSettings::SettingsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSettings_remove_SettingsChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"SettingsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Devices::Sensors::HumanPresenceSettings::SettingsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HumanPresenceSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::HumanPresenceSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HumanPresenceSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::HumanPresenceSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HumanPresenceSettings[] = {
        { "get_current_settings", reinterpret_cast<PyCFunction>(HumanPresenceSettings_GetCurrentSettings), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_settings_async", reinterpret_cast<PyCFunction>(HumanPresenceSettings_GetCurrentSettingsAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_supported_features_for_sensor_id", reinterpret_cast<PyCFunction>(HumanPresenceSettings_GetSupportedFeaturesForSensorId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_supported_features_for_sensor_id_async", reinterpret_cast<PyCFunction>(HumanPresenceSettings_GetSupportedFeaturesForSensorIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_supported_lock_on_leave_timeouts", reinterpret_cast<PyCFunction>(HumanPresenceSettings_GetSupportedLockOnLeaveTimeouts), METH_VARARGS | METH_STATIC, nullptr },
        { "update_settings", reinterpret_cast<PyCFunction>(HumanPresenceSettings_UpdateSettings), METH_VARARGS | METH_STATIC, nullptr },
        { "update_settings_async", reinterpret_cast<PyCFunction>(HumanPresenceSettings_UpdateSettingsAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "add_settings_changed", reinterpret_cast<PyCFunction>(HumanPresenceSettings_add_SettingsChanged), METH_O | METH_STATIC, nullptr },
        { "remove_settings_changed", reinterpret_cast<PyCFunction>(HumanPresenceSettings_remove_SettingsChanged), METH_O | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_HumanPresenceSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HumanPresenceSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HumanPresenceSettings[] = {
        { "wake_on_approach_distance_in_millimeters", reinterpret_cast<getter>(HumanPresenceSettings_get_WakeOnApproachDistanceInMillimeters), reinterpret_cast<setter>(HumanPresenceSettings_put_WakeOnApproachDistanceInMillimeters), nullptr, nullptr },
        { "sensor_id", reinterpret_cast<getter>(HumanPresenceSettings_get_SensorId), reinterpret_cast<setter>(HumanPresenceSettings_put_SensorId), nullptr, nullptr },
        { "lock_on_leave_timeout", reinterpret_cast<getter>(HumanPresenceSettings_get_LockOnLeaveTimeout), reinterpret_cast<setter>(HumanPresenceSettings_put_LockOnLeaveTimeout), nullptr, nullptr },
        { "lock_on_leave_distance_in_millimeters", reinterpret_cast<getter>(HumanPresenceSettings_get_LockOnLeaveDistanceInMillimeters), reinterpret_cast<setter>(HumanPresenceSettings_put_LockOnLeaveDistanceInMillimeters), nullptr, nullptr },
        { "is_wake_on_approach_enabled", reinterpret_cast<getter>(HumanPresenceSettings_get_IsWakeOnApproachEnabled), reinterpret_cast<setter>(HumanPresenceSettings_put_IsWakeOnApproachEnabled), nullptr, nullptr },
        { "is_lock_on_leave_enabled", reinterpret_cast<getter>(HumanPresenceSettings_get_IsLockOnLeaveEnabled), reinterpret_cast<setter>(HumanPresenceSettings_put_IsLockOnLeaveEnabled), nullptr, nullptr },
        { "is_attention_aware_dimming_enabled", reinterpret_cast<getter>(HumanPresenceSettings_get_IsAttentionAwareDimmingEnabled), reinterpret_cast<setter>(HumanPresenceSettings_put_IsAttentionAwareDimmingEnabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HumanPresenceSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HumanPresenceSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HumanPresenceSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HumanPresenceSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HumanPresenceSettings) },
        { },
    };

    static PyType_Spec type_spec_HumanPresenceSettings =
    {
        "_winsdk_Windows_Devices_Sensors.HumanPresenceSettings",
        sizeof(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HumanPresenceSettings
    };

    // ----- Inclinometer class --------------------
    static constexpr const char* const type_name_Inclinometer = "Inclinometer";

    static PyObject* _new_Inclinometer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_Inclinometer);
        return nullptr;
    }

    static void _dealloc_Inclinometer(py::wrapper::Windows::Devices::Sensors::Inclinometer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Inclinometer_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Inclinometer", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Inclinometer::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Inclinometer_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Inclinometer", L"GetCurrentReading", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Inclinometer_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Inclinometer", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Inclinometer::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Inclinometer", L"GetDefault", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::SensorReadingType>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Inclinometer::GetDefault(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Inclinometer_GetDefaultForRelativeReadings(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Inclinometer", L"GetDefaultForRelativeReadings", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Inclinometer::GetDefaultForRelativeReadings());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Inclinometer_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Inclinometer", L"GetDeviceSelector", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::SensorReadingType>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Inclinometer::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Inclinometer_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Inclinometer", L"ReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Inclinometer_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Inclinometer", L"ReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Inclinometer_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Inclinometer", L"MinimumReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Inclinometer_get_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Inclinometer", L"ReadingTransform"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReadingTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Inclinometer_put_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Inclinometer", L"ReadingTransform"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Display::DisplayOrientations>(arg);

            self->obj.ReadingTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Inclinometer_get_ReadingType(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Inclinometer", L"ReadingType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReadingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Inclinometer_get_ReportLatency(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Inclinometer", L"ReportLatency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Inclinometer_put_ReportLatency(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Inclinometer", L"ReportLatency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportLatency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Inclinometer_get_MaxBatchSize(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Inclinometer", L"MaxBatchSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Inclinometer_get_ReportThreshold(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Inclinometer", L"ReportThreshold"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportThreshold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Inclinometer_get_DeviceId(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Inclinometer", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Inclinometer_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Inclinometer", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Inclinometer, winrt::Windows::Devices::Sensors::InclinometerReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Inclinometer_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Inclinometer", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Inclinometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::Inclinometer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Inclinometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::Inclinometer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Inclinometer[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(Inclinometer_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(Inclinometer_GetCurrentReading), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(Inclinometer_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_for_relative_readings", reinterpret_cast<PyCFunction>(Inclinometer_GetDefaultForRelativeReadings), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(Inclinometer_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(Inclinometer_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(Inclinometer_remove_ReadingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_Inclinometer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Inclinometer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Inclinometer[] = {
        { "report_interval", reinterpret_cast<getter>(Inclinometer_get_ReportInterval), reinterpret_cast<setter>(Inclinometer_put_ReportInterval), nullptr, nullptr },
        { "minimum_report_interval", reinterpret_cast<getter>(Inclinometer_get_MinimumReportInterval), nullptr, nullptr, nullptr },
        { "reading_transform", reinterpret_cast<getter>(Inclinometer_get_ReadingTransform), reinterpret_cast<setter>(Inclinometer_put_ReadingTransform), nullptr, nullptr },
        { "reading_type", reinterpret_cast<getter>(Inclinometer_get_ReadingType), nullptr, nullptr, nullptr },
        { "report_latency", reinterpret_cast<getter>(Inclinometer_get_ReportLatency), reinterpret_cast<setter>(Inclinometer_put_ReportLatency), nullptr, nullptr },
        { "max_batch_size", reinterpret_cast<getter>(Inclinometer_get_MaxBatchSize), nullptr, nullptr, nullptr },
        { "report_threshold", reinterpret_cast<getter>(Inclinometer_get_ReportThreshold), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(Inclinometer_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Inclinometer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Inclinometer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Inclinometer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Inclinometer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Inclinometer) },
        { },
    };

    static PyType_Spec type_spec_Inclinometer =
    {
        "_winsdk_Windows_Devices_Sensors.Inclinometer",
        sizeof(py::wrapper::Windows::Devices::Sensors::Inclinometer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Inclinometer
    };

    // ----- InclinometerDataThreshold class --------------------
    static constexpr const char* const type_name_InclinometerDataThreshold = "InclinometerDataThreshold";

    static PyObject* _new_InclinometerDataThreshold(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_InclinometerDataThreshold);
        return nullptr;
    }

    static void _dealloc_InclinometerDataThreshold(py::wrapper::Windows::Devices::Sensors::InclinometerDataThreshold* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InclinometerDataThreshold_get_YawInDegrees(py::wrapper::Windows::Devices::Sensors::InclinometerDataThreshold* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerDataThreshold", L"YawInDegrees"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.YawInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InclinometerDataThreshold_put_YawInDegrees(py::wrapper::Windows::Devices::Sensors::InclinometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerDataThreshold", L"YawInDegrees"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.YawInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InclinometerDataThreshold_get_RollInDegrees(py::wrapper::Windows::Devices::Sensors::InclinometerDataThreshold* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerDataThreshold", L"RollInDegrees"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RollInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InclinometerDataThreshold_put_RollInDegrees(py::wrapper::Windows::Devices::Sensors::InclinometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerDataThreshold", L"RollInDegrees"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.RollInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InclinometerDataThreshold_get_PitchInDegrees(py::wrapper::Windows::Devices::Sensors::InclinometerDataThreshold* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerDataThreshold", L"PitchInDegrees"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PitchInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InclinometerDataThreshold_put_PitchInDegrees(py::wrapper::Windows::Devices::Sensors::InclinometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerDataThreshold", L"PitchInDegrees"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.PitchInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InclinometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::InclinometerDataThreshold>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InclinometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::InclinometerDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InclinometerDataThreshold[] = {
        { "_assign_array_", _assign_array_InclinometerDataThreshold, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InclinometerDataThreshold), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InclinometerDataThreshold[] = {
        { "yaw_in_degrees", reinterpret_cast<getter>(InclinometerDataThreshold_get_YawInDegrees), reinterpret_cast<setter>(InclinometerDataThreshold_put_YawInDegrees), nullptr, nullptr },
        { "roll_in_degrees", reinterpret_cast<getter>(InclinometerDataThreshold_get_RollInDegrees), reinterpret_cast<setter>(InclinometerDataThreshold_put_RollInDegrees), nullptr, nullptr },
        { "pitch_in_degrees", reinterpret_cast<getter>(InclinometerDataThreshold_get_PitchInDegrees), reinterpret_cast<setter>(InclinometerDataThreshold_put_PitchInDegrees), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InclinometerDataThreshold[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InclinometerDataThreshold) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InclinometerDataThreshold) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InclinometerDataThreshold) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InclinometerDataThreshold) },
        { },
    };

    static PyType_Spec type_spec_InclinometerDataThreshold =
    {
        "_winsdk_Windows_Devices_Sensors.InclinometerDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::InclinometerDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InclinometerDataThreshold
    };

    // ----- InclinometerReading class --------------------
    static constexpr const char* const type_name_InclinometerReading = "InclinometerReading";

    static PyObject* _new_InclinometerReading(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_InclinometerReading);
        return nullptr;
    }

    static void _dealloc_InclinometerReading(py::wrapper::Windows::Devices::Sensors::InclinometerReading* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InclinometerReading_get_PitchDegrees(py::wrapper::Windows::Devices::Sensors::InclinometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerReading", L"PitchDegrees"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PitchDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InclinometerReading_get_RollDegrees(py::wrapper::Windows::Devices::Sensors::InclinometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerReading", L"RollDegrees"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RollDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InclinometerReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::InclinometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerReading", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InclinometerReading_get_YawDegrees(py::wrapper::Windows::Devices::Sensors::InclinometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerReading", L"YawDegrees"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.YawDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InclinometerReading_get_PerformanceCount(py::wrapper::Windows::Devices::Sensors::InclinometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerReading", L"PerformanceCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InclinometerReading_get_Properties(py::wrapper::Windows::Devices::Sensors::InclinometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerReading", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InclinometerReading_get_YawAccuracy(py::wrapper::Windows::Devices::Sensors::InclinometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerReading", L"YawAccuracy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.YawAccuracy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InclinometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::InclinometerReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InclinometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::InclinometerReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InclinometerReading[] = {
        { "_assign_array_", _assign_array_InclinometerReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InclinometerReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InclinometerReading[] = {
        { "pitch_degrees", reinterpret_cast<getter>(InclinometerReading_get_PitchDegrees), nullptr, nullptr, nullptr },
        { "roll_degrees", reinterpret_cast<getter>(InclinometerReading_get_RollDegrees), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(InclinometerReading_get_Timestamp), nullptr, nullptr, nullptr },
        { "yaw_degrees", reinterpret_cast<getter>(InclinometerReading_get_YawDegrees), nullptr, nullptr, nullptr },
        { "performance_count", reinterpret_cast<getter>(InclinometerReading_get_PerformanceCount), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(InclinometerReading_get_Properties), nullptr, nullptr, nullptr },
        { "yaw_accuracy", reinterpret_cast<getter>(InclinometerReading_get_YawAccuracy), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InclinometerReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InclinometerReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InclinometerReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InclinometerReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InclinometerReading) },
        { },
    };

    static PyType_Spec type_spec_InclinometerReading =
    {
        "_winsdk_Windows_Devices_Sensors.InclinometerReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::InclinometerReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InclinometerReading
    };

    // ----- InclinometerReadingChangedEventArgs class --------------------
    static constexpr const char* const type_name_InclinometerReadingChangedEventArgs = "InclinometerReadingChangedEventArgs";

    static PyObject* _new_InclinometerReadingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_InclinometerReadingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_InclinometerReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::InclinometerReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InclinometerReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::InclinometerReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerReadingChangedEventArgs", L"Reading"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InclinometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::InclinometerReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InclinometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::InclinometerReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InclinometerReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_InclinometerReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InclinometerReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InclinometerReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(InclinometerReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InclinometerReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InclinometerReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InclinometerReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InclinometerReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InclinometerReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_InclinometerReadingChangedEventArgs =
    {
        "_winsdk_Windows_Devices_Sensors.InclinometerReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::InclinometerReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InclinometerReadingChangedEventArgs
    };

    // ----- LightSensor class --------------------
    static constexpr const char* const type_name_LightSensor = "LightSensor";

    static PyObject* _new_LightSensor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LightSensor);
        return nullptr;
    }

    static void _dealloc_LightSensor(py::wrapper::Windows::Devices::Sensors::LightSensor* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LightSensor_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.LightSensor", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::LightSensor::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LightSensor_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::LightSensor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.LightSensor", L"GetCurrentReading", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LightSensor_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.LightSensor", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::LightSensor::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LightSensor_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.LightSensor", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::LightSensor::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LightSensor_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::LightSensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensor", L"ReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LightSensor_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::LightSensor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensor", L"ReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LightSensor_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::LightSensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensor", L"MinimumReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LightSensor_get_ReportLatency(py::wrapper::Windows::Devices::Sensors::LightSensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensor", L"ReportLatency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LightSensor_put_ReportLatency(py::wrapper::Windows::Devices::Sensors::LightSensor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensor", L"ReportLatency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportLatency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LightSensor_get_MaxBatchSize(py::wrapper::Windows::Devices::Sensors::LightSensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensor", L"MaxBatchSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LightSensor_get_ReportThreshold(py::wrapper::Windows::Devices::Sensors::LightSensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensor", L"ReportThreshold"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportThreshold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LightSensor_get_DeviceId(py::wrapper::Windows::Devices::Sensors::LightSensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensor", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LightSensor_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::LightSensor* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.LightSensor", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::LightSensor, winrt::Windows::Devices::Sensors::LightSensorReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LightSensor_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::LightSensor* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.LightSensor", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LightSensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::LightSensor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LightSensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::LightSensor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LightSensor[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(LightSensor_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(LightSensor_GetCurrentReading), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(LightSensor_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(LightSensor_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(LightSensor_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(LightSensor_remove_ReadingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_LightSensor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LightSensor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LightSensor[] = {
        { "report_interval", reinterpret_cast<getter>(LightSensor_get_ReportInterval), reinterpret_cast<setter>(LightSensor_put_ReportInterval), nullptr, nullptr },
        { "minimum_report_interval", reinterpret_cast<getter>(LightSensor_get_MinimumReportInterval), nullptr, nullptr, nullptr },
        { "report_latency", reinterpret_cast<getter>(LightSensor_get_ReportLatency), reinterpret_cast<setter>(LightSensor_put_ReportLatency), nullptr, nullptr },
        { "max_batch_size", reinterpret_cast<getter>(LightSensor_get_MaxBatchSize), nullptr, nullptr, nullptr },
        { "report_threshold", reinterpret_cast<getter>(LightSensor_get_ReportThreshold), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(LightSensor_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LightSensor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LightSensor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LightSensor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LightSensor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LightSensor) },
        { },
    };

    static PyType_Spec type_spec_LightSensor =
    {
        "_winsdk_Windows_Devices_Sensors.LightSensor",
        sizeof(py::wrapper::Windows::Devices::Sensors::LightSensor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LightSensor
    };

    // ----- LightSensorDataThreshold class --------------------
    static constexpr const char* const type_name_LightSensorDataThreshold = "LightSensorDataThreshold";

    static PyObject* _new_LightSensorDataThreshold(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LightSensorDataThreshold);
        return nullptr;
    }

    static void _dealloc_LightSensorDataThreshold(py::wrapper::Windows::Devices::Sensors::LightSensorDataThreshold* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LightSensorDataThreshold_get_LuxPercentage(py::wrapper::Windows::Devices::Sensors::LightSensorDataThreshold* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensorDataThreshold", L"LuxPercentage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LuxPercentage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LightSensorDataThreshold_put_LuxPercentage(py::wrapper::Windows::Devices::Sensors::LightSensorDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensorDataThreshold", L"LuxPercentage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.LuxPercentage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LightSensorDataThreshold_get_AbsoluteLux(py::wrapper::Windows::Devices::Sensors::LightSensorDataThreshold* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensorDataThreshold", L"AbsoluteLux"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AbsoluteLux());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LightSensorDataThreshold_put_AbsoluteLux(py::wrapper::Windows::Devices::Sensors::LightSensorDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensorDataThreshold", L"AbsoluteLux"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.AbsoluteLux(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_LightSensorDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::LightSensorDataThreshold>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LightSensorDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::LightSensorDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LightSensorDataThreshold[] = {
        { "_assign_array_", _assign_array_LightSensorDataThreshold, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LightSensorDataThreshold), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LightSensorDataThreshold[] = {
        { "lux_percentage", reinterpret_cast<getter>(LightSensorDataThreshold_get_LuxPercentage), reinterpret_cast<setter>(LightSensorDataThreshold_put_LuxPercentage), nullptr, nullptr },
        { "absolute_lux", reinterpret_cast<getter>(LightSensorDataThreshold_get_AbsoluteLux), reinterpret_cast<setter>(LightSensorDataThreshold_put_AbsoluteLux), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LightSensorDataThreshold[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LightSensorDataThreshold) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LightSensorDataThreshold) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LightSensorDataThreshold) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LightSensorDataThreshold) },
        { },
    };

    static PyType_Spec type_spec_LightSensorDataThreshold =
    {
        "_winsdk_Windows_Devices_Sensors.LightSensorDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::LightSensorDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LightSensorDataThreshold
    };

    // ----- LightSensorReading class --------------------
    static constexpr const char* const type_name_LightSensorReading = "LightSensorReading";

    static PyObject* _new_LightSensorReading(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LightSensorReading);
        return nullptr;
    }

    static void _dealloc_LightSensorReading(py::wrapper::Windows::Devices::Sensors::LightSensorReading* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LightSensorReading_get_IlluminanceInLux(py::wrapper::Windows::Devices::Sensors::LightSensorReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensorReading", L"IlluminanceInLux"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IlluminanceInLux());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LightSensorReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::LightSensorReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensorReading", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LightSensorReading_get_PerformanceCount(py::wrapper::Windows::Devices::Sensors::LightSensorReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensorReading", L"PerformanceCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LightSensorReading_get_Properties(py::wrapper::Windows::Devices::Sensors::LightSensorReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensorReading", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LightSensorReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::LightSensorReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LightSensorReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::LightSensorReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LightSensorReading[] = {
        { "_assign_array_", _assign_array_LightSensorReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LightSensorReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LightSensorReading[] = {
        { "illuminance_in_lux", reinterpret_cast<getter>(LightSensorReading_get_IlluminanceInLux), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(LightSensorReading_get_Timestamp), nullptr, nullptr, nullptr },
        { "performance_count", reinterpret_cast<getter>(LightSensorReading_get_PerformanceCount), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(LightSensorReading_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LightSensorReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LightSensorReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LightSensorReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LightSensorReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LightSensorReading) },
        { },
    };

    static PyType_Spec type_spec_LightSensorReading =
    {
        "_winsdk_Windows_Devices_Sensors.LightSensorReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::LightSensorReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LightSensorReading
    };

    // ----- LightSensorReadingChangedEventArgs class --------------------
    static constexpr const char* const type_name_LightSensorReadingChangedEventArgs = "LightSensorReadingChangedEventArgs";

    static PyObject* _new_LightSensorReadingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LightSensorReadingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_LightSensorReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::LightSensorReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LightSensorReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::LightSensorReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensorReadingChangedEventArgs", L"Reading"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LightSensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::LightSensorReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LightSensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::LightSensorReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LightSensorReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_LightSensorReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LightSensorReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LightSensorReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(LightSensorReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LightSensorReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LightSensorReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LightSensorReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LightSensorReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LightSensorReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_LightSensorReadingChangedEventArgs =
    {
        "_winsdk_Windows_Devices_Sensors.LightSensorReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::LightSensorReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LightSensorReadingChangedEventArgs
    };

    // ----- Magnetometer class --------------------
    static constexpr const char* const type_name_Magnetometer = "Magnetometer";

    static PyObject* _new_Magnetometer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_Magnetometer);
        return nullptr;
    }

    static void _dealloc_Magnetometer(py::wrapper::Windows::Devices::Sensors::Magnetometer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Magnetometer_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Magnetometer", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Magnetometer::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Magnetometer_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Magnetometer", L"GetCurrentReading", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Magnetometer_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Magnetometer", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Magnetometer::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Magnetometer_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Magnetometer", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Magnetometer::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Magnetometer_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Magnetometer", L"ReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Magnetometer_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Magnetometer", L"ReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Magnetometer_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Magnetometer", L"MinimumReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Magnetometer_get_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Magnetometer", L"ReadingTransform"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReadingTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Magnetometer_put_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Magnetometer", L"ReadingTransform"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Display::DisplayOrientations>(arg);

            self->obj.ReadingTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Magnetometer_get_ReportLatency(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Magnetometer", L"ReportLatency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Magnetometer_put_ReportLatency(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Magnetometer", L"ReportLatency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportLatency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Magnetometer_get_MaxBatchSize(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Magnetometer", L"MaxBatchSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Magnetometer_get_ReportThreshold(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Magnetometer", L"ReportThreshold"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportThreshold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Magnetometer_get_DeviceId(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Magnetometer", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Magnetometer_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Magnetometer", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Magnetometer, winrt::Windows::Devices::Sensors::MagnetometerReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Magnetometer_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Magnetometer", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Magnetometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::Magnetometer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Magnetometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::Magnetometer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Magnetometer[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(Magnetometer_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(Magnetometer_GetCurrentReading), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(Magnetometer_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(Magnetometer_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(Magnetometer_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(Magnetometer_remove_ReadingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_Magnetometer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Magnetometer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Magnetometer[] = {
        { "report_interval", reinterpret_cast<getter>(Magnetometer_get_ReportInterval), reinterpret_cast<setter>(Magnetometer_put_ReportInterval), nullptr, nullptr },
        { "minimum_report_interval", reinterpret_cast<getter>(Magnetometer_get_MinimumReportInterval), nullptr, nullptr, nullptr },
        { "reading_transform", reinterpret_cast<getter>(Magnetometer_get_ReadingTransform), reinterpret_cast<setter>(Magnetometer_put_ReadingTransform), nullptr, nullptr },
        { "report_latency", reinterpret_cast<getter>(Magnetometer_get_ReportLatency), reinterpret_cast<setter>(Magnetometer_put_ReportLatency), nullptr, nullptr },
        { "max_batch_size", reinterpret_cast<getter>(Magnetometer_get_MaxBatchSize), nullptr, nullptr, nullptr },
        { "report_threshold", reinterpret_cast<getter>(Magnetometer_get_ReportThreshold), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(Magnetometer_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Magnetometer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Magnetometer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Magnetometer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Magnetometer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Magnetometer) },
        { },
    };

    static PyType_Spec type_spec_Magnetometer =
    {
        "_winsdk_Windows_Devices_Sensors.Magnetometer",
        sizeof(py::wrapper::Windows::Devices::Sensors::Magnetometer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Magnetometer
    };

    // ----- MagnetometerDataThreshold class --------------------
    static constexpr const char* const type_name_MagnetometerDataThreshold = "MagnetometerDataThreshold";

    static PyObject* _new_MagnetometerDataThreshold(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MagnetometerDataThreshold);
        return nullptr;
    }

    static void _dealloc_MagnetometerDataThreshold(py::wrapper::Windows::Devices::Sensors::MagnetometerDataThreshold* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MagnetometerDataThreshold_get_ZAxisMicroteslas(py::wrapper::Windows::Devices::Sensors::MagnetometerDataThreshold* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerDataThreshold", L"ZAxisMicroteslas"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZAxisMicroteslas());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MagnetometerDataThreshold_put_ZAxisMicroteslas(py::wrapper::Windows::Devices::Sensors::MagnetometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerDataThreshold", L"ZAxisMicroteslas"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.ZAxisMicroteslas(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MagnetometerDataThreshold_get_YAxisMicroteslas(py::wrapper::Windows::Devices::Sensors::MagnetometerDataThreshold* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerDataThreshold", L"YAxisMicroteslas"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.YAxisMicroteslas());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MagnetometerDataThreshold_put_YAxisMicroteslas(py::wrapper::Windows::Devices::Sensors::MagnetometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerDataThreshold", L"YAxisMicroteslas"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.YAxisMicroteslas(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MagnetometerDataThreshold_get_XAxisMicroteslas(py::wrapper::Windows::Devices::Sensors::MagnetometerDataThreshold* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerDataThreshold", L"XAxisMicroteslas"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.XAxisMicroteslas());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MagnetometerDataThreshold_put_XAxisMicroteslas(py::wrapper::Windows::Devices::Sensors::MagnetometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerDataThreshold", L"XAxisMicroteslas"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.XAxisMicroteslas(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MagnetometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::MagnetometerDataThreshold>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MagnetometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::MagnetometerDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagnetometerDataThreshold[] = {
        { "_assign_array_", _assign_array_MagnetometerDataThreshold, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MagnetometerDataThreshold), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagnetometerDataThreshold[] = {
        { "z_axis_microteslas", reinterpret_cast<getter>(MagnetometerDataThreshold_get_ZAxisMicroteslas), reinterpret_cast<setter>(MagnetometerDataThreshold_put_ZAxisMicroteslas), nullptr, nullptr },
        { "y_axis_microteslas", reinterpret_cast<getter>(MagnetometerDataThreshold_get_YAxisMicroteslas), reinterpret_cast<setter>(MagnetometerDataThreshold_put_YAxisMicroteslas), nullptr, nullptr },
        { "x_axis_microteslas", reinterpret_cast<getter>(MagnetometerDataThreshold_get_XAxisMicroteslas), reinterpret_cast<setter>(MagnetometerDataThreshold_put_XAxisMicroteslas), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagnetometerDataThreshold[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagnetometerDataThreshold) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MagnetometerDataThreshold) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagnetometerDataThreshold) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagnetometerDataThreshold) },
        { },
    };

    static PyType_Spec type_spec_MagnetometerDataThreshold =
    {
        "_winsdk_Windows_Devices_Sensors.MagnetometerDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::MagnetometerDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagnetometerDataThreshold
    };

    // ----- MagnetometerReading class --------------------
    static constexpr const char* const type_name_MagnetometerReading = "MagnetometerReading";

    static PyObject* _new_MagnetometerReading(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MagnetometerReading);
        return nullptr;
    }

    static void _dealloc_MagnetometerReading(py::wrapper::Windows::Devices::Sensors::MagnetometerReading* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MagnetometerReading_get_DirectionalAccuracy(py::wrapper::Windows::Devices::Sensors::MagnetometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerReading", L"DirectionalAccuracy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DirectionalAccuracy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagnetometerReading_get_MagneticFieldX(py::wrapper::Windows::Devices::Sensors::MagnetometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerReading", L"MagneticFieldX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MagneticFieldX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagnetometerReading_get_MagneticFieldY(py::wrapper::Windows::Devices::Sensors::MagnetometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerReading", L"MagneticFieldY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MagneticFieldY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagnetometerReading_get_MagneticFieldZ(py::wrapper::Windows::Devices::Sensors::MagnetometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerReading", L"MagneticFieldZ"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MagneticFieldZ());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagnetometerReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::MagnetometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerReading", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagnetometerReading_get_PerformanceCount(py::wrapper::Windows::Devices::Sensors::MagnetometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerReading", L"PerformanceCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagnetometerReading_get_Properties(py::wrapper::Windows::Devices::Sensors::MagnetometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerReading", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MagnetometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::MagnetometerReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MagnetometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::MagnetometerReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagnetometerReading[] = {
        { "_assign_array_", _assign_array_MagnetometerReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MagnetometerReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagnetometerReading[] = {
        { "directional_accuracy", reinterpret_cast<getter>(MagnetometerReading_get_DirectionalAccuracy), nullptr, nullptr, nullptr },
        { "magnetic_field_x", reinterpret_cast<getter>(MagnetometerReading_get_MagneticFieldX), nullptr, nullptr, nullptr },
        { "magnetic_field_y", reinterpret_cast<getter>(MagnetometerReading_get_MagneticFieldY), nullptr, nullptr, nullptr },
        { "magnetic_field_z", reinterpret_cast<getter>(MagnetometerReading_get_MagneticFieldZ), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MagnetometerReading_get_Timestamp), nullptr, nullptr, nullptr },
        { "performance_count", reinterpret_cast<getter>(MagnetometerReading_get_PerformanceCount), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(MagnetometerReading_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagnetometerReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagnetometerReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MagnetometerReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagnetometerReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagnetometerReading) },
        { },
    };

    static PyType_Spec type_spec_MagnetometerReading =
    {
        "_winsdk_Windows_Devices_Sensors.MagnetometerReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::MagnetometerReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagnetometerReading
    };

    // ----- MagnetometerReadingChangedEventArgs class --------------------
    static constexpr const char* const type_name_MagnetometerReadingChangedEventArgs = "MagnetometerReadingChangedEventArgs";

    static PyObject* _new_MagnetometerReadingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MagnetometerReadingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_MagnetometerReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::MagnetometerReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MagnetometerReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::MagnetometerReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerReadingChangedEventArgs", L"Reading"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MagnetometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::MagnetometerReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MagnetometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::MagnetometerReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagnetometerReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_MagnetometerReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MagnetometerReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagnetometerReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(MagnetometerReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagnetometerReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagnetometerReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MagnetometerReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagnetometerReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagnetometerReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MagnetometerReadingChangedEventArgs =
    {
        "_winsdk_Windows_Devices_Sensors.MagnetometerReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::MagnetometerReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagnetometerReadingChangedEventArgs
    };

    // ----- OrientationSensor class --------------------
    static constexpr const char* const type_name_OrientationSensor = "OrientationSensor";

    static PyObject* _new_OrientationSensor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_OrientationSensor);
        return nullptr;
    }

    static void _dealloc_OrientationSensor(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* OrientationSensor_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.OrientationSensor", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::OrientationSensor::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.OrientationSensor", L"GetCurrentReading", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.OrientationSensor", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::OrientationSensor::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.OrientationSensor", L"GetDefault", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::SensorReadingType>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::OrientationSensor::GetDefault(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.OrientationSensor", L"GetDefault", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::SensorReadingType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Sensors::SensorOptimizationGoal>(args, 1);

                return py::convert(winrt::Windows::Devices::Sensors::OrientationSensor::GetDefault(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_GetDefaultForRelativeReadings(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.OrientationSensor", L"GetDefaultForRelativeReadings", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::OrientationSensor::GetDefaultForRelativeReadings());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.OrientationSensor", L"GetDeviceSelector", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::SensorReadingType>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::OrientationSensor::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.OrientationSensor", L"GetDeviceSelector", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::SensorReadingType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Sensors::SensorOptimizationGoal>(args, 1);

                return py::convert(winrt::Windows::Devices::Sensors::OrientationSensor::GetDeviceSelector(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensor", L"ReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int OrientationSensor_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensor", L"ReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* OrientationSensor_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensor", L"MinimumReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_get_ReadingTransform(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensor", L"ReadingTransform"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReadingTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int OrientationSensor_put_ReadingTransform(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensor", L"ReadingTransform"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Display::DisplayOrientations>(arg);

            self->obj.ReadingTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* OrientationSensor_get_ReadingType(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensor", L"ReadingType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReadingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_get_ReportLatency(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensor", L"ReportLatency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int OrientationSensor_put_ReportLatency(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensor", L"ReportLatency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportLatency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* OrientationSensor_get_MaxBatchSize(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensor", L"MaxBatchSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_get_DeviceId(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensor", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.OrientationSensor", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::OrientationSensor, winrt::Windows::Devices::Sensors::OrientationSensorReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.OrientationSensor", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_OrientationSensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::OrientationSensor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_OrientationSensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::OrientationSensor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_OrientationSensor[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(OrientationSensor_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(OrientationSensor_GetCurrentReading), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(OrientationSensor_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_for_relative_readings", reinterpret_cast<PyCFunction>(OrientationSensor_GetDefaultForRelativeReadings), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(OrientationSensor_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(OrientationSensor_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(OrientationSensor_remove_ReadingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_OrientationSensor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_OrientationSensor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_OrientationSensor[] = {
        { "report_interval", reinterpret_cast<getter>(OrientationSensor_get_ReportInterval), reinterpret_cast<setter>(OrientationSensor_put_ReportInterval), nullptr, nullptr },
        { "minimum_report_interval", reinterpret_cast<getter>(OrientationSensor_get_MinimumReportInterval), nullptr, nullptr, nullptr },
        { "reading_transform", reinterpret_cast<getter>(OrientationSensor_get_ReadingTransform), reinterpret_cast<setter>(OrientationSensor_put_ReadingTransform), nullptr, nullptr },
        { "reading_type", reinterpret_cast<getter>(OrientationSensor_get_ReadingType), nullptr, nullptr, nullptr },
        { "report_latency", reinterpret_cast<getter>(OrientationSensor_get_ReportLatency), reinterpret_cast<setter>(OrientationSensor_put_ReportLatency), nullptr, nullptr },
        { "max_batch_size", reinterpret_cast<getter>(OrientationSensor_get_MaxBatchSize), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(OrientationSensor_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_OrientationSensor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_OrientationSensor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_OrientationSensor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_OrientationSensor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_OrientationSensor) },
        { },
    };

    static PyType_Spec type_spec_OrientationSensor =
    {
        "_winsdk_Windows_Devices_Sensors.OrientationSensor",
        sizeof(py::wrapper::Windows::Devices::Sensors::OrientationSensor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_OrientationSensor
    };

    // ----- OrientationSensorReading class --------------------
    static constexpr const char* const type_name_OrientationSensorReading = "OrientationSensorReading";

    static PyObject* _new_OrientationSensorReading(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_OrientationSensorReading);
        return nullptr;
    }

    static void _dealloc_OrientationSensorReading(py::wrapper::Windows::Devices::Sensors::OrientationSensorReading* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* OrientationSensorReading_get_Quaternion(py::wrapper::Windows::Devices::Sensors::OrientationSensorReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensorReading", L"Quaternion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Quaternion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensorReading_get_RotationMatrix(py::wrapper::Windows::Devices::Sensors::OrientationSensorReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensorReading", L"RotationMatrix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RotationMatrix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensorReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::OrientationSensorReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensorReading", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensorReading_get_PerformanceCount(py::wrapper::Windows::Devices::Sensors::OrientationSensorReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensorReading", L"PerformanceCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensorReading_get_Properties(py::wrapper::Windows::Devices::Sensors::OrientationSensorReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensorReading", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensorReading_get_YawAccuracy(py::wrapper::Windows::Devices::Sensors::OrientationSensorReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensorReading", L"YawAccuracy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.YawAccuracy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_OrientationSensorReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::OrientationSensorReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_OrientationSensorReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::OrientationSensorReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_OrientationSensorReading[] = {
        { "_assign_array_", _assign_array_OrientationSensorReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_OrientationSensorReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_OrientationSensorReading[] = {
        { "quaternion", reinterpret_cast<getter>(OrientationSensorReading_get_Quaternion), nullptr, nullptr, nullptr },
        { "rotation_matrix", reinterpret_cast<getter>(OrientationSensorReading_get_RotationMatrix), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(OrientationSensorReading_get_Timestamp), nullptr, nullptr, nullptr },
        { "performance_count", reinterpret_cast<getter>(OrientationSensorReading_get_PerformanceCount), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(OrientationSensorReading_get_Properties), nullptr, nullptr, nullptr },
        { "yaw_accuracy", reinterpret_cast<getter>(OrientationSensorReading_get_YawAccuracy), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_OrientationSensorReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_OrientationSensorReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_OrientationSensorReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_OrientationSensorReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_OrientationSensorReading) },
        { },
    };

    static PyType_Spec type_spec_OrientationSensorReading =
    {
        "_winsdk_Windows_Devices_Sensors.OrientationSensorReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::OrientationSensorReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_OrientationSensorReading
    };

    // ----- OrientationSensorReadingChangedEventArgs class --------------------
    static constexpr const char* const type_name_OrientationSensorReadingChangedEventArgs = "OrientationSensorReadingChangedEventArgs";

    static PyObject* _new_OrientationSensorReadingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_OrientationSensorReadingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_OrientationSensorReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::OrientationSensorReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* OrientationSensorReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::OrientationSensorReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensorReadingChangedEventArgs", L"Reading"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_OrientationSensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::OrientationSensorReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_OrientationSensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::OrientationSensorReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_OrientationSensorReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_OrientationSensorReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_OrientationSensorReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_OrientationSensorReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(OrientationSensorReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_OrientationSensorReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_OrientationSensorReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_OrientationSensorReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_OrientationSensorReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_OrientationSensorReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_OrientationSensorReadingChangedEventArgs =
    {
        "_winsdk_Windows_Devices_Sensors.OrientationSensorReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::OrientationSensorReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_OrientationSensorReadingChangedEventArgs
    };

    // ----- Pedometer class --------------------
    static constexpr const char* const type_name_Pedometer = "Pedometer";

    static PyObject* _new_Pedometer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_Pedometer);
        return nullptr;
    }

    static void _dealloc_Pedometer(py::wrapper::Windows::Devices::Sensors::Pedometer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Pedometer_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Pedometer", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Pedometer::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Pedometer_GetCurrentReadings(py::wrapper::Windows::Devices::Sensors::Pedometer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Pedometer", L"GetCurrentReadings", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentReadings());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Pedometer_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Pedometer", L"GetDefaultAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Pedometer::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Pedometer_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Pedometer", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Pedometer::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Pedometer_GetReadingsFromTriggerDetails(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Pedometer", L"GetReadingsFromTriggerDetails", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Pedometer::GetReadingsFromTriggerDetails(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Pedometer_GetSystemHistoryAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Pedometer", L"GetSystemHistoryAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Pedometer::GetSystemHistoryAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Pedometer", L"GetSystemHistoryAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(winrt::Windows::Devices::Sensors::Pedometer::GetSystemHistoryAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Pedometer_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::Pedometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Pedometer", L"ReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Pedometer_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::Pedometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Pedometer", L"ReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Pedometer_get_DeviceId(py::wrapper::Windows::Devices::Sensors::Pedometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Pedometer", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Pedometer_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::Pedometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Pedometer", L"MinimumReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Pedometer_get_PowerInMilliwatts(py::wrapper::Windows::Devices::Sensors::Pedometer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Pedometer", L"PowerInMilliwatts"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PowerInMilliwatts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Pedometer_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Pedometer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Pedometer", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Pedometer, winrt::Windows::Devices::Sensors::PedometerReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Pedometer_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Pedometer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Pedometer", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Pedometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::Pedometer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Pedometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::Pedometer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Pedometer[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(Pedometer_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_readings", reinterpret_cast<PyCFunction>(Pedometer_GetCurrentReadings), METH_VARARGS, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(Pedometer_GetDefaultAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(Pedometer_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_readings_from_trigger_details", reinterpret_cast<PyCFunction>(Pedometer_GetReadingsFromTriggerDetails), METH_VARARGS | METH_STATIC, nullptr },
        { "get_system_history_async", reinterpret_cast<PyCFunction>(Pedometer_GetSystemHistoryAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(Pedometer_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(Pedometer_remove_ReadingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_Pedometer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Pedometer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Pedometer[] = {
        { "report_interval", reinterpret_cast<getter>(Pedometer_get_ReportInterval), reinterpret_cast<setter>(Pedometer_put_ReportInterval), nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(Pedometer_get_DeviceId), nullptr, nullptr, nullptr },
        { "minimum_report_interval", reinterpret_cast<getter>(Pedometer_get_MinimumReportInterval), nullptr, nullptr, nullptr },
        { "power_in_milliwatts", reinterpret_cast<getter>(Pedometer_get_PowerInMilliwatts), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Pedometer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Pedometer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Pedometer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Pedometer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Pedometer) },
        { },
    };

    static PyType_Spec type_spec_Pedometer =
    {
        "_winsdk_Windows_Devices_Sensors.Pedometer",
        sizeof(py::wrapper::Windows::Devices::Sensors::Pedometer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Pedometer
    };

    // ----- PedometerDataThreshold class --------------------
    static constexpr const char* const type_name_PedometerDataThreshold = "PedometerDataThreshold";

    static PyObject* _new_PedometerDataThreshold(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::Pedometer>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                winrt::Windows::Devices::Sensors::PedometerDataThreshold instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PedometerDataThreshold(py::wrapper::Windows::Devices::Sensors::PedometerDataThreshold* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PedometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::PedometerDataThreshold>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PedometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::PedometerDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PedometerDataThreshold[] = {
        { "_assign_array_", _assign_array_PedometerDataThreshold, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PedometerDataThreshold), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PedometerDataThreshold[] = {
        { }
    };

    static PyType_Slot _type_slots_PedometerDataThreshold[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PedometerDataThreshold) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PedometerDataThreshold) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PedometerDataThreshold) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PedometerDataThreshold) },
        { },
    };

    static PyType_Spec type_spec_PedometerDataThreshold =
    {
        "_winsdk_Windows_Devices_Sensors.PedometerDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::PedometerDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PedometerDataThreshold
    };

    // ----- PedometerReading class --------------------
    static constexpr const char* const type_name_PedometerReading = "PedometerReading";

    static PyObject* _new_PedometerReading(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PedometerReading);
        return nullptr;
    }

    static void _dealloc_PedometerReading(py::wrapper::Windows::Devices::Sensors::PedometerReading* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PedometerReading_get_CumulativeSteps(py::wrapper::Windows::Devices::Sensors::PedometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.PedometerReading", L"CumulativeSteps"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CumulativeSteps());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PedometerReading_get_CumulativeStepsDuration(py::wrapper::Windows::Devices::Sensors::PedometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.PedometerReading", L"CumulativeStepsDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CumulativeStepsDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PedometerReading_get_StepKind(py::wrapper::Windows::Devices::Sensors::PedometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.PedometerReading", L"StepKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StepKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PedometerReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::PedometerReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.PedometerReading", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PedometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::PedometerReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PedometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::PedometerReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PedometerReading[] = {
        { "_assign_array_", _assign_array_PedometerReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PedometerReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PedometerReading[] = {
        { "cumulative_steps", reinterpret_cast<getter>(PedometerReading_get_CumulativeSteps), nullptr, nullptr, nullptr },
        { "cumulative_steps_duration", reinterpret_cast<getter>(PedometerReading_get_CumulativeStepsDuration), nullptr, nullptr, nullptr },
        { "step_kind", reinterpret_cast<getter>(PedometerReading_get_StepKind), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(PedometerReading_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PedometerReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PedometerReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PedometerReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PedometerReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PedometerReading) },
        { },
    };

    static PyType_Spec type_spec_PedometerReading =
    {
        "_winsdk_Windows_Devices_Sensors.PedometerReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::PedometerReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PedometerReading
    };

    // ----- PedometerReadingChangedEventArgs class --------------------
    static constexpr const char* const type_name_PedometerReadingChangedEventArgs = "PedometerReadingChangedEventArgs";

    static PyObject* _new_PedometerReadingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PedometerReadingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_PedometerReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::PedometerReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PedometerReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::PedometerReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.PedometerReadingChangedEventArgs", L"Reading"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PedometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::PedometerReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PedometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::PedometerReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PedometerReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_PedometerReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PedometerReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PedometerReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(PedometerReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PedometerReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PedometerReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PedometerReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PedometerReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PedometerReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PedometerReadingChangedEventArgs =
    {
        "_winsdk_Windows_Devices_Sensors.PedometerReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::PedometerReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PedometerReadingChangedEventArgs
    };

    // ----- ProximitySensor class --------------------
    static constexpr const char* const type_name_ProximitySensor = "ProximitySensor";

    static PyObject* _new_ProximitySensor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ProximitySensor);
        return nullptr;
    }

    static void _dealloc_ProximitySensor(py::wrapper::Windows::Devices::Sensors::ProximitySensor* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProximitySensor_CreateDisplayOnOffController(py::wrapper::Windows::Devices::Sensors::ProximitySensor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.ProximitySensor", L"CreateDisplayOnOffController", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateDisplayOnOffController());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProximitySensor_FromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.ProximitySensor", L"FromId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::ProximitySensor::FromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProximitySensor_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::ProximitySensor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.ProximitySensor", L"GetCurrentReading", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProximitySensor_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.ProximitySensor", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::ProximitySensor::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProximitySensor_GetReadingsFromTriggerDetails(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.ProximitySensor", L"GetReadingsFromTriggerDetails", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::ProximitySensor::GetReadingsFromTriggerDetails(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProximitySensor_get_DeviceId(py::wrapper::Windows::Devices::Sensors::ProximitySensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ProximitySensor", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProximitySensor_get_MaxDistanceInMillimeters(py::wrapper::Windows::Devices::Sensors::ProximitySensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ProximitySensor", L"MaxDistanceInMillimeters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxDistanceInMillimeters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProximitySensor_get_MinDistanceInMillimeters(py::wrapper::Windows::Devices::Sensors::ProximitySensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ProximitySensor", L"MinDistanceInMillimeters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinDistanceInMillimeters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProximitySensor_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::ProximitySensor* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.ProximitySensor", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::ProximitySensor, winrt::Windows::Devices::Sensors::ProximitySensorReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProximitySensor_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::ProximitySensor* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.ProximitySensor", L"ReadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProximitySensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::ProximitySensor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProximitySensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ProximitySensor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProximitySensor[] = {
        { "create_display_on_off_controller", reinterpret_cast<PyCFunction>(ProximitySensor_CreateDisplayOnOffController), METH_VARARGS, nullptr },
        { "from_id", reinterpret_cast<PyCFunction>(ProximitySensor_FromId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(ProximitySensor_GetCurrentReading), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(ProximitySensor_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_readings_from_trigger_details", reinterpret_cast<PyCFunction>(ProximitySensor_GetReadingsFromTriggerDetails), METH_VARARGS | METH_STATIC, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(ProximitySensor_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(ProximitySensor_remove_ReadingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ProximitySensor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProximitySensor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProximitySensor[] = {
        { "device_id", reinterpret_cast<getter>(ProximitySensor_get_DeviceId), nullptr, nullptr, nullptr },
        { "max_distance_in_millimeters", reinterpret_cast<getter>(ProximitySensor_get_MaxDistanceInMillimeters), nullptr, nullptr, nullptr },
        { "min_distance_in_millimeters", reinterpret_cast<getter>(ProximitySensor_get_MinDistanceInMillimeters), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProximitySensor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProximitySensor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProximitySensor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProximitySensor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProximitySensor) },
        { },
    };

    static PyType_Spec type_spec_ProximitySensor =
    {
        "_winsdk_Windows_Devices_Sensors.ProximitySensor",
        sizeof(py::wrapper::Windows::Devices::Sensors::ProximitySensor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProximitySensor
    };

    // ----- ProximitySensorDataThreshold class --------------------
    static constexpr const char* const type_name_ProximitySensorDataThreshold = "ProximitySensorDataThreshold";

    static PyObject* _new_ProximitySensorDataThreshold(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::ProximitySensor>(args, 0);

                winrt::Windows::Devices::Sensors::ProximitySensorDataThreshold instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProximitySensorDataThreshold(py::wrapper::Windows::Devices::Sensors::ProximitySensorDataThreshold* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ProximitySensorDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::ProximitySensorDataThreshold>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProximitySensorDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ProximitySensorDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProximitySensorDataThreshold[] = {
        { "_assign_array_", _assign_array_ProximitySensorDataThreshold, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProximitySensorDataThreshold), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProximitySensorDataThreshold[] = {
        { }
    };

    static PyType_Slot _type_slots_ProximitySensorDataThreshold[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProximitySensorDataThreshold) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProximitySensorDataThreshold) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProximitySensorDataThreshold) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProximitySensorDataThreshold) },
        { },
    };

    static PyType_Spec type_spec_ProximitySensorDataThreshold =
    {
        "_winsdk_Windows_Devices_Sensors.ProximitySensorDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::ProximitySensorDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProximitySensorDataThreshold
    };

    // ----- ProximitySensorDisplayOnOffController class --------------------
    static constexpr const char* const type_name_ProximitySensorDisplayOnOffController = "ProximitySensorDisplayOnOffController";

    static PyObject* _new_ProximitySensorDisplayOnOffController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ProximitySensorDisplayOnOffController);
        return nullptr;
    }

    static void _dealloc_ProximitySensorDisplayOnOffController(py::wrapper::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProximitySensorDisplayOnOffController_Close(py::wrapper::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.ProximitySensorDisplayOnOffController", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProximitySensorDisplayOnOffController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProximitySensorDisplayOnOffController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ProximitySensorDisplayOnOffController(py::wrapper::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ProximitySensorDisplayOnOffController(py::wrapper::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProximitySensorDisplayOnOffController[] = {
        { "close", reinterpret_cast<PyCFunction>(ProximitySensorDisplayOnOffController_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ProximitySensorDisplayOnOffController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProximitySensorDisplayOnOffController), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ProximitySensorDisplayOnOffController), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ProximitySensorDisplayOnOffController), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProximitySensorDisplayOnOffController[] = {
        { }
    };

    static PyType_Slot _type_slots_ProximitySensorDisplayOnOffController[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProximitySensorDisplayOnOffController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProximitySensorDisplayOnOffController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProximitySensorDisplayOnOffController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProximitySensorDisplayOnOffController) },
        { },
    };

    static PyType_Spec type_spec_ProximitySensorDisplayOnOffController =
    {
        "_winsdk_Windows_Devices_Sensors.ProximitySensorDisplayOnOffController",
        sizeof(py::wrapper::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProximitySensorDisplayOnOffController
    };

    // ----- ProximitySensorReading class --------------------
    static constexpr const char* const type_name_ProximitySensorReading = "ProximitySensorReading";

    static PyObject* _new_ProximitySensorReading(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ProximitySensorReading);
        return nullptr;
    }

    static void _dealloc_ProximitySensorReading(py::wrapper::Windows::Devices::Sensors::ProximitySensorReading* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProximitySensorReading_get_DistanceInMillimeters(py::wrapper::Windows::Devices::Sensors::ProximitySensorReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ProximitySensorReading", L"DistanceInMillimeters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DistanceInMillimeters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProximitySensorReading_get_IsDetected(py::wrapper::Windows::Devices::Sensors::ProximitySensorReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ProximitySensorReading", L"IsDetected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDetected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProximitySensorReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::ProximitySensorReading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ProximitySensorReading", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProximitySensorReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::ProximitySensorReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProximitySensorReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ProximitySensorReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProximitySensorReading[] = {
        { "_assign_array_", _assign_array_ProximitySensorReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProximitySensorReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProximitySensorReading[] = {
        { "distance_in_millimeters", reinterpret_cast<getter>(ProximitySensorReading_get_DistanceInMillimeters), nullptr, nullptr, nullptr },
        { "is_detected", reinterpret_cast<getter>(ProximitySensorReading_get_IsDetected), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(ProximitySensorReading_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProximitySensorReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProximitySensorReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProximitySensorReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProximitySensorReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProximitySensorReading) },
        { },
    };

    static PyType_Spec type_spec_ProximitySensorReading =
    {
        "_winsdk_Windows_Devices_Sensors.ProximitySensorReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::ProximitySensorReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProximitySensorReading
    };

    // ----- ProximitySensorReadingChangedEventArgs class --------------------
    static constexpr const char* const type_name_ProximitySensorReadingChangedEventArgs = "ProximitySensorReadingChangedEventArgs";

    static PyObject* _new_ProximitySensorReadingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ProximitySensorReadingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_ProximitySensorReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::ProximitySensorReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProximitySensorReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::ProximitySensorReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ProximitySensorReadingChangedEventArgs", L"Reading"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProximitySensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::ProximitySensorReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProximitySensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ProximitySensorReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProximitySensorReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_ProximitySensorReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProximitySensorReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProximitySensorReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(ProximitySensorReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProximitySensorReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProximitySensorReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProximitySensorReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProximitySensorReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProximitySensorReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ProximitySensorReadingChangedEventArgs =
    {
        "_winsdk_Windows_Devices_Sensors.ProximitySensorReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::ProximitySensorReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProximitySensorReadingChangedEventArgs
    };

    // ----- SensorDataThresholdTriggerDetails class --------------------
    static constexpr const char* const type_name_SensorDataThresholdTriggerDetails = "SensorDataThresholdTriggerDetails";

    static PyObject* _new_SensorDataThresholdTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SensorDataThresholdTriggerDetails);
        return nullptr;
    }

    static void _dealloc_SensorDataThresholdTriggerDetails(py::wrapper::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SensorDataThresholdTriggerDetails_get_DeviceId(py::wrapper::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorDataThresholdTriggerDetails", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorDataThresholdTriggerDetails_get_SensorType(py::wrapper::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorDataThresholdTriggerDetails", L"SensorType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SensorType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SensorDataThresholdTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SensorDataThresholdTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SensorDataThresholdTriggerDetails[] = {
        { "_assign_array_", _assign_array_SensorDataThresholdTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SensorDataThresholdTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SensorDataThresholdTriggerDetails[] = {
        { "device_id", reinterpret_cast<getter>(SensorDataThresholdTriggerDetails_get_DeviceId), nullptr, nullptr, nullptr },
        { "sensor_type", reinterpret_cast<getter>(SensorDataThresholdTriggerDetails_get_SensorType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SensorDataThresholdTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SensorDataThresholdTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SensorDataThresholdTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SensorDataThresholdTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SensorDataThresholdTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_SensorDataThresholdTriggerDetails =
    {
        "_winsdk_Windows_Devices_Sensors.SensorDataThresholdTriggerDetails",
        sizeof(py::wrapper::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SensorDataThresholdTriggerDetails
    };

    // ----- SensorQuaternion class --------------------
    static constexpr const char* const type_name_SensorQuaternion = "SensorQuaternion";

    static PyObject* _new_SensorQuaternion(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SensorQuaternion);
        return nullptr;
    }

    static void _dealloc_SensorQuaternion(py::wrapper::Windows::Devices::Sensors::SensorQuaternion* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SensorQuaternion_get_W(py::wrapper::Windows::Devices::Sensors::SensorQuaternion* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorQuaternion", L"W"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.W());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorQuaternion_get_X(py::wrapper::Windows::Devices::Sensors::SensorQuaternion* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorQuaternion", L"X"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.X());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorQuaternion_get_Y(py::wrapper::Windows::Devices::Sensors::SensorQuaternion* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorQuaternion", L"Y"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Y());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorQuaternion_get_Z(py::wrapper::Windows::Devices::Sensors::SensorQuaternion* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorQuaternion", L"Z"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Z());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SensorQuaternion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::SensorQuaternion>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SensorQuaternion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::SensorQuaternion>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SensorQuaternion[] = {
        { "_assign_array_", _assign_array_SensorQuaternion, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SensorQuaternion), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SensorQuaternion[] = {
        { "w", reinterpret_cast<getter>(SensorQuaternion_get_W), nullptr, nullptr, nullptr },
        { "x", reinterpret_cast<getter>(SensorQuaternion_get_X), nullptr, nullptr, nullptr },
        { "y", reinterpret_cast<getter>(SensorQuaternion_get_Y), nullptr, nullptr, nullptr },
        { "z", reinterpret_cast<getter>(SensorQuaternion_get_Z), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SensorQuaternion[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SensorQuaternion) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SensorQuaternion) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SensorQuaternion) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SensorQuaternion) },
        { },
    };

    static PyType_Spec type_spec_SensorQuaternion =
    {
        "_winsdk_Windows_Devices_Sensors.SensorQuaternion",
        sizeof(py::wrapper::Windows::Devices::Sensors::SensorQuaternion),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SensorQuaternion
    };

    // ----- SensorRotationMatrix class --------------------
    static constexpr const char* const type_name_SensorRotationMatrix = "SensorRotationMatrix";

    static PyObject* _new_SensorRotationMatrix(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SensorRotationMatrix);
        return nullptr;
    }

    static void _dealloc_SensorRotationMatrix(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SensorRotationMatrix_get_M11(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorRotationMatrix", L"M11"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.M11());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorRotationMatrix_get_M12(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorRotationMatrix", L"M12"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.M12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorRotationMatrix_get_M13(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorRotationMatrix", L"M13"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.M13());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorRotationMatrix_get_M21(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorRotationMatrix", L"M21"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.M21());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorRotationMatrix_get_M22(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorRotationMatrix", L"M22"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.M22());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorRotationMatrix_get_M23(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorRotationMatrix", L"M23"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.M23());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorRotationMatrix_get_M31(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorRotationMatrix", L"M31"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.M31());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorRotationMatrix_get_M32(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorRotationMatrix", L"M32"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.M32());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorRotationMatrix_get_M33(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorRotationMatrix", L"M33"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.M33());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SensorRotationMatrix(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::SensorRotationMatrix>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SensorRotationMatrix(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::SensorRotationMatrix>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SensorRotationMatrix[] = {
        { "_assign_array_", _assign_array_SensorRotationMatrix, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SensorRotationMatrix), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SensorRotationMatrix[] = {
        { "m11", reinterpret_cast<getter>(SensorRotationMatrix_get_M11), nullptr, nullptr, nullptr },
        { "m12", reinterpret_cast<getter>(SensorRotationMatrix_get_M12), nullptr, nullptr, nullptr },
        { "m13", reinterpret_cast<getter>(SensorRotationMatrix_get_M13), nullptr, nullptr, nullptr },
        { "m21", reinterpret_cast<getter>(SensorRotationMatrix_get_M21), nullptr, nullptr, nullptr },
        { "m22", reinterpret_cast<getter>(SensorRotationMatrix_get_M22), nullptr, nullptr, nullptr },
        { "m23", reinterpret_cast<getter>(SensorRotationMatrix_get_M23), nullptr, nullptr, nullptr },
        { "m31", reinterpret_cast<getter>(SensorRotationMatrix_get_M31), nullptr, nullptr, nullptr },
        { "m32", reinterpret_cast<getter>(SensorRotationMatrix_get_M32), nullptr, nullptr, nullptr },
        { "m33", reinterpret_cast<getter>(SensorRotationMatrix_get_M33), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SensorRotationMatrix[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SensorRotationMatrix) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SensorRotationMatrix) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SensorRotationMatrix) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SensorRotationMatrix) },
        { },
    };

    static PyType_Spec type_spec_SensorRotationMatrix =
    {
        "_winsdk_Windows_Devices_Sensors.SensorRotationMatrix",
        sizeof(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SensorRotationMatrix
    };

    // ----- SimpleOrientationSensor class --------------------
    static constexpr const char* const type_name_SimpleOrientationSensor = "SimpleOrientationSensor";

    static PyObject* _new_SimpleOrientationSensor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SimpleOrientationSensor);
        return nullptr;
    }

    static void _dealloc_SimpleOrientationSensor(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensor* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SimpleOrientationSensor_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.SimpleOrientationSensor", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::SimpleOrientationSensor::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SimpleOrientationSensor_GetCurrentOrientation(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.SimpleOrientationSensor", L"GetCurrentOrientation", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentOrientation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SimpleOrientationSensor_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.SimpleOrientationSensor", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::SimpleOrientationSensor::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SimpleOrientationSensor_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.SimpleOrientationSensor", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::SimpleOrientationSensor::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SimpleOrientationSensor_get_ReadingTransform(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SimpleOrientationSensor", L"ReadingTransform"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReadingTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SimpleOrientationSensor_put_ReadingTransform(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SimpleOrientationSensor", L"ReadingTransform"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Display::DisplayOrientations>(arg);

            self->obj.ReadingTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SimpleOrientationSensor_get_DeviceId(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SimpleOrientationSensor", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SimpleOrientationSensor_add_OrientationChanged(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensor* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.SimpleOrientationSensor", L"OrientationChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::SimpleOrientationSensor, winrt::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs>>(arg);

            return py::convert(self->obj.OrientationChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SimpleOrientationSensor_remove_OrientationChanged(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensor* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.SimpleOrientationSensor", L"OrientationChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OrientationChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SimpleOrientationSensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::SimpleOrientationSensor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SimpleOrientationSensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::SimpleOrientationSensor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SimpleOrientationSensor[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(SimpleOrientationSensor_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_orientation", reinterpret_cast<PyCFunction>(SimpleOrientationSensor_GetCurrentOrientation), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(SimpleOrientationSensor_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(SimpleOrientationSensor_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "add_orientation_changed", reinterpret_cast<PyCFunction>(SimpleOrientationSensor_add_OrientationChanged), METH_O, nullptr },
        { "remove_orientation_changed", reinterpret_cast<PyCFunction>(SimpleOrientationSensor_remove_OrientationChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_SimpleOrientationSensor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SimpleOrientationSensor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SimpleOrientationSensor[] = {
        { "reading_transform", reinterpret_cast<getter>(SimpleOrientationSensor_get_ReadingTransform), reinterpret_cast<setter>(SimpleOrientationSensor_put_ReadingTransform), nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(SimpleOrientationSensor_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SimpleOrientationSensor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SimpleOrientationSensor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SimpleOrientationSensor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SimpleOrientationSensor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SimpleOrientationSensor) },
        { },
    };

    static PyType_Spec type_spec_SimpleOrientationSensor =
    {
        "_winsdk_Windows_Devices_Sensors.SimpleOrientationSensor",
        sizeof(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SimpleOrientationSensor
    };

    // ----- SimpleOrientationSensorOrientationChangedEventArgs class --------------------
    static constexpr const char* const type_name_SimpleOrientationSensorOrientationChangedEventArgs = "SimpleOrientationSensorOrientationChangedEventArgs";

    static PyObject* _new_SimpleOrientationSensorOrientationChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SimpleOrientationSensorOrientationChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_SimpleOrientationSensorOrientationChangedEventArgs(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SimpleOrientationSensorOrientationChangedEventArgs_get_Orientation(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SimpleOrientationSensorOrientationChangedEventArgs", L"Orientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SimpleOrientationSensorOrientationChangedEventArgs_get_Timestamp(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SimpleOrientationSensorOrientationChangedEventArgs", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SimpleOrientationSensorOrientationChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SimpleOrientationSensorOrientationChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SimpleOrientationSensorOrientationChangedEventArgs[] = {
        { "_assign_array_", _assign_array_SimpleOrientationSensorOrientationChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SimpleOrientationSensorOrientationChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SimpleOrientationSensorOrientationChangedEventArgs[] = {
        { "orientation", reinterpret_cast<getter>(SimpleOrientationSensorOrientationChangedEventArgs_get_Orientation), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(SimpleOrientationSensorOrientationChangedEventArgs_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SimpleOrientationSensorOrientationChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SimpleOrientationSensorOrientationChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SimpleOrientationSensorOrientationChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SimpleOrientationSensorOrientationChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SimpleOrientationSensorOrientationChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SimpleOrientationSensorOrientationChangedEventArgs =
    {
        "_winsdk_Windows_Devices_Sensors.SimpleOrientationSensorOrientationChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SimpleOrientationSensorOrientationChangedEventArgs
    };

    // ----- ISensorDataThreshold interface --------------------
    static constexpr const char* const type_name_ISensorDataThreshold = "ISensorDataThreshold";

    static PyObject* _new_ISensorDataThreshold(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_ISensorDataThreshold);
        return nullptr;
    }

    static void _dealloc_ISensorDataThreshold(py::wrapper::Windows::Devices::Sensors::ISensorDataThreshold* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ISensorDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::ISensorDataThreshold>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISensorDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ISensorDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISensorDataThreshold[] = {
        { "_assign_array_", _assign_array_ISensorDataThreshold, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISensorDataThreshold), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISensorDataThreshold[] = {
        { }
    };

    static PyType_Slot _type_slots_ISensorDataThreshold[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISensorDataThreshold) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISensorDataThreshold) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISensorDataThreshold) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISensorDataThreshold) },
        { },
    };

    static PyType_Spec type_spec_ISensorDataThreshold =
    {
        "_winsdk_Windows_Devices_Sensors.ISensorDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::ISensorDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISensorDataThreshold
    };

    // ----- Windows.Devices.Sensors Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Devices::Sensors");

    static PyMethodDef module_methods[] = {
        {"_register_AccelerometerReadingType", register_AccelerometerReadingType, METH_O, "registers type"},
        {"_register_ActivitySensorReadingConfidence", register_ActivitySensorReadingConfidence, METH_O, "registers type"},
        {"_register_ActivityType", register_ActivityType, METH_O, "registers type"},
        {"_register_HumanEngagement", register_HumanEngagement, METH_O, "registers type"},
        {"_register_HumanPresence", register_HumanPresence, METH_O, "registers type"},
        {"_register_MagnetometerAccuracy", register_MagnetometerAccuracy, METH_O, "registers type"},
        {"_register_PedometerStepKind", register_PedometerStepKind, METH_O, "registers type"},
        {"_register_SensorOptimizationGoal", register_SensorOptimizationGoal, METH_O, "registers type"},
        {"_register_SensorReadingType", register_SensorReadingType, METH_O, "registers type"},
        {"_register_SensorType", register_SensorType, METH_O, "registers type"},
        {"_register_SimpleOrientation", register_SimpleOrientation, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_AccelerometerReadingType);
        Py_VISIT(state->type_ActivitySensorReadingConfidence);
        Py_VISIT(state->type_ActivityType);
        Py_VISIT(state->type_HumanEngagement);
        Py_VISIT(state->type_HumanPresence);
        Py_VISIT(state->type_MagnetometerAccuracy);
        Py_VISIT(state->type_PedometerStepKind);
        Py_VISIT(state->type_SensorOptimizationGoal);
        Py_VISIT(state->type_SensorReadingType);
        Py_VISIT(state->type_SensorType);
        Py_VISIT(state->type_SimpleOrientation);
        Py_VISIT(state->type_Accelerometer);
        Py_VISIT(state->type_AccelerometerDataThreshold);
        Py_VISIT(state->type_AccelerometerReading);
        Py_VISIT(state->type_AccelerometerReadingChangedEventArgs);
        Py_VISIT(state->type_AccelerometerShakenEventArgs);
        Py_VISIT(state->type_ActivitySensor);
        Py_VISIT(state->type_ActivitySensorReading);
        Py_VISIT(state->type_ActivitySensorReadingChangeReport);
        Py_VISIT(state->type_ActivitySensorReadingChangedEventArgs);
        Py_VISIT(state->type_ActivitySensorTriggerDetails);
        Py_VISIT(state->type_Altimeter);
        Py_VISIT(state->type_AltimeterReading);
        Py_VISIT(state->type_AltimeterReadingChangedEventArgs);
        Py_VISIT(state->type_Barometer);
        Py_VISIT(state->type_BarometerDataThreshold);
        Py_VISIT(state->type_BarometerReading);
        Py_VISIT(state->type_BarometerReadingChangedEventArgs);
        Py_VISIT(state->type_Compass);
        Py_VISIT(state->type_CompassDataThreshold);
        Py_VISIT(state->type_CompassReading);
        Py_VISIT(state->type_CompassReadingChangedEventArgs);
        Py_VISIT(state->type_Gyrometer);
        Py_VISIT(state->type_GyrometerDataThreshold);
        Py_VISIT(state->type_GyrometerReading);
        Py_VISIT(state->type_GyrometerReadingChangedEventArgs);
        Py_VISIT(state->type_HingeAngleReading);
        Py_VISIT(state->type_HingeAngleSensor);
        Py_VISIT(state->type_HingeAngleSensorReadingChangedEventArgs);
        Py_VISIT(state->type_HumanPresenceFeatures);
        Py_VISIT(state->type_HumanPresenceSensor);
        Py_VISIT(state->type_HumanPresenceSensorReading);
        Py_VISIT(state->type_HumanPresenceSensorReadingChangedEventArgs);
        Py_VISIT(state->type_HumanPresenceSettings);
        Py_VISIT(state->type_Inclinometer);
        Py_VISIT(state->type_InclinometerDataThreshold);
        Py_VISIT(state->type_InclinometerReading);
        Py_VISIT(state->type_InclinometerReadingChangedEventArgs);
        Py_VISIT(state->type_LightSensor);
        Py_VISIT(state->type_LightSensorDataThreshold);
        Py_VISIT(state->type_LightSensorReading);
        Py_VISIT(state->type_LightSensorReadingChangedEventArgs);
        Py_VISIT(state->type_Magnetometer);
        Py_VISIT(state->type_MagnetometerDataThreshold);
        Py_VISIT(state->type_MagnetometerReading);
        Py_VISIT(state->type_MagnetometerReadingChangedEventArgs);
        Py_VISIT(state->type_OrientationSensor);
        Py_VISIT(state->type_OrientationSensorReading);
        Py_VISIT(state->type_OrientationSensorReadingChangedEventArgs);
        Py_VISIT(state->type_Pedometer);
        Py_VISIT(state->type_PedometerDataThreshold);
        Py_VISIT(state->type_PedometerReading);
        Py_VISIT(state->type_PedometerReadingChangedEventArgs);
        Py_VISIT(state->type_ProximitySensor);
        Py_VISIT(state->type_ProximitySensorDataThreshold);
        Py_VISIT(state->type_ProximitySensorDisplayOnOffController);
        Py_VISIT(state->type_ProximitySensorReading);
        Py_VISIT(state->type_ProximitySensorReadingChangedEventArgs);
        Py_VISIT(state->type_SensorDataThresholdTriggerDetails);
        Py_VISIT(state->type_SensorQuaternion);
        Py_VISIT(state->type_SensorRotationMatrix);
        Py_VISIT(state->type_SimpleOrientationSensor);
        Py_VISIT(state->type_SimpleOrientationSensorOrientationChangedEventArgs);
        Py_VISIT(state->type_ISensorDataThreshold);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_AccelerometerReadingType);
        Py_CLEAR(state->type_ActivitySensorReadingConfidence);
        Py_CLEAR(state->type_ActivityType);
        Py_CLEAR(state->type_HumanEngagement);
        Py_CLEAR(state->type_HumanPresence);
        Py_CLEAR(state->type_MagnetometerAccuracy);
        Py_CLEAR(state->type_PedometerStepKind);
        Py_CLEAR(state->type_SensorOptimizationGoal);
        Py_CLEAR(state->type_SensorReadingType);
        Py_CLEAR(state->type_SensorType);
        Py_CLEAR(state->type_SimpleOrientation);
        Py_CLEAR(state->type_Accelerometer);
        Py_CLEAR(state->type_AccelerometerDataThreshold);
        Py_CLEAR(state->type_AccelerometerReading);
        Py_CLEAR(state->type_AccelerometerReadingChangedEventArgs);
        Py_CLEAR(state->type_AccelerometerShakenEventArgs);
        Py_CLEAR(state->type_ActivitySensor);
        Py_CLEAR(state->type_ActivitySensorReading);
        Py_CLEAR(state->type_ActivitySensorReadingChangeReport);
        Py_CLEAR(state->type_ActivitySensorReadingChangedEventArgs);
        Py_CLEAR(state->type_ActivitySensorTriggerDetails);
        Py_CLEAR(state->type_Altimeter);
        Py_CLEAR(state->type_AltimeterReading);
        Py_CLEAR(state->type_AltimeterReadingChangedEventArgs);
        Py_CLEAR(state->type_Barometer);
        Py_CLEAR(state->type_BarometerDataThreshold);
        Py_CLEAR(state->type_BarometerReading);
        Py_CLEAR(state->type_BarometerReadingChangedEventArgs);
        Py_CLEAR(state->type_Compass);
        Py_CLEAR(state->type_CompassDataThreshold);
        Py_CLEAR(state->type_CompassReading);
        Py_CLEAR(state->type_CompassReadingChangedEventArgs);
        Py_CLEAR(state->type_Gyrometer);
        Py_CLEAR(state->type_GyrometerDataThreshold);
        Py_CLEAR(state->type_GyrometerReading);
        Py_CLEAR(state->type_GyrometerReadingChangedEventArgs);
        Py_CLEAR(state->type_HingeAngleReading);
        Py_CLEAR(state->type_HingeAngleSensor);
        Py_CLEAR(state->type_HingeAngleSensorReadingChangedEventArgs);
        Py_CLEAR(state->type_HumanPresenceFeatures);
        Py_CLEAR(state->type_HumanPresenceSensor);
        Py_CLEAR(state->type_HumanPresenceSensorReading);
        Py_CLEAR(state->type_HumanPresenceSensorReadingChangedEventArgs);
        Py_CLEAR(state->type_HumanPresenceSettings);
        Py_CLEAR(state->type_Inclinometer);
        Py_CLEAR(state->type_InclinometerDataThreshold);
        Py_CLEAR(state->type_InclinometerReading);
        Py_CLEAR(state->type_InclinometerReadingChangedEventArgs);
        Py_CLEAR(state->type_LightSensor);
        Py_CLEAR(state->type_LightSensorDataThreshold);
        Py_CLEAR(state->type_LightSensorReading);
        Py_CLEAR(state->type_LightSensorReadingChangedEventArgs);
        Py_CLEAR(state->type_Magnetometer);
        Py_CLEAR(state->type_MagnetometerDataThreshold);
        Py_CLEAR(state->type_MagnetometerReading);
        Py_CLEAR(state->type_MagnetometerReadingChangedEventArgs);
        Py_CLEAR(state->type_OrientationSensor);
        Py_CLEAR(state->type_OrientationSensorReading);
        Py_CLEAR(state->type_OrientationSensorReadingChangedEventArgs);
        Py_CLEAR(state->type_Pedometer);
        Py_CLEAR(state->type_PedometerDataThreshold);
        Py_CLEAR(state->type_PedometerReading);
        Py_CLEAR(state->type_PedometerReadingChangedEventArgs);
        Py_CLEAR(state->type_ProximitySensor);
        Py_CLEAR(state->type_ProximitySensorDataThreshold);
        Py_CLEAR(state->type_ProximitySensorDisplayOnOffController);
        Py_CLEAR(state->type_ProximitySensorReading);
        Py_CLEAR(state->type_ProximitySensorReadingChangedEventArgs);
        Py_CLEAR(state->type_SensorDataThresholdTriggerDetails);
        Py_CLEAR(state->type_SensorQuaternion);
        Py_CLEAR(state->type_SensorRotationMatrix);
        Py_CLEAR(state->type_SimpleOrientationSensor);
        Py_CLEAR(state->type_SimpleOrientationSensorOrientationChangedEventArgs);
        Py_CLEAR(state->type_ISensorDataThreshold);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Devices_Sensors",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Devices::Sensors

PyMODINIT_FUNC PyInit__winsdk_Windows_Devices_Sensors(void) noexcept
{
    using namespace py::cpp::Windows::Devices::Sensors;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_Accelerometer = py::register_python_type(module.get(), type_name_Accelerometer, &type_spec_Accelerometer, bases.get(), nullptr);
    if (!state->type_Accelerometer)
    {
        return nullptr;
    }

    state->type_AccelerometerDataThreshold = py::register_python_type(module.get(), type_name_AccelerometerDataThreshold, &type_spec_AccelerometerDataThreshold, bases.get(), nullptr);
    if (!state->type_AccelerometerDataThreshold)
    {
        return nullptr;
    }

    state->type_AccelerometerReading = py::register_python_type(module.get(), type_name_AccelerometerReading, &type_spec_AccelerometerReading, bases.get(), nullptr);
    if (!state->type_AccelerometerReading)
    {
        return nullptr;
    }

    state->type_AccelerometerReadingChangedEventArgs = py::register_python_type(module.get(), type_name_AccelerometerReadingChangedEventArgs, &type_spec_AccelerometerReadingChangedEventArgs, bases.get(), nullptr);
    if (!state->type_AccelerometerReadingChangedEventArgs)
    {
        return nullptr;
    }

    state->type_AccelerometerShakenEventArgs = py::register_python_type(module.get(), type_name_AccelerometerShakenEventArgs, &type_spec_AccelerometerShakenEventArgs, bases.get(), nullptr);
    if (!state->type_AccelerometerShakenEventArgs)
    {
        return nullptr;
    }

    state->type_ActivitySensor = py::register_python_type(module.get(), type_name_ActivitySensor, &type_spec_ActivitySensor, bases.get(), nullptr);
    if (!state->type_ActivitySensor)
    {
        return nullptr;
    }

    state->type_ActivitySensorReading = py::register_python_type(module.get(), type_name_ActivitySensorReading, &type_spec_ActivitySensorReading, bases.get(), nullptr);
    if (!state->type_ActivitySensorReading)
    {
        return nullptr;
    }

    state->type_ActivitySensorReadingChangeReport = py::register_python_type(module.get(), type_name_ActivitySensorReadingChangeReport, &type_spec_ActivitySensorReadingChangeReport, bases.get(), nullptr);
    if (!state->type_ActivitySensorReadingChangeReport)
    {
        return nullptr;
    }

    state->type_ActivitySensorReadingChangedEventArgs = py::register_python_type(module.get(), type_name_ActivitySensorReadingChangedEventArgs, &type_spec_ActivitySensorReadingChangedEventArgs, bases.get(), nullptr);
    if (!state->type_ActivitySensorReadingChangedEventArgs)
    {
        return nullptr;
    }

    state->type_ActivitySensorTriggerDetails = py::register_python_type(module.get(), type_name_ActivitySensorTriggerDetails, &type_spec_ActivitySensorTriggerDetails, bases.get(), nullptr);
    if (!state->type_ActivitySensorTriggerDetails)
    {
        return nullptr;
    }

    state->type_Altimeter = py::register_python_type(module.get(), type_name_Altimeter, &type_spec_Altimeter, bases.get(), nullptr);
    if (!state->type_Altimeter)
    {
        return nullptr;
    }

    state->type_AltimeterReading = py::register_python_type(module.get(), type_name_AltimeterReading, &type_spec_AltimeterReading, bases.get(), nullptr);
    if (!state->type_AltimeterReading)
    {
        return nullptr;
    }

    state->type_AltimeterReadingChangedEventArgs = py::register_python_type(module.get(), type_name_AltimeterReadingChangedEventArgs, &type_spec_AltimeterReadingChangedEventArgs, bases.get(), nullptr);
    if (!state->type_AltimeterReadingChangedEventArgs)
    {
        return nullptr;
    }

    state->type_Barometer = py::register_python_type(module.get(), type_name_Barometer, &type_spec_Barometer, bases.get(), nullptr);
    if (!state->type_Barometer)
    {
        return nullptr;
    }

    state->type_BarometerDataThreshold = py::register_python_type(module.get(), type_name_BarometerDataThreshold, &type_spec_BarometerDataThreshold, bases.get(), nullptr);
    if (!state->type_BarometerDataThreshold)
    {
        return nullptr;
    }

    state->type_BarometerReading = py::register_python_type(module.get(), type_name_BarometerReading, &type_spec_BarometerReading, bases.get(), nullptr);
    if (!state->type_BarometerReading)
    {
        return nullptr;
    }

    state->type_BarometerReadingChangedEventArgs = py::register_python_type(module.get(), type_name_BarometerReadingChangedEventArgs, &type_spec_BarometerReadingChangedEventArgs, bases.get(), nullptr);
    if (!state->type_BarometerReadingChangedEventArgs)
    {
        return nullptr;
    }

    state->type_Compass = py::register_python_type(module.get(), type_name_Compass, &type_spec_Compass, bases.get(), nullptr);
    if (!state->type_Compass)
    {
        return nullptr;
    }

    state->type_CompassDataThreshold = py::register_python_type(module.get(), type_name_CompassDataThreshold, &type_spec_CompassDataThreshold, bases.get(), nullptr);
    if (!state->type_CompassDataThreshold)
    {
        return nullptr;
    }

    state->type_CompassReading = py::register_python_type(module.get(), type_name_CompassReading, &type_spec_CompassReading, bases.get(), nullptr);
    if (!state->type_CompassReading)
    {
        return nullptr;
    }

    state->type_CompassReadingChangedEventArgs = py::register_python_type(module.get(), type_name_CompassReadingChangedEventArgs, &type_spec_CompassReadingChangedEventArgs, bases.get(), nullptr);
    if (!state->type_CompassReadingChangedEventArgs)
    {
        return nullptr;
    }

    state->type_Gyrometer = py::register_python_type(module.get(), type_name_Gyrometer, &type_spec_Gyrometer, bases.get(), nullptr);
    if (!state->type_Gyrometer)
    {
        return nullptr;
    }

    state->type_GyrometerDataThreshold = py::register_python_type(module.get(), type_name_GyrometerDataThreshold, &type_spec_GyrometerDataThreshold, bases.get(), nullptr);
    if (!state->type_GyrometerDataThreshold)
    {
        return nullptr;
    }

    state->type_GyrometerReading = py::register_python_type(module.get(), type_name_GyrometerReading, &type_spec_GyrometerReading, bases.get(), nullptr);
    if (!state->type_GyrometerReading)
    {
        return nullptr;
    }

    state->type_GyrometerReadingChangedEventArgs = py::register_python_type(module.get(), type_name_GyrometerReadingChangedEventArgs, &type_spec_GyrometerReadingChangedEventArgs, bases.get(), nullptr);
    if (!state->type_GyrometerReadingChangedEventArgs)
    {
        return nullptr;
    }

    state->type_HingeAngleReading = py::register_python_type(module.get(), type_name_HingeAngleReading, &type_spec_HingeAngleReading, bases.get(), nullptr);
    if (!state->type_HingeAngleReading)
    {
        return nullptr;
    }

    state->type_HingeAngleSensor = py::register_python_type(module.get(), type_name_HingeAngleSensor, &type_spec_HingeAngleSensor, bases.get(), nullptr);
    if (!state->type_HingeAngleSensor)
    {
        return nullptr;
    }

    state->type_HingeAngleSensorReadingChangedEventArgs = py::register_python_type(module.get(), type_name_HingeAngleSensorReadingChangedEventArgs, &type_spec_HingeAngleSensorReadingChangedEventArgs, bases.get(), nullptr);
    if (!state->type_HingeAngleSensorReadingChangedEventArgs)
    {
        return nullptr;
    }

    state->type_HumanPresenceFeatures = py::register_python_type(module.get(), type_name_HumanPresenceFeatures, &type_spec_HumanPresenceFeatures, bases.get(), nullptr);
    if (!state->type_HumanPresenceFeatures)
    {
        return nullptr;
    }

    state->type_HumanPresenceSensor = py::register_python_type(module.get(), type_name_HumanPresenceSensor, &type_spec_HumanPresenceSensor, bases.get(), nullptr);
    if (!state->type_HumanPresenceSensor)
    {
        return nullptr;
    }

    state->type_HumanPresenceSensorReading = py::register_python_type(module.get(), type_name_HumanPresenceSensorReading, &type_spec_HumanPresenceSensorReading, bases.get(), nullptr);
    if (!state->type_HumanPresenceSensorReading)
    {
        return nullptr;
    }

    state->type_HumanPresenceSensorReadingChangedEventArgs = py::register_python_type(module.get(), type_name_HumanPresenceSensorReadingChangedEventArgs, &type_spec_HumanPresenceSensorReadingChangedEventArgs, bases.get(), nullptr);
    if (!state->type_HumanPresenceSensorReadingChangedEventArgs)
    {
        return nullptr;
    }

    state->type_HumanPresenceSettings = py::register_python_type(module.get(), type_name_HumanPresenceSettings, &type_spec_HumanPresenceSettings, bases.get(), nullptr);
    if (!state->type_HumanPresenceSettings)
    {
        return nullptr;
    }

    state->type_Inclinometer = py::register_python_type(module.get(), type_name_Inclinometer, &type_spec_Inclinometer, bases.get(), nullptr);
    if (!state->type_Inclinometer)
    {
        return nullptr;
    }

    state->type_InclinometerDataThreshold = py::register_python_type(module.get(), type_name_InclinometerDataThreshold, &type_spec_InclinometerDataThreshold, bases.get(), nullptr);
    if (!state->type_InclinometerDataThreshold)
    {
        return nullptr;
    }

    state->type_InclinometerReading = py::register_python_type(module.get(), type_name_InclinometerReading, &type_spec_InclinometerReading, bases.get(), nullptr);
    if (!state->type_InclinometerReading)
    {
        return nullptr;
    }

    state->type_InclinometerReadingChangedEventArgs = py::register_python_type(module.get(), type_name_InclinometerReadingChangedEventArgs, &type_spec_InclinometerReadingChangedEventArgs, bases.get(), nullptr);
    if (!state->type_InclinometerReadingChangedEventArgs)
    {
        return nullptr;
    }

    state->type_LightSensor = py::register_python_type(module.get(), type_name_LightSensor, &type_spec_LightSensor, bases.get(), nullptr);
    if (!state->type_LightSensor)
    {
        return nullptr;
    }

    state->type_LightSensorDataThreshold = py::register_python_type(module.get(), type_name_LightSensorDataThreshold, &type_spec_LightSensorDataThreshold, bases.get(), nullptr);
    if (!state->type_LightSensorDataThreshold)
    {
        return nullptr;
    }

    state->type_LightSensorReading = py::register_python_type(module.get(), type_name_LightSensorReading, &type_spec_LightSensorReading, bases.get(), nullptr);
    if (!state->type_LightSensorReading)
    {
        return nullptr;
    }

    state->type_LightSensorReadingChangedEventArgs = py::register_python_type(module.get(), type_name_LightSensorReadingChangedEventArgs, &type_spec_LightSensorReadingChangedEventArgs, bases.get(), nullptr);
    if (!state->type_LightSensorReadingChangedEventArgs)
    {
        return nullptr;
    }

    state->type_Magnetometer = py::register_python_type(module.get(), type_name_Magnetometer, &type_spec_Magnetometer, bases.get(), nullptr);
    if (!state->type_Magnetometer)
    {
        return nullptr;
    }

    state->type_MagnetometerDataThreshold = py::register_python_type(module.get(), type_name_MagnetometerDataThreshold, &type_spec_MagnetometerDataThreshold, bases.get(), nullptr);
    if (!state->type_MagnetometerDataThreshold)
    {
        return nullptr;
    }

    state->type_MagnetometerReading = py::register_python_type(module.get(), type_name_MagnetometerReading, &type_spec_MagnetometerReading, bases.get(), nullptr);
    if (!state->type_MagnetometerReading)
    {
        return nullptr;
    }

    state->type_MagnetometerReadingChangedEventArgs = py::register_python_type(module.get(), type_name_MagnetometerReadingChangedEventArgs, &type_spec_MagnetometerReadingChangedEventArgs, bases.get(), nullptr);
    if (!state->type_MagnetometerReadingChangedEventArgs)
    {
        return nullptr;
    }

    state->type_OrientationSensor = py::register_python_type(module.get(), type_name_OrientationSensor, &type_spec_OrientationSensor, bases.get(), nullptr);
    if (!state->type_OrientationSensor)
    {
        return nullptr;
    }

    state->type_OrientationSensorReading = py::register_python_type(module.get(), type_name_OrientationSensorReading, &type_spec_OrientationSensorReading, bases.get(), nullptr);
    if (!state->type_OrientationSensorReading)
    {
        return nullptr;
    }

    state->type_OrientationSensorReadingChangedEventArgs = py::register_python_type(module.get(), type_name_OrientationSensorReadingChangedEventArgs, &type_spec_OrientationSensorReadingChangedEventArgs, bases.get(), nullptr);
    if (!state->type_OrientationSensorReadingChangedEventArgs)
    {
        return nullptr;
    }

    state->type_Pedometer = py::register_python_type(module.get(), type_name_Pedometer, &type_spec_Pedometer, bases.get(), nullptr);
    if (!state->type_Pedometer)
    {
        return nullptr;
    }

    state->type_PedometerDataThreshold = py::register_python_type(module.get(), type_name_PedometerDataThreshold, &type_spec_PedometerDataThreshold, bases.get(), nullptr);
    if (!state->type_PedometerDataThreshold)
    {
        return nullptr;
    }

    state->type_PedometerReading = py::register_python_type(module.get(), type_name_PedometerReading, &type_spec_PedometerReading, bases.get(), nullptr);
    if (!state->type_PedometerReading)
    {
        return nullptr;
    }

    state->type_PedometerReadingChangedEventArgs = py::register_python_type(module.get(), type_name_PedometerReadingChangedEventArgs, &type_spec_PedometerReadingChangedEventArgs, bases.get(), nullptr);
    if (!state->type_PedometerReadingChangedEventArgs)
    {
        return nullptr;
    }

    state->type_ProximitySensor = py::register_python_type(module.get(), type_name_ProximitySensor, &type_spec_ProximitySensor, bases.get(), nullptr);
    if (!state->type_ProximitySensor)
    {
        return nullptr;
    }

    state->type_ProximitySensorDataThreshold = py::register_python_type(module.get(), type_name_ProximitySensorDataThreshold, &type_spec_ProximitySensorDataThreshold, bases.get(), nullptr);
    if (!state->type_ProximitySensorDataThreshold)
    {
        return nullptr;
    }

    state->type_ProximitySensorDisplayOnOffController = py::register_python_type(module.get(), type_name_ProximitySensorDisplayOnOffController, &type_spec_ProximitySensorDisplayOnOffController, bases.get(), nullptr);
    if (!state->type_ProximitySensorDisplayOnOffController)
    {
        return nullptr;
    }

    state->type_ProximitySensorReading = py::register_python_type(module.get(), type_name_ProximitySensorReading, &type_spec_ProximitySensorReading, bases.get(), nullptr);
    if (!state->type_ProximitySensorReading)
    {
        return nullptr;
    }

    state->type_ProximitySensorReadingChangedEventArgs = py::register_python_type(module.get(), type_name_ProximitySensorReadingChangedEventArgs, &type_spec_ProximitySensorReadingChangedEventArgs, bases.get(), nullptr);
    if (!state->type_ProximitySensorReadingChangedEventArgs)
    {
        return nullptr;
    }

    state->type_SensorDataThresholdTriggerDetails = py::register_python_type(module.get(), type_name_SensorDataThresholdTriggerDetails, &type_spec_SensorDataThresholdTriggerDetails, bases.get(), nullptr);
    if (!state->type_SensorDataThresholdTriggerDetails)
    {
        return nullptr;
    }

    state->type_SensorQuaternion = py::register_python_type(module.get(), type_name_SensorQuaternion, &type_spec_SensorQuaternion, bases.get(), nullptr);
    if (!state->type_SensorQuaternion)
    {
        return nullptr;
    }

    state->type_SensorRotationMatrix = py::register_python_type(module.get(), type_name_SensorRotationMatrix, &type_spec_SensorRotationMatrix, bases.get(), nullptr);
    if (!state->type_SensorRotationMatrix)
    {
        return nullptr;
    }

    state->type_SimpleOrientationSensor = py::register_python_type(module.get(), type_name_SimpleOrientationSensor, &type_spec_SimpleOrientationSensor, bases.get(), nullptr);
    if (!state->type_SimpleOrientationSensor)
    {
        return nullptr;
    }

    state->type_SimpleOrientationSensorOrientationChangedEventArgs = py::register_python_type(module.get(), type_name_SimpleOrientationSensorOrientationChangedEventArgs, &type_spec_SimpleOrientationSensorOrientationChangedEventArgs, bases.get(), nullptr);
    if (!state->type_SimpleOrientationSensorOrientationChangedEventArgs)
    {
        return nullptr;
    }

    state->type_ISensorDataThreshold = py::register_python_type(module.get(), type_name_ISensorDataThreshold, &type_spec_ISensorDataThreshold, bases.get(), nullptr);
    if (!state->type_ISensorDataThreshold)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Devices::Sensors::AccelerometerReadingType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AccelerometerReadingType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::AccelerometerReadingType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Sensors::ActivitySensorReadingConfidence>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ActivitySensorReadingConfidence;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::ActivitySensorReadingConfidence is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Sensors::ActivityType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ActivityType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::ActivityType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Sensors::HumanEngagement>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HumanEngagement;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::HumanEngagement is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Sensors::HumanPresence>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HumanPresence;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::HumanPresence is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Sensors::MagnetometerAccuracy>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MagnetometerAccuracy;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::MagnetometerAccuracy is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Sensors::PedometerStepKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PedometerStepKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::PedometerStepKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Sensors::SensorOptimizationGoal>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SensorOptimizationGoal;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::SensorOptimizationGoal is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Sensors::SensorReadingType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SensorReadingType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::SensorReadingType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Sensors::SensorType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SensorType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::SensorType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Sensors::SimpleOrientation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SimpleOrientation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::SimpleOrientation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::Accelerometer>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Accelerometer;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::Accelerometer is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::AccelerometerDataThreshold>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AccelerometerDataThreshold;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::AccelerometerDataThreshold is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::AccelerometerReading>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AccelerometerReading;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::AccelerometerReading is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::AccelerometerReadingChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AccelerometerReadingChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::AccelerometerReadingChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::AccelerometerShakenEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AccelerometerShakenEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::AccelerometerShakenEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::ActivitySensor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ActivitySensor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::ActivitySensor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::ActivitySensorReading>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ActivitySensorReading;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::ActivitySensorReading is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::ActivitySensorReadingChangeReport>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ActivitySensorReadingChangeReport;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::ActivitySensorReadingChangeReport is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::ActivitySensorReadingChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ActivitySensorReadingChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::ActivitySensorReadingChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::ActivitySensorTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ActivitySensorTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::ActivitySensorTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::Altimeter>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Altimeter;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::Altimeter is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::AltimeterReading>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AltimeterReading;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::AltimeterReading is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::AltimeterReadingChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AltimeterReadingChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::AltimeterReadingChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::Barometer>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Barometer;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::Barometer is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::BarometerDataThreshold>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BarometerDataThreshold;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::BarometerDataThreshold is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::BarometerReading>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BarometerReading;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::BarometerReading is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::BarometerReadingChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BarometerReadingChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::BarometerReadingChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::Compass>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Compass;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::Compass is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::CompassDataThreshold>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CompassDataThreshold;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::CompassDataThreshold is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::CompassReading>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CompassReading;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::CompassReading is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::CompassReadingChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CompassReadingChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::CompassReadingChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::Gyrometer>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Gyrometer;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::Gyrometer is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::GyrometerDataThreshold>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GyrometerDataThreshold;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::GyrometerDataThreshold is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::GyrometerReading>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GyrometerReading;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::GyrometerReading is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::GyrometerReadingChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GyrometerReadingChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::GyrometerReadingChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::HingeAngleReading>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HingeAngleReading;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::HingeAngleReading is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::HingeAngleSensor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HingeAngleSensor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::HingeAngleSensor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::HingeAngleSensorReadingChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HingeAngleSensorReadingChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::HingeAngleSensorReadingChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::HumanPresenceFeatures>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HumanPresenceFeatures;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::HumanPresenceFeatures is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::HumanPresenceSensor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HumanPresenceSensor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::HumanPresenceSensor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::HumanPresenceSensorReading>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HumanPresenceSensorReading;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::HumanPresenceSensorReading is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::HumanPresenceSensorReadingChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HumanPresenceSensorReadingChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::HumanPresenceSensorReadingChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::HumanPresenceSettings>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HumanPresenceSettings;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::HumanPresenceSettings is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::Inclinometer>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Inclinometer;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::Inclinometer is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::InclinometerDataThreshold>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_InclinometerDataThreshold;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::InclinometerDataThreshold is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::InclinometerReading>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_InclinometerReading;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::InclinometerReading is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::InclinometerReadingChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_InclinometerReadingChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::InclinometerReadingChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::LightSensor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LightSensor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::LightSensor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::LightSensorDataThreshold>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LightSensorDataThreshold;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::LightSensorDataThreshold is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::LightSensorReading>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LightSensorReading;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::LightSensorReading is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::LightSensorReadingChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LightSensorReadingChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::LightSensorReadingChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::Magnetometer>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Magnetometer;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::Magnetometer is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::MagnetometerDataThreshold>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MagnetometerDataThreshold;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::MagnetometerDataThreshold is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::MagnetometerReading>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MagnetometerReading;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::MagnetometerReading is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::MagnetometerReadingChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MagnetometerReadingChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::MagnetometerReadingChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::OrientationSensor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_OrientationSensor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::OrientationSensor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::OrientationSensorReading>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_OrientationSensorReading;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::OrientationSensorReading is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::OrientationSensorReadingChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_OrientationSensorReadingChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::OrientationSensorReadingChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::Pedometer>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Pedometer;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::Pedometer is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::PedometerDataThreshold>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PedometerDataThreshold;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::PedometerDataThreshold is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::PedometerReading>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PedometerReading;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::PedometerReading is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::PedometerReadingChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PedometerReadingChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::PedometerReadingChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::ProximitySensor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProximitySensor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::ProximitySensor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::ProximitySensorDataThreshold>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProximitySensorDataThreshold;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::ProximitySensorDataThreshold is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProximitySensorDisplayOnOffController;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::ProximitySensorReading>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProximitySensorReading;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::ProximitySensorReading is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::ProximitySensorReadingChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProximitySensorReadingChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::ProximitySensorReadingChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SensorDataThresholdTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::SensorQuaternion>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SensorQuaternion;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::SensorQuaternion is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::SensorRotationMatrix>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SensorRotationMatrix;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::SensorRotationMatrix is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::SimpleOrientationSensor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SimpleOrientationSensor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::SimpleOrientationSensor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SimpleOrientationSensorOrientationChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::ISensorDataThreshold>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Sensors;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Sensors");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ISensorDataThreshold;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Sensors::ISensorDataThreshold is not registered");
        return nullptr;
    }

    return python_type;
}
