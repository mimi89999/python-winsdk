// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.Security.Cryptography.Core.h"


namespace py::cpp::Windows::Security::Cryptography::Core
{
    struct module_state
    {
        PyObject* type_Capi1KdfTargetAlgorithm;
        PyObject* type_CryptographicPadding;
        PyObject* type_CryptographicPrivateKeyBlobType;
        PyObject* type_CryptographicPublicKeyBlobType;
        PyTypeObject* type_AsymmetricAlgorithmNames;
        PyTypeObject* type_AsymmetricKeyAlgorithmProvider;
        PyTypeObject* type_CryptographicEngine;
        PyTypeObject* type_CryptographicHash;
        PyTypeObject* type_CryptographicKey;
        PyTypeObject* type_EccCurveNames;
        PyTypeObject* type_EncryptedAndAuthenticatedData;
        PyTypeObject* type_HashAlgorithmNames;
        PyTypeObject* type_HashAlgorithmProvider;
        PyTypeObject* type_KeyDerivationAlgorithmNames;
        PyTypeObject* type_KeyDerivationAlgorithmProvider;
        PyTypeObject* type_KeyDerivationParameters;
        PyTypeObject* type_MacAlgorithmNames;
        PyTypeObject* type_MacAlgorithmProvider;
        PyTypeObject* type_PersistedKeyProvider;
        PyTypeObject* type_SymmetricAlgorithmNames;
        PyTypeObject* type_SymmetricKeyAlgorithmProvider;
    };

    static PyObject* register_Capi1KdfTargetAlgorithm(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_Capi1KdfTargetAlgorithm)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_Capi1KdfTargetAlgorithm = type;
        Py_INCREF(state->type_Capi1KdfTargetAlgorithm);


        Py_RETURN_NONE;
    }

    static PyObject* register_CryptographicPadding(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CryptographicPadding)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CryptographicPadding = type;
        Py_INCREF(state->type_CryptographicPadding);


        Py_RETURN_NONE;
    }

    static PyObject* register_CryptographicPrivateKeyBlobType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CryptographicPrivateKeyBlobType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CryptographicPrivateKeyBlobType = type;
        Py_INCREF(state->type_CryptographicPrivateKeyBlobType);


        Py_RETURN_NONE;
    }

    static PyObject* register_CryptographicPublicKeyBlobType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CryptographicPublicKeyBlobType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CryptographicPublicKeyBlobType = type;
        Py_INCREF(state->type_CryptographicPublicKeyBlobType);


        Py_RETURN_NONE;
    }

    // ----- AsymmetricAlgorithmNames class --------------------
    static constexpr const char* const type_name_AsymmetricAlgorithmNames = "AsymmetricAlgorithmNames";

    static PyObject* _new_AsymmetricAlgorithmNames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AsymmetricAlgorithmNames);
        return nullptr;
    }

    static PyObject* AsymmetricAlgorithmNames_get_EcdsaP521Sha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"EcdsaP521Sha512"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::EcdsaP521Sha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_DsaSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"DsaSha1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::DsaSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_DsaSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"DsaSha256"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::DsaSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_EcdsaP256Sha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"EcdsaP256Sha256"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::EcdsaP256Sha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_EcdsaP384Sha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"EcdsaP384Sha384"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::EcdsaP384Sha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"RsaSignPkcs1Sha256"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPkcs1Sha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaOaepSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"RsaOaepSha1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaOaepSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaOaepSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"RsaOaepSha256"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaOaepSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaOaepSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"RsaOaepSha384"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaOaepSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaOaepSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"RsaOaepSha512"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaOaepSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaPkcs1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"RsaPkcs1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaPkcs1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"RsaSignPkcs1Sha1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPkcs1Sha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"RsaSignPkcs1Sha384"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPkcs1Sha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"RsaSignPkcs1Sha512"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPkcs1Sha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPssSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"RsaSignPssSha1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPssSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPssSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"RsaSignPssSha256"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPssSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPssSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"RsaSignPssSha384"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPssSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPssSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"RsaSignPssSha512"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPssSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_EcdsaSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"EcdsaSha384"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::EcdsaSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_EcdsaSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"EcdsaSha512"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::EcdsaSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_EcdsaSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"EcdsaSha256"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::EcdsaSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AsymmetricAlgorithmNames[] = {
        { }
    };

    static PyGetSetDef _getset_AsymmetricAlgorithmNames[] = {
        { }
    };

    static PyType_Slot _type_slots_AsymmetricAlgorithmNames[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AsymmetricAlgorithmNames) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AsymmetricAlgorithmNames) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AsymmetricAlgorithmNames) },
        { },
    };

    static PyType_Spec type_spec_AsymmetricAlgorithmNames =
    {
        "_winsdk_Windows_Security_Cryptography_Core.AsymmetricAlgorithmNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AsymmetricAlgorithmNames
    };

    static PyGetSetDef getset_AsymmetricAlgorithmNames_Meta[] = {
        { "ecdsa_p521_sha512", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_EcdsaP521Sha512), nullptr, nullptr, nullptr },
        { "dsa_sha1", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_DsaSha1), nullptr, nullptr, nullptr },
        { "dsa_sha256", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_DsaSha256), nullptr, nullptr, nullptr },
        { "ecdsa_p256_sha256", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_EcdsaP256Sha256), nullptr, nullptr, nullptr },
        { "ecdsa_p384_sha384", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_EcdsaP384Sha384), nullptr, nullptr, nullptr },
        { "rsa_sign_pkcs1_sha256", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha256), nullptr, nullptr, nullptr },
        { "rsa_oaep_sha1", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_RsaOaepSha1), nullptr, nullptr, nullptr },
        { "rsa_oaep_sha256", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_RsaOaepSha256), nullptr, nullptr, nullptr },
        { "rsa_oaep_sha384", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_RsaOaepSha384), nullptr, nullptr, nullptr },
        { "rsa_oaep_sha512", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_RsaOaepSha512), nullptr, nullptr, nullptr },
        { "rsa_pkcs1", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_RsaPkcs1), nullptr, nullptr, nullptr },
        { "rsa_sign_pkcs1_sha1", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha1), nullptr, nullptr, nullptr },
        { "rsa_sign_pkcs1_sha384", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha384), nullptr, nullptr, nullptr },
        { "rsa_sign_pkcs1_sha512", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha512), nullptr, nullptr, nullptr },
        { "rsa_sign_pss_sha1", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_RsaSignPssSha1), nullptr, nullptr, nullptr },
        { "rsa_sign_pss_sha256", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_RsaSignPssSha256), nullptr, nullptr, nullptr },
        { "rsa_sign_pss_sha384", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_RsaSignPssSha384), nullptr, nullptr, nullptr },
        { "rsa_sign_pss_sha512", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_RsaSignPssSha512), nullptr, nullptr, nullptr },
        { "ecdsa_sha384", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_EcdsaSha384), nullptr, nullptr, nullptr },
        { "ecdsa_sha512", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_EcdsaSha512), nullptr, nullptr, nullptr },
        { "ecdsa_sha256", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_EcdsaSha256), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_AsymmetricAlgorithmNames_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AsymmetricAlgorithmNames_Meta) },
        { }
    };

    static PyType_Spec type_spec_AsymmetricAlgorithmNames_Meta =
    {
        "_winsdk_Windows_Security_Cryptography_Core.AsymmetricAlgorithmNames_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AsymmetricAlgorithmNames_Meta
    };

    // ----- AsymmetricKeyAlgorithmProvider class --------------------
    static constexpr const char* const type_name_AsymmetricKeyAlgorithmProvider = "AsymmetricKeyAlgorithmProvider";

    static PyObject* _new_AsymmetricKeyAlgorithmProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AsymmetricKeyAlgorithmProvider);
        return nullptr;
    }

    static void _dealloc_AsymmetricKeyAlgorithmProvider(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_CreateKeyPair(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider", L"CreateKeyPair", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.CreateKeyPair(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_CreateKeyPairWithCurveName(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider", L"CreateKeyPairWithCurveName", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateKeyPairWithCurveName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_CreateKeyPairWithCurveParameters(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider", L"CreateKeyPairWithCurveParameters", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert(self->obj.CreateKeyPairWithCurveParameters(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_ImportKeyPair(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider", L"ImportKeyPair", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.ImportKeyPair(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider", L"ImportKeyPair", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicPrivateKeyBlobType>(args, 1);

                return py::convert(self->obj.ImportKeyPair(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_ImportPublicKey(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider", L"ImportPublicKey", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.ImportPublicKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider", L"ImportPublicKey", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicPublicKeyBlobType>(args, 1);

                return py::convert(self->obj.ImportPublicKey(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_OpenAlgorithm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider", L"OpenAlgorithm", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider::OpenAlgorithm(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_get_AlgorithmName(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider", L"AlgorithmName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AsymmetricKeyAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AsymmetricKeyAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AsymmetricKeyAlgorithmProvider[] = {
        { "create_key_pair", reinterpret_cast<PyCFunction>(AsymmetricKeyAlgorithmProvider_CreateKeyPair), METH_VARARGS, nullptr },
        { "create_key_pair_with_curve_name", reinterpret_cast<PyCFunction>(AsymmetricKeyAlgorithmProvider_CreateKeyPairWithCurveName), METH_VARARGS, nullptr },
        { "create_key_pair_with_curve_parameters", reinterpret_cast<PyCFunction>(AsymmetricKeyAlgorithmProvider_CreateKeyPairWithCurveParameters), METH_VARARGS, nullptr },
        { "import_key_pair", reinterpret_cast<PyCFunction>(AsymmetricKeyAlgorithmProvider_ImportKeyPair), METH_VARARGS, nullptr },
        { "import_public_key", reinterpret_cast<PyCFunction>(AsymmetricKeyAlgorithmProvider_ImportPublicKey), METH_VARARGS, nullptr },
        { "open_algorithm", reinterpret_cast<PyCFunction>(AsymmetricKeyAlgorithmProvider_OpenAlgorithm), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_AsymmetricKeyAlgorithmProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AsymmetricKeyAlgorithmProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AsymmetricKeyAlgorithmProvider[] = {
        { "algorithm_name", reinterpret_cast<getter>(AsymmetricKeyAlgorithmProvider_get_AlgorithmName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AsymmetricKeyAlgorithmProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AsymmetricKeyAlgorithmProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AsymmetricKeyAlgorithmProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AsymmetricKeyAlgorithmProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AsymmetricKeyAlgorithmProvider) },
        { },
    };

    static PyType_Spec type_spec_AsymmetricKeyAlgorithmProvider =
    {
        "_winsdk_Windows_Security_Cryptography_Core.AsymmetricKeyAlgorithmProvider",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AsymmetricKeyAlgorithmProvider
    };

    // ----- CryptographicEngine class --------------------
    static constexpr const char* const type_name_CryptographicEngine = "CryptographicEngine";

    static PyObject* _new_CryptographicEngine(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CryptographicEngine);
        return nullptr;
    }

    static PyObject* CryptographicEngine_Decrypt(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicEngine", L"Decrypt", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::Decrypt(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_DecryptAndAuthenticate(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicEngine", L"DecryptAndAuthenticate", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 4);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::DecryptAndAuthenticate(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_DecryptAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicEngine", L"DecryptAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::DecryptAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_DeriveKeyMaterial(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicEngine", L"DeriveKeyMaterial", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::DeriveKeyMaterial(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_Encrypt(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicEngine", L"Encrypt", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::Encrypt(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_EncryptAndAuthenticate(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicEngine", L"EncryptAndAuthenticate", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 3);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::EncryptAndAuthenticate(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_Sign(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicEngine", L"Sign", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::Sign(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_SignAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicEngine", L"SignAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::SignAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_SignHashedData(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicEngine", L"SignHashedData", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::SignHashedData(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_SignHashedDataAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicEngine", L"SignHashedDataAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::SignHashedDataAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_VerifySignature(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicEngine", L"VerifySignature", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::VerifySignature(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_VerifySignatureWithHashInput(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicEngine", L"VerifySignatureWithHashInput", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::VerifySignatureWithHashInput(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_CryptographicEngine[] = {
        { "decrypt", reinterpret_cast<PyCFunction>(CryptographicEngine_Decrypt), METH_VARARGS | METH_STATIC, nullptr },
        { "decrypt_and_authenticate", reinterpret_cast<PyCFunction>(CryptographicEngine_DecryptAndAuthenticate), METH_VARARGS | METH_STATIC, nullptr },
        { "decrypt_async", reinterpret_cast<PyCFunction>(CryptographicEngine_DecryptAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "derive_key_material", reinterpret_cast<PyCFunction>(CryptographicEngine_DeriveKeyMaterial), METH_VARARGS | METH_STATIC, nullptr },
        { "encrypt", reinterpret_cast<PyCFunction>(CryptographicEngine_Encrypt), METH_VARARGS | METH_STATIC, nullptr },
        { "encrypt_and_authenticate", reinterpret_cast<PyCFunction>(CryptographicEngine_EncryptAndAuthenticate), METH_VARARGS | METH_STATIC, nullptr },
        { "sign", reinterpret_cast<PyCFunction>(CryptographicEngine_Sign), METH_VARARGS | METH_STATIC, nullptr },
        { "sign_async", reinterpret_cast<PyCFunction>(CryptographicEngine_SignAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "sign_hashed_data", reinterpret_cast<PyCFunction>(CryptographicEngine_SignHashedData), METH_VARARGS | METH_STATIC, nullptr },
        { "sign_hashed_data_async", reinterpret_cast<PyCFunction>(CryptographicEngine_SignHashedDataAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "verify_signature", reinterpret_cast<PyCFunction>(CryptographicEngine_VerifySignature), METH_VARARGS | METH_STATIC, nullptr },
        { "verify_signature_with_hash_input", reinterpret_cast<PyCFunction>(CryptographicEngine_VerifySignatureWithHashInput), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CryptographicEngine[] = {
        { }
    };

    static PyType_Slot _type_slots_CryptographicEngine[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CryptographicEngine) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CryptographicEngine) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CryptographicEngine) },
        { },
    };

    static PyType_Spec type_spec_CryptographicEngine =
    {
        "_winsdk_Windows_Security_Cryptography_Core.CryptographicEngine",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CryptographicEngine
    };

    // ----- CryptographicHash class --------------------
    static constexpr const char* const type_name_CryptographicHash = "CryptographicHash";

    static PyObject* _new_CryptographicHash(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CryptographicHash);
        return nullptr;
    }

    static void _dealloc_CryptographicHash(py::wrapper::Windows::Security::Cryptography::Core::CryptographicHash* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CryptographicHash_Append(py::wrapper::Windows::Security::Cryptography::Core::CryptographicHash* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicHash", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicHash_GetValueAndReset(py::wrapper::Windows::Security::Cryptography::Core::CryptographicHash* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicHash", L"GetValueAndReset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetValueAndReset());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_CryptographicHash(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Core::CryptographicHash>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CryptographicHash(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::CryptographicHash>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CryptographicHash[] = {
        { "append", reinterpret_cast<PyCFunction>(CryptographicHash_Append), METH_VARARGS, nullptr },
        { "get_value_and_reset", reinterpret_cast<PyCFunction>(CryptographicHash_GetValueAndReset), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CryptographicHash, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CryptographicHash), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CryptographicHash[] = {
        { }
    };

    static PyType_Slot _type_slots_CryptographicHash[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CryptographicHash) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CryptographicHash) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CryptographicHash) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CryptographicHash) },
        { },
    };

    static PyType_Spec type_spec_CryptographicHash =
    {
        "_winsdk_Windows_Security_Cryptography_Core.CryptographicHash",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::CryptographicHash),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CryptographicHash
    };

    // ----- CryptographicKey class --------------------
    static constexpr const char* const type_name_CryptographicKey = "CryptographicKey";

    static PyObject* _new_CryptographicKey(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CryptographicKey);
        return nullptr;
    }

    static void _dealloc_CryptographicKey(py::wrapper::Windows::Security::Cryptography::Core::CryptographicKey* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CryptographicKey_Export(py::wrapper::Windows::Security::Cryptography::Core::CryptographicKey* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicKey", L"Export", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Export());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicKey", L"Export", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicPrivateKeyBlobType>(args, 0);

                return py::convert(self->obj.Export(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicKey_ExportPublicKey(py::wrapper::Windows::Security::Cryptography::Core::CryptographicKey* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicKey", L"ExportPublicKey", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ExportPublicKey());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicKey", L"ExportPublicKey", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicPublicKeyBlobType>(args, 0);

                return py::convert(self->obj.ExportPublicKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicKey_get_KeySize(py::wrapper::Windows::Security::Cryptography::Core::CryptographicKey* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.CryptographicKey", L"KeySize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeySize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CryptographicKey(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Core::CryptographicKey>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CryptographicKey(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::CryptographicKey>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CryptographicKey[] = {
        { "export", reinterpret_cast<PyCFunction>(CryptographicKey_Export), METH_VARARGS, nullptr },
        { "export_public_key", reinterpret_cast<PyCFunction>(CryptographicKey_ExportPublicKey), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CryptographicKey, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CryptographicKey), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CryptographicKey[] = {
        { "key_size", reinterpret_cast<getter>(CryptographicKey_get_KeySize), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CryptographicKey[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CryptographicKey) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CryptographicKey) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CryptographicKey) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CryptographicKey) },
        { },
    };

    static PyType_Spec type_spec_CryptographicKey =
    {
        "_winsdk_Windows_Security_Cryptography_Core.CryptographicKey",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::CryptographicKey),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CryptographicKey
    };

    // ----- EccCurveNames class --------------------
    static constexpr const char* const type_name_EccCurveNames = "EccCurveNames";

    static PyObject* _new_EccCurveNames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EccCurveNames);
        return nullptr;
    }

    static PyObject* EccCurveNames_get_AllEccCurveNames(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"AllEccCurveNames"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::AllEccCurveNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP160r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP160r1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP160r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP160t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP160t1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP160t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP192r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP192r1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP192r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP192t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP192t1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP192t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP224r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP224r1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP224r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP224t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP224t1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP224t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP256r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP256r1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP256r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP256t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP256t1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP256t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP320r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP320r1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP320r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP320t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP320t1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP320t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP384r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP384r1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP384r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP384t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP384t1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP384t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP512r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP512r1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP512r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP512t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP512t1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP512t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_Curve25519(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"Curve25519"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::Curve25519());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_Ec192wapi(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"Ec192wapi"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::Ec192wapi());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NistP192(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"NistP192"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NistP192());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NistP224(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"NistP224"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NistP224());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NistP256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"NistP256"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NistP256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NistP384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"NistP384"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NistP384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NistP521(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"NistP521"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NistP521());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NumsP256t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"NumsP256t1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NumsP256t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NumsP384t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"NumsP384t1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NumsP384t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NumsP512t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"NumsP512t1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NumsP512t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP160k1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"SecP160k1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP160k1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP160r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"SecP160r1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP160r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP160r2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"SecP160r2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP160r2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP192k1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"SecP192k1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP192k1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP192r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"SecP192r1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP192r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP224k1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"SecP224k1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP224k1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP224r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"SecP224r1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP224r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP256k1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"SecP256k1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP256k1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP256r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"SecP256r1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP256r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP384r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"SecP384r1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP384r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP521r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"SecP521r1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP521r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_Wtls12(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"Wtls12"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::Wtls12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_Wtls7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"Wtls7"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::Wtls7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_Wtls9(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"Wtls9"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::Wtls9());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P192v1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"X962P192v1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P192v1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P192v2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"X962P192v2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P192v2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P192v3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"X962P192v3"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P192v3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P239v1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"X962P239v1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P239v1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P239v2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"X962P239v2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P239v2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P239v3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"X962P239v3"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P239v3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P256v1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"X962P256v1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P256v1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EccCurveNames[] = {
        { }
    };

    static PyGetSetDef _getset_EccCurveNames[] = {
        { }
    };

    static PyType_Slot _type_slots_EccCurveNames[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EccCurveNames) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EccCurveNames) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EccCurveNames) },
        { },
    };

    static PyType_Spec type_spec_EccCurveNames =
    {
        "_winsdk_Windows_Security_Cryptography_Core.EccCurveNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EccCurveNames
    };

    static PyGetSetDef getset_EccCurveNames_Meta[] = {
        { "all_ecc_curve_names", reinterpret_cast<getter>(EccCurveNames_get_AllEccCurveNames), nullptr, nullptr, nullptr },
        { "brainpool_p160r1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP160r1), nullptr, nullptr, nullptr },
        { "brainpool_p160t1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP160t1), nullptr, nullptr, nullptr },
        { "brainpool_p192r1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP192r1), nullptr, nullptr, nullptr },
        { "brainpool_p192t1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP192t1), nullptr, nullptr, nullptr },
        { "brainpool_p224r1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP224r1), nullptr, nullptr, nullptr },
        { "brainpool_p224t1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP224t1), nullptr, nullptr, nullptr },
        { "brainpool_p256r1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP256r1), nullptr, nullptr, nullptr },
        { "brainpool_p256t1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP256t1), nullptr, nullptr, nullptr },
        { "brainpool_p320r1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP320r1), nullptr, nullptr, nullptr },
        { "brainpool_p320t1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP320t1), nullptr, nullptr, nullptr },
        { "brainpool_p384r1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP384r1), nullptr, nullptr, nullptr },
        { "brainpool_p384t1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP384t1), nullptr, nullptr, nullptr },
        { "brainpool_p512r1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP512r1), nullptr, nullptr, nullptr },
        { "brainpool_p512t1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP512t1), nullptr, nullptr, nullptr },
        { "curve25519", reinterpret_cast<getter>(EccCurveNames_get_Curve25519), nullptr, nullptr, nullptr },
        { "ec192wapi", reinterpret_cast<getter>(EccCurveNames_get_Ec192wapi), nullptr, nullptr, nullptr },
        { "nist_p192", reinterpret_cast<getter>(EccCurveNames_get_NistP192), nullptr, nullptr, nullptr },
        { "nist_p224", reinterpret_cast<getter>(EccCurveNames_get_NistP224), nullptr, nullptr, nullptr },
        { "nist_p256", reinterpret_cast<getter>(EccCurveNames_get_NistP256), nullptr, nullptr, nullptr },
        { "nist_p384", reinterpret_cast<getter>(EccCurveNames_get_NistP384), nullptr, nullptr, nullptr },
        { "nist_p521", reinterpret_cast<getter>(EccCurveNames_get_NistP521), nullptr, nullptr, nullptr },
        { "nums_p256t1", reinterpret_cast<getter>(EccCurveNames_get_NumsP256t1), nullptr, nullptr, nullptr },
        { "nums_p384t1", reinterpret_cast<getter>(EccCurveNames_get_NumsP384t1), nullptr, nullptr, nullptr },
        { "nums_p512t1", reinterpret_cast<getter>(EccCurveNames_get_NumsP512t1), nullptr, nullptr, nullptr },
        { "sec_p160k1", reinterpret_cast<getter>(EccCurveNames_get_SecP160k1), nullptr, nullptr, nullptr },
        { "sec_p160r1", reinterpret_cast<getter>(EccCurveNames_get_SecP160r1), nullptr, nullptr, nullptr },
        { "sec_p160r2", reinterpret_cast<getter>(EccCurveNames_get_SecP160r2), nullptr, nullptr, nullptr },
        { "sec_p192k1", reinterpret_cast<getter>(EccCurveNames_get_SecP192k1), nullptr, nullptr, nullptr },
        { "sec_p192r1", reinterpret_cast<getter>(EccCurveNames_get_SecP192r1), nullptr, nullptr, nullptr },
        { "sec_p224k1", reinterpret_cast<getter>(EccCurveNames_get_SecP224k1), nullptr, nullptr, nullptr },
        { "sec_p224r1", reinterpret_cast<getter>(EccCurveNames_get_SecP224r1), nullptr, nullptr, nullptr },
        { "sec_p256k1", reinterpret_cast<getter>(EccCurveNames_get_SecP256k1), nullptr, nullptr, nullptr },
        { "sec_p256r1", reinterpret_cast<getter>(EccCurveNames_get_SecP256r1), nullptr, nullptr, nullptr },
        { "sec_p384r1", reinterpret_cast<getter>(EccCurveNames_get_SecP384r1), nullptr, nullptr, nullptr },
        { "sec_p521r1", reinterpret_cast<getter>(EccCurveNames_get_SecP521r1), nullptr, nullptr, nullptr },
        { "wtls12", reinterpret_cast<getter>(EccCurveNames_get_Wtls12), nullptr, nullptr, nullptr },
        { "wtls7", reinterpret_cast<getter>(EccCurveNames_get_Wtls7), nullptr, nullptr, nullptr },
        { "wtls9", reinterpret_cast<getter>(EccCurveNames_get_Wtls9), nullptr, nullptr, nullptr },
        { "x962_p192v1", reinterpret_cast<getter>(EccCurveNames_get_X962P192v1), nullptr, nullptr, nullptr },
        { "x962_p192v2", reinterpret_cast<getter>(EccCurveNames_get_X962P192v2), nullptr, nullptr, nullptr },
        { "x962_p192v3", reinterpret_cast<getter>(EccCurveNames_get_X962P192v3), nullptr, nullptr, nullptr },
        { "x962_p239v1", reinterpret_cast<getter>(EccCurveNames_get_X962P239v1), nullptr, nullptr, nullptr },
        { "x962_p239v2", reinterpret_cast<getter>(EccCurveNames_get_X962P239v2), nullptr, nullptr, nullptr },
        { "x962_p239v3", reinterpret_cast<getter>(EccCurveNames_get_X962P239v3), nullptr, nullptr, nullptr },
        { "x962_p256v1", reinterpret_cast<getter>(EccCurveNames_get_X962P256v1), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_EccCurveNames_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_EccCurveNames_Meta) },
        { }
    };

    static PyType_Spec type_spec_EccCurveNames_Meta =
    {
        "_winsdk_Windows_Security_Cryptography_Core.EccCurveNames_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_EccCurveNames_Meta
    };

    // ----- EncryptedAndAuthenticatedData class --------------------
    static constexpr const char* const type_name_EncryptedAndAuthenticatedData = "EncryptedAndAuthenticatedData";

    static PyObject* _new_EncryptedAndAuthenticatedData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EncryptedAndAuthenticatedData);
        return nullptr;
    }

    static void _dealloc_EncryptedAndAuthenticatedData(py::wrapper::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EncryptedAndAuthenticatedData_get_AuthenticationTag(py::wrapper::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EncryptedAndAuthenticatedData", L"AuthenticationTag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AuthenticationTag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EncryptedAndAuthenticatedData_get_EncryptedData(py::wrapper::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EncryptedAndAuthenticatedData", L"EncryptedData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncryptedData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EncryptedAndAuthenticatedData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EncryptedAndAuthenticatedData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EncryptedAndAuthenticatedData[] = {
        { "_assign_array_", _assign_array_EncryptedAndAuthenticatedData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EncryptedAndAuthenticatedData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EncryptedAndAuthenticatedData[] = {
        { "authentication_tag", reinterpret_cast<getter>(EncryptedAndAuthenticatedData_get_AuthenticationTag), nullptr, nullptr, nullptr },
        { "encrypted_data", reinterpret_cast<getter>(EncryptedAndAuthenticatedData_get_EncryptedData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EncryptedAndAuthenticatedData[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EncryptedAndAuthenticatedData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EncryptedAndAuthenticatedData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EncryptedAndAuthenticatedData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EncryptedAndAuthenticatedData) },
        { },
    };

    static PyType_Spec type_spec_EncryptedAndAuthenticatedData =
    {
        "_winsdk_Windows_Security_Cryptography_Core.EncryptedAndAuthenticatedData",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EncryptedAndAuthenticatedData
    };

    // ----- HashAlgorithmNames class --------------------
    static constexpr const char* const type_name_HashAlgorithmNames = "HashAlgorithmNames";

    static PyObject* _new_HashAlgorithmNames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HashAlgorithmNames);
        return nullptr;
    }

    static PyObject* HashAlgorithmNames_get_Md5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.HashAlgorithmNames", L"Md5"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames::Md5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmNames_get_Sha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.HashAlgorithmNames", L"Sha1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames::Sha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmNames_get_Sha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.HashAlgorithmNames", L"Sha256"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames::Sha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmNames_get_Sha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.HashAlgorithmNames", L"Sha384"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames::Sha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmNames_get_Sha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.HashAlgorithmNames", L"Sha512"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames::Sha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HashAlgorithmNames[] = {
        { }
    };

    static PyGetSetDef _getset_HashAlgorithmNames[] = {
        { }
    };

    static PyType_Slot _type_slots_HashAlgorithmNames[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HashAlgorithmNames) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HashAlgorithmNames) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HashAlgorithmNames) },
        { },
    };

    static PyType_Spec type_spec_HashAlgorithmNames =
    {
        "_winsdk_Windows_Security_Cryptography_Core.HashAlgorithmNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HashAlgorithmNames
    };

    static PyGetSetDef getset_HashAlgorithmNames_Meta[] = {
        { "md5", reinterpret_cast<getter>(HashAlgorithmNames_get_Md5), nullptr, nullptr, nullptr },
        { "sha1", reinterpret_cast<getter>(HashAlgorithmNames_get_Sha1), nullptr, nullptr, nullptr },
        { "sha256", reinterpret_cast<getter>(HashAlgorithmNames_get_Sha256), nullptr, nullptr, nullptr },
        { "sha384", reinterpret_cast<getter>(HashAlgorithmNames_get_Sha384), nullptr, nullptr, nullptr },
        { "sha512", reinterpret_cast<getter>(HashAlgorithmNames_get_Sha512), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_HashAlgorithmNames_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HashAlgorithmNames_Meta) },
        { }
    };

    static PyType_Spec type_spec_HashAlgorithmNames_Meta =
    {
        "_winsdk_Windows_Security_Cryptography_Core.HashAlgorithmNames_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HashAlgorithmNames_Meta
    };

    // ----- HashAlgorithmProvider class --------------------
    static constexpr const char* const type_name_HashAlgorithmProvider = "HashAlgorithmProvider";

    static PyObject* _new_HashAlgorithmProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HashAlgorithmProvider);
        return nullptr;
    }

    static void _dealloc_HashAlgorithmProvider(py::wrapper::Windows::Security::Cryptography::Core::HashAlgorithmProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HashAlgorithmProvider_CreateHash(py::wrapper::Windows::Security::Cryptography::Core::HashAlgorithmProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.HashAlgorithmProvider", L"CreateHash", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateHash());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmProvider_HashData(py::wrapper::Windows::Security::Cryptography::Core::HashAlgorithmProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.HashAlgorithmProvider", L"HashData", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.HashData(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmProvider_OpenAlgorithm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.HashAlgorithmProvider", L"OpenAlgorithm", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Core::HashAlgorithmProvider::OpenAlgorithm(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmProvider_get_AlgorithmName(py::wrapper::Windows::Security::Cryptography::Core::HashAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.HashAlgorithmProvider", L"AlgorithmName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmProvider_get_HashLength(py::wrapper::Windows::Security::Cryptography::Core::HashAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.HashAlgorithmProvider", L"HashLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HashLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HashAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Core::HashAlgorithmProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HashAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::HashAlgorithmProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HashAlgorithmProvider[] = {
        { "create_hash", reinterpret_cast<PyCFunction>(HashAlgorithmProvider_CreateHash), METH_VARARGS, nullptr },
        { "hash_data", reinterpret_cast<PyCFunction>(HashAlgorithmProvider_HashData), METH_VARARGS, nullptr },
        { "open_algorithm", reinterpret_cast<PyCFunction>(HashAlgorithmProvider_OpenAlgorithm), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_HashAlgorithmProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HashAlgorithmProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HashAlgorithmProvider[] = {
        { "algorithm_name", reinterpret_cast<getter>(HashAlgorithmProvider_get_AlgorithmName), nullptr, nullptr, nullptr },
        { "hash_length", reinterpret_cast<getter>(HashAlgorithmProvider_get_HashLength), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HashAlgorithmProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HashAlgorithmProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HashAlgorithmProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HashAlgorithmProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HashAlgorithmProvider) },
        { },
    };

    static PyType_Spec type_spec_HashAlgorithmProvider =
    {
        "_winsdk_Windows_Security_Cryptography_Core.HashAlgorithmProvider",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::HashAlgorithmProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HashAlgorithmProvider
    };

    // ----- KeyDerivationAlgorithmNames class --------------------
    static constexpr const char* const type_name_KeyDerivationAlgorithmNames = "KeyDerivationAlgorithmNames";

    static PyObject* _new_KeyDerivationAlgorithmNames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KeyDerivationAlgorithmNames);
        return nullptr;
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Pbkdf2Sha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Pbkdf2Sha256"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Pbkdf2Sha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Pbkdf2Md5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Pbkdf2Md5"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Pbkdf2Md5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Pbkdf2Sha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Pbkdf2Sha1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Pbkdf2Sha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Sp800108CtrHmacSha512"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp800108CtrHmacSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Pbkdf2Sha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Pbkdf2Sha384"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Pbkdf2Sha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Pbkdf2Sha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Pbkdf2Sha512"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Pbkdf2Sha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp800108CtrHmacMd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Sp800108CtrHmacMd5"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp800108CtrHmacMd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Sp800108CtrHmacSha1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp800108CtrHmacSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Sp800108CtrHmacSha256"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp800108CtrHmacSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Sp800108CtrHmacSha384"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp800108CtrHmacSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp80056aConcatMd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Sp80056aConcatMd5"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp80056aConcatMd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp80056aConcatSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Sp80056aConcatSha1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp80056aConcatSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp80056aConcatSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Sp80056aConcatSha256"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp80056aConcatSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp80056aConcatSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Sp80056aConcatSha384"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp80056aConcatSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp80056aConcatSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Sp80056aConcatSha512"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp80056aConcatSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_CapiKdfSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"CapiKdfSha1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::CapiKdfSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_CapiKdfSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"CapiKdfSha256"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::CapiKdfSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_CapiKdfSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"CapiKdfSha384"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::CapiKdfSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_CapiKdfSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"CapiKdfSha512"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::CapiKdfSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_CapiKdfMd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"CapiKdfMd5"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::CapiKdfMd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyDerivationAlgorithmNames[] = {
        { }
    };

    static PyGetSetDef _getset_KeyDerivationAlgorithmNames[] = {
        { }
    };

    static PyType_Slot _type_slots_KeyDerivationAlgorithmNames[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyDerivationAlgorithmNames) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeyDerivationAlgorithmNames) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyDerivationAlgorithmNames) },
        { },
    };

    static PyType_Spec type_spec_KeyDerivationAlgorithmNames =
    {
        "_winsdk_Windows_Security_Cryptography_Core.KeyDerivationAlgorithmNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyDerivationAlgorithmNames
    };

    static PyGetSetDef getset_KeyDerivationAlgorithmNames_Meta[] = {
        { "pbkdf2_sha256", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Pbkdf2Sha256), nullptr, nullptr, nullptr },
        { "pbkdf2_md5", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Pbkdf2Md5), nullptr, nullptr, nullptr },
        { "pbkdf2_sha1", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Pbkdf2Sha1), nullptr, nullptr, nullptr },
        { "sp800108_ctr_hmac_sha512", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha512), nullptr, nullptr, nullptr },
        { "pbkdf2_sha384", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Pbkdf2Sha384), nullptr, nullptr, nullptr },
        { "pbkdf2_sha512", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Pbkdf2Sha512), nullptr, nullptr, nullptr },
        { "sp800108_ctr_hmac_md5", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Sp800108CtrHmacMd5), nullptr, nullptr, nullptr },
        { "sp800108_ctr_hmac_sha1", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha1), nullptr, nullptr, nullptr },
        { "sp800108_ctr_hmac_sha256", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha256), nullptr, nullptr, nullptr },
        { "sp800108_ctr_hmac_sha384", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha384), nullptr, nullptr, nullptr },
        { "sp80056a_concat_md5", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Sp80056aConcatMd5), nullptr, nullptr, nullptr },
        { "sp80056a_concat_sha1", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Sp80056aConcatSha1), nullptr, nullptr, nullptr },
        { "sp80056a_concat_sha256", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Sp80056aConcatSha256), nullptr, nullptr, nullptr },
        { "sp80056a_concat_sha384", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Sp80056aConcatSha384), nullptr, nullptr, nullptr },
        { "sp80056a_concat_sha512", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Sp80056aConcatSha512), nullptr, nullptr, nullptr },
        { "capi_kdf_sha1", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_CapiKdfSha1), nullptr, nullptr, nullptr },
        { "capi_kdf_sha256", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_CapiKdfSha256), nullptr, nullptr, nullptr },
        { "capi_kdf_sha384", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_CapiKdfSha384), nullptr, nullptr, nullptr },
        { "capi_kdf_sha512", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_CapiKdfSha512), nullptr, nullptr, nullptr },
        { "capi_kdf_md5", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_CapiKdfMd5), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_KeyDerivationAlgorithmNames_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KeyDerivationAlgorithmNames_Meta) },
        { }
    };

    static PyType_Spec type_spec_KeyDerivationAlgorithmNames_Meta =
    {
        "_winsdk_Windows_Security_Cryptography_Core.KeyDerivationAlgorithmNames_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KeyDerivationAlgorithmNames_Meta
    };

    // ----- KeyDerivationAlgorithmProvider class --------------------
    static constexpr const char* const type_name_KeyDerivationAlgorithmProvider = "KeyDerivationAlgorithmProvider";

    static PyObject* _new_KeyDerivationAlgorithmProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KeyDerivationAlgorithmProvider);
        return nullptr;
    }

    static void _dealloc_KeyDerivationAlgorithmProvider(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* KeyDerivationAlgorithmProvider_CreateKey(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmProvider", L"CreateKey", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.CreateKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmProvider_OpenAlgorithm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmProvider", L"OpenAlgorithm", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider::OpenAlgorithm(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmProvider_get_AlgorithmName(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmProvider", L"AlgorithmName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_KeyDerivationAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_KeyDerivationAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyDerivationAlgorithmProvider[] = {
        { "create_key", reinterpret_cast<PyCFunction>(KeyDerivationAlgorithmProvider_CreateKey), METH_VARARGS, nullptr },
        { "open_algorithm", reinterpret_cast<PyCFunction>(KeyDerivationAlgorithmProvider_OpenAlgorithm), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_KeyDerivationAlgorithmProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_KeyDerivationAlgorithmProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KeyDerivationAlgorithmProvider[] = {
        { "algorithm_name", reinterpret_cast<getter>(KeyDerivationAlgorithmProvider_get_AlgorithmName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_KeyDerivationAlgorithmProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyDerivationAlgorithmProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_KeyDerivationAlgorithmProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeyDerivationAlgorithmProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyDerivationAlgorithmProvider) },
        { },
    };

    static PyType_Spec type_spec_KeyDerivationAlgorithmProvider =
    {
        "_winsdk_Windows_Security_Cryptography_Core.KeyDerivationAlgorithmProvider",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyDerivationAlgorithmProvider
    };

    // ----- KeyDerivationParameters class --------------------
    static constexpr const char* const type_name_KeyDerivationParameters = "KeyDerivationParameters";

    static PyObject* _new_KeyDerivationParameters(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KeyDerivationParameters);
        return nullptr;
    }

    static void _dealloc_KeyDerivationParameters(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* KeyDerivationParameters_BuildForCapi1Kdf(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.KeyDerivationParameters", L"BuildForCapi1Kdf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::Capi1KdfTargetAlgorithm>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters::BuildForCapi1Kdf(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyDerivationParameters_BuildForPbkdf2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.KeyDerivationParameters", L"BuildForPbkdf2", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters::BuildForPbkdf2(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyDerivationParameters_BuildForSP800108(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.KeyDerivationParameters", L"BuildForSP800108", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters::BuildForSP800108(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyDerivationParameters_BuildForSP80056a(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.KeyDerivationParameters", L"BuildForSP80056a", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 4);

                return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters::BuildForSP80056a(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyDerivationParameters_get_KdfGenericBinary(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationParameters", L"KdfGenericBinary"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KdfGenericBinary());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyDerivationParameters_put_KdfGenericBinary(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationParameters", L"KdfGenericBinary"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.KdfGenericBinary(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeyDerivationParameters_get_IterationCount(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationParameters", L"IterationCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IterationCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationParameters_get_Capi1KdfTargetAlgorithm(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationParameters", L"Capi1KdfTargetAlgorithm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Capi1KdfTargetAlgorithm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyDerivationParameters_put_Capi1KdfTargetAlgorithm(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationParameters", L"Capi1KdfTargetAlgorithm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::Capi1KdfTargetAlgorithm>(arg);

            self->obj.Capi1KdfTargetAlgorithm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_KeyDerivationParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_KeyDerivationParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyDerivationParameters[] = {
        { "build_for_capi1_kdf", reinterpret_cast<PyCFunction>(KeyDerivationParameters_BuildForCapi1Kdf), METH_VARARGS | METH_STATIC, nullptr },
        { "build_for_pbkdf2", reinterpret_cast<PyCFunction>(KeyDerivationParameters_BuildForPbkdf2), METH_VARARGS | METH_STATIC, nullptr },
        { "build_for_s_p800108", reinterpret_cast<PyCFunction>(KeyDerivationParameters_BuildForSP800108), METH_VARARGS | METH_STATIC, nullptr },
        { "build_for_s_p80056a", reinterpret_cast<PyCFunction>(KeyDerivationParameters_BuildForSP80056a), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_KeyDerivationParameters, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_KeyDerivationParameters), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KeyDerivationParameters[] = {
        { "kdf_generic_binary", reinterpret_cast<getter>(KeyDerivationParameters_get_KdfGenericBinary), reinterpret_cast<setter>(KeyDerivationParameters_put_KdfGenericBinary), nullptr, nullptr },
        { "iteration_count", reinterpret_cast<getter>(KeyDerivationParameters_get_IterationCount), nullptr, nullptr, nullptr },
        { "capi1_kdf_target_algorithm", reinterpret_cast<getter>(KeyDerivationParameters_get_Capi1KdfTargetAlgorithm), reinterpret_cast<setter>(KeyDerivationParameters_put_Capi1KdfTargetAlgorithm), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_KeyDerivationParameters[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyDerivationParameters) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_KeyDerivationParameters) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeyDerivationParameters) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyDerivationParameters) },
        { },
    };

    static PyType_Spec type_spec_KeyDerivationParameters =
    {
        "_winsdk_Windows_Security_Cryptography_Core.KeyDerivationParameters",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyDerivationParameters
    };

    // ----- MacAlgorithmNames class --------------------
    static constexpr const char* const type_name_MacAlgorithmNames = "MacAlgorithmNames";

    static PyObject* _new_MacAlgorithmNames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MacAlgorithmNames);
        return nullptr;
    }

    static PyObject* MacAlgorithmNames_get_AesCmac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.MacAlgorithmNames", L"AesCmac"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames::AesCmac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmNames_get_HmacMd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.MacAlgorithmNames", L"HmacMd5"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames::HmacMd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmNames_get_HmacSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.MacAlgorithmNames", L"HmacSha1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames::HmacSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmNames_get_HmacSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.MacAlgorithmNames", L"HmacSha256"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames::HmacSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmNames_get_HmacSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.MacAlgorithmNames", L"HmacSha384"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames::HmacSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmNames_get_HmacSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.MacAlgorithmNames", L"HmacSha512"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames::HmacSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MacAlgorithmNames[] = {
        { }
    };

    static PyGetSetDef _getset_MacAlgorithmNames[] = {
        { }
    };

    static PyType_Slot _type_slots_MacAlgorithmNames[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MacAlgorithmNames) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MacAlgorithmNames) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MacAlgorithmNames) },
        { },
    };

    static PyType_Spec type_spec_MacAlgorithmNames =
    {
        "_winsdk_Windows_Security_Cryptography_Core.MacAlgorithmNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MacAlgorithmNames
    };

    static PyGetSetDef getset_MacAlgorithmNames_Meta[] = {
        { "aes_cmac", reinterpret_cast<getter>(MacAlgorithmNames_get_AesCmac), nullptr, nullptr, nullptr },
        { "hmac_md5", reinterpret_cast<getter>(MacAlgorithmNames_get_HmacMd5), nullptr, nullptr, nullptr },
        { "hmac_sha1", reinterpret_cast<getter>(MacAlgorithmNames_get_HmacSha1), nullptr, nullptr, nullptr },
        { "hmac_sha256", reinterpret_cast<getter>(MacAlgorithmNames_get_HmacSha256), nullptr, nullptr, nullptr },
        { "hmac_sha384", reinterpret_cast<getter>(MacAlgorithmNames_get_HmacSha384), nullptr, nullptr, nullptr },
        { "hmac_sha512", reinterpret_cast<getter>(MacAlgorithmNames_get_HmacSha512), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_MacAlgorithmNames_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MacAlgorithmNames_Meta) },
        { }
    };

    static PyType_Spec type_spec_MacAlgorithmNames_Meta =
    {
        "_winsdk_Windows_Security_Cryptography_Core.MacAlgorithmNames_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MacAlgorithmNames_Meta
    };

    // ----- MacAlgorithmProvider class --------------------
    static constexpr const char* const type_name_MacAlgorithmProvider = "MacAlgorithmProvider";

    static PyObject* _new_MacAlgorithmProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MacAlgorithmProvider);
        return nullptr;
    }

    static void _dealloc_MacAlgorithmProvider(py::wrapper::Windows::Security::Cryptography::Core::MacAlgorithmProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MacAlgorithmProvider_CreateHash(py::wrapper::Windows::Security::Cryptography::Core::MacAlgorithmProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.MacAlgorithmProvider", L"CreateHash", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.CreateHash(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmProvider_CreateKey(py::wrapper::Windows::Security::Cryptography::Core::MacAlgorithmProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.MacAlgorithmProvider", L"CreateKey", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.CreateKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmProvider_OpenAlgorithm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.MacAlgorithmProvider", L"OpenAlgorithm", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmProvider::OpenAlgorithm(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmProvider_get_AlgorithmName(py::wrapper::Windows::Security::Cryptography::Core::MacAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.MacAlgorithmProvider", L"AlgorithmName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmProvider_get_MacLength(py::wrapper::Windows::Security::Cryptography::Core::MacAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.MacAlgorithmProvider", L"MacLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MacLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MacAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Core::MacAlgorithmProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MacAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::MacAlgorithmProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MacAlgorithmProvider[] = {
        { "create_hash", reinterpret_cast<PyCFunction>(MacAlgorithmProvider_CreateHash), METH_VARARGS, nullptr },
        { "create_key", reinterpret_cast<PyCFunction>(MacAlgorithmProvider_CreateKey), METH_VARARGS, nullptr },
        { "open_algorithm", reinterpret_cast<PyCFunction>(MacAlgorithmProvider_OpenAlgorithm), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_MacAlgorithmProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MacAlgorithmProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MacAlgorithmProvider[] = {
        { "algorithm_name", reinterpret_cast<getter>(MacAlgorithmProvider_get_AlgorithmName), nullptr, nullptr, nullptr },
        { "mac_length", reinterpret_cast<getter>(MacAlgorithmProvider_get_MacLength), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MacAlgorithmProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MacAlgorithmProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MacAlgorithmProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MacAlgorithmProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MacAlgorithmProvider) },
        { },
    };

    static PyType_Spec type_spec_MacAlgorithmProvider =
    {
        "_winsdk_Windows_Security_Cryptography_Core.MacAlgorithmProvider",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::MacAlgorithmProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MacAlgorithmProvider
    };

    // ----- PersistedKeyProvider class --------------------
    static constexpr const char* const type_name_PersistedKeyProvider = "PersistedKeyProvider";

    static PyObject* _new_PersistedKeyProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PersistedKeyProvider);
        return nullptr;
    }

    static PyObject* PersistedKeyProvider_OpenKeyPairFromCertificateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.PersistedKeyProvider", L"OpenKeyPairFromCertificateAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicPadding>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::PersistedKeyProvider::OpenKeyPairFromCertificateAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PersistedKeyProvider_OpenPublicKeyFromCertificate(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.PersistedKeyProvider", L"OpenPublicKeyFromCertificate", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicPadding>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::PersistedKeyProvider::OpenPublicKeyFromCertificate(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PersistedKeyProvider[] = {
        { "open_key_pair_from_certificate_async", reinterpret_cast<PyCFunction>(PersistedKeyProvider_OpenKeyPairFromCertificateAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "open_public_key_from_certificate", reinterpret_cast<PyCFunction>(PersistedKeyProvider_OpenPublicKeyFromCertificate), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PersistedKeyProvider[] = {
        { }
    };

    static PyType_Slot _type_slots_PersistedKeyProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PersistedKeyProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PersistedKeyProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PersistedKeyProvider) },
        { },
    };

    static PyType_Spec type_spec_PersistedKeyProvider =
    {
        "_winsdk_Windows_Security_Cryptography_Core.PersistedKeyProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PersistedKeyProvider
    };

    // ----- SymmetricAlgorithmNames class --------------------
    static constexpr const char* const type_name_SymmetricAlgorithmNames = "SymmetricAlgorithmNames";

    static PyObject* _new_SymmetricAlgorithmNames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SymmetricAlgorithmNames);
        return nullptr;
    }

    static PyObject* SymmetricAlgorithmNames_get_AesCbc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"AesCbc"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::AesCbc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_AesCbcPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"AesCbcPkcs7"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::AesCbcPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_AesCcm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"AesCcm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::AesCcm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_AesEcb(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"AesEcb"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::AesEcb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_AesEcbPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"AesEcbPkcs7"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::AesEcbPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_AesGcm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"AesGcm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::AesGcm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_DesCbc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"DesCbc"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::DesCbc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_DesCbcPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"DesCbcPkcs7"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::DesCbcPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_DesEcb(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"DesEcb"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::DesEcb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_DesEcbPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"DesEcbPkcs7"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::DesEcbPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_Rc2Cbc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"Rc2Cbc"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::Rc2Cbc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_Rc2CbcPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"Rc2CbcPkcs7"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::Rc2CbcPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_Rc2Ecb(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"Rc2Ecb"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::Rc2Ecb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_Rc2EcbPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"Rc2EcbPkcs7"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::Rc2EcbPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_Rc4(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"Rc4"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::Rc4());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_TripleDesCbc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"TripleDesCbc"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::TripleDesCbc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_TripleDesCbcPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"TripleDesCbcPkcs7"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::TripleDesCbcPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_TripleDesEcb(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"TripleDesEcb"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::TripleDesEcb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_TripleDesEcbPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"TripleDesEcbPkcs7"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::TripleDesEcbPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SymmetricAlgorithmNames[] = {
        { }
    };

    static PyGetSetDef _getset_SymmetricAlgorithmNames[] = {
        { }
    };

    static PyType_Slot _type_slots_SymmetricAlgorithmNames[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SymmetricAlgorithmNames) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SymmetricAlgorithmNames) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SymmetricAlgorithmNames) },
        { },
    };

    static PyType_Spec type_spec_SymmetricAlgorithmNames =
    {
        "_winsdk_Windows_Security_Cryptography_Core.SymmetricAlgorithmNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SymmetricAlgorithmNames
    };

    static PyGetSetDef getset_SymmetricAlgorithmNames_Meta[] = {
        { "aes_cbc", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_AesCbc), nullptr, nullptr, nullptr },
        { "aes_cbc_pkcs7", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_AesCbcPkcs7), nullptr, nullptr, nullptr },
        { "aes_ccm", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_AesCcm), nullptr, nullptr, nullptr },
        { "aes_ecb", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_AesEcb), nullptr, nullptr, nullptr },
        { "aes_ecb_pkcs7", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_AesEcbPkcs7), nullptr, nullptr, nullptr },
        { "aes_gcm", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_AesGcm), nullptr, nullptr, nullptr },
        { "des_cbc", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_DesCbc), nullptr, nullptr, nullptr },
        { "des_cbc_pkcs7", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_DesCbcPkcs7), nullptr, nullptr, nullptr },
        { "des_ecb", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_DesEcb), nullptr, nullptr, nullptr },
        { "des_ecb_pkcs7", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_DesEcbPkcs7), nullptr, nullptr, nullptr },
        { "rc2_cbc", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_Rc2Cbc), nullptr, nullptr, nullptr },
        { "rc2_cbc_pkcs7", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_Rc2CbcPkcs7), nullptr, nullptr, nullptr },
        { "rc2_ecb", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_Rc2Ecb), nullptr, nullptr, nullptr },
        { "rc2_ecb_pkcs7", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_Rc2EcbPkcs7), nullptr, nullptr, nullptr },
        { "rc4", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_Rc4), nullptr, nullptr, nullptr },
        { "triple_des_cbc", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_TripleDesCbc), nullptr, nullptr, nullptr },
        { "triple_des_cbc_pkcs7", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_TripleDesCbcPkcs7), nullptr, nullptr, nullptr },
        { "triple_des_ecb", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_TripleDesEcb), nullptr, nullptr, nullptr },
        { "triple_des_ecb_pkcs7", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_TripleDesEcbPkcs7), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_SymmetricAlgorithmNames_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SymmetricAlgorithmNames_Meta) },
        { }
    };

    static PyType_Spec type_spec_SymmetricAlgorithmNames_Meta =
    {
        "_winsdk_Windows_Security_Cryptography_Core.SymmetricAlgorithmNames_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SymmetricAlgorithmNames_Meta
    };

    // ----- SymmetricKeyAlgorithmProvider class --------------------
    static constexpr const char* const type_name_SymmetricKeyAlgorithmProvider = "SymmetricKeyAlgorithmProvider";

    static PyObject* _new_SymmetricKeyAlgorithmProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SymmetricKeyAlgorithmProvider);
        return nullptr;
    }

    static void _dealloc_SymmetricKeyAlgorithmProvider(py::wrapper::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SymmetricKeyAlgorithmProvider_CreateSymmetricKey(py::wrapper::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.SymmetricKeyAlgorithmProvider", L"CreateSymmetricKey", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.CreateSymmetricKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SymmetricKeyAlgorithmProvider_OpenAlgorithm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.SymmetricKeyAlgorithmProvider", L"OpenAlgorithm", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider::OpenAlgorithm(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SymmetricKeyAlgorithmProvider_get_AlgorithmName(py::wrapper::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricKeyAlgorithmProvider", L"AlgorithmName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricKeyAlgorithmProvider_get_BlockLength(py::wrapper::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricKeyAlgorithmProvider", L"BlockLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BlockLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SymmetricKeyAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SymmetricKeyAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SymmetricKeyAlgorithmProvider[] = {
        { "create_symmetric_key", reinterpret_cast<PyCFunction>(SymmetricKeyAlgorithmProvider_CreateSymmetricKey), METH_VARARGS, nullptr },
        { "open_algorithm", reinterpret_cast<PyCFunction>(SymmetricKeyAlgorithmProvider_OpenAlgorithm), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_SymmetricKeyAlgorithmProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SymmetricKeyAlgorithmProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SymmetricKeyAlgorithmProvider[] = {
        { "algorithm_name", reinterpret_cast<getter>(SymmetricKeyAlgorithmProvider_get_AlgorithmName), nullptr, nullptr, nullptr },
        { "block_length", reinterpret_cast<getter>(SymmetricKeyAlgorithmProvider_get_BlockLength), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SymmetricKeyAlgorithmProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SymmetricKeyAlgorithmProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SymmetricKeyAlgorithmProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SymmetricKeyAlgorithmProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SymmetricKeyAlgorithmProvider) },
        { },
    };

    static PyType_Spec type_spec_SymmetricKeyAlgorithmProvider =
    {
        "_winsdk_Windows_Security_Cryptography_Core.SymmetricKeyAlgorithmProvider",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SymmetricKeyAlgorithmProvider
    };

    // ----- Windows.Security.Cryptography.Core Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Security::Cryptography::Core");

    static PyMethodDef module_methods[] = {
        {"_register_Capi1KdfTargetAlgorithm", register_Capi1KdfTargetAlgorithm, METH_O, "registers type"},
        {"_register_CryptographicPadding", register_CryptographicPadding, METH_O, "registers type"},
        {"_register_CryptographicPrivateKeyBlobType", register_CryptographicPrivateKeyBlobType, METH_O, "registers type"},
        {"_register_CryptographicPublicKeyBlobType", register_CryptographicPublicKeyBlobType, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_Capi1KdfTargetAlgorithm);
        Py_VISIT(state->type_CryptographicPadding);
        Py_VISIT(state->type_CryptographicPrivateKeyBlobType);
        Py_VISIT(state->type_CryptographicPublicKeyBlobType);
        Py_VISIT(state->type_AsymmetricAlgorithmNames);
        Py_VISIT(state->type_AsymmetricKeyAlgorithmProvider);
        Py_VISIT(state->type_CryptographicEngine);
        Py_VISIT(state->type_CryptographicHash);
        Py_VISIT(state->type_CryptographicKey);
        Py_VISIT(state->type_EccCurveNames);
        Py_VISIT(state->type_EncryptedAndAuthenticatedData);
        Py_VISIT(state->type_HashAlgorithmNames);
        Py_VISIT(state->type_HashAlgorithmProvider);
        Py_VISIT(state->type_KeyDerivationAlgorithmNames);
        Py_VISIT(state->type_KeyDerivationAlgorithmProvider);
        Py_VISIT(state->type_KeyDerivationParameters);
        Py_VISIT(state->type_MacAlgorithmNames);
        Py_VISIT(state->type_MacAlgorithmProvider);
        Py_VISIT(state->type_PersistedKeyProvider);
        Py_VISIT(state->type_SymmetricAlgorithmNames);
        Py_VISIT(state->type_SymmetricKeyAlgorithmProvider);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_Capi1KdfTargetAlgorithm);
        Py_CLEAR(state->type_CryptographicPadding);
        Py_CLEAR(state->type_CryptographicPrivateKeyBlobType);
        Py_CLEAR(state->type_CryptographicPublicKeyBlobType);
        Py_CLEAR(state->type_AsymmetricAlgorithmNames);
        Py_CLEAR(state->type_AsymmetricKeyAlgorithmProvider);
        Py_CLEAR(state->type_CryptographicEngine);
        Py_CLEAR(state->type_CryptographicHash);
        Py_CLEAR(state->type_CryptographicKey);
        Py_CLEAR(state->type_EccCurveNames);
        Py_CLEAR(state->type_EncryptedAndAuthenticatedData);
        Py_CLEAR(state->type_HashAlgorithmNames);
        Py_CLEAR(state->type_HashAlgorithmProvider);
        Py_CLEAR(state->type_KeyDerivationAlgorithmNames);
        Py_CLEAR(state->type_KeyDerivationAlgorithmProvider);
        Py_CLEAR(state->type_KeyDerivationParameters);
        Py_CLEAR(state->type_MacAlgorithmNames);
        Py_CLEAR(state->type_MacAlgorithmProvider);
        Py_CLEAR(state->type_PersistedKeyProvider);
        Py_CLEAR(state->type_SymmetricAlgorithmNames);
        Py_CLEAR(state->type_SymmetricKeyAlgorithmProvider);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Security_Cryptography_Core",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Security::Cryptography::Core

PyMODINIT_FUNC PyInit__winsdk_Windows_Security_Cryptography_Core(void) noexcept
{
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    py::pyobj_handle type_AsymmetricAlgorithmNames_Meta{PyType_FromSpec(&type_spec_AsymmetricAlgorithmNames_Meta)};
    if (!type_AsymmetricAlgorithmNames_Meta)
    {
        return nullptr;
    }

    state->type_AsymmetricAlgorithmNames = py::register_python_type(module.get(), type_name_AsymmetricAlgorithmNames, &type_spec_AsymmetricAlgorithmNames, nullptr, reinterpret_cast<PyTypeObject*>(type_AsymmetricAlgorithmNames_Meta.get()));
    if (!state->type_AsymmetricAlgorithmNames)
    {
        return nullptr;
    }

    state->type_AsymmetricKeyAlgorithmProvider = py::register_python_type(module.get(), type_name_AsymmetricKeyAlgorithmProvider, &type_spec_AsymmetricKeyAlgorithmProvider, bases.get(), nullptr);
    if (!state->type_AsymmetricKeyAlgorithmProvider)
    {
        return nullptr;
    }

    state->type_CryptographicEngine = py::register_python_type(module.get(), type_name_CryptographicEngine, &type_spec_CryptographicEngine, nullptr, nullptr);
    if (!state->type_CryptographicEngine)
    {
        return nullptr;
    }

    state->type_CryptographicHash = py::register_python_type(module.get(), type_name_CryptographicHash, &type_spec_CryptographicHash, bases.get(), nullptr);
    if (!state->type_CryptographicHash)
    {
        return nullptr;
    }

    state->type_CryptographicKey = py::register_python_type(module.get(), type_name_CryptographicKey, &type_spec_CryptographicKey, bases.get(), nullptr);
    if (!state->type_CryptographicKey)
    {
        return nullptr;
    }

    py::pyobj_handle type_EccCurveNames_Meta{PyType_FromSpec(&type_spec_EccCurveNames_Meta)};
    if (!type_EccCurveNames_Meta)
    {
        return nullptr;
    }

    state->type_EccCurveNames = py::register_python_type(module.get(), type_name_EccCurveNames, &type_spec_EccCurveNames, nullptr, reinterpret_cast<PyTypeObject*>(type_EccCurveNames_Meta.get()));
    if (!state->type_EccCurveNames)
    {
        return nullptr;
    }

    state->type_EncryptedAndAuthenticatedData = py::register_python_type(module.get(), type_name_EncryptedAndAuthenticatedData, &type_spec_EncryptedAndAuthenticatedData, bases.get(), nullptr);
    if (!state->type_EncryptedAndAuthenticatedData)
    {
        return nullptr;
    }

    py::pyobj_handle type_HashAlgorithmNames_Meta{PyType_FromSpec(&type_spec_HashAlgorithmNames_Meta)};
    if (!type_HashAlgorithmNames_Meta)
    {
        return nullptr;
    }

    state->type_HashAlgorithmNames = py::register_python_type(module.get(), type_name_HashAlgorithmNames, &type_spec_HashAlgorithmNames, nullptr, reinterpret_cast<PyTypeObject*>(type_HashAlgorithmNames_Meta.get()));
    if (!state->type_HashAlgorithmNames)
    {
        return nullptr;
    }

    state->type_HashAlgorithmProvider = py::register_python_type(module.get(), type_name_HashAlgorithmProvider, &type_spec_HashAlgorithmProvider, bases.get(), nullptr);
    if (!state->type_HashAlgorithmProvider)
    {
        return nullptr;
    }

    py::pyobj_handle type_KeyDerivationAlgorithmNames_Meta{PyType_FromSpec(&type_spec_KeyDerivationAlgorithmNames_Meta)};
    if (!type_KeyDerivationAlgorithmNames_Meta)
    {
        return nullptr;
    }

    state->type_KeyDerivationAlgorithmNames = py::register_python_type(module.get(), type_name_KeyDerivationAlgorithmNames, &type_spec_KeyDerivationAlgorithmNames, nullptr, reinterpret_cast<PyTypeObject*>(type_KeyDerivationAlgorithmNames_Meta.get()));
    if (!state->type_KeyDerivationAlgorithmNames)
    {
        return nullptr;
    }

    state->type_KeyDerivationAlgorithmProvider = py::register_python_type(module.get(), type_name_KeyDerivationAlgorithmProvider, &type_spec_KeyDerivationAlgorithmProvider, bases.get(), nullptr);
    if (!state->type_KeyDerivationAlgorithmProvider)
    {
        return nullptr;
    }

    state->type_KeyDerivationParameters = py::register_python_type(module.get(), type_name_KeyDerivationParameters, &type_spec_KeyDerivationParameters, bases.get(), nullptr);
    if (!state->type_KeyDerivationParameters)
    {
        return nullptr;
    }

    py::pyobj_handle type_MacAlgorithmNames_Meta{PyType_FromSpec(&type_spec_MacAlgorithmNames_Meta)};
    if (!type_MacAlgorithmNames_Meta)
    {
        return nullptr;
    }

    state->type_MacAlgorithmNames = py::register_python_type(module.get(), type_name_MacAlgorithmNames, &type_spec_MacAlgorithmNames, nullptr, reinterpret_cast<PyTypeObject*>(type_MacAlgorithmNames_Meta.get()));
    if (!state->type_MacAlgorithmNames)
    {
        return nullptr;
    }

    state->type_MacAlgorithmProvider = py::register_python_type(module.get(), type_name_MacAlgorithmProvider, &type_spec_MacAlgorithmProvider, bases.get(), nullptr);
    if (!state->type_MacAlgorithmProvider)
    {
        return nullptr;
    }

    state->type_PersistedKeyProvider = py::register_python_type(module.get(), type_name_PersistedKeyProvider, &type_spec_PersistedKeyProvider, nullptr, nullptr);
    if (!state->type_PersistedKeyProvider)
    {
        return nullptr;
    }

    py::pyobj_handle type_SymmetricAlgorithmNames_Meta{PyType_FromSpec(&type_spec_SymmetricAlgorithmNames_Meta)};
    if (!type_SymmetricAlgorithmNames_Meta)
    {
        return nullptr;
    }

    state->type_SymmetricAlgorithmNames = py::register_python_type(module.get(), type_name_SymmetricAlgorithmNames, &type_spec_SymmetricAlgorithmNames, nullptr, reinterpret_cast<PyTypeObject*>(type_SymmetricAlgorithmNames_Meta.get()));
    if (!state->type_SymmetricAlgorithmNames)
    {
        return nullptr;
    }

    state->type_SymmetricKeyAlgorithmProvider = py::register_python_type(module.get(), type_name_SymmetricKeyAlgorithmProvider, &type_spec_SymmetricKeyAlgorithmProvider, bases.get(), nullptr);
    if (!state->type_SymmetricKeyAlgorithmProvider)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Security::Cryptography::Core::Capi1KdfTargetAlgorithm>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Capi1KdfTargetAlgorithm;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::Capi1KdfTargetAlgorithm is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Cryptography::Core::CryptographicPadding>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CryptographicPadding;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::CryptographicPadding is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Cryptography::Core::CryptographicPrivateKeyBlobType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CryptographicPrivateKeyBlobType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::CryptographicPrivateKeyBlobType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Cryptography::Core::CryptographicPublicKeyBlobType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CryptographicPublicKeyBlobType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::CryptographicPublicKeyBlobType is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AsymmetricAlgorithmNames;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AsymmetricKeyAlgorithmProvider;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::CryptographicEngine>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CryptographicEngine;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::CryptographicEngine is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::CryptographicHash>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CryptographicHash;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::CryptographicHash is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::CryptographicKey>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CryptographicKey;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::CryptographicKey is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::EccCurveNames>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EccCurveNames;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::EccCurveNames is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EncryptedAndAuthenticatedData;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HashAlgorithmNames;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::HashAlgorithmProvider>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HashAlgorithmProvider;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::HashAlgorithmProvider is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KeyDerivationAlgorithmNames;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KeyDerivationAlgorithmProvider;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KeyDerivationParameters;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MacAlgorithmNames;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::MacAlgorithmProvider>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MacAlgorithmProvider;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::MacAlgorithmProvider is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::PersistedKeyProvider>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PersistedKeyProvider;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::PersistedKeyProvider is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SymmetricAlgorithmNames;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SymmetricKeyAlgorithmProvider;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider is not registered");
        return nullptr;
    }

    return python_type;
}
