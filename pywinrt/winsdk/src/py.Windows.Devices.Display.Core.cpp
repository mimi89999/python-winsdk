// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.Devices.Display.Core.h"


PyObject* py::converter<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>::convert(winrt::Windows::Devices::Display::Core::DisplayPresentationRate instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Devices::Display::Core::DisplayPresentationRate py::converter<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Devices::Display::Core::DisplayPresentationRate");
    throw python_exception();
}

namespace py::cpp::Windows::Devices::Display::Core
{
    struct module_state
    {
        PyObject* type_DisplayBitsPerChannel;
        PyObject* type_DisplayDeviceCapability;
        PyObject* type_DisplayManagerOptions;
        PyObject* type_DisplayManagerResult;
        PyObject* type_DisplayModeQueryOptions;
        PyObject* type_DisplayPathScaling;
        PyObject* type_DisplayPathStatus;
        PyObject* type_DisplayPresentStatus;
        PyObject* type_DisplayRotation;
        PyObject* type_DisplayScanoutOptions;
        PyObject* type_DisplaySourceStatus;
        PyObject* type_DisplayStateApplyOptions;
        PyObject* type_DisplayStateFunctionalizeOptions;
        PyObject* type_DisplayStateOperationStatus;
        PyObject* type_DisplayTargetPersistence;
        PyObject* type_DisplayTaskSignalKind;
        PyObject* type_DisplayWireFormatColorSpace;
        PyObject* type_DisplayWireFormatEotf;
        PyObject* type_DisplayWireFormatHdrMetadata;
        PyObject* type_DisplayWireFormatPixelEncoding;
        PyTypeObject* type_DisplayAdapter;
        PyTypeObject* type_DisplayDevice;
        PyTypeObject* type_DisplayFence;
        PyTypeObject* type_DisplayManager;
        PyTypeObject* type_DisplayManagerChangedEventArgs;
        PyTypeObject* type_DisplayManagerDisabledEventArgs;
        PyTypeObject* type_DisplayManagerEnabledEventArgs;
        PyTypeObject* type_DisplayManagerPathsFailedOrInvalidatedEventArgs;
        PyTypeObject* type_DisplayManagerResultWithState;
        PyTypeObject* type_DisplayModeInfo;
        PyTypeObject* type_DisplayPath;
        PyTypeObject* type_DisplayPrimaryDescription;
        PyTypeObject* type_DisplayScanout;
        PyTypeObject* type_DisplaySource;
        PyTypeObject* type_DisplayState;
        PyTypeObject* type_DisplayStateOperationResult;
        PyTypeObject* type_DisplaySurface;
        PyTypeObject* type_DisplayTarget;
        PyTypeObject* type_DisplayTask;
        PyTypeObject* type_DisplayTaskPool;
        PyTypeObject* type_DisplayTaskResult;
        PyTypeObject* type_DisplayView;
        PyTypeObject* type_DisplayWireFormat;
        PyTypeObject* type_DisplayPresentationRate;
    };

    static PyObject* register_DisplayBitsPerChannel(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DisplayBitsPerChannel)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DisplayBitsPerChannel = type;
        Py_INCREF(state->type_DisplayBitsPerChannel);


        Py_RETURN_NONE;
    }

    static PyObject* register_DisplayDeviceCapability(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DisplayDeviceCapability)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DisplayDeviceCapability = type;
        Py_INCREF(state->type_DisplayDeviceCapability);


        Py_RETURN_NONE;
    }

    static PyObject* register_DisplayManagerOptions(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DisplayManagerOptions)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DisplayManagerOptions = type;
        Py_INCREF(state->type_DisplayManagerOptions);


        Py_RETURN_NONE;
    }

    static PyObject* register_DisplayManagerResult(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DisplayManagerResult)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DisplayManagerResult = type;
        Py_INCREF(state->type_DisplayManagerResult);


        Py_RETURN_NONE;
    }

    static PyObject* register_DisplayModeQueryOptions(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DisplayModeQueryOptions)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DisplayModeQueryOptions = type;
        Py_INCREF(state->type_DisplayModeQueryOptions);


        Py_RETURN_NONE;
    }

    static PyObject* register_DisplayPathScaling(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DisplayPathScaling)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DisplayPathScaling = type;
        Py_INCREF(state->type_DisplayPathScaling);


        Py_RETURN_NONE;
    }

    static PyObject* register_DisplayPathStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DisplayPathStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DisplayPathStatus = type;
        Py_INCREF(state->type_DisplayPathStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_DisplayPresentStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DisplayPresentStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DisplayPresentStatus = type;
        Py_INCREF(state->type_DisplayPresentStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_DisplayRotation(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DisplayRotation)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DisplayRotation = type;
        Py_INCREF(state->type_DisplayRotation);


        Py_RETURN_NONE;
    }

    static PyObject* register_DisplayScanoutOptions(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DisplayScanoutOptions)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DisplayScanoutOptions = type;
        Py_INCREF(state->type_DisplayScanoutOptions);


        Py_RETURN_NONE;
    }

    static PyObject* register_DisplaySourceStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DisplaySourceStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DisplaySourceStatus = type;
        Py_INCREF(state->type_DisplaySourceStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_DisplayStateApplyOptions(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DisplayStateApplyOptions)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DisplayStateApplyOptions = type;
        Py_INCREF(state->type_DisplayStateApplyOptions);


        Py_RETURN_NONE;
    }

    static PyObject* register_DisplayStateFunctionalizeOptions(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DisplayStateFunctionalizeOptions)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DisplayStateFunctionalizeOptions = type;
        Py_INCREF(state->type_DisplayStateFunctionalizeOptions);


        Py_RETURN_NONE;
    }

    static PyObject* register_DisplayStateOperationStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DisplayStateOperationStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DisplayStateOperationStatus = type;
        Py_INCREF(state->type_DisplayStateOperationStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_DisplayTargetPersistence(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DisplayTargetPersistence)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DisplayTargetPersistence = type;
        Py_INCREF(state->type_DisplayTargetPersistence);


        Py_RETURN_NONE;
    }

    static PyObject* register_DisplayTaskSignalKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DisplayTaskSignalKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DisplayTaskSignalKind = type;
        Py_INCREF(state->type_DisplayTaskSignalKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_DisplayWireFormatColorSpace(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DisplayWireFormatColorSpace)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DisplayWireFormatColorSpace = type;
        Py_INCREF(state->type_DisplayWireFormatColorSpace);


        Py_RETURN_NONE;
    }

    static PyObject* register_DisplayWireFormatEotf(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DisplayWireFormatEotf)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DisplayWireFormatEotf = type;
        Py_INCREF(state->type_DisplayWireFormatEotf);


        Py_RETURN_NONE;
    }

    static PyObject* register_DisplayWireFormatHdrMetadata(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DisplayWireFormatHdrMetadata)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DisplayWireFormatHdrMetadata = type;
        Py_INCREF(state->type_DisplayWireFormatHdrMetadata);


        Py_RETURN_NONE;
    }

    static PyObject* register_DisplayWireFormatPixelEncoding(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DisplayWireFormatPixelEncoding)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DisplayWireFormatPixelEncoding = type;
        Py_INCREF(state->type_DisplayWireFormatPixelEncoding);


        Py_RETURN_NONE;
    }

    // ----- DisplayAdapter class --------------------
    static constexpr const char* const type_name_DisplayAdapter = "DisplayAdapter";

    static PyObject* _new_DisplayAdapter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DisplayAdapter);
        return nullptr;
    }

    static void _dealloc_DisplayAdapter(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayAdapter_FromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayAdapter", L"FromId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DisplayAdapterId>(args, 0);

                return py::convert(winrt::Windows::Devices::Display::Core::DisplayAdapter::FromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_DeviceInterfacePath(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayAdapter", L"DeviceInterfacePath"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceInterfacePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_Id(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayAdapter", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_PciDeviceId(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayAdapter", L"PciDeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PciDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_PciRevision(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayAdapter", L"PciRevision"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PciRevision());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_PciSubSystemId(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayAdapter", L"PciSubSystemId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PciSubSystemId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_PciVendorId(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayAdapter", L"PciVendorId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PciVendorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayAdapter", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_SourceCount(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayAdapter", L"SourceCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayAdapter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayAdapter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayAdapter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayAdapter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayAdapter[] = {
        { "from_id", reinterpret_cast<PyCFunction>(DisplayAdapter_FromId), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_DisplayAdapter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayAdapter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayAdapter[] = {
        { "device_interface_path", reinterpret_cast<getter>(DisplayAdapter_get_DeviceInterfacePath), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(DisplayAdapter_get_Id), nullptr, nullptr, nullptr },
        { "pci_device_id", reinterpret_cast<getter>(DisplayAdapter_get_PciDeviceId), nullptr, nullptr, nullptr },
        { "pci_revision", reinterpret_cast<getter>(DisplayAdapter_get_PciRevision), nullptr, nullptr, nullptr },
        { "pci_sub_system_id", reinterpret_cast<getter>(DisplayAdapter_get_PciSubSystemId), nullptr, nullptr, nullptr },
        { "pci_vendor_id", reinterpret_cast<getter>(DisplayAdapter_get_PciVendorId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DisplayAdapter_get_Properties), nullptr, nullptr, nullptr },
        { "source_count", reinterpret_cast<getter>(DisplayAdapter_get_SourceCount), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayAdapter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayAdapter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayAdapter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayAdapter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayAdapter) },
        { },
    };

    static PyType_Spec type_spec_DisplayAdapter =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayAdapter",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayAdapter
    };

    // ----- DisplayDevice class --------------------
    static constexpr const char* const type_name_DisplayDevice = "DisplayDevice";

    static PyObject* _new_DisplayDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DisplayDevice);
        return nullptr;
    }

    static void _dealloc_DisplayDevice(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayDevice_CreatePeriodicFence(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayDevice", L"CreatePeriodicFence", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(self->obj.CreatePeriodicFence(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_CreatePrimary(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayDevice", L"CreatePrimary", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayPrimaryDescription>(args, 1);

                return py::convert(self->obj.CreatePrimary(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_CreateScanoutSource(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayDevice", L"CreateScanoutSource", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.CreateScanoutSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_CreateSimpleScanout(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayDevice", L"CreateSimpleScanout", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplaySource>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplaySurface>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                return py::convert(self->obj.CreateSimpleScanout(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_CreateSimpleScanoutWithDirtyRectsAndOptions(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayDevice", L"CreateSimpleScanoutWithDirtyRectsAndOptions", 6))
            {
                py::set_arg_count_version_error(6);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplaySource>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplaySurface>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Graphics::RectInt32>>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayScanoutOptions>(args, 5);

                return py::convert(self->obj.CreateSimpleScanoutWithDirtyRectsAndOptions(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_CreateTaskPool(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayDevice", L"CreateTaskPool", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateTaskPool());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_IsCapabilitySupported(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayDevice", L"IsCapabilitySupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayDeviceCapability>(args, 0);

                return py::convert(self->obj.IsCapabilitySupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_WaitForVBlank(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayDevice", L"WaitForVBlank", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplaySource>(args, 0);

                self->obj.WaitForVBlank(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayDevice[] = {
        { "create_periodic_fence", reinterpret_cast<PyCFunction>(DisplayDevice_CreatePeriodicFence), METH_VARARGS, nullptr },
        { "create_primary", reinterpret_cast<PyCFunction>(DisplayDevice_CreatePrimary), METH_VARARGS, nullptr },
        { "create_scanout_source", reinterpret_cast<PyCFunction>(DisplayDevice_CreateScanoutSource), METH_VARARGS, nullptr },
        { "create_simple_scanout", reinterpret_cast<PyCFunction>(DisplayDevice_CreateSimpleScanout), METH_VARARGS, nullptr },
        { "create_simple_scanout_with_dirty_rects_and_options", reinterpret_cast<PyCFunction>(DisplayDevice_CreateSimpleScanoutWithDirtyRectsAndOptions), METH_VARARGS, nullptr },
        { "create_task_pool", reinterpret_cast<PyCFunction>(DisplayDevice_CreateTaskPool), METH_VARARGS, nullptr },
        { "is_capability_supported", reinterpret_cast<PyCFunction>(DisplayDevice_IsCapabilitySupported), METH_VARARGS, nullptr },
        { "wait_for_v_blank", reinterpret_cast<PyCFunction>(DisplayDevice_WaitForVBlank), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DisplayDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayDevice), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayDevice[] = {
        { }
    };

    static PyType_Slot _type_slots_DisplayDevice[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayDevice) },
        { },
    };

    static PyType_Spec type_spec_DisplayDevice =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayDevice",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayDevice
    };

    // ----- DisplayFence class --------------------
    static constexpr const char* const type_name_DisplayFence = "DisplayFence";

    static PyObject* _new_DisplayFence(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DisplayFence);
        return nullptr;
    }

    static void _dealloc_DisplayFence(py::wrapper::Windows::Devices::Display::Core::DisplayFence* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DisplayFence(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayFence>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayFence(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayFence>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayFence[] = {
        { "_assign_array_", _assign_array_DisplayFence, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayFence), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayFence[] = {
        { }
    };

    static PyType_Slot _type_slots_DisplayFence[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayFence) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayFence) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayFence) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayFence) },
        { },
    };

    static PyType_Spec type_spec_DisplayFence =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayFence",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayFence),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayFence
    };

    // ----- DisplayManager class --------------------
    static constexpr const char* const type_name_DisplayManager = "DisplayManager";

    static PyObject* _new_DisplayManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DisplayManager);
        return nullptr;
    }

    static void _dealloc_DisplayManager(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayManager_Close(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManager", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManager", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayManagerOptions>(args, 0);

                return py::convert(winrt::Windows::Devices::Display::Core::DisplayManager::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_CreateDisplayDevice(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManager", L"CreateDisplayDevice", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayAdapter>(args, 0);

                return py::convert(self->obj.CreateDisplayDevice(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_GetCurrentAdapters(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManager", L"GetCurrentAdapters", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentAdapters());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_GetCurrentTargets(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManager", L"GetCurrentTargets", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentTargets());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_ReleaseTarget(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManager", L"ReleaseTarget", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                self->obj.ReleaseTarget(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_Start(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManager", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_Stop(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManager", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_TryAcquireTarget(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManager", L"TryAcquireTarget", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.TryAcquireTarget(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_TryAcquireTargetsAndCreateEmptyState(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManager", L"TryAcquireTargetsAndCreateEmptyState", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Display::Core::DisplayTarget>>(args, 0);

                return py::convert(self->obj.TryAcquireTargetsAndCreateEmptyState(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_TryAcquireTargetsAndCreateSubstate(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManager", L"TryAcquireTargetsAndCreateSubstate", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayState>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Display::Core::DisplayTarget>>(args, 1);

                return py::convert(self->obj.TryAcquireTargetsAndCreateSubstate(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_TryAcquireTargetsAndReadCurrentState(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManager", L"TryAcquireTargetsAndReadCurrentState", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Display::Core::DisplayTarget>>(args, 0);

                return py::convert(self->obj.TryAcquireTargetsAndReadCurrentState(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_TryReadCurrentStateForAllTargets(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManager", L"TryReadCurrentStateForAllTargets", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryReadCurrentStateForAllTargets());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_add_Changed(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Display.Core.DisplayManager", L"Changed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Display::Core::DisplayManager, winrt::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs>>(arg);

            return py::convert(self->obj.Changed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_remove_Changed(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Display.Core.DisplayManager", L"Changed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Changed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_add_Disabled(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Display.Core.DisplayManager", L"Disabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Display::Core::DisplayManager, winrt::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs>>(arg);

            return py::convert(self->obj.Disabled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_remove_Disabled(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Display.Core.DisplayManager", L"Disabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Disabled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_add_Enabled(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Display.Core.DisplayManager", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Display::Core::DisplayManager, winrt::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs>>(arg);

            return py::convert(self->obj.Enabled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_remove_Enabled(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Display.Core.DisplayManager", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Enabled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_add_PathsFailedOrInvalidated(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Display.Core.DisplayManager", L"PathsFailedOrInvalidated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Display::Core::DisplayManager, winrt::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs>>(arg);

            return py::convert(self->obj.PathsFailedOrInvalidated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_remove_PathsFailedOrInvalidated(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Display.Core.DisplayManager", L"PathsFailedOrInvalidated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PathsFailedOrInvalidated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_DisplayManager(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_DisplayManager(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayManager[] = {
        { "close", reinterpret_cast<PyCFunction>(DisplayManager_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(DisplayManager_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_display_device", reinterpret_cast<PyCFunction>(DisplayManager_CreateDisplayDevice), METH_VARARGS, nullptr },
        { "get_current_adapters", reinterpret_cast<PyCFunction>(DisplayManager_GetCurrentAdapters), METH_VARARGS, nullptr },
        { "get_current_targets", reinterpret_cast<PyCFunction>(DisplayManager_GetCurrentTargets), METH_VARARGS, nullptr },
        { "release_target", reinterpret_cast<PyCFunction>(DisplayManager_ReleaseTarget), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(DisplayManager_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(DisplayManager_Stop), METH_VARARGS, nullptr },
        { "try_acquire_target", reinterpret_cast<PyCFunction>(DisplayManager_TryAcquireTarget), METH_VARARGS, nullptr },
        { "try_acquire_targets_and_create_empty_state", reinterpret_cast<PyCFunction>(DisplayManager_TryAcquireTargetsAndCreateEmptyState), METH_VARARGS, nullptr },
        { "try_acquire_targets_and_create_substate", reinterpret_cast<PyCFunction>(DisplayManager_TryAcquireTargetsAndCreateSubstate), METH_VARARGS, nullptr },
        { "try_acquire_targets_and_read_current_state", reinterpret_cast<PyCFunction>(DisplayManager_TryAcquireTargetsAndReadCurrentState), METH_VARARGS, nullptr },
        { "try_read_current_state_for_all_targets", reinterpret_cast<PyCFunction>(DisplayManager_TryReadCurrentStateForAllTargets), METH_VARARGS, nullptr },
        { "add_changed", reinterpret_cast<PyCFunction>(DisplayManager_add_Changed), METH_O, nullptr },
        { "remove_changed", reinterpret_cast<PyCFunction>(DisplayManager_remove_Changed), METH_O, nullptr },
        { "add_disabled", reinterpret_cast<PyCFunction>(DisplayManager_add_Disabled), METH_O, nullptr },
        { "remove_disabled", reinterpret_cast<PyCFunction>(DisplayManager_remove_Disabled), METH_O, nullptr },
        { "add_enabled", reinterpret_cast<PyCFunction>(DisplayManager_add_Enabled), METH_O, nullptr },
        { "remove_enabled", reinterpret_cast<PyCFunction>(DisplayManager_remove_Enabled), METH_O, nullptr },
        { "add_paths_failed_or_invalidated", reinterpret_cast<PyCFunction>(DisplayManager_add_PathsFailedOrInvalidated), METH_O, nullptr },
        { "remove_paths_failed_or_invalidated", reinterpret_cast<PyCFunction>(DisplayManager_remove_PathsFailedOrInvalidated), METH_O, nullptr },
        { "_assign_array_", _assign_array_DisplayManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayManager), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_DisplayManager), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_DisplayManager), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayManager[] = {
        { }
    };

    static PyType_Slot _type_slots_DisplayManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayManager) },
        { },
    };

    static PyType_Spec type_spec_DisplayManager =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayManager",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayManager
    };

    // ----- DisplayManagerChangedEventArgs class --------------------
    static constexpr const char* const type_name_DisplayManagerChangedEventArgs = "DisplayManagerChangedEventArgs";

    static PyObject* _new_DisplayManagerChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DisplayManagerChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_DisplayManagerChangedEventArgs(py::wrapper::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayManagerChangedEventArgs_GetDeferral(py::wrapper::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManagerChangedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManagerChangedEventArgs_get_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayManagerChangedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayManagerChangedEventArgs_put_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayManagerChangedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DisplayManagerChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayManagerChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayManagerChangedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(DisplayManagerChangedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DisplayManagerChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayManagerChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayManagerChangedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(DisplayManagerChangedEventArgs_get_Handled), reinterpret_cast<setter>(DisplayManagerChangedEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayManagerChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayManagerChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayManagerChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayManagerChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayManagerChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DisplayManagerChangedEventArgs =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayManagerChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayManagerChangedEventArgs
    };

    // ----- DisplayManagerDisabledEventArgs class --------------------
    static constexpr const char* const type_name_DisplayManagerDisabledEventArgs = "DisplayManagerDisabledEventArgs";

    static PyObject* _new_DisplayManagerDisabledEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DisplayManagerDisabledEventArgs);
        return nullptr;
    }

    static void _dealloc_DisplayManagerDisabledEventArgs(py::wrapper::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayManagerDisabledEventArgs_GetDeferral(py::wrapper::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManagerDisabledEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManagerDisabledEventArgs_get_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayManagerDisabledEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayManagerDisabledEventArgs_put_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayManagerDisabledEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DisplayManagerDisabledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayManagerDisabledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayManagerDisabledEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(DisplayManagerDisabledEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DisplayManagerDisabledEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayManagerDisabledEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayManagerDisabledEventArgs[] = {
        { "handled", reinterpret_cast<getter>(DisplayManagerDisabledEventArgs_get_Handled), reinterpret_cast<setter>(DisplayManagerDisabledEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayManagerDisabledEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayManagerDisabledEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayManagerDisabledEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayManagerDisabledEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayManagerDisabledEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DisplayManagerDisabledEventArgs =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayManagerDisabledEventArgs",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayManagerDisabledEventArgs
    };

    // ----- DisplayManagerEnabledEventArgs class --------------------
    static constexpr const char* const type_name_DisplayManagerEnabledEventArgs = "DisplayManagerEnabledEventArgs";

    static PyObject* _new_DisplayManagerEnabledEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DisplayManagerEnabledEventArgs);
        return nullptr;
    }

    static void _dealloc_DisplayManagerEnabledEventArgs(py::wrapper::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayManagerEnabledEventArgs_GetDeferral(py::wrapper::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManagerEnabledEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManagerEnabledEventArgs_get_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayManagerEnabledEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayManagerEnabledEventArgs_put_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayManagerEnabledEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DisplayManagerEnabledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayManagerEnabledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayManagerEnabledEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(DisplayManagerEnabledEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DisplayManagerEnabledEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayManagerEnabledEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayManagerEnabledEventArgs[] = {
        { "handled", reinterpret_cast<getter>(DisplayManagerEnabledEventArgs_get_Handled), reinterpret_cast<setter>(DisplayManagerEnabledEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayManagerEnabledEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayManagerEnabledEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayManagerEnabledEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayManagerEnabledEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayManagerEnabledEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DisplayManagerEnabledEventArgs =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayManagerEnabledEventArgs",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayManagerEnabledEventArgs
    };

    // ----- DisplayManagerPathsFailedOrInvalidatedEventArgs class --------------------
    static constexpr const char* const type_name_DisplayManagerPathsFailedOrInvalidatedEventArgs = "DisplayManagerPathsFailedOrInvalidatedEventArgs";

    static PyObject* _new_DisplayManagerPathsFailedOrInvalidatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DisplayManagerPathsFailedOrInvalidatedEventArgs);
        return nullptr;
    }

    static void _dealloc_DisplayManagerPathsFailedOrInvalidatedEventArgs(py::wrapper::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayManagerPathsFailedOrInvalidatedEventArgs_GetDeferral(py::wrapper::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManagerPathsFailedOrInvalidatedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManagerPathsFailedOrInvalidatedEventArgs_get_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayManagerPathsFailedOrInvalidatedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayManagerPathsFailedOrInvalidatedEventArgs_put_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayManagerPathsFailedOrInvalidatedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DisplayManagerPathsFailedOrInvalidatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayManagerPathsFailedOrInvalidatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayManagerPathsFailedOrInvalidatedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(DisplayManagerPathsFailedOrInvalidatedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DisplayManagerPathsFailedOrInvalidatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayManagerPathsFailedOrInvalidatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayManagerPathsFailedOrInvalidatedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(DisplayManagerPathsFailedOrInvalidatedEventArgs_get_Handled), reinterpret_cast<setter>(DisplayManagerPathsFailedOrInvalidatedEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayManagerPathsFailedOrInvalidatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayManagerPathsFailedOrInvalidatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayManagerPathsFailedOrInvalidatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayManagerPathsFailedOrInvalidatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayManagerPathsFailedOrInvalidatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DisplayManagerPathsFailedOrInvalidatedEventArgs =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayManagerPathsFailedOrInvalidatedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayManagerPathsFailedOrInvalidatedEventArgs
    };

    // ----- DisplayManagerResultWithState class --------------------
    static constexpr const char* const type_name_DisplayManagerResultWithState = "DisplayManagerResultWithState";

    static PyObject* _new_DisplayManagerResultWithState(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DisplayManagerResultWithState);
        return nullptr;
    }

    static void _dealloc_DisplayManagerResultWithState(py::wrapper::Windows::Devices::Display::Core::DisplayManagerResultWithState* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayManagerResultWithState_get_ErrorCode(py::wrapper::Windows::Devices::Display::Core::DisplayManagerResultWithState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayManagerResultWithState", L"ErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManagerResultWithState_get_ExtendedErrorCode(py::wrapper::Windows::Devices::Display::Core::DisplayManagerResultWithState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayManagerResultWithState", L"ExtendedErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManagerResultWithState_get_State(py::wrapper::Windows::Devices::Display::Core::DisplayManagerResultWithState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayManagerResultWithState", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayManagerResultWithState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayManagerResultWithState>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayManagerResultWithState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayManagerResultWithState>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayManagerResultWithState[] = {
        { "_assign_array_", _assign_array_DisplayManagerResultWithState, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayManagerResultWithState), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayManagerResultWithState[] = {
        { "error_code", reinterpret_cast<getter>(DisplayManagerResultWithState_get_ErrorCode), nullptr, nullptr, nullptr },
        { "extended_error_code", reinterpret_cast<getter>(DisplayManagerResultWithState_get_ExtendedErrorCode), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(DisplayManagerResultWithState_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayManagerResultWithState[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayManagerResultWithState) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayManagerResultWithState) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayManagerResultWithState) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayManagerResultWithState) },
        { },
    };

    static PyType_Spec type_spec_DisplayManagerResultWithState =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayManagerResultWithState",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayManagerResultWithState),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayManagerResultWithState
    };

    // ----- DisplayModeInfo class --------------------
    static constexpr const char* const type_name_DisplayModeInfo = "DisplayModeInfo";

    static PyObject* _new_DisplayModeInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DisplayModeInfo);
        return nullptr;
    }

    static void _dealloc_DisplayModeInfo(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayModeInfo_GetWireFormatSupportedBitsPerChannel(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayModeInfo", L"GetWireFormatSupportedBitsPerChannel", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatPixelEncoding>(args, 0);

                return py::convert(self->obj.GetWireFormatSupportedBitsPerChannel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_IsWireFormatSupported(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayModeInfo", L"IsWireFormatSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormat>(args, 0);

                return py::convert(self->obj.IsWireFormatSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_IsInterlaced(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayModeInfo", L"IsInterlaced"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInterlaced());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_IsStereo(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayModeInfo", L"IsStereo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStereo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_PresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayModeInfo", L"PresentationRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PresentationRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayModeInfo", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_SourcePixelFormat(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayModeInfo", L"SourcePixelFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourcePixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_SourceResolution(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayModeInfo", L"SourceResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_TargetResolution(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayModeInfo", L"TargetResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_PhysicalPresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayModeInfo", L"PhysicalPresentationRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhysicalPresentationRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayModeInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayModeInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayModeInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayModeInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayModeInfo[] = {
        { "get_wire_format_supported_bits_per_channel", reinterpret_cast<PyCFunction>(DisplayModeInfo_GetWireFormatSupportedBitsPerChannel), METH_VARARGS, nullptr },
        { "is_wire_format_supported", reinterpret_cast<PyCFunction>(DisplayModeInfo_IsWireFormatSupported), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DisplayModeInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayModeInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayModeInfo[] = {
        { "is_interlaced", reinterpret_cast<getter>(DisplayModeInfo_get_IsInterlaced), nullptr, nullptr, nullptr },
        { "is_stereo", reinterpret_cast<getter>(DisplayModeInfo_get_IsStereo), nullptr, nullptr, nullptr },
        { "presentation_rate", reinterpret_cast<getter>(DisplayModeInfo_get_PresentationRate), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DisplayModeInfo_get_Properties), nullptr, nullptr, nullptr },
        { "source_pixel_format", reinterpret_cast<getter>(DisplayModeInfo_get_SourcePixelFormat), nullptr, nullptr, nullptr },
        { "source_resolution", reinterpret_cast<getter>(DisplayModeInfo_get_SourceResolution), nullptr, nullptr, nullptr },
        { "target_resolution", reinterpret_cast<getter>(DisplayModeInfo_get_TargetResolution), nullptr, nullptr, nullptr },
        { "physical_presentation_rate", reinterpret_cast<getter>(DisplayModeInfo_get_PhysicalPresentationRate), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayModeInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayModeInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayModeInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayModeInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayModeInfo) },
        { },
    };

    static PyType_Spec type_spec_DisplayModeInfo =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayModeInfo",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayModeInfo
    };

    // ----- DisplayPath class --------------------
    static constexpr const char* const type_name_DisplayPath = "DisplayPath";

    static PyObject* _new_DisplayPath(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DisplayPath);
        return nullptr;
    }

    static void _dealloc_DisplayPath(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayPath_ApplyPropertiesFromMode(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayPath", L"ApplyPropertiesFromMode", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayModeInfo>(args, 0);

                self->obj.ApplyPropertiesFromMode(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayPath_FindModes(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayPath", L"FindModes", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayModeQueryOptions>(args, 0);

                return py::convert(self->obj.FindModes(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayPath_get_WireFormat(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"WireFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WireFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_WireFormat(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"WireFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormat>(arg);

            self->obj.WireFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_TargetResolution(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"TargetResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_TargetResolution(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"TargetResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Graphics::SizeInt32>>(arg);

            self->obj.TargetResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_SourceResolution(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"SourceResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_SourceResolution(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"SourceResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Graphics::SizeInt32>>(arg);

            self->obj.SourceResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_SourcePixelFormat(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"SourcePixelFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourcePixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_SourcePixelFormat(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"SourcePixelFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXPixelFormat>(arg);

            self->obj.SourcePixelFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_Scaling(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"Scaling"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Scaling());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_Scaling(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"Scaling"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayPathScaling>(arg);

            self->obj.Scaling(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_Rotation(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"Rotation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Rotation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_Rotation(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"Rotation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayRotation>(arg);

            self->obj.Rotation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_PresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"PresentationRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PresentationRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_PresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"PresentationRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>>(arg);

            self->obj.PresentationRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_IsStereo(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"IsStereo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStereo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_IsStereo(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"IsStereo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsStereo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_IsInterlaced(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"IsInterlaced"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInterlaced());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_IsInterlaced(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"IsInterlaced"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            self->obj.IsInterlaced(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPath_get_Status(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPath_get_Target(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"Target"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Target());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPath_get_View(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"View"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.View());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPath_get_PhysicalPresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"PhysicalPresentationRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhysicalPresentationRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_PhysicalPresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"PhysicalPresentationRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>>(arg);

            self->obj.PhysicalPresentationRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DisplayPath(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayPath>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayPath(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayPath>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayPath[] = {
        { "apply_properties_from_mode", reinterpret_cast<PyCFunction>(DisplayPath_ApplyPropertiesFromMode), METH_VARARGS, nullptr },
        { "find_modes", reinterpret_cast<PyCFunction>(DisplayPath_FindModes), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DisplayPath, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayPath), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayPath[] = {
        { "wire_format", reinterpret_cast<getter>(DisplayPath_get_WireFormat), reinterpret_cast<setter>(DisplayPath_put_WireFormat), nullptr, nullptr },
        { "target_resolution", reinterpret_cast<getter>(DisplayPath_get_TargetResolution), reinterpret_cast<setter>(DisplayPath_put_TargetResolution), nullptr, nullptr },
        { "source_resolution", reinterpret_cast<getter>(DisplayPath_get_SourceResolution), reinterpret_cast<setter>(DisplayPath_put_SourceResolution), nullptr, nullptr },
        { "source_pixel_format", reinterpret_cast<getter>(DisplayPath_get_SourcePixelFormat), reinterpret_cast<setter>(DisplayPath_put_SourcePixelFormat), nullptr, nullptr },
        { "scaling", reinterpret_cast<getter>(DisplayPath_get_Scaling), reinterpret_cast<setter>(DisplayPath_put_Scaling), nullptr, nullptr },
        { "rotation", reinterpret_cast<getter>(DisplayPath_get_Rotation), reinterpret_cast<setter>(DisplayPath_put_Rotation), nullptr, nullptr },
        { "presentation_rate", reinterpret_cast<getter>(DisplayPath_get_PresentationRate), reinterpret_cast<setter>(DisplayPath_put_PresentationRate), nullptr, nullptr },
        { "is_stereo", reinterpret_cast<getter>(DisplayPath_get_IsStereo), reinterpret_cast<setter>(DisplayPath_put_IsStereo), nullptr, nullptr },
        { "is_interlaced", reinterpret_cast<getter>(DisplayPath_get_IsInterlaced), reinterpret_cast<setter>(DisplayPath_put_IsInterlaced), nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DisplayPath_get_Properties), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(DisplayPath_get_Status), nullptr, nullptr, nullptr },
        { "target", reinterpret_cast<getter>(DisplayPath_get_Target), nullptr, nullptr, nullptr },
        { "view", reinterpret_cast<getter>(DisplayPath_get_View), nullptr, nullptr, nullptr },
        { "physical_presentation_rate", reinterpret_cast<getter>(DisplayPath_get_PhysicalPresentationRate), reinterpret_cast<setter>(DisplayPath_put_PhysicalPresentationRate), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayPath[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayPath) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayPath) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayPath) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayPath) },
        { },
    };

    static PyType_Spec type_spec_DisplayPath =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayPath",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayPath),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayPath
    };

    // ----- DisplayPrimaryDescription class --------------------
    static constexpr const char* const type_name_DisplayPrimaryDescription = "DisplayPrimaryDescription";

    static PyObject* _new_DisplayPrimaryDescription(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXPixelFormat>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXColorSpace>(args, 3);
                auto param4 = py::convert_to<bool>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::Direct3DMultisampleDescription>(args, 5);

                winrt::Windows::Devices::Display::Core::DisplayPrimaryDescription instance{ param0, param1, param2, param3, param4, param5 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DisplayPrimaryDescription(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayPrimaryDescription_CreateWithProperties(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 7)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayPrimaryDescription", L"CreateWithProperties", 7))
            {
                py::set_arg_count_version_error(7);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::guid, winrt::Windows::Foundation::IInspectable>>>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXPixelFormat>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXColorSpace>(args, 4);
                auto param5 = py::convert_to<bool>(args, 5);
                auto param6 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::Direct3DMultisampleDescription>(args, 6);

                return py::convert(winrt::Windows::Devices::Display::Core::DisplayPrimaryDescription::CreateWithProperties(param0, param1, param2, param3, param4, param5, param6));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_ColorSpace(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPrimaryDescription", L"ColorSpace"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColorSpace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_Format(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPrimaryDescription", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_Height(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPrimaryDescription", L"Height"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_IsStereo(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPrimaryDescription", L"IsStereo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStereo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_MultisampleDescription(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPrimaryDescription", L"MultisampleDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MultisampleDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPrimaryDescription", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_Width(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPrimaryDescription", L"Width"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayPrimaryDescription(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayPrimaryDescription>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayPrimaryDescription(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayPrimaryDescription>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayPrimaryDescription[] = {
        { "create_with_properties", reinterpret_cast<PyCFunction>(DisplayPrimaryDescription_CreateWithProperties), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_DisplayPrimaryDescription, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayPrimaryDescription), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayPrimaryDescription[] = {
        { "color_space", reinterpret_cast<getter>(DisplayPrimaryDescription_get_ColorSpace), nullptr, nullptr, nullptr },
        { "format", reinterpret_cast<getter>(DisplayPrimaryDescription_get_Format), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(DisplayPrimaryDescription_get_Height), nullptr, nullptr, nullptr },
        { "is_stereo", reinterpret_cast<getter>(DisplayPrimaryDescription_get_IsStereo), nullptr, nullptr, nullptr },
        { "multisample_description", reinterpret_cast<getter>(DisplayPrimaryDescription_get_MultisampleDescription), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DisplayPrimaryDescription_get_Properties), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(DisplayPrimaryDescription_get_Width), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayPrimaryDescription[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayPrimaryDescription) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayPrimaryDescription) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayPrimaryDescription) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayPrimaryDescription) },
        { },
    };

    static PyType_Spec type_spec_DisplayPrimaryDescription =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayPrimaryDescription",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayPrimaryDescription
    };

    // ----- DisplayScanout class --------------------
    static constexpr const char* const type_name_DisplayScanout = "DisplayScanout";

    static PyObject* _new_DisplayScanout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DisplayScanout);
        return nullptr;
    }

    static void _dealloc_DisplayScanout(py::wrapper::Windows::Devices::Display::Core::DisplayScanout* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DisplayScanout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayScanout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayScanout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayScanout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayScanout[] = {
        { "_assign_array_", _assign_array_DisplayScanout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayScanout), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayScanout[] = {
        { }
    };

    static PyType_Slot _type_slots_DisplayScanout[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayScanout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayScanout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayScanout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayScanout) },
        { },
    };

    static PyType_Spec type_spec_DisplayScanout =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayScanout",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayScanout),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayScanout
    };

    // ----- DisplaySource class --------------------
    static constexpr const char* const type_name_DisplaySource = "DisplaySource";

    static PyObject* _new_DisplaySource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DisplaySource);
        return nullptr;
    }

    static void _dealloc_DisplaySource(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplaySource_GetMetadata(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplaySource", L"GetMetadata", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.GetMetadata(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplaySource_get_AdapterId(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplaySource", L"AdapterId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AdapterId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplaySource_get_SourceId(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplaySource", L"SourceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplaySource_get_Status(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplaySource", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplaySource_add_StatusChanged(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Display.Core.DisplaySource", L"StatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Display::Core::DisplaySource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplaySource_remove_StatusChanged(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Display.Core.DisplaySource", L"StatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplaySource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplaySource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplaySource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplaySource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplaySource[] = {
        { "get_metadata", reinterpret_cast<PyCFunction>(DisplaySource_GetMetadata), METH_VARARGS, nullptr },
        { "add_status_changed", reinterpret_cast<PyCFunction>(DisplaySource_add_StatusChanged), METH_O, nullptr },
        { "remove_status_changed", reinterpret_cast<PyCFunction>(DisplaySource_remove_StatusChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_DisplaySource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplaySource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplaySource[] = {
        { "adapter_id", reinterpret_cast<getter>(DisplaySource_get_AdapterId), nullptr, nullptr, nullptr },
        { "source_id", reinterpret_cast<getter>(DisplaySource_get_SourceId), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(DisplaySource_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplaySource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplaySource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplaySource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplaySource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplaySource) },
        { },
    };

    static PyType_Spec type_spec_DisplaySource =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplaySource",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplaySource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplaySource
    };

    // ----- DisplayState class --------------------
    static constexpr const char* const type_name_DisplayState = "DisplayState";

    static PyObject* _new_DisplayState(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DisplayState);
        return nullptr;
    }

    static void _dealloc_DisplayState(py::wrapper::Windows::Devices::Display::Core::DisplayState* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayState_CanConnectTargetToView(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayState", L"CanConnectTargetToView", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayView>(args, 1);

                return py::convert(self->obj.CanConnectTargetToView(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_Clone(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayState", L"Clone", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Clone());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_ConnectTarget(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayState", L"ConnectTarget", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.ConnectTarget(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayState", L"ConnectTarget", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayView>(args, 1);

                return py::convert(self->obj.ConnectTarget(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_DisconnectTarget(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayState", L"DisconnectTarget", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                self->obj.DisconnectTarget(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_GetPathForTarget(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayState", L"GetPathForTarget", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.GetPathForTarget(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_GetViewForTarget(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayState", L"GetViewForTarget", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.GetViewForTarget(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_TryApply(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayState", L"TryApply", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayStateApplyOptions>(args, 0);

                return py::convert(self->obj.TryApply(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_TryFunctionalize(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayState", L"TryFunctionalize", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayStateFunctionalizeOptions>(args, 0);

                return py::convert(self->obj.TryFunctionalize(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_get_IsReadOnly(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayState", L"IsReadOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayState_get_IsStale(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayState", L"IsStale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayState_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayState", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayState_get_Targets(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayState", L"Targets"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Targets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayState_get_Views(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayState", L"Views"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Views());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayState>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayState>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayState[] = {
        { "can_connect_target_to_view", reinterpret_cast<PyCFunction>(DisplayState_CanConnectTargetToView), METH_VARARGS, nullptr },
        { "clone", reinterpret_cast<PyCFunction>(DisplayState_Clone), METH_VARARGS, nullptr },
        { "connect_target", reinterpret_cast<PyCFunction>(DisplayState_ConnectTarget), METH_VARARGS, nullptr },
        { "disconnect_target", reinterpret_cast<PyCFunction>(DisplayState_DisconnectTarget), METH_VARARGS, nullptr },
        { "get_path_for_target", reinterpret_cast<PyCFunction>(DisplayState_GetPathForTarget), METH_VARARGS, nullptr },
        { "get_view_for_target", reinterpret_cast<PyCFunction>(DisplayState_GetViewForTarget), METH_VARARGS, nullptr },
        { "try_apply", reinterpret_cast<PyCFunction>(DisplayState_TryApply), METH_VARARGS, nullptr },
        { "try_functionalize", reinterpret_cast<PyCFunction>(DisplayState_TryFunctionalize), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DisplayState, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayState), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayState[] = {
        { "is_read_only", reinterpret_cast<getter>(DisplayState_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "is_stale", reinterpret_cast<getter>(DisplayState_get_IsStale), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DisplayState_get_Properties), nullptr, nullptr, nullptr },
        { "targets", reinterpret_cast<getter>(DisplayState_get_Targets), nullptr, nullptr, nullptr },
        { "views", reinterpret_cast<getter>(DisplayState_get_Views), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayState[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayState) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayState) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayState) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayState) },
        { },
    };

    static PyType_Spec type_spec_DisplayState =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayState",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayState),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayState
    };

    // ----- DisplayStateOperationResult class --------------------
    static constexpr const char* const type_name_DisplayStateOperationResult = "DisplayStateOperationResult";

    static PyObject* _new_DisplayStateOperationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DisplayStateOperationResult);
        return nullptr;
    }

    static void _dealloc_DisplayStateOperationResult(py::wrapper::Windows::Devices::Display::Core::DisplayStateOperationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayStateOperationResult_get_ExtendedErrorCode(py::wrapper::Windows::Devices::Display::Core::DisplayStateOperationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayStateOperationResult", L"ExtendedErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayStateOperationResult_get_Status(py::wrapper::Windows::Devices::Display::Core::DisplayStateOperationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayStateOperationResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayStateOperationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayStateOperationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayStateOperationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayStateOperationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayStateOperationResult[] = {
        { "_assign_array_", _assign_array_DisplayStateOperationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayStateOperationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayStateOperationResult[] = {
        { "extended_error_code", reinterpret_cast<getter>(DisplayStateOperationResult_get_ExtendedErrorCode), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(DisplayStateOperationResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayStateOperationResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayStateOperationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayStateOperationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayStateOperationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayStateOperationResult) },
        { },
    };

    static PyType_Spec type_spec_DisplayStateOperationResult =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayStateOperationResult",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayStateOperationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayStateOperationResult
    };

    // ----- DisplaySurface class --------------------
    static constexpr const char* const type_name_DisplaySurface = "DisplaySurface";

    static PyObject* _new_DisplaySurface(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DisplaySurface);
        return nullptr;
    }

    static void _dealloc_DisplaySurface(py::wrapper::Windows::Devices::Display::Core::DisplaySurface* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DisplaySurface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplaySurface>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplaySurface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplaySurface>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplaySurface[] = {
        { "_assign_array_", _assign_array_DisplaySurface, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplaySurface), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplaySurface[] = {
        { }
    };

    static PyType_Slot _type_slots_DisplaySurface[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplaySurface) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplaySurface) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplaySurface) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplaySurface) },
        { },
    };

    static PyType_Spec type_spec_DisplaySurface =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplaySurface",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplaySurface),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplaySurface
    };

    // ----- DisplayTarget class --------------------
    static constexpr const char* const type_name_DisplayTarget = "DisplayTarget";

    static PyObject* _new_DisplayTarget(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DisplayTarget);
        return nullptr;
    }

    static void _dealloc_DisplayTarget(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayTarget_IsEqual(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"IsEqual", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.IsEqual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_IsSame(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"IsSame", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.IsSame(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_TryGetMonitor(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"TryGetMonitor", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryGetMonitor());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_Adapter(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"Adapter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Adapter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_AdapterRelativeId(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"AdapterRelativeId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AdapterRelativeId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_DeviceInterfacePath(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"DeviceInterfacePath"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceInterfacePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_IsConnected(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"IsConnected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsConnected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_IsStale(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"IsStale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_IsVirtualModeEnabled(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"IsVirtualModeEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsVirtualModeEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_IsVirtualTopologyEnabled(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"IsVirtualTopologyEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsVirtualTopologyEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_MonitorPersistence(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"MonitorPersistence"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MonitorPersistence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_StableMonitorId(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"StableMonitorId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StableMonitorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_UsageKind(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"UsageKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UsageKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayTarget(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayTarget>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayTarget(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayTarget>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayTarget[] = {
        { "is_equal", reinterpret_cast<PyCFunction>(DisplayTarget_IsEqual), METH_VARARGS, nullptr },
        { "is_same", reinterpret_cast<PyCFunction>(DisplayTarget_IsSame), METH_VARARGS, nullptr },
        { "try_get_monitor", reinterpret_cast<PyCFunction>(DisplayTarget_TryGetMonitor), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DisplayTarget, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayTarget), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayTarget[] = {
        { "adapter", reinterpret_cast<getter>(DisplayTarget_get_Adapter), nullptr, nullptr, nullptr },
        { "adapter_relative_id", reinterpret_cast<getter>(DisplayTarget_get_AdapterRelativeId), nullptr, nullptr, nullptr },
        { "device_interface_path", reinterpret_cast<getter>(DisplayTarget_get_DeviceInterfacePath), nullptr, nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(DisplayTarget_get_IsConnected), nullptr, nullptr, nullptr },
        { "is_stale", reinterpret_cast<getter>(DisplayTarget_get_IsStale), nullptr, nullptr, nullptr },
        { "is_virtual_mode_enabled", reinterpret_cast<getter>(DisplayTarget_get_IsVirtualModeEnabled), nullptr, nullptr, nullptr },
        { "is_virtual_topology_enabled", reinterpret_cast<getter>(DisplayTarget_get_IsVirtualTopologyEnabled), nullptr, nullptr, nullptr },
        { "monitor_persistence", reinterpret_cast<getter>(DisplayTarget_get_MonitorPersistence), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DisplayTarget_get_Properties), nullptr, nullptr, nullptr },
        { "stable_monitor_id", reinterpret_cast<getter>(DisplayTarget_get_StableMonitorId), nullptr, nullptr, nullptr },
        { "usage_kind", reinterpret_cast<getter>(DisplayTarget_get_UsageKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayTarget[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayTarget) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayTarget) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayTarget) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayTarget) },
        { },
    };

    static PyType_Spec type_spec_DisplayTarget =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayTarget",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayTarget),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayTarget
    };

    // ----- DisplayTask class --------------------
    static constexpr const char* const type_name_DisplayTask = "DisplayTask";

    static PyObject* _new_DisplayTask(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DisplayTask);
        return nullptr;
    }

    static void _dealloc_DisplayTask(py::wrapper::Windows::Devices::Display::Core::DisplayTask* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayTask_SetScanout(py::wrapper::Windows::Devices::Display::Core::DisplayTask* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayTask", L"SetScanout", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayScanout>(args, 0);

                self->obj.SetScanout(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTask_SetSignal(py::wrapper::Windows::Devices::Display::Core::DisplayTask* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayTask", L"SetSignal", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTaskSignalKind>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayFence>(args, 1);

                self->obj.SetSignal(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTask_SetWait(py::wrapper::Windows::Devices::Display::Core::DisplayTask* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayTask", L"SetWait", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayFence>(args, 0);
                auto param1 = py::convert_to<uint64_t>(args, 1);

                self->obj.SetWait(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayTask(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayTask>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayTask(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayTask>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayTask[] = {
        { "set_scanout", reinterpret_cast<PyCFunction>(DisplayTask_SetScanout), METH_VARARGS, nullptr },
        { "set_signal", reinterpret_cast<PyCFunction>(DisplayTask_SetSignal), METH_VARARGS, nullptr },
        { "set_wait", reinterpret_cast<PyCFunction>(DisplayTask_SetWait), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DisplayTask, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayTask), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayTask[] = {
        { }
    };

    static PyType_Slot _type_slots_DisplayTask[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayTask) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayTask) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayTask) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayTask) },
        { },
    };

    static PyType_Spec type_spec_DisplayTask =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayTask",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayTask),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayTask
    };

    // ----- DisplayTaskPool class --------------------
    static constexpr const char* const type_name_DisplayTaskPool = "DisplayTaskPool";

    static PyObject* _new_DisplayTaskPool(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DisplayTaskPool);
        return nullptr;
    }

    static void _dealloc_DisplayTaskPool(py::wrapper::Windows::Devices::Display::Core::DisplayTaskPool* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayTaskPool_CreateTask(py::wrapper::Windows::Devices::Display::Core::DisplayTaskPool* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayTaskPool", L"CreateTask", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateTask());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTaskPool_ExecuteTask(py::wrapper::Windows::Devices::Display::Core::DisplayTaskPool* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayTaskPool", L"ExecuteTask", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTask>(args, 0);

                self->obj.ExecuteTask(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTaskPool_TryExecuteTask(py::wrapper::Windows::Devices::Display::Core::DisplayTaskPool* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayTaskPool", L"TryExecuteTask", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTask>(args, 0);

                return py::convert(self->obj.TryExecuteTask(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayTaskPool(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayTaskPool>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayTaskPool(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayTaskPool>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayTaskPool[] = {
        { "create_task", reinterpret_cast<PyCFunction>(DisplayTaskPool_CreateTask), METH_VARARGS, nullptr },
        { "execute_task", reinterpret_cast<PyCFunction>(DisplayTaskPool_ExecuteTask), METH_VARARGS, nullptr },
        { "try_execute_task", reinterpret_cast<PyCFunction>(DisplayTaskPool_TryExecuteTask), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DisplayTaskPool, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayTaskPool), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayTaskPool[] = {
        { }
    };

    static PyType_Slot _type_slots_DisplayTaskPool[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayTaskPool) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayTaskPool) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayTaskPool) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayTaskPool) },
        { },
    };

    static PyType_Spec type_spec_DisplayTaskPool =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayTaskPool",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayTaskPool),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayTaskPool
    };

    // ----- DisplayTaskResult class --------------------
    static constexpr const char* const type_name_DisplayTaskResult = "DisplayTaskResult";

    static PyObject* _new_DisplayTaskResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DisplayTaskResult);
        return nullptr;
    }

    static void _dealloc_DisplayTaskResult(py::wrapper::Windows::Devices::Display::Core::DisplayTaskResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayTaskResult_get_PresentId(py::wrapper::Windows::Devices::Display::Core::DisplayTaskResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTaskResult", L"PresentId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PresentId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTaskResult_get_PresentStatus(py::wrapper::Windows::Devices::Display::Core::DisplayTaskResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTaskResult", L"PresentStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PresentStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTaskResult_get_SourceStatus(py::wrapper::Windows::Devices::Display::Core::DisplayTaskResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTaskResult", L"SourceStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayTaskResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayTaskResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayTaskResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayTaskResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayTaskResult[] = {
        { "_assign_array_", _assign_array_DisplayTaskResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayTaskResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayTaskResult[] = {
        { "present_id", reinterpret_cast<getter>(DisplayTaskResult_get_PresentId), nullptr, nullptr, nullptr },
        { "present_status", reinterpret_cast<getter>(DisplayTaskResult_get_PresentStatus), nullptr, nullptr, nullptr },
        { "source_status", reinterpret_cast<getter>(DisplayTaskResult_get_SourceStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayTaskResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayTaskResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayTaskResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayTaskResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayTaskResult) },
        { },
    };

    static PyType_Spec type_spec_DisplayTaskResult =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayTaskResult",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayTaskResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayTaskResult
    };

    // ----- DisplayView class --------------------
    static constexpr const char* const type_name_DisplayView = "DisplayView";

    static PyObject* _new_DisplayView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DisplayView);
        return nullptr;
    }

    static void _dealloc_DisplayView(py::wrapper::Windows::Devices::Display::Core::DisplayView* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayView_SetPrimaryPath(py::wrapper::Windows::Devices::Display::Core::DisplayView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayView", L"SetPrimaryPath", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayPath>(args, 0);

                self->obj.SetPrimaryPath(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayView_get_ContentResolution(py::wrapper::Windows::Devices::Display::Core::DisplayView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayView", L"ContentResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContentResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayView_put_ContentResolution(py::wrapper::Windows::Devices::Display::Core::DisplayView* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayView", L"ContentResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Graphics::SizeInt32>>(arg);

            self->obj.ContentResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayView_get_Paths(py::wrapper::Windows::Devices::Display::Core::DisplayView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayView", L"Paths"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Paths());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayView_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayView", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayView[] = {
        { "set_primary_path", reinterpret_cast<PyCFunction>(DisplayView_SetPrimaryPath), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DisplayView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayView[] = {
        { "content_resolution", reinterpret_cast<getter>(DisplayView_get_ContentResolution), reinterpret_cast<setter>(DisplayView_put_ContentResolution), nullptr, nullptr },
        { "paths", reinterpret_cast<getter>(DisplayView_get_Paths), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DisplayView_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayView[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayView) },
        { },
    };

    static PyType_Spec type_spec_DisplayView =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayView",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayView
    };

    // ----- DisplayWireFormat class --------------------
    static constexpr const char* const type_name_DisplayWireFormat = "DisplayWireFormat";

    static PyObject* _new_DisplayWireFormat(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatPixelEncoding>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatColorSpace>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatEotf>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatHdrMetadata>(args, 4);

                winrt::Windows::Devices::Display::Core::DisplayWireFormat instance{ param0, param1, param2, param3, param4 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DisplayWireFormat(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayWireFormat_CreateWithProperties(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayWireFormat", L"CreateWithProperties", 6))
            {
                py::set_arg_count_version_error(6);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::guid, winrt::Windows::Foundation::IInspectable>>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatPixelEncoding>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatColorSpace>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatEotf>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatHdrMetadata>(args, 5);

                return py::convert(winrt::Windows::Devices::Display::Core::DisplayWireFormat::CreateWithProperties(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayWireFormat_get_BitsPerChannel(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayWireFormat", L"BitsPerChannel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BitsPerChannel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayWireFormat_get_ColorSpace(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayWireFormat", L"ColorSpace"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColorSpace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayWireFormat_get_Eotf(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayWireFormat", L"Eotf"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Eotf());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayWireFormat_get_HdrMetadata(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayWireFormat", L"HdrMetadata"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HdrMetadata());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayWireFormat_get_PixelEncoding(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayWireFormat", L"PixelEncoding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PixelEncoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayWireFormat_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayWireFormat", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayWireFormat(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayWireFormat>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayWireFormat(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayWireFormat>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayWireFormat[] = {
        { "create_with_properties", reinterpret_cast<PyCFunction>(DisplayWireFormat_CreateWithProperties), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_DisplayWireFormat, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayWireFormat), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayWireFormat[] = {
        { "bits_per_channel", reinterpret_cast<getter>(DisplayWireFormat_get_BitsPerChannel), nullptr, nullptr, nullptr },
        { "color_space", reinterpret_cast<getter>(DisplayWireFormat_get_ColorSpace), nullptr, nullptr, nullptr },
        { "eotf", reinterpret_cast<getter>(DisplayWireFormat_get_Eotf), nullptr, nullptr, nullptr },
        { "hdr_metadata", reinterpret_cast<getter>(DisplayWireFormat_get_HdrMetadata), nullptr, nullptr, nullptr },
        { "pixel_encoding", reinterpret_cast<getter>(DisplayWireFormat_get_PixelEncoding), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DisplayWireFormat_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayWireFormat[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayWireFormat) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayWireFormat) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayWireFormat) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayWireFormat) },
        { },
    };

    static PyType_Spec type_spec_DisplayWireFormat =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayWireFormat",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayWireFormat
    };

    // ----- DisplayPresentationRate struct --------------------
    static constexpr const char* const type_name_DisplayPresentationRate = "DisplayPresentationRate";

    PyObject* _new_DisplayPresentationRate(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Devices::Display::Core::DisplayPresentationRate return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        PyObject* _VerticalSyncRate{};
        int32_t _VerticalSyncsPerPresentation{};

        static const char* kwlist[] = {"vertical_sync_rate", "vertical_syncs_per_presentation", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "Oi", const_cast<char**>(kwlist), &_VerticalSyncRate, &_VerticalSyncsPerPresentation))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Devices::Display::Core::DisplayPresentationRate return_value{ py::converter<winrt::Windows::Foundation::Numerics::Rational>::convert_to(_VerticalSyncRate), _VerticalSyncsPerPresentation };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_DisplayPresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayPresentationRate* self) noexcept
    {
    }

    static PyObject* DisplayPresentationRate_get_VerticalSyncRate(py::wrapper::Windows::Devices::Display::Core::DisplayPresentationRate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VerticalSyncRate);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPresentationRate_set_VerticalSyncRate(py::wrapper::Windows::Devices::Display::Core::DisplayPresentationRate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.VerticalSyncRate = py::converter<winrt::Windows::Foundation::Numerics::Rational>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPresentationRate_get_VerticalSyncsPerPresentation(py::wrapper::Windows::Devices::Display::Core::DisplayPresentationRate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VerticalSyncsPerPresentation);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPresentationRate_set_VerticalSyncsPerPresentation(py::wrapper::Windows::Devices::Display::Core::DisplayPresentationRate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.VerticalSyncsPerPresentation = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_DisplayPresentationRate[] = {
        { "vertical_sync_rate", reinterpret_cast<getter>(DisplayPresentationRate_get_VerticalSyncRate), reinterpret_cast<setter>(DisplayPresentationRate_set_VerticalSyncRate), nullptr, nullptr },
        { "vertical_syncs_per_presentation", reinterpret_cast<getter>(DisplayPresentationRate_get_VerticalSyncsPerPresentation), reinterpret_cast<setter>(DisplayPresentationRate_set_VerticalSyncsPerPresentation), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayPresentationRate[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayPresentationRate) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayPresentationRate) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayPresentationRate) },
        { },
    };

    static PyType_Spec type_spec_DisplayPresentationRate =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayPresentationRate",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayPresentationRate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayPresentationRate
    };

    // ----- Windows.Devices.Display.Core Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Devices::Display::Core");

    static PyMethodDef module_methods[] = {
        {"_register_DisplayBitsPerChannel", register_DisplayBitsPerChannel, METH_O, "registers type"},
        {"_register_DisplayDeviceCapability", register_DisplayDeviceCapability, METH_O, "registers type"},
        {"_register_DisplayManagerOptions", register_DisplayManagerOptions, METH_O, "registers type"},
        {"_register_DisplayManagerResult", register_DisplayManagerResult, METH_O, "registers type"},
        {"_register_DisplayModeQueryOptions", register_DisplayModeQueryOptions, METH_O, "registers type"},
        {"_register_DisplayPathScaling", register_DisplayPathScaling, METH_O, "registers type"},
        {"_register_DisplayPathStatus", register_DisplayPathStatus, METH_O, "registers type"},
        {"_register_DisplayPresentStatus", register_DisplayPresentStatus, METH_O, "registers type"},
        {"_register_DisplayRotation", register_DisplayRotation, METH_O, "registers type"},
        {"_register_DisplayScanoutOptions", register_DisplayScanoutOptions, METH_O, "registers type"},
        {"_register_DisplaySourceStatus", register_DisplaySourceStatus, METH_O, "registers type"},
        {"_register_DisplayStateApplyOptions", register_DisplayStateApplyOptions, METH_O, "registers type"},
        {"_register_DisplayStateFunctionalizeOptions", register_DisplayStateFunctionalizeOptions, METH_O, "registers type"},
        {"_register_DisplayStateOperationStatus", register_DisplayStateOperationStatus, METH_O, "registers type"},
        {"_register_DisplayTargetPersistence", register_DisplayTargetPersistence, METH_O, "registers type"},
        {"_register_DisplayTaskSignalKind", register_DisplayTaskSignalKind, METH_O, "registers type"},
        {"_register_DisplayWireFormatColorSpace", register_DisplayWireFormatColorSpace, METH_O, "registers type"},
        {"_register_DisplayWireFormatEotf", register_DisplayWireFormatEotf, METH_O, "registers type"},
        {"_register_DisplayWireFormatHdrMetadata", register_DisplayWireFormatHdrMetadata, METH_O, "registers type"},
        {"_register_DisplayWireFormatPixelEncoding", register_DisplayWireFormatPixelEncoding, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_DisplayBitsPerChannel);
        Py_VISIT(state->type_DisplayDeviceCapability);
        Py_VISIT(state->type_DisplayManagerOptions);
        Py_VISIT(state->type_DisplayManagerResult);
        Py_VISIT(state->type_DisplayModeQueryOptions);
        Py_VISIT(state->type_DisplayPathScaling);
        Py_VISIT(state->type_DisplayPathStatus);
        Py_VISIT(state->type_DisplayPresentStatus);
        Py_VISIT(state->type_DisplayRotation);
        Py_VISIT(state->type_DisplayScanoutOptions);
        Py_VISIT(state->type_DisplaySourceStatus);
        Py_VISIT(state->type_DisplayStateApplyOptions);
        Py_VISIT(state->type_DisplayStateFunctionalizeOptions);
        Py_VISIT(state->type_DisplayStateOperationStatus);
        Py_VISIT(state->type_DisplayTargetPersistence);
        Py_VISIT(state->type_DisplayTaskSignalKind);
        Py_VISIT(state->type_DisplayWireFormatColorSpace);
        Py_VISIT(state->type_DisplayWireFormatEotf);
        Py_VISIT(state->type_DisplayWireFormatHdrMetadata);
        Py_VISIT(state->type_DisplayWireFormatPixelEncoding);
        Py_VISIT(state->type_DisplayAdapter);
        Py_VISIT(state->type_DisplayDevice);
        Py_VISIT(state->type_DisplayFence);
        Py_VISIT(state->type_DisplayManager);
        Py_VISIT(state->type_DisplayManagerChangedEventArgs);
        Py_VISIT(state->type_DisplayManagerDisabledEventArgs);
        Py_VISIT(state->type_DisplayManagerEnabledEventArgs);
        Py_VISIT(state->type_DisplayManagerPathsFailedOrInvalidatedEventArgs);
        Py_VISIT(state->type_DisplayManagerResultWithState);
        Py_VISIT(state->type_DisplayModeInfo);
        Py_VISIT(state->type_DisplayPath);
        Py_VISIT(state->type_DisplayPrimaryDescription);
        Py_VISIT(state->type_DisplayScanout);
        Py_VISIT(state->type_DisplaySource);
        Py_VISIT(state->type_DisplayState);
        Py_VISIT(state->type_DisplayStateOperationResult);
        Py_VISIT(state->type_DisplaySurface);
        Py_VISIT(state->type_DisplayTarget);
        Py_VISIT(state->type_DisplayTask);
        Py_VISIT(state->type_DisplayTaskPool);
        Py_VISIT(state->type_DisplayTaskResult);
        Py_VISIT(state->type_DisplayView);
        Py_VISIT(state->type_DisplayWireFormat);
        Py_VISIT(state->type_DisplayPresentationRate);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_DisplayBitsPerChannel);
        Py_CLEAR(state->type_DisplayDeviceCapability);
        Py_CLEAR(state->type_DisplayManagerOptions);
        Py_CLEAR(state->type_DisplayManagerResult);
        Py_CLEAR(state->type_DisplayModeQueryOptions);
        Py_CLEAR(state->type_DisplayPathScaling);
        Py_CLEAR(state->type_DisplayPathStatus);
        Py_CLEAR(state->type_DisplayPresentStatus);
        Py_CLEAR(state->type_DisplayRotation);
        Py_CLEAR(state->type_DisplayScanoutOptions);
        Py_CLEAR(state->type_DisplaySourceStatus);
        Py_CLEAR(state->type_DisplayStateApplyOptions);
        Py_CLEAR(state->type_DisplayStateFunctionalizeOptions);
        Py_CLEAR(state->type_DisplayStateOperationStatus);
        Py_CLEAR(state->type_DisplayTargetPersistence);
        Py_CLEAR(state->type_DisplayTaskSignalKind);
        Py_CLEAR(state->type_DisplayWireFormatColorSpace);
        Py_CLEAR(state->type_DisplayWireFormatEotf);
        Py_CLEAR(state->type_DisplayWireFormatHdrMetadata);
        Py_CLEAR(state->type_DisplayWireFormatPixelEncoding);
        Py_CLEAR(state->type_DisplayAdapter);
        Py_CLEAR(state->type_DisplayDevice);
        Py_CLEAR(state->type_DisplayFence);
        Py_CLEAR(state->type_DisplayManager);
        Py_CLEAR(state->type_DisplayManagerChangedEventArgs);
        Py_CLEAR(state->type_DisplayManagerDisabledEventArgs);
        Py_CLEAR(state->type_DisplayManagerEnabledEventArgs);
        Py_CLEAR(state->type_DisplayManagerPathsFailedOrInvalidatedEventArgs);
        Py_CLEAR(state->type_DisplayManagerResultWithState);
        Py_CLEAR(state->type_DisplayModeInfo);
        Py_CLEAR(state->type_DisplayPath);
        Py_CLEAR(state->type_DisplayPrimaryDescription);
        Py_CLEAR(state->type_DisplayScanout);
        Py_CLEAR(state->type_DisplaySource);
        Py_CLEAR(state->type_DisplayState);
        Py_CLEAR(state->type_DisplayStateOperationResult);
        Py_CLEAR(state->type_DisplaySurface);
        Py_CLEAR(state->type_DisplayTarget);
        Py_CLEAR(state->type_DisplayTask);
        Py_CLEAR(state->type_DisplayTaskPool);
        Py_CLEAR(state->type_DisplayTaskResult);
        Py_CLEAR(state->type_DisplayView);
        Py_CLEAR(state->type_DisplayWireFormat);
        Py_CLEAR(state->type_DisplayPresentationRate);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Devices_Display_Core",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Devices::Display::Core

PyMODINIT_FUNC PyInit__winsdk_Windows_Devices_Display_Core(void) noexcept
{
    using namespace py::cpp::Windows::Devices::Display::Core;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_DisplayAdapter = py::register_python_type(module.get(), type_name_DisplayAdapter, &type_spec_DisplayAdapter, bases.get(), nullptr);
    if (!state->type_DisplayAdapter)
    {
        return nullptr;
    }

    state->type_DisplayDevice = py::register_python_type(module.get(), type_name_DisplayDevice, &type_spec_DisplayDevice, bases.get(), nullptr);
    if (!state->type_DisplayDevice)
    {
        return nullptr;
    }

    state->type_DisplayFence = py::register_python_type(module.get(), type_name_DisplayFence, &type_spec_DisplayFence, bases.get(), nullptr);
    if (!state->type_DisplayFence)
    {
        return nullptr;
    }

    state->type_DisplayManager = py::register_python_type(module.get(), type_name_DisplayManager, &type_spec_DisplayManager, bases.get(), nullptr);
    if (!state->type_DisplayManager)
    {
        return nullptr;
    }

    state->type_DisplayManagerChangedEventArgs = py::register_python_type(module.get(), type_name_DisplayManagerChangedEventArgs, &type_spec_DisplayManagerChangedEventArgs, bases.get(), nullptr);
    if (!state->type_DisplayManagerChangedEventArgs)
    {
        return nullptr;
    }

    state->type_DisplayManagerDisabledEventArgs = py::register_python_type(module.get(), type_name_DisplayManagerDisabledEventArgs, &type_spec_DisplayManagerDisabledEventArgs, bases.get(), nullptr);
    if (!state->type_DisplayManagerDisabledEventArgs)
    {
        return nullptr;
    }

    state->type_DisplayManagerEnabledEventArgs = py::register_python_type(module.get(), type_name_DisplayManagerEnabledEventArgs, &type_spec_DisplayManagerEnabledEventArgs, bases.get(), nullptr);
    if (!state->type_DisplayManagerEnabledEventArgs)
    {
        return nullptr;
    }

    state->type_DisplayManagerPathsFailedOrInvalidatedEventArgs = py::register_python_type(module.get(), type_name_DisplayManagerPathsFailedOrInvalidatedEventArgs, &type_spec_DisplayManagerPathsFailedOrInvalidatedEventArgs, bases.get(), nullptr);
    if (!state->type_DisplayManagerPathsFailedOrInvalidatedEventArgs)
    {
        return nullptr;
    }

    state->type_DisplayManagerResultWithState = py::register_python_type(module.get(), type_name_DisplayManagerResultWithState, &type_spec_DisplayManagerResultWithState, bases.get(), nullptr);
    if (!state->type_DisplayManagerResultWithState)
    {
        return nullptr;
    }

    state->type_DisplayModeInfo = py::register_python_type(module.get(), type_name_DisplayModeInfo, &type_spec_DisplayModeInfo, bases.get(), nullptr);
    if (!state->type_DisplayModeInfo)
    {
        return nullptr;
    }

    state->type_DisplayPath = py::register_python_type(module.get(), type_name_DisplayPath, &type_spec_DisplayPath, bases.get(), nullptr);
    if (!state->type_DisplayPath)
    {
        return nullptr;
    }

    state->type_DisplayPrimaryDescription = py::register_python_type(module.get(), type_name_DisplayPrimaryDescription, &type_spec_DisplayPrimaryDescription, bases.get(), nullptr);
    if (!state->type_DisplayPrimaryDescription)
    {
        return nullptr;
    }

    state->type_DisplayScanout = py::register_python_type(module.get(), type_name_DisplayScanout, &type_spec_DisplayScanout, bases.get(), nullptr);
    if (!state->type_DisplayScanout)
    {
        return nullptr;
    }

    state->type_DisplaySource = py::register_python_type(module.get(), type_name_DisplaySource, &type_spec_DisplaySource, bases.get(), nullptr);
    if (!state->type_DisplaySource)
    {
        return nullptr;
    }

    state->type_DisplayState = py::register_python_type(module.get(), type_name_DisplayState, &type_spec_DisplayState, bases.get(), nullptr);
    if (!state->type_DisplayState)
    {
        return nullptr;
    }

    state->type_DisplayStateOperationResult = py::register_python_type(module.get(), type_name_DisplayStateOperationResult, &type_spec_DisplayStateOperationResult, bases.get(), nullptr);
    if (!state->type_DisplayStateOperationResult)
    {
        return nullptr;
    }

    state->type_DisplaySurface = py::register_python_type(module.get(), type_name_DisplaySurface, &type_spec_DisplaySurface, bases.get(), nullptr);
    if (!state->type_DisplaySurface)
    {
        return nullptr;
    }

    state->type_DisplayTarget = py::register_python_type(module.get(), type_name_DisplayTarget, &type_spec_DisplayTarget, bases.get(), nullptr);
    if (!state->type_DisplayTarget)
    {
        return nullptr;
    }

    state->type_DisplayTask = py::register_python_type(module.get(), type_name_DisplayTask, &type_spec_DisplayTask, bases.get(), nullptr);
    if (!state->type_DisplayTask)
    {
        return nullptr;
    }

    state->type_DisplayTaskPool = py::register_python_type(module.get(), type_name_DisplayTaskPool, &type_spec_DisplayTaskPool, bases.get(), nullptr);
    if (!state->type_DisplayTaskPool)
    {
        return nullptr;
    }

    state->type_DisplayTaskResult = py::register_python_type(module.get(), type_name_DisplayTaskResult, &type_spec_DisplayTaskResult, bases.get(), nullptr);
    if (!state->type_DisplayTaskResult)
    {
        return nullptr;
    }

    state->type_DisplayView = py::register_python_type(module.get(), type_name_DisplayView, &type_spec_DisplayView, bases.get(), nullptr);
    if (!state->type_DisplayView)
    {
        return nullptr;
    }

    state->type_DisplayWireFormat = py::register_python_type(module.get(), type_name_DisplayWireFormat, &type_spec_DisplayWireFormat, bases.get(), nullptr);
    if (!state->type_DisplayWireFormat)
    {
        return nullptr;
    }

    state->type_DisplayPresentationRate = py::register_python_type(module.get(), type_name_DisplayPresentationRate, &type_spec_DisplayPresentationRate, bases.get(), nullptr);
    if (!state->type_DisplayPresentationRate)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Devices::Display::Core::DisplayBitsPerChannel>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayBitsPerChannel;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayBitsPerChannel is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Display::Core::DisplayDeviceCapability>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayDeviceCapability;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayDeviceCapability is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Display::Core::DisplayManagerOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayManagerOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayManagerOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Display::Core::DisplayManagerResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayManagerResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayManagerResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Display::Core::DisplayModeQueryOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayModeQueryOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayModeQueryOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Display::Core::DisplayPathScaling>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayPathScaling;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayPathScaling is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Display::Core::DisplayPathStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayPathStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayPathStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Display::Core::DisplayPresentStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayPresentStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayPresentStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Display::Core::DisplayRotation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayRotation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayRotation is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Display::Core::DisplayScanoutOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayScanoutOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayScanoutOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Display::Core::DisplaySourceStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplaySourceStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplaySourceStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Display::Core::DisplayStateApplyOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayStateApplyOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayStateApplyOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Display::Core::DisplayStateFunctionalizeOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayStateFunctionalizeOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayStateFunctionalizeOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Display::Core::DisplayStateOperationStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayStateOperationStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayStateOperationStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Display::Core::DisplayTargetPersistence>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayTargetPersistence;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayTargetPersistence is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Display::Core::DisplayTaskSignalKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayTaskSignalKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayTaskSignalKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Display::Core::DisplayWireFormatColorSpace>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayWireFormatColorSpace;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayWireFormatColorSpace is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Display::Core::DisplayWireFormatEotf>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayWireFormatEotf;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayWireFormatEotf is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Display::Core::DisplayWireFormatHdrMetadata>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayWireFormatHdrMetadata;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayWireFormatHdrMetadata is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Display::Core::DisplayWireFormatPixelEncoding>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayWireFormatPixelEncoding;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayWireFormatPixelEncoding is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayAdapter>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayAdapter;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayAdapter is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayDevice>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayDevice;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayDevice is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayFence>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayFence;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayFence is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayManagerChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayManagerDisabledEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayManagerEnabledEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayManagerPathsFailedOrInvalidatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManagerResultWithState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayManagerResultWithState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayManagerResultWithState is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayModeInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayModeInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayModeInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayPath>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayPath;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayPath is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayPrimaryDescription>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayPrimaryDescription;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayPrimaryDescription is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayScanout>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayScanout;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayScanout is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplaySource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplaySource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplaySource is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayState is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayStateOperationResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayStateOperationResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayStateOperationResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplaySurface>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplaySurface;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplaySurface is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayTarget>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayTarget;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayTarget is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayTask>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayTask;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayTask is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayTaskPool>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayTaskPool;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayTaskPool is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayTaskResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayTaskResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayTaskResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayView>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayView;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayView is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayWireFormat>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayWireFormat;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayWireFormat is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Display::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Display::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DisplayPresentationRate;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Display::Core::DisplayPresentationRate is not registered");
        return nullptr;
    }

    return python_type;
}
