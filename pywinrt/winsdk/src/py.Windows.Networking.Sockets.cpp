// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.Networking.Sockets.h"


PyObject* py::converter<winrt::Windows::Networking::Sockets::BandwidthStatistics>::convert(winrt::Windows::Networking::Sockets::BandwidthStatistics instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Networking::Sockets::BandwidthStatistics>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Networking::Sockets::BandwidthStatistics py::converter<winrt::Windows::Networking::Sockets::BandwidthStatistics>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Networking::Sockets::BandwidthStatistics>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Networking::Sockets::BandwidthStatistics>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Networking::Sockets::BandwidthStatistics");
    throw python_exception();
}

PyObject* py::converter<winrt::Windows::Networking::Sockets::RoundTripTimeStatistics>::convert(winrt::Windows::Networking::Sockets::RoundTripTimeStatistics instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Networking::Sockets::RoundTripTimeStatistics>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Networking::Sockets::RoundTripTimeStatistics py::converter<winrt::Windows::Networking::Sockets::RoundTripTimeStatistics>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Networking::Sockets::RoundTripTimeStatistics>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Networking::Sockets::RoundTripTimeStatistics>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Networking::Sockets::RoundTripTimeStatistics");
    throw python_exception();
}

namespace py::cpp::Windows::Networking::Sockets
{
    struct module_state
    {
        PyObject* type_ControlChannelTriggerResetReason;
        PyObject* type_ControlChannelTriggerResourceType;
        PyObject* type_ControlChannelTriggerStatus;
        PyObject* type_MessageWebSocketReceiveMode;
        PyObject* type_SocketActivityConnectedStandbyAction;
        PyObject* type_SocketActivityKind;
        PyObject* type_SocketActivityTriggerReason;
        PyObject* type_SocketErrorStatus;
        PyObject* type_SocketMessageType;
        PyObject* type_SocketProtectionLevel;
        PyObject* type_SocketQualityOfService;
        PyObject* type_SocketSslErrorSeverity;
        PyTypeObject* type_ControlChannelTrigger;
        PyTypeObject* type_DatagramSocket;
        PyTypeObject* type_DatagramSocketControl;
        PyTypeObject* type_DatagramSocketInformation;
        PyTypeObject* type_DatagramSocketMessageReceivedEventArgs;
        PyTypeObject* type_MessageWebSocket;
        PyTypeObject* type_MessageWebSocketControl;
        PyTypeObject* type_MessageWebSocketInformation;
        PyTypeObject* type_MessageWebSocketMessageReceivedEventArgs;
        PyTypeObject* type_ServerMessageWebSocket;
        PyTypeObject* type_ServerMessageWebSocketControl;
        PyTypeObject* type_ServerMessageWebSocketInformation;
        PyTypeObject* type_ServerStreamWebSocket;
        PyTypeObject* type_ServerStreamWebSocketInformation;
        PyTypeObject* type_SocketActivityContext;
        PyTypeObject* type_SocketActivityInformation;
        PyTypeObject* type_SocketActivityTriggerDetails;
        PyTypeObject* type_SocketError;
        PyTypeObject* type_StreamSocket;
        PyTypeObject* type_StreamSocketControl;
        PyTypeObject* type_StreamSocketInformation;
        PyTypeObject* type_StreamSocketListener;
        PyTypeObject* type_StreamSocketListenerConnectionReceivedEventArgs;
        PyTypeObject* type_StreamSocketListenerControl;
        PyTypeObject* type_StreamSocketListenerInformation;
        PyTypeObject* type_StreamWebSocket;
        PyTypeObject* type_StreamWebSocketControl;
        PyTypeObject* type_StreamWebSocketInformation;
        PyTypeObject* type_WebSocketClosedEventArgs;
        PyTypeObject* type_WebSocketError;
        PyTypeObject* type_WebSocketKeepAlive;
        PyTypeObject* type_WebSocketServerCustomValidationRequestedEventArgs;
        PyTypeObject* type_IControlChannelTriggerEventDetails;
        PyTypeObject* type_IControlChannelTriggerResetEventDetails;
        PyTypeObject* type_IWebSocket;
        PyTypeObject* type_IWebSocketControl;
        PyTypeObject* type_IWebSocketControl2;
        PyTypeObject* type_IWebSocketInformation;
        PyTypeObject* type_IWebSocketInformation2;
        PyTypeObject* type_BandwidthStatistics;
        PyTypeObject* type_RoundTripTimeStatistics;
    };

    static PyObject* register_ControlChannelTriggerResetReason(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ControlChannelTriggerResetReason)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ControlChannelTriggerResetReason = type;
        Py_INCREF(state->type_ControlChannelTriggerResetReason);


        Py_RETURN_NONE;
    }

    static PyObject* register_ControlChannelTriggerResourceType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ControlChannelTriggerResourceType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ControlChannelTriggerResourceType = type;
        Py_INCREF(state->type_ControlChannelTriggerResourceType);


        Py_RETURN_NONE;
    }

    static PyObject* register_ControlChannelTriggerStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ControlChannelTriggerStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ControlChannelTriggerStatus = type;
        Py_INCREF(state->type_ControlChannelTriggerStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_MessageWebSocketReceiveMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MessageWebSocketReceiveMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MessageWebSocketReceiveMode = type;
        Py_INCREF(state->type_MessageWebSocketReceiveMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_SocketActivityConnectedStandbyAction(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SocketActivityConnectedStandbyAction)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SocketActivityConnectedStandbyAction = type;
        Py_INCREF(state->type_SocketActivityConnectedStandbyAction);


        Py_RETURN_NONE;
    }

    static PyObject* register_SocketActivityKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SocketActivityKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SocketActivityKind = type;
        Py_INCREF(state->type_SocketActivityKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_SocketActivityTriggerReason(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SocketActivityTriggerReason)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SocketActivityTriggerReason = type;
        Py_INCREF(state->type_SocketActivityTriggerReason);


        Py_RETURN_NONE;
    }

    static PyObject* register_SocketErrorStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SocketErrorStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SocketErrorStatus = type;
        Py_INCREF(state->type_SocketErrorStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_SocketMessageType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SocketMessageType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SocketMessageType = type;
        Py_INCREF(state->type_SocketMessageType);


        Py_RETURN_NONE;
    }

    static PyObject* register_SocketProtectionLevel(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SocketProtectionLevel)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SocketProtectionLevel = type;
        Py_INCREF(state->type_SocketProtectionLevel);


        Py_RETURN_NONE;
    }

    static PyObject* register_SocketQualityOfService(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SocketQualityOfService)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SocketQualityOfService = type;
        Py_INCREF(state->type_SocketQualityOfService);


        Py_RETURN_NONE;
    }

    static PyObject* register_SocketSslErrorSeverity(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SocketSslErrorSeverity)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SocketSslErrorSeverity = type;
        Py_INCREF(state->type_SocketSslErrorSeverity);


        Py_RETURN_NONE;
    }

    // ----- ControlChannelTrigger class --------------------
    static constexpr const char* const type_name_ControlChannelTrigger = "ControlChannelTrigger";

    static PyObject* _new_ControlChannelTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                winrt::Windows::Networking::Sockets::ControlChannelTrigger instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Sockets::ControlChannelTriggerResourceType>(args, 2);

                winrt::Windows::Networking::Sockets::ControlChannelTrigger instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ControlChannelTrigger(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ControlChannelTrigger_Close(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.ControlChannelTrigger", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_DecreaseNetworkKeepAliveInterval(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.ControlChannelTrigger", L"DecreaseNetworkKeepAliveInterval", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.DecreaseNetworkKeepAliveInterval();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_FlushTransport(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.ControlChannelTrigger", L"FlushTransport", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.FlushTransport();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_UsingTransport(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.ControlChannelTrigger", L"UsingTransport", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                self->obj.UsingTransport(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_WaitForPushEnabled(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.ControlChannelTrigger", L"WaitForPushEnabled", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.WaitForPushEnabled());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_get_ServerKeepAliveIntervalInMinutes(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ControlChannelTrigger", L"ServerKeepAliveIntervalInMinutes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerKeepAliveIntervalInMinutes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ControlChannelTrigger_put_ServerKeepAliveIntervalInMinutes(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ControlChannelTrigger", L"ServerKeepAliveIntervalInMinutes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ServerKeepAliveIntervalInMinutes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ControlChannelTrigger_get_ControlChannelTriggerId(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ControlChannelTrigger", L"ControlChannelTriggerId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ControlChannelTriggerId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_get_CurrentKeepAliveIntervalInMinutes(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ControlChannelTrigger", L"CurrentKeepAliveIntervalInMinutes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentKeepAliveIntervalInMinutes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_get_KeepAliveTrigger(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ControlChannelTrigger", L"KeepAliveTrigger"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeepAliveTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_get_PushNotificationTrigger(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ControlChannelTrigger", L"PushNotificationTrigger"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PushNotificationTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_get_TransportObject(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ControlChannelTrigger", L"TransportObject"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransportObject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_get_IsWakeFromLowPowerSupported(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ControlChannelTrigger", L"IsWakeFromLowPowerSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsWakeFromLowPowerSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ControlChannelTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::ControlChannelTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ControlChannelTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::ControlChannelTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ControlChannelTrigger(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ControlChannelTrigger(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ControlChannelTrigger[] = {
        { "close", reinterpret_cast<PyCFunction>(ControlChannelTrigger_Close), METH_VARARGS, nullptr },
        { "decrease_network_keep_alive_interval", reinterpret_cast<PyCFunction>(ControlChannelTrigger_DecreaseNetworkKeepAliveInterval), METH_VARARGS, nullptr },
        { "flush_transport", reinterpret_cast<PyCFunction>(ControlChannelTrigger_FlushTransport), METH_VARARGS, nullptr },
        { "using_transport", reinterpret_cast<PyCFunction>(ControlChannelTrigger_UsingTransport), METH_VARARGS, nullptr },
        { "wait_for_push_enabled", reinterpret_cast<PyCFunction>(ControlChannelTrigger_WaitForPushEnabled), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ControlChannelTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ControlChannelTrigger), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ControlChannelTrigger), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ControlChannelTrigger), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ControlChannelTrigger[] = {
        { "server_keep_alive_interval_in_minutes", reinterpret_cast<getter>(ControlChannelTrigger_get_ServerKeepAliveIntervalInMinutes), reinterpret_cast<setter>(ControlChannelTrigger_put_ServerKeepAliveIntervalInMinutes), nullptr, nullptr },
        { "control_channel_trigger_id", reinterpret_cast<getter>(ControlChannelTrigger_get_ControlChannelTriggerId), nullptr, nullptr, nullptr },
        { "current_keep_alive_interval_in_minutes", reinterpret_cast<getter>(ControlChannelTrigger_get_CurrentKeepAliveIntervalInMinutes), nullptr, nullptr, nullptr },
        { "keep_alive_trigger", reinterpret_cast<getter>(ControlChannelTrigger_get_KeepAliveTrigger), nullptr, nullptr, nullptr },
        { "push_notification_trigger", reinterpret_cast<getter>(ControlChannelTrigger_get_PushNotificationTrigger), nullptr, nullptr, nullptr },
        { "transport_object", reinterpret_cast<getter>(ControlChannelTrigger_get_TransportObject), nullptr, nullptr, nullptr },
        { "is_wake_from_low_power_supported", reinterpret_cast<getter>(ControlChannelTrigger_get_IsWakeFromLowPowerSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ControlChannelTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ControlChannelTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ControlChannelTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ControlChannelTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ControlChannelTrigger) },
        { },
    };

    static PyType_Spec type_spec_ControlChannelTrigger =
    {
        "_winsdk_Windows_Networking_Sockets.ControlChannelTrigger",
        sizeof(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ControlChannelTrigger
    };

    // ----- DatagramSocket class --------------------
    static constexpr const char* const type_name_DatagramSocket = "DatagramSocket";

    static PyObject* _new_DatagramSocket(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Sockets::DatagramSocket instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DatagramSocket(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DatagramSocket_BindEndpointAsync(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"BindEndpointAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.BindEndpointAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_BindServiceNameAsync(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"BindServiceNameAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.BindServiceNameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"BindServiceNameAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkAdapter>(args, 1);

                return py::convert(self->obj.BindServiceNameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_CancelIOAsync(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"CancelIOAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CancelIOAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_Close(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_ConnectAsync(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"ConnectAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::EndpointPair>(args, 0);

                return py::convert(self->obj.ConnectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"ConnectAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.ConnectAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_EnableTransferOwnership(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"EnableTransferOwnership", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.EnableTransferOwnership(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"EnableTransferOwnership", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityConnectedStandbyAction>(args, 1);

                self->obj.EnableTransferOwnership(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_GetEndpointPairsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"GetEndpointPairsAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Networking::Sockets::DatagramSocket::GetEndpointPairsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"GetEndpointPairsAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::HostNameSortOptions>(args, 2);

                return py::convert(winrt::Windows::Networking::Sockets::DatagramSocket::GetEndpointPairsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_GetOutputStreamAsync(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"GetOutputStreamAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::EndpointPair>(args, 0);

                return py::convert(self->obj.GetOutputStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"GetOutputStreamAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetOutputStreamAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_JoinMulticastGroup(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"JoinMulticastGroup", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);

                self->obj.JoinMulticastGroup(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_TransferOwnership(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"TransferOwnership", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.TransferOwnership(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"TransferOwnership", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityContext>(args, 1);

                self->obj.TransferOwnership(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"TransferOwnership", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityContext>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);

                self->obj.TransferOwnership(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_get_Control(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocket", L"Control"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Control());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_get_Information(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocket", L"Information"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocket", L"OutputStream"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_add_MessageReceived(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.DatagramSocket", L"MessageReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::DatagramSocket, winrt::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs>>(arg);

            return py::convert(self->obj.MessageReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_remove_MessageReceived(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.DatagramSocket", L"MessageReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MessageReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DatagramSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::DatagramSocket>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DatagramSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::DatagramSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_DatagramSocket(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_DatagramSocket(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DatagramSocket[] = {
        { "bind_endpoint_async", reinterpret_cast<PyCFunction>(DatagramSocket_BindEndpointAsync), METH_VARARGS, nullptr },
        { "bind_service_name_async", reinterpret_cast<PyCFunction>(DatagramSocket_BindServiceNameAsync), METH_VARARGS, nullptr },
        { "cancel_i_o_async", reinterpret_cast<PyCFunction>(DatagramSocket_CancelIOAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(DatagramSocket_Close), METH_VARARGS, nullptr },
        { "connect_async", reinterpret_cast<PyCFunction>(DatagramSocket_ConnectAsync), METH_VARARGS, nullptr },
        { "enable_transfer_ownership", reinterpret_cast<PyCFunction>(DatagramSocket_EnableTransferOwnership), METH_VARARGS, nullptr },
        { "get_endpoint_pairs_async", reinterpret_cast<PyCFunction>(DatagramSocket_GetEndpointPairsAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_output_stream_async", reinterpret_cast<PyCFunction>(DatagramSocket_GetOutputStreamAsync), METH_VARARGS, nullptr },
        { "join_multicast_group", reinterpret_cast<PyCFunction>(DatagramSocket_JoinMulticastGroup), METH_VARARGS, nullptr },
        { "transfer_ownership", reinterpret_cast<PyCFunction>(DatagramSocket_TransferOwnership), METH_VARARGS, nullptr },
        { "add_message_received", reinterpret_cast<PyCFunction>(DatagramSocket_add_MessageReceived), METH_O, nullptr },
        { "remove_message_received", reinterpret_cast<PyCFunction>(DatagramSocket_remove_MessageReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_DatagramSocket, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DatagramSocket), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_DatagramSocket), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_DatagramSocket), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_DatagramSocket[] = {
        { "control", reinterpret_cast<getter>(DatagramSocket_get_Control), nullptr, nullptr, nullptr },
        { "information", reinterpret_cast<getter>(DatagramSocket_get_Information), nullptr, nullptr, nullptr },
        { "output_stream", reinterpret_cast<getter>(DatagramSocket_get_OutputStream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DatagramSocket[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DatagramSocket) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DatagramSocket) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DatagramSocket) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DatagramSocket) },
        { },
    };

    static PyType_Spec type_spec_DatagramSocket =
    {
        "_winsdk_Windows_Networking_Sockets.DatagramSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::DatagramSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DatagramSocket
    };

    // ----- DatagramSocketControl class --------------------
    static constexpr const char* const type_name_DatagramSocketControl = "DatagramSocketControl";

    static PyObject* _new_DatagramSocketControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DatagramSocketControl);
        return nullptr;
    }

    static void _dealloc_DatagramSocketControl(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DatagramSocketControl_get_QualityOfService(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketControl", L"QualityOfService"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QualityOfService());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatagramSocketControl_put_QualityOfService(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketControl", L"QualityOfService"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketQualityOfService>(arg);

            self->obj.QualityOfService(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatagramSocketControl_get_OutboundUnicastHopLimit(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketControl", L"OutboundUnicastHopLimit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutboundUnicastHopLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatagramSocketControl_put_OutboundUnicastHopLimit(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketControl", L"OutboundUnicastHopLimit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.OutboundUnicastHopLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatagramSocketControl_get_InboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketControl", L"InboundBufferSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatagramSocketControl_put_InboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketControl", L"InboundBufferSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.InboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatagramSocketControl_get_DontFragment(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketControl", L"DontFragment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DontFragment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatagramSocketControl_put_DontFragment(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketControl", L"DontFragment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DontFragment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatagramSocketControl_get_MulticastOnly(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketControl", L"MulticastOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MulticastOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatagramSocketControl_put_MulticastOnly(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketControl", L"MulticastOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.MulticastOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DatagramSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::DatagramSocketControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DatagramSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::DatagramSocketControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DatagramSocketControl[] = {
        { "_assign_array_", _assign_array_DatagramSocketControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DatagramSocketControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DatagramSocketControl[] = {
        { "quality_of_service", reinterpret_cast<getter>(DatagramSocketControl_get_QualityOfService), reinterpret_cast<setter>(DatagramSocketControl_put_QualityOfService), nullptr, nullptr },
        { "outbound_unicast_hop_limit", reinterpret_cast<getter>(DatagramSocketControl_get_OutboundUnicastHopLimit), reinterpret_cast<setter>(DatagramSocketControl_put_OutboundUnicastHopLimit), nullptr, nullptr },
        { "inbound_buffer_size_in_bytes", reinterpret_cast<getter>(DatagramSocketControl_get_InboundBufferSizeInBytes), reinterpret_cast<setter>(DatagramSocketControl_put_InboundBufferSizeInBytes), nullptr, nullptr },
        { "dont_fragment", reinterpret_cast<getter>(DatagramSocketControl_get_DontFragment), reinterpret_cast<setter>(DatagramSocketControl_put_DontFragment), nullptr, nullptr },
        { "multicast_only", reinterpret_cast<getter>(DatagramSocketControl_get_MulticastOnly), reinterpret_cast<setter>(DatagramSocketControl_put_MulticastOnly), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DatagramSocketControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DatagramSocketControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DatagramSocketControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DatagramSocketControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DatagramSocketControl) },
        { },
    };

    static PyType_Spec type_spec_DatagramSocketControl =
    {
        "_winsdk_Windows_Networking_Sockets.DatagramSocketControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DatagramSocketControl
    };

    // ----- DatagramSocketInformation class --------------------
    static constexpr const char* const type_name_DatagramSocketInformation = "DatagramSocketInformation";

    static PyObject* _new_DatagramSocketInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DatagramSocketInformation);
        return nullptr;
    }

    static void _dealloc_DatagramSocketInformation(py::wrapper::Windows::Networking::Sockets::DatagramSocketInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DatagramSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::DatagramSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketInformation", L"LocalAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocketInformation_get_LocalPort(py::wrapper::Windows::Networking::Sockets::DatagramSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketInformation", L"LocalPort"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocalPort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocketInformation_get_RemoteAddress(py::wrapper::Windows::Networking::Sockets::DatagramSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketInformation", L"RemoteAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocketInformation_get_RemotePort(py::wrapper::Windows::Networking::Sockets::DatagramSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketInformation", L"RemotePort"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemotePort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DatagramSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::DatagramSocketInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DatagramSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::DatagramSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DatagramSocketInformation[] = {
        { "_assign_array_", _assign_array_DatagramSocketInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DatagramSocketInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DatagramSocketInformation[] = {
        { "local_address", reinterpret_cast<getter>(DatagramSocketInformation_get_LocalAddress), nullptr, nullptr, nullptr },
        { "local_port", reinterpret_cast<getter>(DatagramSocketInformation_get_LocalPort), nullptr, nullptr, nullptr },
        { "remote_address", reinterpret_cast<getter>(DatagramSocketInformation_get_RemoteAddress), nullptr, nullptr, nullptr },
        { "remote_port", reinterpret_cast<getter>(DatagramSocketInformation_get_RemotePort), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DatagramSocketInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DatagramSocketInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DatagramSocketInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DatagramSocketInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DatagramSocketInformation) },
        { },
    };

    static PyType_Spec type_spec_DatagramSocketInformation =
    {
        "_winsdk_Windows_Networking_Sockets.DatagramSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::DatagramSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DatagramSocketInformation
    };

    // ----- DatagramSocketMessageReceivedEventArgs class --------------------
    static constexpr const char* const type_name_DatagramSocketMessageReceivedEventArgs = "DatagramSocketMessageReceivedEventArgs";

    static PyObject* _new_DatagramSocketMessageReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DatagramSocketMessageReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_DatagramSocketMessageReceivedEventArgs(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DatagramSocketMessageReceivedEventArgs_GetDataReader(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs", L"GetDataReader", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDataReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocketMessageReceivedEventArgs_GetDataStream(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs", L"GetDataStream", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDataStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocketMessageReceivedEventArgs_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs", L"LocalAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocketMessageReceivedEventArgs_get_RemoteAddress(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs", L"RemoteAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocketMessageReceivedEventArgs_get_RemotePort(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs", L"RemotePort"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemotePort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DatagramSocketMessageReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DatagramSocketMessageReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DatagramSocketMessageReceivedEventArgs[] = {
        { "get_data_reader", reinterpret_cast<PyCFunction>(DatagramSocketMessageReceivedEventArgs_GetDataReader), METH_VARARGS, nullptr },
        { "get_data_stream", reinterpret_cast<PyCFunction>(DatagramSocketMessageReceivedEventArgs_GetDataStream), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DatagramSocketMessageReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DatagramSocketMessageReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DatagramSocketMessageReceivedEventArgs[] = {
        { "local_address", reinterpret_cast<getter>(DatagramSocketMessageReceivedEventArgs_get_LocalAddress), nullptr, nullptr, nullptr },
        { "remote_address", reinterpret_cast<getter>(DatagramSocketMessageReceivedEventArgs_get_RemoteAddress), nullptr, nullptr, nullptr },
        { "remote_port", reinterpret_cast<getter>(DatagramSocketMessageReceivedEventArgs_get_RemotePort), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DatagramSocketMessageReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DatagramSocketMessageReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DatagramSocketMessageReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DatagramSocketMessageReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DatagramSocketMessageReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DatagramSocketMessageReceivedEventArgs =
    {
        "_winsdk_Windows_Networking_Sockets.DatagramSocketMessageReceivedEventArgs",
        sizeof(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DatagramSocketMessageReceivedEventArgs
    };

    // ----- MessageWebSocket class --------------------
    static constexpr const char* const type_name_MessageWebSocket = "MessageWebSocket";

    static PyObject* _new_MessageWebSocket(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Sockets::MessageWebSocket instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MessageWebSocket(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MessageWebSocket_Close(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"Close", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Close(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_ConnectAsync(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"ConnectAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.ConnectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_SendFinalFrameAsync(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"SendFinalFrameAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.SendFinalFrameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_SendNonfinalFrameAsync(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"SendNonfinalFrameAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.SendNonfinalFrameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_SetRequestHeader(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"SetRequestHeader", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_get_Control(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"Control"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Control());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_get_Information(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"Information"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"OutputStream"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_add_MessageReceived(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"MessageReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::MessageWebSocket, winrt::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs>>(arg);

            return py::convert(self->obj.MessageReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_remove_MessageReceived(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"MessageReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MessageReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_add_Closed(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::IWebSocket, winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_remove_Closed(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_add_ServerCustomValidationRequested(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"ServerCustomValidationRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::MessageWebSocket, winrt::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs>>(arg);

            return py::convert(self->obj.ServerCustomValidationRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_remove_ServerCustomValidationRequested(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"ServerCustomValidationRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ServerCustomValidationRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MessageWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::MessageWebSocket>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MessageWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::MessageWebSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MessageWebSocket(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_MessageWebSocket(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MessageWebSocket[] = {
        { "close", reinterpret_cast<PyCFunction>(MessageWebSocket_Close), METH_VARARGS, nullptr },
        { "connect_async", reinterpret_cast<PyCFunction>(MessageWebSocket_ConnectAsync), METH_VARARGS, nullptr },
        { "send_final_frame_async", reinterpret_cast<PyCFunction>(MessageWebSocket_SendFinalFrameAsync), METH_VARARGS, nullptr },
        { "send_nonfinal_frame_async", reinterpret_cast<PyCFunction>(MessageWebSocket_SendNonfinalFrameAsync), METH_VARARGS, nullptr },
        { "set_request_header", reinterpret_cast<PyCFunction>(MessageWebSocket_SetRequestHeader), METH_VARARGS, nullptr },
        { "add_message_received", reinterpret_cast<PyCFunction>(MessageWebSocket_add_MessageReceived), METH_O, nullptr },
        { "remove_message_received", reinterpret_cast<PyCFunction>(MessageWebSocket_remove_MessageReceived), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(MessageWebSocket_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(MessageWebSocket_remove_Closed), METH_O, nullptr },
        { "add_server_custom_validation_requested", reinterpret_cast<PyCFunction>(MessageWebSocket_add_ServerCustomValidationRequested), METH_O, nullptr },
        { "remove_server_custom_validation_requested", reinterpret_cast<PyCFunction>(MessageWebSocket_remove_ServerCustomValidationRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_MessageWebSocket, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MessageWebSocket), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MessageWebSocket), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MessageWebSocket), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MessageWebSocket[] = {
        { "control", reinterpret_cast<getter>(MessageWebSocket_get_Control), nullptr, nullptr, nullptr },
        { "information", reinterpret_cast<getter>(MessageWebSocket_get_Information), nullptr, nullptr, nullptr },
        { "output_stream", reinterpret_cast<getter>(MessageWebSocket_get_OutputStream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MessageWebSocket[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MessageWebSocket) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MessageWebSocket) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MessageWebSocket) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MessageWebSocket) },
        { },
    };

    static PyType_Spec type_spec_MessageWebSocket =
    {
        "_winsdk_Windows_Networking_Sockets.MessageWebSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::MessageWebSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MessageWebSocket
    };

    // ----- MessageWebSocketControl class --------------------
    static constexpr const char* const type_name_MessageWebSocketControl = "MessageWebSocketControl";

    static PyObject* _new_MessageWebSocketControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MessageWebSocketControl);
        return nullptr;
    }

    static void _dealloc_MessageWebSocketControl(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MessageWebSocketControl_get_MessageType(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"MessageType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_MessageType(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"MessageType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketMessageType>(arg);

            self->obj.MessageType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_MaxMessageSize(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"MaxMessageSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxMessageSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_MaxMessageSize(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"MaxMessageSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.MaxMessageSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_ReceiveMode(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"ReceiveMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReceiveMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_ReceiveMode(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"ReceiveMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::MessageWebSocketReceiveMode>(arg);

            self->obj.ReceiveMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_DesiredUnsolicitedPongInterval(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"DesiredUnsolicitedPongInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredUnsolicitedPongInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_DesiredUnsolicitedPongInterval(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"DesiredUnsolicitedPongInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DesiredUnsolicitedPongInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_ClientCertificate(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"ClientCertificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ClientCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_ClientCertificate(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"ClientCertificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(arg);

            self->obj.ClientCertificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_ActualUnsolicitedPongInterval(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"ActualUnsolicitedPongInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActualUnsolicitedPongInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketControl_get_ServerCredential(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"ServerCredential"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_ServerCredential(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"ServerCredential"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_ProxyCredential(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"ProxyCredential"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_ProxyCredential(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"ProxyCredential"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"OutboundBufferSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"OutboundBufferSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.OutboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_SupportedProtocols(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"SupportedProtocols"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedProtocols());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketControl_get_IgnorableServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"IgnorableServerCertificateErrors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IgnorableServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MessageWebSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::MessageWebSocketControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MessageWebSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::MessageWebSocketControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MessageWebSocketControl[] = {
        { "_assign_array_", _assign_array_MessageWebSocketControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MessageWebSocketControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MessageWebSocketControl[] = {
        { "message_type", reinterpret_cast<getter>(MessageWebSocketControl_get_MessageType), reinterpret_cast<setter>(MessageWebSocketControl_put_MessageType), nullptr, nullptr },
        { "max_message_size", reinterpret_cast<getter>(MessageWebSocketControl_get_MaxMessageSize), reinterpret_cast<setter>(MessageWebSocketControl_put_MaxMessageSize), nullptr, nullptr },
        { "receive_mode", reinterpret_cast<getter>(MessageWebSocketControl_get_ReceiveMode), reinterpret_cast<setter>(MessageWebSocketControl_put_ReceiveMode), nullptr, nullptr },
        { "desired_unsolicited_pong_interval", reinterpret_cast<getter>(MessageWebSocketControl_get_DesiredUnsolicitedPongInterval), reinterpret_cast<setter>(MessageWebSocketControl_put_DesiredUnsolicitedPongInterval), nullptr, nullptr },
        { "client_certificate", reinterpret_cast<getter>(MessageWebSocketControl_get_ClientCertificate), reinterpret_cast<setter>(MessageWebSocketControl_put_ClientCertificate), nullptr, nullptr },
        { "actual_unsolicited_pong_interval", reinterpret_cast<getter>(MessageWebSocketControl_get_ActualUnsolicitedPongInterval), nullptr, nullptr, nullptr },
        { "server_credential", reinterpret_cast<getter>(MessageWebSocketControl_get_ServerCredential), reinterpret_cast<setter>(MessageWebSocketControl_put_ServerCredential), nullptr, nullptr },
        { "proxy_credential", reinterpret_cast<getter>(MessageWebSocketControl_get_ProxyCredential), reinterpret_cast<setter>(MessageWebSocketControl_put_ProxyCredential), nullptr, nullptr },
        { "outbound_buffer_size_in_bytes", reinterpret_cast<getter>(MessageWebSocketControl_get_OutboundBufferSizeInBytes), reinterpret_cast<setter>(MessageWebSocketControl_put_OutboundBufferSizeInBytes), nullptr, nullptr },
        { "supported_protocols", reinterpret_cast<getter>(MessageWebSocketControl_get_SupportedProtocols), nullptr, nullptr, nullptr },
        { "ignorable_server_certificate_errors", reinterpret_cast<getter>(MessageWebSocketControl_get_IgnorableServerCertificateErrors), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MessageWebSocketControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MessageWebSocketControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MessageWebSocketControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MessageWebSocketControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MessageWebSocketControl) },
        { },
    };

    static PyType_Spec type_spec_MessageWebSocketControl =
    {
        "_winsdk_Windows_Networking_Sockets.MessageWebSocketControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MessageWebSocketControl
    };

    // ----- MessageWebSocketInformation class --------------------
    static constexpr const char* const type_name_MessageWebSocketInformation = "MessageWebSocketInformation";

    static PyObject* _new_MessageWebSocketInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MessageWebSocketInformation);
        return nullptr;
    }

    static void _dealloc_MessageWebSocketInformation(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MessageWebSocketInformation_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketInformation", L"BandwidthStatistics"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketInformation", L"LocalAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketInformation_get_Protocol(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketInformation", L"Protocol"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Protocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketInformation_get_ServerCertificate(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketInformation", L"ServerCertificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketInformation_get_ServerCertificateErrorSeverity(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketInformation", L"ServerCertificateErrorSeverity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerCertificateErrorSeverity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketInformation_get_ServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketInformation", L"ServerCertificateErrors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketInformation_get_ServerIntermediateCertificates(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketInformation", L"ServerIntermediateCertificates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerIntermediateCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MessageWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::MessageWebSocketInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MessageWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::MessageWebSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MessageWebSocketInformation[] = {
        { "_assign_array_", _assign_array_MessageWebSocketInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MessageWebSocketInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MessageWebSocketInformation[] = {
        { "bandwidth_statistics", reinterpret_cast<getter>(MessageWebSocketInformation_get_BandwidthStatistics), nullptr, nullptr, nullptr },
        { "local_address", reinterpret_cast<getter>(MessageWebSocketInformation_get_LocalAddress), nullptr, nullptr, nullptr },
        { "protocol", reinterpret_cast<getter>(MessageWebSocketInformation_get_Protocol), nullptr, nullptr, nullptr },
        { "server_certificate", reinterpret_cast<getter>(MessageWebSocketInformation_get_ServerCertificate), nullptr, nullptr, nullptr },
        { "server_certificate_error_severity", reinterpret_cast<getter>(MessageWebSocketInformation_get_ServerCertificateErrorSeverity), nullptr, nullptr, nullptr },
        { "server_certificate_errors", reinterpret_cast<getter>(MessageWebSocketInformation_get_ServerCertificateErrors), nullptr, nullptr, nullptr },
        { "server_intermediate_certificates", reinterpret_cast<getter>(MessageWebSocketInformation_get_ServerIntermediateCertificates), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MessageWebSocketInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MessageWebSocketInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MessageWebSocketInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MessageWebSocketInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MessageWebSocketInformation) },
        { },
    };

    static PyType_Spec type_spec_MessageWebSocketInformation =
    {
        "_winsdk_Windows_Networking_Sockets.MessageWebSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MessageWebSocketInformation
    };

    // ----- MessageWebSocketMessageReceivedEventArgs class --------------------
    static constexpr const char* const type_name_MessageWebSocketMessageReceivedEventArgs = "MessageWebSocketMessageReceivedEventArgs";

    static PyObject* _new_MessageWebSocketMessageReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MessageWebSocketMessageReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_MessageWebSocketMessageReceivedEventArgs(py::wrapper::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MessageWebSocketMessageReceivedEventArgs_GetDataReader(py::wrapper::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs", L"GetDataReader", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDataReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketMessageReceivedEventArgs_GetDataStream(py::wrapper::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs", L"GetDataStream", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDataStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketMessageReceivedEventArgs_get_MessageType(py::wrapper::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs", L"MessageType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketMessageReceivedEventArgs_get_IsMessageComplete(py::wrapper::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs", L"IsMessageComplete"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsMessageComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MessageWebSocketMessageReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MessageWebSocketMessageReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MessageWebSocketMessageReceivedEventArgs[] = {
        { "get_data_reader", reinterpret_cast<PyCFunction>(MessageWebSocketMessageReceivedEventArgs_GetDataReader), METH_VARARGS, nullptr },
        { "get_data_stream", reinterpret_cast<PyCFunction>(MessageWebSocketMessageReceivedEventArgs_GetDataStream), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MessageWebSocketMessageReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MessageWebSocketMessageReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MessageWebSocketMessageReceivedEventArgs[] = {
        { "message_type", reinterpret_cast<getter>(MessageWebSocketMessageReceivedEventArgs_get_MessageType), nullptr, nullptr, nullptr },
        { "is_message_complete", reinterpret_cast<getter>(MessageWebSocketMessageReceivedEventArgs_get_IsMessageComplete), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MessageWebSocketMessageReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MessageWebSocketMessageReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MessageWebSocketMessageReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MessageWebSocketMessageReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MessageWebSocketMessageReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MessageWebSocketMessageReceivedEventArgs =
    {
        "_winsdk_Windows_Networking_Sockets.MessageWebSocketMessageReceivedEventArgs",
        sizeof(py::wrapper::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MessageWebSocketMessageReceivedEventArgs
    };

    // ----- ServerMessageWebSocket class --------------------
    static constexpr const char* const type_name_ServerMessageWebSocket = "ServerMessageWebSocket";

    static PyObject* _new_ServerMessageWebSocket(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ServerMessageWebSocket);
        return nullptr;
    }

    static void _dealloc_ServerMessageWebSocket(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ServerMessageWebSocket_Close(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.ServerMessageWebSocket", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.ServerMessageWebSocket", L"Close", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Close(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_get_Control(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerMessageWebSocket", L"Control"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Control());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_get_Information(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerMessageWebSocket", L"Information"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerMessageWebSocket", L"OutputStream"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_add_Closed(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.ServerMessageWebSocket", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::ServerMessageWebSocket, winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_remove_Closed(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.ServerMessageWebSocket", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_add_MessageReceived(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.ServerMessageWebSocket", L"MessageReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::ServerMessageWebSocket, winrt::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs>>(arg);

            return py::convert(self->obj.MessageReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_remove_MessageReceived(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.ServerMessageWebSocket", L"MessageReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MessageReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ServerMessageWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::ServerMessageWebSocket>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ServerMessageWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::ServerMessageWebSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ServerMessageWebSocket(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ServerMessageWebSocket(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ServerMessageWebSocket[] = {
        { "close", reinterpret_cast<PyCFunction>(ServerMessageWebSocket_Close), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(ServerMessageWebSocket_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(ServerMessageWebSocket_remove_Closed), METH_O, nullptr },
        { "add_message_received", reinterpret_cast<PyCFunction>(ServerMessageWebSocket_add_MessageReceived), METH_O, nullptr },
        { "remove_message_received", reinterpret_cast<PyCFunction>(ServerMessageWebSocket_remove_MessageReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_ServerMessageWebSocket, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ServerMessageWebSocket), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ServerMessageWebSocket), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ServerMessageWebSocket), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ServerMessageWebSocket[] = {
        { "control", reinterpret_cast<getter>(ServerMessageWebSocket_get_Control), nullptr, nullptr, nullptr },
        { "information", reinterpret_cast<getter>(ServerMessageWebSocket_get_Information), nullptr, nullptr, nullptr },
        { "output_stream", reinterpret_cast<getter>(ServerMessageWebSocket_get_OutputStream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ServerMessageWebSocket[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ServerMessageWebSocket) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ServerMessageWebSocket) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ServerMessageWebSocket) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ServerMessageWebSocket) },
        { },
    };

    static PyType_Spec type_spec_ServerMessageWebSocket =
    {
        "_winsdk_Windows_Networking_Sockets.ServerMessageWebSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ServerMessageWebSocket
    };

    // ----- ServerMessageWebSocketControl class --------------------
    static constexpr const char* const type_name_ServerMessageWebSocketControl = "ServerMessageWebSocketControl";

    static PyObject* _new_ServerMessageWebSocketControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ServerMessageWebSocketControl);
        return nullptr;
    }

    static void _dealloc_ServerMessageWebSocketControl(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketControl* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ServerMessageWebSocketControl_get_MessageType(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerMessageWebSocketControl", L"MessageType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ServerMessageWebSocketControl_put_MessageType(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerMessageWebSocketControl", L"MessageType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketMessageType>(arg);

            self->obj.MessageType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ServerMessageWebSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::ServerMessageWebSocketControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ServerMessageWebSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::ServerMessageWebSocketControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ServerMessageWebSocketControl[] = {
        { "_assign_array_", _assign_array_ServerMessageWebSocketControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ServerMessageWebSocketControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ServerMessageWebSocketControl[] = {
        { "message_type", reinterpret_cast<getter>(ServerMessageWebSocketControl_get_MessageType), reinterpret_cast<setter>(ServerMessageWebSocketControl_put_MessageType), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ServerMessageWebSocketControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ServerMessageWebSocketControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ServerMessageWebSocketControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ServerMessageWebSocketControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ServerMessageWebSocketControl) },
        { },
    };

    static PyType_Spec type_spec_ServerMessageWebSocketControl =
    {
        "_winsdk_Windows_Networking_Sockets.ServerMessageWebSocketControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ServerMessageWebSocketControl
    };

    // ----- ServerMessageWebSocketInformation class --------------------
    static constexpr const char* const type_name_ServerMessageWebSocketInformation = "ServerMessageWebSocketInformation";

    static PyObject* _new_ServerMessageWebSocketInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ServerMessageWebSocketInformation);
        return nullptr;
    }

    static void _dealloc_ServerMessageWebSocketInformation(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ServerMessageWebSocketInformation_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerMessageWebSocketInformation", L"BandwidthStatistics"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerMessageWebSocketInformation", L"LocalAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocketInformation_get_Protocol(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerMessageWebSocketInformation", L"Protocol"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Protocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ServerMessageWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::ServerMessageWebSocketInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ServerMessageWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::ServerMessageWebSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ServerMessageWebSocketInformation[] = {
        { "_assign_array_", _assign_array_ServerMessageWebSocketInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ServerMessageWebSocketInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ServerMessageWebSocketInformation[] = {
        { "bandwidth_statistics", reinterpret_cast<getter>(ServerMessageWebSocketInformation_get_BandwidthStatistics), nullptr, nullptr, nullptr },
        { "local_address", reinterpret_cast<getter>(ServerMessageWebSocketInformation_get_LocalAddress), nullptr, nullptr, nullptr },
        { "protocol", reinterpret_cast<getter>(ServerMessageWebSocketInformation_get_Protocol), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ServerMessageWebSocketInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ServerMessageWebSocketInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ServerMessageWebSocketInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ServerMessageWebSocketInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ServerMessageWebSocketInformation) },
        { },
    };

    static PyType_Spec type_spec_ServerMessageWebSocketInformation =
    {
        "_winsdk_Windows_Networking_Sockets.ServerMessageWebSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ServerMessageWebSocketInformation
    };

    // ----- ServerStreamWebSocket class --------------------
    static constexpr const char* const type_name_ServerStreamWebSocket = "ServerStreamWebSocket";

    static PyObject* _new_ServerStreamWebSocket(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ServerStreamWebSocket);
        return nullptr;
    }

    static void _dealloc_ServerStreamWebSocket(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ServerStreamWebSocket_Close(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.ServerStreamWebSocket", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.ServerStreamWebSocket", L"Close", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Close(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocket_get_Information(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerStreamWebSocket", L"Information"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocket_get_InputStream(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerStreamWebSocket", L"InputStream"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerStreamWebSocket", L"OutputStream"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocket_add_Closed(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.ServerStreamWebSocket", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::ServerStreamWebSocket, winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocket_remove_Closed(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.ServerStreamWebSocket", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ServerStreamWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::ServerStreamWebSocket>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ServerStreamWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::ServerStreamWebSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ServerStreamWebSocket(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ServerStreamWebSocket(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ServerStreamWebSocket[] = {
        { "close", reinterpret_cast<PyCFunction>(ServerStreamWebSocket_Close), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(ServerStreamWebSocket_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(ServerStreamWebSocket_remove_Closed), METH_O, nullptr },
        { "_assign_array_", _assign_array_ServerStreamWebSocket, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ServerStreamWebSocket), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ServerStreamWebSocket), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ServerStreamWebSocket), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ServerStreamWebSocket[] = {
        { "information", reinterpret_cast<getter>(ServerStreamWebSocket_get_Information), nullptr, nullptr, nullptr },
        { "input_stream", reinterpret_cast<getter>(ServerStreamWebSocket_get_InputStream), nullptr, nullptr, nullptr },
        { "output_stream", reinterpret_cast<getter>(ServerStreamWebSocket_get_OutputStream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ServerStreamWebSocket[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ServerStreamWebSocket) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ServerStreamWebSocket) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ServerStreamWebSocket) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ServerStreamWebSocket) },
        { },
    };

    static PyType_Spec type_spec_ServerStreamWebSocket =
    {
        "_winsdk_Windows_Networking_Sockets.ServerStreamWebSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ServerStreamWebSocket
    };

    // ----- ServerStreamWebSocketInformation class --------------------
    static constexpr const char* const type_name_ServerStreamWebSocketInformation = "ServerStreamWebSocketInformation";

    static PyObject* _new_ServerStreamWebSocketInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ServerStreamWebSocketInformation);
        return nullptr;
    }

    static void _dealloc_ServerStreamWebSocketInformation(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocketInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ServerStreamWebSocketInformation_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerStreamWebSocketInformation", L"BandwidthStatistics"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerStreamWebSocketInformation", L"LocalAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocketInformation_get_Protocol(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerStreamWebSocketInformation", L"Protocol"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Protocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ServerStreamWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::ServerStreamWebSocketInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ServerStreamWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::ServerStreamWebSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ServerStreamWebSocketInformation[] = {
        { "_assign_array_", _assign_array_ServerStreamWebSocketInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ServerStreamWebSocketInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ServerStreamWebSocketInformation[] = {
        { "bandwidth_statistics", reinterpret_cast<getter>(ServerStreamWebSocketInformation_get_BandwidthStatistics), nullptr, nullptr, nullptr },
        { "local_address", reinterpret_cast<getter>(ServerStreamWebSocketInformation_get_LocalAddress), nullptr, nullptr, nullptr },
        { "protocol", reinterpret_cast<getter>(ServerStreamWebSocketInformation_get_Protocol), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ServerStreamWebSocketInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ServerStreamWebSocketInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ServerStreamWebSocketInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ServerStreamWebSocketInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ServerStreamWebSocketInformation) },
        { },
    };

    static PyType_Spec type_spec_ServerStreamWebSocketInformation =
    {
        "_winsdk_Windows_Networking_Sockets.ServerStreamWebSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ServerStreamWebSocketInformation
    };

    // ----- SocketActivityContext class --------------------
    static constexpr const char* const type_name_SocketActivityContext = "SocketActivityContext";

    static PyObject* _new_SocketActivityContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                winrt::Windows::Networking::Sockets::SocketActivityContext instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SocketActivityContext(py::wrapper::Windows::Networking::Sockets::SocketActivityContext* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SocketActivityContext_get_Data(py::wrapper::Windows::Networking::Sockets::SocketActivityContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.SocketActivityContext", L"Data"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SocketActivityContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::SocketActivityContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SocketActivityContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::SocketActivityContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SocketActivityContext[] = {
        { "_assign_array_", _assign_array_SocketActivityContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SocketActivityContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SocketActivityContext[] = {
        { "data", reinterpret_cast<getter>(SocketActivityContext_get_Data), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SocketActivityContext[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SocketActivityContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SocketActivityContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SocketActivityContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SocketActivityContext) },
        { },
    };

    static PyType_Spec type_spec_SocketActivityContext =
    {
        "_winsdk_Windows_Networking_Sockets.SocketActivityContext",
        sizeof(py::wrapper::Windows::Networking::Sockets::SocketActivityContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SocketActivityContext
    };

    // ----- SocketActivityInformation class --------------------
    static constexpr const char* const type_name_SocketActivityInformation = "SocketActivityInformation";

    static PyObject* _new_SocketActivityInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SocketActivityInformation);
        return nullptr;
    }

    static void _dealloc_SocketActivityInformation(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SocketActivityInformation_get_Context(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.SocketActivityInformation", L"Context"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Context());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_DatagramSocket(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.SocketActivityInformation", L"DatagramSocket"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DatagramSocket());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_Id(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.SocketActivityInformation", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_SocketKind(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.SocketActivityInformation", L"SocketKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SocketKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_StreamSocket(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.SocketActivityInformation", L"StreamSocket"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StreamSocket());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_StreamSocketListener(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.SocketActivityInformation", L"StreamSocketListener"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StreamSocketListener());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_TaskId(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.SocketActivityInformation", L"TaskId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_AllSockets(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.SocketActivityInformation", L"AllSockets"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::Sockets::SocketActivityInformation::AllSockets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SocketActivityInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::SocketActivityInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SocketActivityInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::SocketActivityInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SocketActivityInformation[] = {
        { "_assign_array_", _assign_array_SocketActivityInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SocketActivityInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SocketActivityInformation[] = {
        { "context", reinterpret_cast<getter>(SocketActivityInformation_get_Context), nullptr, nullptr, nullptr },
        { "datagram_socket", reinterpret_cast<getter>(SocketActivityInformation_get_DatagramSocket), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(SocketActivityInformation_get_Id), nullptr, nullptr, nullptr },
        { "socket_kind", reinterpret_cast<getter>(SocketActivityInformation_get_SocketKind), nullptr, nullptr, nullptr },
        { "stream_socket", reinterpret_cast<getter>(SocketActivityInformation_get_StreamSocket), nullptr, nullptr, nullptr },
        { "stream_socket_listener", reinterpret_cast<getter>(SocketActivityInformation_get_StreamSocketListener), nullptr, nullptr, nullptr },
        { "task_id", reinterpret_cast<getter>(SocketActivityInformation_get_TaskId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SocketActivityInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SocketActivityInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SocketActivityInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SocketActivityInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SocketActivityInformation) },
        { },
    };

    static PyType_Spec type_spec_SocketActivityInformation =
    {
        "_winsdk_Windows_Networking_Sockets.SocketActivityInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SocketActivityInformation
    };

    static PyGetSetDef getset_SocketActivityInformation_Meta[] = {
        { "all_sockets", reinterpret_cast<getter>(SocketActivityInformation_get_AllSockets), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_SocketActivityInformation_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SocketActivityInformation_Meta) },
        { }
    };

    static PyType_Spec type_spec_SocketActivityInformation_Meta =
    {
        "_winsdk_Windows_Networking_Sockets.SocketActivityInformation_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SocketActivityInformation_Meta
    };

    // ----- SocketActivityTriggerDetails class --------------------
    static constexpr const char* const type_name_SocketActivityTriggerDetails = "SocketActivityTriggerDetails";

    static PyObject* _new_SocketActivityTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SocketActivityTriggerDetails);
        return nullptr;
    }

    static void _dealloc_SocketActivityTriggerDetails(py::wrapper::Windows::Networking::Sockets::SocketActivityTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SocketActivityTriggerDetails_get_Reason(py::wrapper::Windows::Networking::Sockets::SocketActivityTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.SocketActivityTriggerDetails", L"Reason"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityTriggerDetails_get_SocketInformation(py::wrapper::Windows::Networking::Sockets::SocketActivityTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.SocketActivityTriggerDetails", L"SocketInformation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SocketInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SocketActivityTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::SocketActivityTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SocketActivityTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::SocketActivityTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SocketActivityTriggerDetails[] = {
        { "_assign_array_", _assign_array_SocketActivityTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SocketActivityTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SocketActivityTriggerDetails[] = {
        { "reason", reinterpret_cast<getter>(SocketActivityTriggerDetails_get_Reason), nullptr, nullptr, nullptr },
        { "socket_information", reinterpret_cast<getter>(SocketActivityTriggerDetails_get_SocketInformation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SocketActivityTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SocketActivityTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SocketActivityTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SocketActivityTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SocketActivityTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_SocketActivityTriggerDetails =
    {
        "_winsdk_Windows_Networking_Sockets.SocketActivityTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::Sockets::SocketActivityTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SocketActivityTriggerDetails
    };

    // ----- SocketError class --------------------
    static constexpr const char* const type_name_SocketError = "SocketError";

    static PyObject* _new_SocketError(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SocketError);
        return nullptr;
    }

    static PyObject* SocketError_GetStatus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.SocketError", L"GetStatus", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(winrt::Windows::Networking::Sockets::SocketError::GetStatus(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_SocketError[] = {
        { "get_status", reinterpret_cast<PyCFunction>(SocketError_GetStatus), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SocketError[] = {
        { }
    };

    static PyType_Slot _type_slots_SocketError[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SocketError) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SocketError) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SocketError) },
        { },
    };

    static PyType_Spec type_spec_SocketError =
    {
        "_winsdk_Windows_Networking_Sockets.SocketError",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SocketError
    };

    // ----- StreamSocket class --------------------
    static constexpr const char* const type_name_StreamSocket = "StreamSocket";

    static PyObject* _new_StreamSocket(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Sockets::StreamSocket instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StreamSocket(py::wrapper::Windows::Networking::Sockets::StreamSocket* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StreamSocket_CancelIOAsync(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"CancelIOAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CancelIOAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_Close(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_ConnectAsync(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"ConnectAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::EndpointPair>(args, 0);

                return py::convert(self->obj.ConnectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"ConnectAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.ConnectAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"ConnectAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Sockets::SocketProtectionLevel>(args, 2);

                return py::convert(self->obj.ConnectAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"ConnectAsync", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Sockets::SocketProtectionLevel>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkAdapter>(args, 3);

                return py::convert(self->obj.ConnectAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_EnableTransferOwnership(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"EnableTransferOwnership", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.EnableTransferOwnership(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"EnableTransferOwnership", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityConnectedStandbyAction>(args, 1);

                self->obj.EnableTransferOwnership(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_GetEndpointPairsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"GetEndpointPairsAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Networking::Sockets::StreamSocket::GetEndpointPairsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"GetEndpointPairsAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::HostNameSortOptions>(args, 2);

                return py::convert(winrt::Windows::Networking::Sockets::StreamSocket::GetEndpointPairsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_TransferOwnership(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"TransferOwnership", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.TransferOwnership(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"TransferOwnership", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityContext>(args, 1);

                self->obj.TransferOwnership(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"TransferOwnership", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityContext>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);

                self->obj.TransferOwnership(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_UpgradeToSslAsync(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"UpgradeToSslAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketProtectionLevel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::HostName>(args, 1);

                return py::convert(self->obj.UpgradeToSslAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_get_Control(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocket", L"Control"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Control());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocket_get_Information(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocket", L"Information"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocket_get_InputStream(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocket", L"InputStream"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocket", L"OutputStream"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StreamSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::StreamSocket>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StreamSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_StreamSocket(py::wrapper::Windows::Networking::Sockets::StreamSocket* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_StreamSocket(py::wrapper::Windows::Networking::Sockets::StreamSocket* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocket[] = {
        { "cancel_i_o_async", reinterpret_cast<PyCFunction>(StreamSocket_CancelIOAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(StreamSocket_Close), METH_VARARGS, nullptr },
        { "connect_async", reinterpret_cast<PyCFunction>(StreamSocket_ConnectAsync), METH_VARARGS, nullptr },
        { "enable_transfer_ownership", reinterpret_cast<PyCFunction>(StreamSocket_EnableTransferOwnership), METH_VARARGS, nullptr },
        { "get_endpoint_pairs_async", reinterpret_cast<PyCFunction>(StreamSocket_GetEndpointPairsAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "transfer_ownership", reinterpret_cast<PyCFunction>(StreamSocket_TransferOwnership), METH_VARARGS, nullptr },
        { "upgrade_to_ssl_async", reinterpret_cast<PyCFunction>(StreamSocket_UpgradeToSslAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StreamSocket, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamSocket), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_StreamSocket), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_StreamSocket), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamSocket[] = {
        { "control", reinterpret_cast<getter>(StreamSocket_get_Control), nullptr, nullptr, nullptr },
        { "information", reinterpret_cast<getter>(StreamSocket_get_Information), nullptr, nullptr, nullptr },
        { "input_stream", reinterpret_cast<getter>(StreamSocket_get_InputStream), nullptr, nullptr, nullptr },
        { "output_stream", reinterpret_cast<getter>(StreamSocket_get_OutputStream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamSocket[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StreamSocket) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StreamSocket) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StreamSocket) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StreamSocket) },
        { },
    };

    static PyType_Spec type_spec_StreamSocket =
    {
        "_winsdk_Windows_Networking_Sockets.StreamSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocket
    };

    // ----- StreamSocketControl class --------------------
    static constexpr const char* const type_name_StreamSocketControl = "StreamSocketControl";

    static PyObject* _new_StreamSocketControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StreamSocketControl);
        return nullptr;
    }

    static void _dealloc_StreamSocketControl(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StreamSocketControl_get_QualityOfService(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"QualityOfService"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QualityOfService());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_QualityOfService(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"QualityOfService"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketQualityOfService>(arg);

            self->obj.QualityOfService(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_OutboundUnicastHopLimit(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"OutboundUnicastHopLimit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutboundUnicastHopLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_OutboundUnicastHopLimit(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"OutboundUnicastHopLimit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.OutboundUnicastHopLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"OutboundBufferSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"OutboundBufferSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.OutboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_NoDelay(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"NoDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NoDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_NoDelay(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"NoDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.NoDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_KeepAlive(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"KeepAlive"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeepAlive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_KeepAlive(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"KeepAlive"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.KeepAlive(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_IgnorableServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"IgnorableServerCertificateErrors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IgnorableServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketControl_get_SerializeConnectionAttempts(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"SerializeConnectionAttempts"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SerializeConnectionAttempts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_SerializeConnectionAttempts(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"SerializeConnectionAttempts"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SerializeConnectionAttempts(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_ClientCertificate(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"ClientCertificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ClientCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_ClientCertificate(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"ClientCertificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(arg);

            self->obj.ClientCertificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_MinProtectionLevel(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"MinProtectionLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_MinProtectionLevel(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"MinProtectionLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketProtectionLevel>(arg);

            self->obj.MinProtectionLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StreamSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::StreamSocketControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StreamSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocketControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocketControl[] = {
        { "_assign_array_", _assign_array_StreamSocketControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamSocketControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamSocketControl[] = {
        { "quality_of_service", reinterpret_cast<getter>(StreamSocketControl_get_QualityOfService), reinterpret_cast<setter>(StreamSocketControl_put_QualityOfService), nullptr, nullptr },
        { "outbound_unicast_hop_limit", reinterpret_cast<getter>(StreamSocketControl_get_OutboundUnicastHopLimit), reinterpret_cast<setter>(StreamSocketControl_put_OutboundUnicastHopLimit), nullptr, nullptr },
        { "outbound_buffer_size_in_bytes", reinterpret_cast<getter>(StreamSocketControl_get_OutboundBufferSizeInBytes), reinterpret_cast<setter>(StreamSocketControl_put_OutboundBufferSizeInBytes), nullptr, nullptr },
        { "no_delay", reinterpret_cast<getter>(StreamSocketControl_get_NoDelay), reinterpret_cast<setter>(StreamSocketControl_put_NoDelay), nullptr, nullptr },
        { "keep_alive", reinterpret_cast<getter>(StreamSocketControl_get_KeepAlive), reinterpret_cast<setter>(StreamSocketControl_put_KeepAlive), nullptr, nullptr },
        { "ignorable_server_certificate_errors", reinterpret_cast<getter>(StreamSocketControl_get_IgnorableServerCertificateErrors), nullptr, nullptr, nullptr },
        { "serialize_connection_attempts", reinterpret_cast<getter>(StreamSocketControl_get_SerializeConnectionAttempts), reinterpret_cast<setter>(StreamSocketControl_put_SerializeConnectionAttempts), nullptr, nullptr },
        { "client_certificate", reinterpret_cast<getter>(StreamSocketControl_get_ClientCertificate), reinterpret_cast<setter>(StreamSocketControl_put_ClientCertificate), nullptr, nullptr },
        { "min_protection_level", reinterpret_cast<getter>(StreamSocketControl_get_MinProtectionLevel), reinterpret_cast<setter>(StreamSocketControl_put_MinProtectionLevel), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamSocketControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StreamSocketControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StreamSocketControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StreamSocketControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StreamSocketControl) },
        { },
    };

    static PyType_Spec type_spec_StreamSocketControl =
    {
        "_winsdk_Windows_Networking_Sockets.StreamSocketControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocketControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocketControl
    };

    // ----- StreamSocketInformation class --------------------
    static constexpr const char* const type_name_StreamSocketInformation = "StreamSocketInformation";

    static PyObject* _new_StreamSocketInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StreamSocketInformation);
        return nullptr;
    }

    static void _dealloc_StreamSocketInformation(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StreamSocketInformation_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"BandwidthStatistics"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"LocalAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_LocalPort(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"LocalPort"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocalPort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_ProtectionLevel(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"ProtectionLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_RemoteAddress(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"RemoteAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_RemoteHostName(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"RemoteHostName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteHostName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_RemotePort(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"RemotePort"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemotePort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_RemoteServiceName(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"RemoteServiceName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteServiceName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_RoundTripTimeStatistics(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"RoundTripTimeStatistics"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RoundTripTimeStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_SessionKey(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"SessionKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SessionKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_ServerCertificate(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"ServerCertificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_ServerCertificateErrorSeverity(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"ServerCertificateErrorSeverity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerCertificateErrorSeverity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_ServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"ServerCertificateErrors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_ServerIntermediateCertificates(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"ServerIntermediateCertificates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerIntermediateCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StreamSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::StreamSocketInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StreamSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocketInformation[] = {
        { "_assign_array_", _assign_array_StreamSocketInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamSocketInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamSocketInformation[] = {
        { "bandwidth_statistics", reinterpret_cast<getter>(StreamSocketInformation_get_BandwidthStatistics), nullptr, nullptr, nullptr },
        { "local_address", reinterpret_cast<getter>(StreamSocketInformation_get_LocalAddress), nullptr, nullptr, nullptr },
        { "local_port", reinterpret_cast<getter>(StreamSocketInformation_get_LocalPort), nullptr, nullptr, nullptr },
        { "protection_level", reinterpret_cast<getter>(StreamSocketInformation_get_ProtectionLevel), nullptr, nullptr, nullptr },
        { "remote_address", reinterpret_cast<getter>(StreamSocketInformation_get_RemoteAddress), nullptr, nullptr, nullptr },
        { "remote_host_name", reinterpret_cast<getter>(StreamSocketInformation_get_RemoteHostName), nullptr, nullptr, nullptr },
        { "remote_port", reinterpret_cast<getter>(StreamSocketInformation_get_RemotePort), nullptr, nullptr, nullptr },
        { "remote_service_name", reinterpret_cast<getter>(StreamSocketInformation_get_RemoteServiceName), nullptr, nullptr, nullptr },
        { "round_trip_time_statistics", reinterpret_cast<getter>(StreamSocketInformation_get_RoundTripTimeStatistics), nullptr, nullptr, nullptr },
        { "session_key", reinterpret_cast<getter>(StreamSocketInformation_get_SessionKey), nullptr, nullptr, nullptr },
        { "server_certificate", reinterpret_cast<getter>(StreamSocketInformation_get_ServerCertificate), nullptr, nullptr, nullptr },
        { "server_certificate_error_severity", reinterpret_cast<getter>(StreamSocketInformation_get_ServerCertificateErrorSeverity), nullptr, nullptr, nullptr },
        { "server_certificate_errors", reinterpret_cast<getter>(StreamSocketInformation_get_ServerCertificateErrors), nullptr, nullptr, nullptr },
        { "server_intermediate_certificates", reinterpret_cast<getter>(StreamSocketInformation_get_ServerIntermediateCertificates), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamSocketInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StreamSocketInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StreamSocketInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StreamSocketInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StreamSocketInformation) },
        { },
    };

    static PyType_Spec type_spec_StreamSocketInformation =
    {
        "_winsdk_Windows_Networking_Sockets.StreamSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocketInformation
    };

    // ----- StreamSocketListener class --------------------
    static constexpr const char* const type_name_StreamSocketListener = "StreamSocketListener";

    static PyObject* _new_StreamSocketListener(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Sockets::StreamSocketListener instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StreamSocketListener(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StreamSocketListener_BindEndpointAsync(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"BindEndpointAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.BindEndpointAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_BindServiceNameAsync(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"BindServiceNameAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.BindServiceNameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"BindServiceNameAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketProtectionLevel>(args, 1);

                return py::convert(self->obj.BindServiceNameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"BindServiceNameAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketProtectionLevel>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkAdapter>(args, 2);

                return py::convert(self->obj.BindServiceNameAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_CancelIOAsync(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"CancelIOAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CancelIOAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_Close(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_EnableTransferOwnership(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"EnableTransferOwnership", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.EnableTransferOwnership(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"EnableTransferOwnership", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityConnectedStandbyAction>(args, 1);

                self->obj.EnableTransferOwnership(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_TransferOwnership(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"TransferOwnership", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.TransferOwnership(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"TransferOwnership", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityContext>(args, 1);

                self->obj.TransferOwnership(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_get_Control(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"Control"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Control());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_get_Information(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"Information"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_add_ConnectionReceived(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"ConnectionReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::StreamSocketListener, winrt::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs>>(arg);

            return py::convert(self->obj.ConnectionReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_remove_ConnectionReceived(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"ConnectionReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ConnectionReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StreamSocketListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::StreamSocketListener>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StreamSocketListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocketListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_StreamSocketListener(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_StreamSocketListener(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocketListener[] = {
        { "bind_endpoint_async", reinterpret_cast<PyCFunction>(StreamSocketListener_BindEndpointAsync), METH_VARARGS, nullptr },
        { "bind_service_name_async", reinterpret_cast<PyCFunction>(StreamSocketListener_BindServiceNameAsync), METH_VARARGS, nullptr },
        { "cancel_i_o_async", reinterpret_cast<PyCFunction>(StreamSocketListener_CancelIOAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(StreamSocketListener_Close), METH_VARARGS, nullptr },
        { "enable_transfer_ownership", reinterpret_cast<PyCFunction>(StreamSocketListener_EnableTransferOwnership), METH_VARARGS, nullptr },
        { "transfer_ownership", reinterpret_cast<PyCFunction>(StreamSocketListener_TransferOwnership), METH_VARARGS, nullptr },
        { "add_connection_received", reinterpret_cast<PyCFunction>(StreamSocketListener_add_ConnectionReceived), METH_O, nullptr },
        { "remove_connection_received", reinterpret_cast<PyCFunction>(StreamSocketListener_remove_ConnectionReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_StreamSocketListener, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamSocketListener), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_StreamSocketListener), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_StreamSocketListener), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamSocketListener[] = {
        { "control", reinterpret_cast<getter>(StreamSocketListener_get_Control), nullptr, nullptr, nullptr },
        { "information", reinterpret_cast<getter>(StreamSocketListener_get_Information), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamSocketListener[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StreamSocketListener) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StreamSocketListener) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StreamSocketListener) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StreamSocketListener) },
        { },
    };

    static PyType_Spec type_spec_StreamSocketListener =
    {
        "_winsdk_Windows_Networking_Sockets.StreamSocketListener",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocketListener),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocketListener
    };

    // ----- StreamSocketListenerConnectionReceivedEventArgs class --------------------
    static constexpr const char* const type_name_StreamSocketListenerConnectionReceivedEventArgs = "StreamSocketListenerConnectionReceivedEventArgs";

    static PyObject* _new_StreamSocketListenerConnectionReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StreamSocketListenerConnectionReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_StreamSocketListenerConnectionReceivedEventArgs(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StreamSocketListenerConnectionReceivedEventArgs_get_Socket(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListenerConnectionReceivedEventArgs", L"Socket"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Socket());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StreamSocketListenerConnectionReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StreamSocketListenerConnectionReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocketListenerConnectionReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_StreamSocketListenerConnectionReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamSocketListenerConnectionReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamSocketListenerConnectionReceivedEventArgs[] = {
        { "socket", reinterpret_cast<getter>(StreamSocketListenerConnectionReceivedEventArgs_get_Socket), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamSocketListenerConnectionReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StreamSocketListenerConnectionReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StreamSocketListenerConnectionReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StreamSocketListenerConnectionReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StreamSocketListenerConnectionReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_StreamSocketListenerConnectionReceivedEventArgs =
    {
        "_winsdk_Windows_Networking_Sockets.StreamSocketListenerConnectionReceivedEventArgs",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocketListenerConnectionReceivedEventArgs
    };

    // ----- StreamSocketListenerControl class --------------------
    static constexpr const char* const type_name_StreamSocketListenerControl = "StreamSocketListenerControl";

    static PyObject* _new_StreamSocketListenerControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StreamSocketListenerControl);
        return nullptr;
    }

    static void _dealloc_StreamSocketListenerControl(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StreamSocketListenerControl_get_QualityOfService(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListenerControl", L"QualityOfService"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QualityOfService());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketListenerControl_put_QualityOfService(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListenerControl", L"QualityOfService"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketQualityOfService>(arg);

            self->obj.QualityOfService(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketListenerControl_get_OutboundUnicastHopLimit(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListenerControl", L"OutboundUnicastHopLimit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutboundUnicastHopLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketListenerControl_put_OutboundUnicastHopLimit(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListenerControl", L"OutboundUnicastHopLimit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.OutboundUnicastHopLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketListenerControl_get_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListenerControl", L"OutboundBufferSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketListenerControl_put_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListenerControl", L"OutboundBufferSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.OutboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketListenerControl_get_NoDelay(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListenerControl", L"NoDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NoDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketListenerControl_put_NoDelay(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListenerControl", L"NoDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.NoDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketListenerControl_get_KeepAlive(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListenerControl", L"KeepAlive"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeepAlive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketListenerControl_put_KeepAlive(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListenerControl", L"KeepAlive"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.KeepAlive(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StreamSocketListenerControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::StreamSocketListenerControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StreamSocketListenerControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocketListenerControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocketListenerControl[] = {
        { "_assign_array_", _assign_array_StreamSocketListenerControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamSocketListenerControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamSocketListenerControl[] = {
        { "quality_of_service", reinterpret_cast<getter>(StreamSocketListenerControl_get_QualityOfService), reinterpret_cast<setter>(StreamSocketListenerControl_put_QualityOfService), nullptr, nullptr },
        { "outbound_unicast_hop_limit", reinterpret_cast<getter>(StreamSocketListenerControl_get_OutboundUnicastHopLimit), reinterpret_cast<setter>(StreamSocketListenerControl_put_OutboundUnicastHopLimit), nullptr, nullptr },
        { "outbound_buffer_size_in_bytes", reinterpret_cast<getter>(StreamSocketListenerControl_get_OutboundBufferSizeInBytes), reinterpret_cast<setter>(StreamSocketListenerControl_put_OutboundBufferSizeInBytes), nullptr, nullptr },
        { "no_delay", reinterpret_cast<getter>(StreamSocketListenerControl_get_NoDelay), reinterpret_cast<setter>(StreamSocketListenerControl_put_NoDelay), nullptr, nullptr },
        { "keep_alive", reinterpret_cast<getter>(StreamSocketListenerControl_get_KeepAlive), reinterpret_cast<setter>(StreamSocketListenerControl_put_KeepAlive), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamSocketListenerControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StreamSocketListenerControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StreamSocketListenerControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StreamSocketListenerControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StreamSocketListenerControl) },
        { },
    };

    static PyType_Spec type_spec_StreamSocketListenerControl =
    {
        "_winsdk_Windows_Networking_Sockets.StreamSocketListenerControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocketListenerControl
    };

    // ----- StreamSocketListenerInformation class --------------------
    static constexpr const char* const type_name_StreamSocketListenerInformation = "StreamSocketListenerInformation";

    static PyObject* _new_StreamSocketListenerInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StreamSocketListenerInformation);
        return nullptr;
    }

    static void _dealloc_StreamSocketListenerInformation(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StreamSocketListenerInformation_get_LocalPort(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListenerInformation", L"LocalPort"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocalPort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StreamSocketListenerInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::StreamSocketListenerInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StreamSocketListenerInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocketListenerInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocketListenerInformation[] = {
        { "_assign_array_", _assign_array_StreamSocketListenerInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamSocketListenerInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamSocketListenerInformation[] = {
        { "local_port", reinterpret_cast<getter>(StreamSocketListenerInformation_get_LocalPort), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamSocketListenerInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StreamSocketListenerInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StreamSocketListenerInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StreamSocketListenerInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StreamSocketListenerInformation) },
        { },
    };

    static PyType_Spec type_spec_StreamSocketListenerInformation =
    {
        "_winsdk_Windows_Networking_Sockets.StreamSocketListenerInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocketListenerInformation
    };

    // ----- StreamWebSocket class --------------------
    static constexpr const char* const type_name_StreamWebSocket = "StreamWebSocket";

    static PyObject* _new_StreamWebSocket(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Sockets::StreamWebSocket instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StreamWebSocket(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StreamWebSocket_Close(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamWebSocket", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamWebSocket", L"Close", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Close(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_ConnectAsync(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamWebSocket", L"ConnectAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.ConnectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_SetRequestHeader(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamWebSocket", L"SetRequestHeader", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_get_Control(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocket", L"Control"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Control());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_get_Information(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocket", L"Information"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_get_InputStream(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocket", L"InputStream"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocket", L"OutputStream"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_add_Closed(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.StreamWebSocket", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::IWebSocket, winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_remove_Closed(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.StreamWebSocket", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_add_ServerCustomValidationRequested(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.StreamWebSocket", L"ServerCustomValidationRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::StreamWebSocket, winrt::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs>>(arg);

            return py::convert(self->obj.ServerCustomValidationRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_remove_ServerCustomValidationRequested(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.StreamWebSocket", L"ServerCustomValidationRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ServerCustomValidationRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StreamWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::StreamWebSocket>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StreamWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamWebSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_StreamWebSocket(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_StreamWebSocket(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamWebSocket[] = {
        { "close", reinterpret_cast<PyCFunction>(StreamWebSocket_Close), METH_VARARGS, nullptr },
        { "connect_async", reinterpret_cast<PyCFunction>(StreamWebSocket_ConnectAsync), METH_VARARGS, nullptr },
        { "set_request_header", reinterpret_cast<PyCFunction>(StreamWebSocket_SetRequestHeader), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(StreamWebSocket_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(StreamWebSocket_remove_Closed), METH_O, nullptr },
        { "add_server_custom_validation_requested", reinterpret_cast<PyCFunction>(StreamWebSocket_add_ServerCustomValidationRequested), METH_O, nullptr },
        { "remove_server_custom_validation_requested", reinterpret_cast<PyCFunction>(StreamWebSocket_remove_ServerCustomValidationRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_StreamWebSocket, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamWebSocket), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_StreamWebSocket), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_StreamWebSocket), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamWebSocket[] = {
        { "control", reinterpret_cast<getter>(StreamWebSocket_get_Control), nullptr, nullptr, nullptr },
        { "information", reinterpret_cast<getter>(StreamWebSocket_get_Information), nullptr, nullptr, nullptr },
        { "input_stream", reinterpret_cast<getter>(StreamWebSocket_get_InputStream), nullptr, nullptr, nullptr },
        { "output_stream", reinterpret_cast<getter>(StreamWebSocket_get_OutputStream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamWebSocket[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StreamWebSocket) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StreamWebSocket) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StreamWebSocket) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StreamWebSocket) },
        { },
    };

    static PyType_Spec type_spec_StreamWebSocket =
    {
        "_winsdk_Windows_Networking_Sockets.StreamWebSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamWebSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamWebSocket
    };

    // ----- StreamWebSocketControl class --------------------
    static constexpr const char* const type_name_StreamWebSocketControl = "StreamWebSocketControl";

    static PyObject* _new_StreamWebSocketControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StreamWebSocketControl);
        return nullptr;
    }

    static void _dealloc_StreamWebSocketControl(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StreamWebSocketControl_get_NoDelay(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"NoDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NoDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamWebSocketControl_put_NoDelay(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"NoDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.NoDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamWebSocketControl_get_DesiredUnsolicitedPongInterval(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"DesiredUnsolicitedPongInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredUnsolicitedPongInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamWebSocketControl_put_DesiredUnsolicitedPongInterval(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"DesiredUnsolicitedPongInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DesiredUnsolicitedPongInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamWebSocketControl_get_ClientCertificate(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"ClientCertificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ClientCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamWebSocketControl_put_ClientCertificate(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"ClientCertificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(arg);

            self->obj.ClientCertificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamWebSocketControl_get_ActualUnsolicitedPongInterval(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"ActualUnsolicitedPongInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActualUnsolicitedPongInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketControl_get_ServerCredential(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"ServerCredential"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamWebSocketControl_put_ServerCredential(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"ServerCredential"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamWebSocketControl_get_ProxyCredential(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"ProxyCredential"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamWebSocketControl_put_ProxyCredential(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"ProxyCredential"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamWebSocketControl_get_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"OutboundBufferSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamWebSocketControl_put_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"OutboundBufferSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.OutboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamWebSocketControl_get_SupportedProtocols(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"SupportedProtocols"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedProtocols());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketControl_get_IgnorableServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"IgnorableServerCertificateErrors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IgnorableServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StreamWebSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::StreamWebSocketControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StreamWebSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamWebSocketControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamWebSocketControl[] = {
        { "_assign_array_", _assign_array_StreamWebSocketControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamWebSocketControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamWebSocketControl[] = {
        { "no_delay", reinterpret_cast<getter>(StreamWebSocketControl_get_NoDelay), reinterpret_cast<setter>(StreamWebSocketControl_put_NoDelay), nullptr, nullptr },
        { "desired_unsolicited_pong_interval", reinterpret_cast<getter>(StreamWebSocketControl_get_DesiredUnsolicitedPongInterval), reinterpret_cast<setter>(StreamWebSocketControl_put_DesiredUnsolicitedPongInterval), nullptr, nullptr },
        { "client_certificate", reinterpret_cast<getter>(StreamWebSocketControl_get_ClientCertificate), reinterpret_cast<setter>(StreamWebSocketControl_put_ClientCertificate), nullptr, nullptr },
        { "actual_unsolicited_pong_interval", reinterpret_cast<getter>(StreamWebSocketControl_get_ActualUnsolicitedPongInterval), nullptr, nullptr, nullptr },
        { "server_credential", reinterpret_cast<getter>(StreamWebSocketControl_get_ServerCredential), reinterpret_cast<setter>(StreamWebSocketControl_put_ServerCredential), nullptr, nullptr },
        { "proxy_credential", reinterpret_cast<getter>(StreamWebSocketControl_get_ProxyCredential), reinterpret_cast<setter>(StreamWebSocketControl_put_ProxyCredential), nullptr, nullptr },
        { "outbound_buffer_size_in_bytes", reinterpret_cast<getter>(StreamWebSocketControl_get_OutboundBufferSizeInBytes), reinterpret_cast<setter>(StreamWebSocketControl_put_OutboundBufferSizeInBytes), nullptr, nullptr },
        { "supported_protocols", reinterpret_cast<getter>(StreamWebSocketControl_get_SupportedProtocols), nullptr, nullptr, nullptr },
        { "ignorable_server_certificate_errors", reinterpret_cast<getter>(StreamWebSocketControl_get_IgnorableServerCertificateErrors), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamWebSocketControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StreamWebSocketControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StreamWebSocketControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StreamWebSocketControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StreamWebSocketControl) },
        { },
    };

    static PyType_Spec type_spec_StreamWebSocketControl =
    {
        "_winsdk_Windows_Networking_Sockets.StreamWebSocketControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamWebSocketControl
    };

    // ----- StreamWebSocketInformation class --------------------
    static constexpr const char* const type_name_StreamWebSocketInformation = "StreamWebSocketInformation";

    static PyObject* _new_StreamWebSocketInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StreamWebSocketInformation);
        return nullptr;
    }

    static void _dealloc_StreamWebSocketInformation(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StreamWebSocketInformation_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketInformation", L"BandwidthStatistics"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketInformation", L"LocalAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketInformation_get_Protocol(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketInformation", L"Protocol"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Protocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketInformation_get_ServerCertificate(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketInformation", L"ServerCertificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketInformation_get_ServerCertificateErrorSeverity(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketInformation", L"ServerCertificateErrorSeverity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerCertificateErrorSeverity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketInformation_get_ServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketInformation", L"ServerCertificateErrors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketInformation_get_ServerIntermediateCertificates(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketInformation", L"ServerIntermediateCertificates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerIntermediateCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StreamWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::StreamWebSocketInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StreamWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamWebSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamWebSocketInformation[] = {
        { "_assign_array_", _assign_array_StreamWebSocketInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamWebSocketInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamWebSocketInformation[] = {
        { "bandwidth_statistics", reinterpret_cast<getter>(StreamWebSocketInformation_get_BandwidthStatistics), nullptr, nullptr, nullptr },
        { "local_address", reinterpret_cast<getter>(StreamWebSocketInformation_get_LocalAddress), nullptr, nullptr, nullptr },
        { "protocol", reinterpret_cast<getter>(StreamWebSocketInformation_get_Protocol), nullptr, nullptr, nullptr },
        { "server_certificate", reinterpret_cast<getter>(StreamWebSocketInformation_get_ServerCertificate), nullptr, nullptr, nullptr },
        { "server_certificate_error_severity", reinterpret_cast<getter>(StreamWebSocketInformation_get_ServerCertificateErrorSeverity), nullptr, nullptr, nullptr },
        { "server_certificate_errors", reinterpret_cast<getter>(StreamWebSocketInformation_get_ServerCertificateErrors), nullptr, nullptr, nullptr },
        { "server_intermediate_certificates", reinterpret_cast<getter>(StreamWebSocketInformation_get_ServerIntermediateCertificates), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamWebSocketInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StreamWebSocketInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StreamWebSocketInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StreamWebSocketInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StreamWebSocketInformation) },
        { },
    };

    static PyType_Spec type_spec_StreamWebSocketInformation =
    {
        "_winsdk_Windows_Networking_Sockets.StreamWebSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamWebSocketInformation
    };

    // ----- WebSocketClosedEventArgs class --------------------
    static constexpr const char* const type_name_WebSocketClosedEventArgs = "WebSocketClosedEventArgs";

    static PyObject* _new_WebSocketClosedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebSocketClosedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebSocketClosedEventArgs(py::wrapper::Windows::Networking::Sockets::WebSocketClosedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebSocketClosedEventArgs_get_Code(py::wrapper::Windows::Networking::Sockets::WebSocketClosedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.WebSocketClosedEventArgs", L"Code"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Code());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebSocketClosedEventArgs_get_Reason(py::wrapper::Windows::Networking::Sockets::WebSocketClosedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.WebSocketClosedEventArgs", L"Reason"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebSocketClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebSocketClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebSocketClosedEventArgs[] = {
        { "_assign_array_", _assign_array_WebSocketClosedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebSocketClosedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebSocketClosedEventArgs[] = {
        { "code", reinterpret_cast<getter>(WebSocketClosedEventArgs_get_Code), nullptr, nullptr, nullptr },
        { "reason", reinterpret_cast<getter>(WebSocketClosedEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebSocketClosedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebSocketClosedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebSocketClosedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebSocketClosedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebSocketClosedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebSocketClosedEventArgs =
    {
        "_winsdk_Windows_Networking_Sockets.WebSocketClosedEventArgs",
        sizeof(py::wrapper::Windows::Networking::Sockets::WebSocketClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebSocketClosedEventArgs
    };

    // ----- WebSocketError class --------------------
    static constexpr const char* const type_name_WebSocketError = "WebSocketError";

    static PyObject* _new_WebSocketError(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebSocketError);
        return nullptr;
    }

    static PyObject* WebSocketError_GetStatus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.WebSocketError", L"GetStatus", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(winrt::Windows::Networking::Sockets::WebSocketError::GetStatus(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebSocketError[] = {
        { "get_status", reinterpret_cast<PyCFunction>(WebSocketError_GetStatus), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebSocketError[] = {
        { }
    };

    static PyType_Slot _type_slots_WebSocketError[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebSocketError) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebSocketError) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebSocketError) },
        { },
    };

    static PyType_Spec type_spec_WebSocketError =
    {
        "_winsdk_Windows_Networking_Sockets.WebSocketError",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebSocketError
    };

    // ----- WebSocketKeepAlive class --------------------
    static constexpr const char* const type_name_WebSocketKeepAlive = "WebSocketKeepAlive";

    static PyObject* _new_WebSocketKeepAlive(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Sockets::WebSocketKeepAlive instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WebSocketKeepAlive(py::wrapper::Windows::Networking::Sockets::WebSocketKeepAlive* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebSocketKeepAlive_Run(py::wrapper::Windows::Networking::Sockets::WebSocketKeepAlive* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.WebSocketKeepAlive", L"Run", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance>(args, 0);

                self->obj.Run(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebSocketKeepAlive(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::WebSocketKeepAlive>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebSocketKeepAlive(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::WebSocketKeepAlive>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebSocketKeepAlive[] = {
        { "run", reinterpret_cast<PyCFunction>(WebSocketKeepAlive_Run), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WebSocketKeepAlive, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebSocketKeepAlive), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebSocketKeepAlive[] = {
        { }
    };

    static PyType_Slot _type_slots_WebSocketKeepAlive[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebSocketKeepAlive) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebSocketKeepAlive) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebSocketKeepAlive) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebSocketKeepAlive) },
        { },
    };

    static PyType_Spec type_spec_WebSocketKeepAlive =
    {
        "_winsdk_Windows_Networking_Sockets.WebSocketKeepAlive",
        sizeof(py::wrapper::Windows::Networking::Sockets::WebSocketKeepAlive),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebSocketKeepAlive
    };

    // ----- WebSocketServerCustomValidationRequestedEventArgs class --------------------
    static constexpr const char* const type_name_WebSocketServerCustomValidationRequestedEventArgs = "WebSocketServerCustomValidationRequestedEventArgs";

    static PyObject* _new_WebSocketServerCustomValidationRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebSocketServerCustomValidationRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebSocketServerCustomValidationRequestedEventArgs(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebSocketServerCustomValidationRequestedEventArgs_GetDeferral(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.WebSocketServerCustomValidationRequestedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebSocketServerCustomValidationRequestedEventArgs_Reject(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.WebSocketServerCustomValidationRequestedEventArgs", L"Reject", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reject();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebSocketServerCustomValidationRequestedEventArgs_get_ServerCertificate(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.WebSocketServerCustomValidationRequestedEventArgs", L"ServerCertificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebSocketServerCustomValidationRequestedEventArgs_get_ServerCertificateErrorSeverity(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.WebSocketServerCustomValidationRequestedEventArgs", L"ServerCertificateErrorSeverity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerCertificateErrorSeverity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebSocketServerCustomValidationRequestedEventArgs_get_ServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.WebSocketServerCustomValidationRequestedEventArgs", L"ServerCertificateErrors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebSocketServerCustomValidationRequestedEventArgs_get_ServerIntermediateCertificates(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.WebSocketServerCustomValidationRequestedEventArgs", L"ServerIntermediateCertificates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerIntermediateCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebSocketServerCustomValidationRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebSocketServerCustomValidationRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebSocketServerCustomValidationRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(WebSocketServerCustomValidationRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "reject", reinterpret_cast<PyCFunction>(WebSocketServerCustomValidationRequestedEventArgs_Reject), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WebSocketServerCustomValidationRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebSocketServerCustomValidationRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebSocketServerCustomValidationRequestedEventArgs[] = {
        { "server_certificate", reinterpret_cast<getter>(WebSocketServerCustomValidationRequestedEventArgs_get_ServerCertificate), nullptr, nullptr, nullptr },
        { "server_certificate_error_severity", reinterpret_cast<getter>(WebSocketServerCustomValidationRequestedEventArgs_get_ServerCertificateErrorSeverity), nullptr, nullptr, nullptr },
        { "server_certificate_errors", reinterpret_cast<getter>(WebSocketServerCustomValidationRequestedEventArgs_get_ServerCertificateErrors), nullptr, nullptr, nullptr },
        { "server_intermediate_certificates", reinterpret_cast<getter>(WebSocketServerCustomValidationRequestedEventArgs_get_ServerIntermediateCertificates), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebSocketServerCustomValidationRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebSocketServerCustomValidationRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebSocketServerCustomValidationRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebSocketServerCustomValidationRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebSocketServerCustomValidationRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebSocketServerCustomValidationRequestedEventArgs =
    {
        "_winsdk_Windows_Networking_Sockets.WebSocketServerCustomValidationRequestedEventArgs",
        sizeof(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebSocketServerCustomValidationRequestedEventArgs
    };

    // ----- IControlChannelTriggerEventDetails interface --------------------
    static constexpr const char* const type_name_IControlChannelTriggerEventDetails = "IControlChannelTriggerEventDetails";

    static PyObject* _new_IControlChannelTriggerEventDetails(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IControlChannelTriggerEventDetails);
        return nullptr;
    }

    static void _dealloc_IControlChannelTriggerEventDetails(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerEventDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IControlChannelTriggerEventDetails_get_ControlChannelTrigger(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerEventDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IControlChannelTriggerEventDetails", L"ControlChannelTrigger"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ControlChannelTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IControlChannelTriggerEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::IControlChannelTriggerEventDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IControlChannelTriggerEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IControlChannelTriggerEventDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IControlChannelTriggerEventDetails[] = {
        { "_assign_array_", _assign_array_IControlChannelTriggerEventDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IControlChannelTriggerEventDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IControlChannelTriggerEventDetails[] = {
        { "control_channel_trigger", reinterpret_cast<getter>(IControlChannelTriggerEventDetails_get_ControlChannelTrigger), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IControlChannelTriggerEventDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IControlChannelTriggerEventDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IControlChannelTriggerEventDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IControlChannelTriggerEventDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IControlChannelTriggerEventDetails) },
        { },
    };

    static PyType_Spec type_spec_IControlChannelTriggerEventDetails =
    {
        "_winsdk_Windows_Networking_Sockets.IControlChannelTriggerEventDetails",
        sizeof(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerEventDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IControlChannelTriggerEventDetails
    };

    // ----- IControlChannelTriggerResetEventDetails interface --------------------
    static constexpr const char* const type_name_IControlChannelTriggerResetEventDetails = "IControlChannelTriggerResetEventDetails";

    static PyObject* _new_IControlChannelTriggerResetEventDetails(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IControlChannelTriggerResetEventDetails);
        return nullptr;
    }

    static void _dealloc_IControlChannelTriggerResetEventDetails(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IControlChannelTriggerResetEventDetails_get_HardwareSlotReset(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IControlChannelTriggerResetEventDetails", L"HardwareSlotReset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareSlotReset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IControlChannelTriggerResetEventDetails_get_ResetReason(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IControlChannelTriggerResetEventDetails", L"ResetReason"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ResetReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IControlChannelTriggerResetEventDetails_get_SoftwareSlotReset(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IControlChannelTriggerResetEventDetails", L"SoftwareSlotReset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SoftwareSlotReset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IControlChannelTriggerResetEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IControlChannelTriggerResetEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IControlChannelTriggerResetEventDetails[] = {
        { "_assign_array_", _assign_array_IControlChannelTriggerResetEventDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IControlChannelTriggerResetEventDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IControlChannelTriggerResetEventDetails[] = {
        { "hardware_slot_reset", reinterpret_cast<getter>(IControlChannelTriggerResetEventDetails_get_HardwareSlotReset), nullptr, nullptr, nullptr },
        { "reset_reason", reinterpret_cast<getter>(IControlChannelTriggerResetEventDetails_get_ResetReason), nullptr, nullptr, nullptr },
        { "software_slot_reset", reinterpret_cast<getter>(IControlChannelTriggerResetEventDetails_get_SoftwareSlotReset), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IControlChannelTriggerResetEventDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IControlChannelTriggerResetEventDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IControlChannelTriggerResetEventDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IControlChannelTriggerResetEventDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IControlChannelTriggerResetEventDetails) },
        { },
    };

    static PyType_Spec type_spec_IControlChannelTriggerResetEventDetails =
    {
        "_winsdk_Windows_Networking_Sockets.IControlChannelTriggerResetEventDetails",
        sizeof(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IControlChannelTriggerResetEventDetails
    };

    // ----- IWebSocket interface --------------------
    static constexpr const char* const type_name_IWebSocket = "IWebSocket";

    static PyObject* _new_IWebSocket(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IWebSocket);
        return nullptr;
    }

    static void _dealloc_IWebSocket(py::wrapper::Windows::Networking::Sockets::IWebSocket* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWebSocket_Close(py::wrapper::Windows::Networking::Sockets::IWebSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.IWebSocket", L"Close", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Close(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWebSocket_ConnectAsync(py::wrapper::Windows::Networking::Sockets::IWebSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.IWebSocket", L"ConnectAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.ConnectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWebSocket_SetRequestHeader(py::wrapper::Windows::Networking::Sockets::IWebSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.IWebSocket", L"SetRequestHeader", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWebSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::IWebSocket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocket", L"OutputStream"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocket_add_Closed(py::wrapper::Windows::Networking::Sockets::IWebSocket* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.IWebSocket", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::IWebSocket, winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocket_remove_Closed(py::wrapper::Windows::Networking::Sockets::IWebSocket* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.IWebSocket", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::IWebSocket>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IWebSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IWebSocket(py::wrapper::Windows::Networking::Sockets::IWebSocket* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_IWebSocket(py::wrapper::Windows::Networking::Sockets::IWebSocket* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebSocket[] = {
        { "close", reinterpret_cast<PyCFunction>(IWebSocket_Close), METH_VARARGS, nullptr },
        { "connect_async", reinterpret_cast<PyCFunction>(IWebSocket_ConnectAsync), METH_VARARGS, nullptr },
        { "set_request_header", reinterpret_cast<PyCFunction>(IWebSocket_SetRequestHeader), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(IWebSocket_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(IWebSocket_remove_Closed), METH_O, nullptr },
        { "_assign_array_", _assign_array_IWebSocket, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWebSocket), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IWebSocket), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IWebSocket), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWebSocket[] = {
        { "output_stream", reinterpret_cast<getter>(IWebSocket_get_OutputStream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IWebSocket[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWebSocket) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWebSocket) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWebSocket) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWebSocket) },
        { },
    };

    static PyType_Spec type_spec_IWebSocket =
    {
        "_winsdk_Windows_Networking_Sockets.IWebSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::IWebSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebSocket
    };

    // ----- IWebSocketControl interface --------------------
    static constexpr const char* const type_name_IWebSocketControl = "IWebSocketControl";

    static PyObject* _new_IWebSocketControl(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IWebSocketControl);
        return nullptr;
    }

    static void _dealloc_IWebSocketControl(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWebSocketControl_get_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"OutboundBufferSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebSocketControl_put_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"OutboundBufferSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.OutboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IWebSocketControl_get_ProxyCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"ProxyCredential"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebSocketControl_put_ProxyCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"ProxyCredential"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IWebSocketControl_get_ServerCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"ServerCredential"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebSocketControl_put_ServerCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"ServerCredential"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IWebSocketControl_get_SupportedProtocols(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"SupportedProtocols"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedProtocols());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IWebSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::IWebSocketControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWebSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IWebSocketControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebSocketControl[] = {
        { "_assign_array_", _assign_array_IWebSocketControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWebSocketControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWebSocketControl[] = {
        { "outbound_buffer_size_in_bytes", reinterpret_cast<getter>(IWebSocketControl_get_OutboundBufferSizeInBytes), reinterpret_cast<setter>(IWebSocketControl_put_OutboundBufferSizeInBytes), nullptr, nullptr },
        { "proxy_credential", reinterpret_cast<getter>(IWebSocketControl_get_ProxyCredential), reinterpret_cast<setter>(IWebSocketControl_put_ProxyCredential), nullptr, nullptr },
        { "server_credential", reinterpret_cast<getter>(IWebSocketControl_get_ServerCredential), reinterpret_cast<setter>(IWebSocketControl_put_ServerCredential), nullptr, nullptr },
        { "supported_protocols", reinterpret_cast<getter>(IWebSocketControl_get_SupportedProtocols), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IWebSocketControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWebSocketControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWebSocketControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWebSocketControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWebSocketControl) },
        { },
    };

    static PyType_Spec type_spec_IWebSocketControl =
    {
        "_winsdk_Windows_Networking_Sockets.IWebSocketControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::IWebSocketControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebSocketControl
    };

    // ----- IWebSocketControl2 interface --------------------
    static constexpr const char* const type_name_IWebSocketControl2 = "IWebSocketControl2";

    static PyObject* _new_IWebSocketControl2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IWebSocketControl2);
        return nullptr;
    }

    static void _dealloc_IWebSocketControl2(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWebSocketControl2_get_IgnorableServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl2", L"IgnorableServerCertificateErrors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IgnorableServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketControl2_get_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"OutboundBufferSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebSocketControl2_put_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"OutboundBufferSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.OutboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IWebSocketControl2_get_ProxyCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"ProxyCredential"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebSocketControl2_put_ProxyCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"ProxyCredential"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IWebSocketControl2_get_ServerCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"ServerCredential"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebSocketControl2_put_ServerCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"ServerCredential"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IWebSocketControl2_get_SupportedProtocols(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"SupportedProtocols"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedProtocols());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IWebSocketControl2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::IWebSocketControl2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWebSocketControl2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IWebSocketControl2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebSocketControl2[] = {
        { "_assign_array_", _assign_array_IWebSocketControl2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWebSocketControl2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWebSocketControl2[] = {
        { "ignorable_server_certificate_errors", reinterpret_cast<getter>(IWebSocketControl2_get_IgnorableServerCertificateErrors), nullptr, nullptr, nullptr },
        { "outbound_buffer_size_in_bytes", reinterpret_cast<getter>(IWebSocketControl2_get_OutboundBufferSizeInBytes), reinterpret_cast<setter>(IWebSocketControl2_put_OutboundBufferSizeInBytes), nullptr, nullptr },
        { "proxy_credential", reinterpret_cast<getter>(IWebSocketControl2_get_ProxyCredential), reinterpret_cast<setter>(IWebSocketControl2_put_ProxyCredential), nullptr, nullptr },
        { "server_credential", reinterpret_cast<getter>(IWebSocketControl2_get_ServerCredential), reinterpret_cast<setter>(IWebSocketControl2_put_ServerCredential), nullptr, nullptr },
        { "supported_protocols", reinterpret_cast<getter>(IWebSocketControl2_get_SupportedProtocols), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IWebSocketControl2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWebSocketControl2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWebSocketControl2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWebSocketControl2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWebSocketControl2) },
        { },
    };

    static PyType_Spec type_spec_IWebSocketControl2 =
    {
        "_winsdk_Windows_Networking_Sockets.IWebSocketControl2",
        sizeof(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebSocketControl2
    };

    // ----- IWebSocketInformation interface --------------------
    static constexpr const char* const type_name_IWebSocketInformation = "IWebSocketInformation";

    static PyObject* _new_IWebSocketInformation(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IWebSocketInformation);
        return nullptr;
    }

    static void _dealloc_IWebSocketInformation(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWebSocketInformation_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketInformation", L"BandwidthStatistics"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketInformation", L"LocalAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation_get_Protocol(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketInformation", L"Protocol"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Protocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::IWebSocketInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IWebSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebSocketInformation[] = {
        { "_assign_array_", _assign_array_IWebSocketInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWebSocketInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWebSocketInformation[] = {
        { "bandwidth_statistics", reinterpret_cast<getter>(IWebSocketInformation_get_BandwidthStatistics), nullptr, nullptr, nullptr },
        { "local_address", reinterpret_cast<getter>(IWebSocketInformation_get_LocalAddress), nullptr, nullptr, nullptr },
        { "protocol", reinterpret_cast<getter>(IWebSocketInformation_get_Protocol), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IWebSocketInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWebSocketInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWebSocketInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWebSocketInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWebSocketInformation) },
        { },
    };

    static PyType_Spec type_spec_IWebSocketInformation =
    {
        "_winsdk_Windows_Networking_Sockets.IWebSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebSocketInformation
    };

    // ----- IWebSocketInformation2 interface --------------------
    static constexpr const char* const type_name_IWebSocketInformation2 = "IWebSocketInformation2";

    static PyObject* _new_IWebSocketInformation2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IWebSocketInformation2);
        return nullptr;
    }

    static void _dealloc_IWebSocketInformation2(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWebSocketInformation2_get_ServerCertificate(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketInformation2", L"ServerCertificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation2_get_ServerCertificateErrorSeverity(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketInformation2", L"ServerCertificateErrorSeverity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerCertificateErrorSeverity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation2_get_ServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketInformation2", L"ServerCertificateErrors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation2_get_ServerIntermediateCertificates(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketInformation2", L"ServerIntermediateCertificates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerIntermediateCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation2_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketInformation", L"BandwidthStatistics"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation2_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketInformation", L"LocalAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation2_get_Protocol(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketInformation", L"Protocol"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Protocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IWebSocketInformation2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::IWebSocketInformation2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWebSocketInformation2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IWebSocketInformation2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebSocketInformation2[] = {
        { "_assign_array_", _assign_array_IWebSocketInformation2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWebSocketInformation2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWebSocketInformation2[] = {
        { "server_certificate", reinterpret_cast<getter>(IWebSocketInformation2_get_ServerCertificate), nullptr, nullptr, nullptr },
        { "server_certificate_error_severity", reinterpret_cast<getter>(IWebSocketInformation2_get_ServerCertificateErrorSeverity), nullptr, nullptr, nullptr },
        { "server_certificate_errors", reinterpret_cast<getter>(IWebSocketInformation2_get_ServerCertificateErrors), nullptr, nullptr, nullptr },
        { "server_intermediate_certificates", reinterpret_cast<getter>(IWebSocketInformation2_get_ServerIntermediateCertificates), nullptr, nullptr, nullptr },
        { "bandwidth_statistics", reinterpret_cast<getter>(IWebSocketInformation2_get_BandwidthStatistics), nullptr, nullptr, nullptr },
        { "local_address", reinterpret_cast<getter>(IWebSocketInformation2_get_LocalAddress), nullptr, nullptr, nullptr },
        { "protocol", reinterpret_cast<getter>(IWebSocketInformation2_get_Protocol), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IWebSocketInformation2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWebSocketInformation2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWebSocketInformation2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWebSocketInformation2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWebSocketInformation2) },
        { },
    };

    static PyType_Spec type_spec_IWebSocketInformation2 =
    {
        "_winsdk_Windows_Networking_Sockets.IWebSocketInformation2",
        sizeof(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebSocketInformation2
    };

    // ----- BandwidthStatistics struct --------------------
    static constexpr const char* const type_name_BandwidthStatistics = "BandwidthStatistics";

    PyObject* _new_BandwidthStatistics(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Networking::Sockets::BandwidthStatistics return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        uint64_t _OutboundBitsPerSecond{};
        uint64_t _InboundBitsPerSecond{};
        uint64_t _OutboundBitsPerSecondInstability{};
        uint64_t _InboundBitsPerSecondInstability{};
        bool _OutboundBandwidthPeaked{};
        bool _InboundBandwidthPeaked{};

        static const char* kwlist[] = {"outbound_bits_per_second", "inbound_bits_per_second", "outbound_bits_per_second_instability", "inbound_bits_per_second_instability", "outbound_bandwidth_peaked", "inbound_bandwidth_peaked", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KKKKpp", const_cast<char**>(kwlist), &_OutboundBitsPerSecond, &_InboundBitsPerSecond, &_OutboundBitsPerSecondInstability, &_InboundBitsPerSecondInstability, &_OutboundBandwidthPeaked, &_InboundBandwidthPeaked))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Networking::Sockets::BandwidthStatistics return_value{ _OutboundBitsPerSecond, _InboundBitsPerSecond, _OutboundBitsPerSecondInstability, _InboundBitsPerSecondInstability, _OutboundBandwidthPeaked, _InboundBandwidthPeaked };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self) noexcept
    {
    }

    static PyObject* BandwidthStatistics_get_OutboundBitsPerSecond(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundBitsPerSecond);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BandwidthStatistics_set_OutboundBitsPerSecond(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.OutboundBitsPerSecond = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BandwidthStatistics_get_InboundBitsPerSecond(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InboundBitsPerSecond);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BandwidthStatistics_set_InboundBitsPerSecond(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.InboundBitsPerSecond = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BandwidthStatistics_get_OutboundBitsPerSecondInstability(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundBitsPerSecondInstability);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BandwidthStatistics_set_OutboundBitsPerSecondInstability(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.OutboundBitsPerSecondInstability = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BandwidthStatistics_get_InboundBitsPerSecondInstability(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InboundBitsPerSecondInstability);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BandwidthStatistics_set_InboundBitsPerSecondInstability(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.InboundBitsPerSecondInstability = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BandwidthStatistics_get_OutboundBandwidthPeaked(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundBandwidthPeaked);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BandwidthStatistics_set_OutboundBandwidthPeaked(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.OutboundBandwidthPeaked = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BandwidthStatistics_get_InboundBandwidthPeaked(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InboundBandwidthPeaked);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BandwidthStatistics_set_InboundBandwidthPeaked(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.InboundBandwidthPeaked = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_BandwidthStatistics[] = {
        { "outbound_bits_per_second", reinterpret_cast<getter>(BandwidthStatistics_get_OutboundBitsPerSecond), reinterpret_cast<setter>(BandwidthStatistics_set_OutboundBitsPerSecond), nullptr, nullptr },
        { "inbound_bits_per_second", reinterpret_cast<getter>(BandwidthStatistics_get_InboundBitsPerSecond), reinterpret_cast<setter>(BandwidthStatistics_set_InboundBitsPerSecond), nullptr, nullptr },
        { "outbound_bits_per_second_instability", reinterpret_cast<getter>(BandwidthStatistics_get_OutboundBitsPerSecondInstability), reinterpret_cast<setter>(BandwidthStatistics_set_OutboundBitsPerSecondInstability), nullptr, nullptr },
        { "inbound_bits_per_second_instability", reinterpret_cast<getter>(BandwidthStatistics_get_InboundBitsPerSecondInstability), reinterpret_cast<setter>(BandwidthStatistics_set_InboundBitsPerSecondInstability), nullptr, nullptr },
        { "outbound_bandwidth_peaked", reinterpret_cast<getter>(BandwidthStatistics_get_OutboundBandwidthPeaked), reinterpret_cast<setter>(BandwidthStatistics_set_OutboundBandwidthPeaked), nullptr, nullptr },
        { "inbound_bandwidth_peaked", reinterpret_cast<getter>(BandwidthStatistics_get_InboundBandwidthPeaked), reinterpret_cast<setter>(BandwidthStatistics_set_InboundBandwidthPeaked), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BandwidthStatistics[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BandwidthStatistics) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BandwidthStatistics) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BandwidthStatistics) },
        { },
    };

    static PyType_Spec type_spec_BandwidthStatistics =
    {
        "_winsdk_Windows_Networking_Sockets.BandwidthStatistics",
        sizeof(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BandwidthStatistics
    };

    // ----- RoundTripTimeStatistics struct --------------------
    static constexpr const char* const type_name_RoundTripTimeStatistics = "RoundTripTimeStatistics";

    PyObject* _new_RoundTripTimeStatistics(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Networking::Sockets::RoundTripTimeStatistics return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        uint32_t _Variance{};
        uint32_t _Max{};
        uint32_t _Min{};
        uint32_t _Sum{};

        static const char* kwlist[] = {"variance", "max", "min", "sum", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "IIII", const_cast<char**>(kwlist), &_Variance, &_Max, &_Min, &_Sum))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Networking::Sockets::RoundTripTimeStatistics return_value{ _Variance, _Max, _Min, _Sum };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_RoundTripTimeStatistics(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self) noexcept
    {
    }

    static PyObject* RoundTripTimeStatistics_get_Variance(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Variance);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RoundTripTimeStatistics_set_Variance(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Variance = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RoundTripTimeStatistics_get_Max(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RoundTripTimeStatistics_set_Max(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Max = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RoundTripTimeStatistics_get_Min(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RoundTripTimeStatistics_set_Min(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Min = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RoundTripTimeStatistics_get_Sum(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Sum);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RoundTripTimeStatistics_set_Sum(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Sum = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_RoundTripTimeStatistics[] = {
        { "variance", reinterpret_cast<getter>(RoundTripTimeStatistics_get_Variance), reinterpret_cast<setter>(RoundTripTimeStatistics_set_Variance), nullptr, nullptr },
        { "max", reinterpret_cast<getter>(RoundTripTimeStatistics_get_Max), reinterpret_cast<setter>(RoundTripTimeStatistics_set_Max), nullptr, nullptr },
        { "min", reinterpret_cast<getter>(RoundTripTimeStatistics_get_Min), reinterpret_cast<setter>(RoundTripTimeStatistics_set_Min), nullptr, nullptr },
        { "sum", reinterpret_cast<getter>(RoundTripTimeStatistics_get_Sum), reinterpret_cast<setter>(RoundTripTimeStatistics_set_Sum), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RoundTripTimeStatistics[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RoundTripTimeStatistics) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RoundTripTimeStatistics) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RoundTripTimeStatistics) },
        { },
    };

    static PyType_Spec type_spec_RoundTripTimeStatistics =
    {
        "_winsdk_Windows_Networking_Sockets.RoundTripTimeStatistics",
        sizeof(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RoundTripTimeStatistics
    };

    // ----- Windows.Networking.Sockets Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Networking::Sockets");

    static PyMethodDef module_methods[] = {
        {"_register_ControlChannelTriggerResetReason", register_ControlChannelTriggerResetReason, METH_O, "registers type"},
        {"_register_ControlChannelTriggerResourceType", register_ControlChannelTriggerResourceType, METH_O, "registers type"},
        {"_register_ControlChannelTriggerStatus", register_ControlChannelTriggerStatus, METH_O, "registers type"},
        {"_register_MessageWebSocketReceiveMode", register_MessageWebSocketReceiveMode, METH_O, "registers type"},
        {"_register_SocketActivityConnectedStandbyAction", register_SocketActivityConnectedStandbyAction, METH_O, "registers type"},
        {"_register_SocketActivityKind", register_SocketActivityKind, METH_O, "registers type"},
        {"_register_SocketActivityTriggerReason", register_SocketActivityTriggerReason, METH_O, "registers type"},
        {"_register_SocketErrorStatus", register_SocketErrorStatus, METH_O, "registers type"},
        {"_register_SocketMessageType", register_SocketMessageType, METH_O, "registers type"},
        {"_register_SocketProtectionLevel", register_SocketProtectionLevel, METH_O, "registers type"},
        {"_register_SocketQualityOfService", register_SocketQualityOfService, METH_O, "registers type"},
        {"_register_SocketSslErrorSeverity", register_SocketSslErrorSeverity, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_ControlChannelTriggerResetReason);
        Py_VISIT(state->type_ControlChannelTriggerResourceType);
        Py_VISIT(state->type_ControlChannelTriggerStatus);
        Py_VISIT(state->type_MessageWebSocketReceiveMode);
        Py_VISIT(state->type_SocketActivityConnectedStandbyAction);
        Py_VISIT(state->type_SocketActivityKind);
        Py_VISIT(state->type_SocketActivityTriggerReason);
        Py_VISIT(state->type_SocketErrorStatus);
        Py_VISIT(state->type_SocketMessageType);
        Py_VISIT(state->type_SocketProtectionLevel);
        Py_VISIT(state->type_SocketQualityOfService);
        Py_VISIT(state->type_SocketSslErrorSeverity);
        Py_VISIT(state->type_ControlChannelTrigger);
        Py_VISIT(state->type_DatagramSocket);
        Py_VISIT(state->type_DatagramSocketControl);
        Py_VISIT(state->type_DatagramSocketInformation);
        Py_VISIT(state->type_DatagramSocketMessageReceivedEventArgs);
        Py_VISIT(state->type_MessageWebSocket);
        Py_VISIT(state->type_MessageWebSocketControl);
        Py_VISIT(state->type_MessageWebSocketInformation);
        Py_VISIT(state->type_MessageWebSocketMessageReceivedEventArgs);
        Py_VISIT(state->type_ServerMessageWebSocket);
        Py_VISIT(state->type_ServerMessageWebSocketControl);
        Py_VISIT(state->type_ServerMessageWebSocketInformation);
        Py_VISIT(state->type_ServerStreamWebSocket);
        Py_VISIT(state->type_ServerStreamWebSocketInformation);
        Py_VISIT(state->type_SocketActivityContext);
        Py_VISIT(state->type_SocketActivityInformation);
        Py_VISIT(state->type_SocketActivityTriggerDetails);
        Py_VISIT(state->type_SocketError);
        Py_VISIT(state->type_StreamSocket);
        Py_VISIT(state->type_StreamSocketControl);
        Py_VISIT(state->type_StreamSocketInformation);
        Py_VISIT(state->type_StreamSocketListener);
        Py_VISIT(state->type_StreamSocketListenerConnectionReceivedEventArgs);
        Py_VISIT(state->type_StreamSocketListenerControl);
        Py_VISIT(state->type_StreamSocketListenerInformation);
        Py_VISIT(state->type_StreamWebSocket);
        Py_VISIT(state->type_StreamWebSocketControl);
        Py_VISIT(state->type_StreamWebSocketInformation);
        Py_VISIT(state->type_WebSocketClosedEventArgs);
        Py_VISIT(state->type_WebSocketError);
        Py_VISIT(state->type_WebSocketKeepAlive);
        Py_VISIT(state->type_WebSocketServerCustomValidationRequestedEventArgs);
        Py_VISIT(state->type_IControlChannelTriggerEventDetails);
        Py_VISIT(state->type_IControlChannelTriggerResetEventDetails);
        Py_VISIT(state->type_IWebSocket);
        Py_VISIT(state->type_IWebSocketControl);
        Py_VISIT(state->type_IWebSocketControl2);
        Py_VISIT(state->type_IWebSocketInformation);
        Py_VISIT(state->type_IWebSocketInformation2);
        Py_VISIT(state->type_BandwidthStatistics);
        Py_VISIT(state->type_RoundTripTimeStatistics);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_ControlChannelTriggerResetReason);
        Py_CLEAR(state->type_ControlChannelTriggerResourceType);
        Py_CLEAR(state->type_ControlChannelTriggerStatus);
        Py_CLEAR(state->type_MessageWebSocketReceiveMode);
        Py_CLEAR(state->type_SocketActivityConnectedStandbyAction);
        Py_CLEAR(state->type_SocketActivityKind);
        Py_CLEAR(state->type_SocketActivityTriggerReason);
        Py_CLEAR(state->type_SocketErrorStatus);
        Py_CLEAR(state->type_SocketMessageType);
        Py_CLEAR(state->type_SocketProtectionLevel);
        Py_CLEAR(state->type_SocketQualityOfService);
        Py_CLEAR(state->type_SocketSslErrorSeverity);
        Py_CLEAR(state->type_ControlChannelTrigger);
        Py_CLEAR(state->type_DatagramSocket);
        Py_CLEAR(state->type_DatagramSocketControl);
        Py_CLEAR(state->type_DatagramSocketInformation);
        Py_CLEAR(state->type_DatagramSocketMessageReceivedEventArgs);
        Py_CLEAR(state->type_MessageWebSocket);
        Py_CLEAR(state->type_MessageWebSocketControl);
        Py_CLEAR(state->type_MessageWebSocketInformation);
        Py_CLEAR(state->type_MessageWebSocketMessageReceivedEventArgs);
        Py_CLEAR(state->type_ServerMessageWebSocket);
        Py_CLEAR(state->type_ServerMessageWebSocketControl);
        Py_CLEAR(state->type_ServerMessageWebSocketInformation);
        Py_CLEAR(state->type_ServerStreamWebSocket);
        Py_CLEAR(state->type_ServerStreamWebSocketInformation);
        Py_CLEAR(state->type_SocketActivityContext);
        Py_CLEAR(state->type_SocketActivityInformation);
        Py_CLEAR(state->type_SocketActivityTriggerDetails);
        Py_CLEAR(state->type_SocketError);
        Py_CLEAR(state->type_StreamSocket);
        Py_CLEAR(state->type_StreamSocketControl);
        Py_CLEAR(state->type_StreamSocketInformation);
        Py_CLEAR(state->type_StreamSocketListener);
        Py_CLEAR(state->type_StreamSocketListenerConnectionReceivedEventArgs);
        Py_CLEAR(state->type_StreamSocketListenerControl);
        Py_CLEAR(state->type_StreamSocketListenerInformation);
        Py_CLEAR(state->type_StreamWebSocket);
        Py_CLEAR(state->type_StreamWebSocketControl);
        Py_CLEAR(state->type_StreamWebSocketInformation);
        Py_CLEAR(state->type_WebSocketClosedEventArgs);
        Py_CLEAR(state->type_WebSocketError);
        Py_CLEAR(state->type_WebSocketKeepAlive);
        Py_CLEAR(state->type_WebSocketServerCustomValidationRequestedEventArgs);
        Py_CLEAR(state->type_IControlChannelTriggerEventDetails);
        Py_CLEAR(state->type_IControlChannelTriggerResetEventDetails);
        Py_CLEAR(state->type_IWebSocket);
        Py_CLEAR(state->type_IWebSocketControl);
        Py_CLEAR(state->type_IWebSocketControl2);
        Py_CLEAR(state->type_IWebSocketInformation);
        Py_CLEAR(state->type_IWebSocketInformation2);
        Py_CLEAR(state->type_BandwidthStatistics);
        Py_CLEAR(state->type_RoundTripTimeStatistics);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Networking_Sockets",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Networking::Sockets

PyMODINIT_FUNC PyInit__winsdk_Windows_Networking_Sockets(void) noexcept
{
    using namespace py::cpp::Windows::Networking::Sockets;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_ControlChannelTrigger = py::register_python_type(module.get(), type_name_ControlChannelTrigger, &type_spec_ControlChannelTrigger, bases.get(), nullptr);
    if (!state->type_ControlChannelTrigger)
    {
        return nullptr;
    }

    state->type_DatagramSocket = py::register_python_type(module.get(), type_name_DatagramSocket, &type_spec_DatagramSocket, bases.get(), nullptr);
    if (!state->type_DatagramSocket)
    {
        return nullptr;
    }

    state->type_DatagramSocketControl = py::register_python_type(module.get(), type_name_DatagramSocketControl, &type_spec_DatagramSocketControl, bases.get(), nullptr);
    if (!state->type_DatagramSocketControl)
    {
        return nullptr;
    }

    state->type_DatagramSocketInformation = py::register_python_type(module.get(), type_name_DatagramSocketInformation, &type_spec_DatagramSocketInformation, bases.get(), nullptr);
    if (!state->type_DatagramSocketInformation)
    {
        return nullptr;
    }

    state->type_DatagramSocketMessageReceivedEventArgs = py::register_python_type(module.get(), type_name_DatagramSocketMessageReceivedEventArgs, &type_spec_DatagramSocketMessageReceivedEventArgs, bases.get(), nullptr);
    if (!state->type_DatagramSocketMessageReceivedEventArgs)
    {
        return nullptr;
    }

    state->type_MessageWebSocket = py::register_python_type(module.get(), type_name_MessageWebSocket, &type_spec_MessageWebSocket, bases.get(), nullptr);
    if (!state->type_MessageWebSocket)
    {
        return nullptr;
    }

    state->type_MessageWebSocketControl = py::register_python_type(module.get(), type_name_MessageWebSocketControl, &type_spec_MessageWebSocketControl, bases.get(), nullptr);
    if (!state->type_MessageWebSocketControl)
    {
        return nullptr;
    }

    state->type_MessageWebSocketInformation = py::register_python_type(module.get(), type_name_MessageWebSocketInformation, &type_spec_MessageWebSocketInformation, bases.get(), nullptr);
    if (!state->type_MessageWebSocketInformation)
    {
        return nullptr;
    }

    state->type_MessageWebSocketMessageReceivedEventArgs = py::register_python_type(module.get(), type_name_MessageWebSocketMessageReceivedEventArgs, &type_spec_MessageWebSocketMessageReceivedEventArgs, bases.get(), nullptr);
    if (!state->type_MessageWebSocketMessageReceivedEventArgs)
    {
        return nullptr;
    }

    state->type_ServerMessageWebSocket = py::register_python_type(module.get(), type_name_ServerMessageWebSocket, &type_spec_ServerMessageWebSocket, bases.get(), nullptr);
    if (!state->type_ServerMessageWebSocket)
    {
        return nullptr;
    }

    state->type_ServerMessageWebSocketControl = py::register_python_type(module.get(), type_name_ServerMessageWebSocketControl, &type_spec_ServerMessageWebSocketControl, bases.get(), nullptr);
    if (!state->type_ServerMessageWebSocketControl)
    {
        return nullptr;
    }

    state->type_ServerMessageWebSocketInformation = py::register_python_type(module.get(), type_name_ServerMessageWebSocketInformation, &type_spec_ServerMessageWebSocketInformation, bases.get(), nullptr);
    if (!state->type_ServerMessageWebSocketInformation)
    {
        return nullptr;
    }

    state->type_ServerStreamWebSocket = py::register_python_type(module.get(), type_name_ServerStreamWebSocket, &type_spec_ServerStreamWebSocket, bases.get(), nullptr);
    if (!state->type_ServerStreamWebSocket)
    {
        return nullptr;
    }

    state->type_ServerStreamWebSocketInformation = py::register_python_type(module.get(), type_name_ServerStreamWebSocketInformation, &type_spec_ServerStreamWebSocketInformation, bases.get(), nullptr);
    if (!state->type_ServerStreamWebSocketInformation)
    {
        return nullptr;
    }

    state->type_SocketActivityContext = py::register_python_type(module.get(), type_name_SocketActivityContext, &type_spec_SocketActivityContext, bases.get(), nullptr);
    if (!state->type_SocketActivityContext)
    {
        return nullptr;
    }

    py::pyobj_handle type_SocketActivityInformation_Meta{PyType_FromSpec(&type_spec_SocketActivityInformation_Meta)};
    if (!type_SocketActivityInformation_Meta)
    {
        return nullptr;
    }

    state->type_SocketActivityInformation = py::register_python_type(module.get(), type_name_SocketActivityInformation, &type_spec_SocketActivityInformation, bases.get(), reinterpret_cast<PyTypeObject*>(type_SocketActivityInformation_Meta.get()));
    if (!state->type_SocketActivityInformation)
    {
        return nullptr;
    }

    state->type_SocketActivityTriggerDetails = py::register_python_type(module.get(), type_name_SocketActivityTriggerDetails, &type_spec_SocketActivityTriggerDetails, bases.get(), nullptr);
    if (!state->type_SocketActivityTriggerDetails)
    {
        return nullptr;
    }

    state->type_SocketError = py::register_python_type(module.get(), type_name_SocketError, &type_spec_SocketError, nullptr, nullptr);
    if (!state->type_SocketError)
    {
        return nullptr;
    }

    state->type_StreamSocket = py::register_python_type(module.get(), type_name_StreamSocket, &type_spec_StreamSocket, bases.get(), nullptr);
    if (!state->type_StreamSocket)
    {
        return nullptr;
    }

    state->type_StreamSocketControl = py::register_python_type(module.get(), type_name_StreamSocketControl, &type_spec_StreamSocketControl, bases.get(), nullptr);
    if (!state->type_StreamSocketControl)
    {
        return nullptr;
    }

    state->type_StreamSocketInformation = py::register_python_type(module.get(), type_name_StreamSocketInformation, &type_spec_StreamSocketInformation, bases.get(), nullptr);
    if (!state->type_StreamSocketInformation)
    {
        return nullptr;
    }

    state->type_StreamSocketListener = py::register_python_type(module.get(), type_name_StreamSocketListener, &type_spec_StreamSocketListener, bases.get(), nullptr);
    if (!state->type_StreamSocketListener)
    {
        return nullptr;
    }

    state->type_StreamSocketListenerConnectionReceivedEventArgs = py::register_python_type(module.get(), type_name_StreamSocketListenerConnectionReceivedEventArgs, &type_spec_StreamSocketListenerConnectionReceivedEventArgs, bases.get(), nullptr);
    if (!state->type_StreamSocketListenerConnectionReceivedEventArgs)
    {
        return nullptr;
    }

    state->type_StreamSocketListenerControl = py::register_python_type(module.get(), type_name_StreamSocketListenerControl, &type_spec_StreamSocketListenerControl, bases.get(), nullptr);
    if (!state->type_StreamSocketListenerControl)
    {
        return nullptr;
    }

    state->type_StreamSocketListenerInformation = py::register_python_type(module.get(), type_name_StreamSocketListenerInformation, &type_spec_StreamSocketListenerInformation, bases.get(), nullptr);
    if (!state->type_StreamSocketListenerInformation)
    {
        return nullptr;
    }

    state->type_StreamWebSocket = py::register_python_type(module.get(), type_name_StreamWebSocket, &type_spec_StreamWebSocket, bases.get(), nullptr);
    if (!state->type_StreamWebSocket)
    {
        return nullptr;
    }

    state->type_StreamWebSocketControl = py::register_python_type(module.get(), type_name_StreamWebSocketControl, &type_spec_StreamWebSocketControl, bases.get(), nullptr);
    if (!state->type_StreamWebSocketControl)
    {
        return nullptr;
    }

    state->type_StreamWebSocketInformation = py::register_python_type(module.get(), type_name_StreamWebSocketInformation, &type_spec_StreamWebSocketInformation, bases.get(), nullptr);
    if (!state->type_StreamWebSocketInformation)
    {
        return nullptr;
    }

    state->type_WebSocketClosedEventArgs = py::register_python_type(module.get(), type_name_WebSocketClosedEventArgs, &type_spec_WebSocketClosedEventArgs, bases.get(), nullptr);
    if (!state->type_WebSocketClosedEventArgs)
    {
        return nullptr;
    }

    state->type_WebSocketError = py::register_python_type(module.get(), type_name_WebSocketError, &type_spec_WebSocketError, nullptr, nullptr);
    if (!state->type_WebSocketError)
    {
        return nullptr;
    }

    state->type_WebSocketKeepAlive = py::register_python_type(module.get(), type_name_WebSocketKeepAlive, &type_spec_WebSocketKeepAlive, bases.get(), nullptr);
    if (!state->type_WebSocketKeepAlive)
    {
        return nullptr;
    }

    state->type_WebSocketServerCustomValidationRequestedEventArgs = py::register_python_type(module.get(), type_name_WebSocketServerCustomValidationRequestedEventArgs, &type_spec_WebSocketServerCustomValidationRequestedEventArgs, bases.get(), nullptr);
    if (!state->type_WebSocketServerCustomValidationRequestedEventArgs)
    {
        return nullptr;
    }

    state->type_IControlChannelTriggerEventDetails = py::register_python_type(module.get(), type_name_IControlChannelTriggerEventDetails, &type_spec_IControlChannelTriggerEventDetails, bases.get(), nullptr);
    if (!state->type_IControlChannelTriggerEventDetails)
    {
        return nullptr;
    }

    state->type_IControlChannelTriggerResetEventDetails = py::register_python_type(module.get(), type_name_IControlChannelTriggerResetEventDetails, &type_spec_IControlChannelTriggerResetEventDetails, bases.get(), nullptr);
    if (!state->type_IControlChannelTriggerResetEventDetails)
    {
        return nullptr;
    }

    state->type_IWebSocket = py::register_python_type(module.get(), type_name_IWebSocket, &type_spec_IWebSocket, bases.get(), nullptr);
    if (!state->type_IWebSocket)
    {
        return nullptr;
    }

    state->type_IWebSocketControl = py::register_python_type(module.get(), type_name_IWebSocketControl, &type_spec_IWebSocketControl, bases.get(), nullptr);
    if (!state->type_IWebSocketControl)
    {
        return nullptr;
    }

    state->type_IWebSocketControl2 = py::register_python_type(module.get(), type_name_IWebSocketControl2, &type_spec_IWebSocketControl2, bases.get(), nullptr);
    if (!state->type_IWebSocketControl2)
    {
        return nullptr;
    }

    state->type_IWebSocketInformation = py::register_python_type(module.get(), type_name_IWebSocketInformation, &type_spec_IWebSocketInformation, bases.get(), nullptr);
    if (!state->type_IWebSocketInformation)
    {
        return nullptr;
    }

    state->type_IWebSocketInformation2 = py::register_python_type(module.get(), type_name_IWebSocketInformation2, &type_spec_IWebSocketInformation2, bases.get(), nullptr);
    if (!state->type_IWebSocketInformation2)
    {
        return nullptr;
    }

    state->type_BandwidthStatistics = py::register_python_type(module.get(), type_name_BandwidthStatistics, &type_spec_BandwidthStatistics, bases.get(), nullptr);
    if (!state->type_BandwidthStatistics)
    {
        return nullptr;
    }

    state->type_RoundTripTimeStatistics = py::register_python_type(module.get(), type_name_RoundTripTimeStatistics, &type_spec_RoundTripTimeStatistics, bases.get(), nullptr);
    if (!state->type_RoundTripTimeStatistics)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Networking::Sockets::ControlChannelTriggerResetReason>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ControlChannelTriggerResetReason;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::ControlChannelTriggerResetReason is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::Sockets::ControlChannelTriggerResourceType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ControlChannelTriggerResourceType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::ControlChannelTriggerResourceType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::Sockets::ControlChannelTriggerStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ControlChannelTriggerStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::ControlChannelTriggerStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::Sockets::MessageWebSocketReceiveMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MessageWebSocketReceiveMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::MessageWebSocketReceiveMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::Sockets::SocketActivityConnectedStandbyAction>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SocketActivityConnectedStandbyAction;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::SocketActivityConnectedStandbyAction is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::Sockets::SocketActivityKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SocketActivityKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::SocketActivityKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::Sockets::SocketActivityTriggerReason>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SocketActivityTriggerReason;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::SocketActivityTriggerReason is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::Sockets::SocketErrorStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SocketErrorStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::SocketErrorStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::Sockets::SocketMessageType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SocketMessageType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::SocketMessageType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::Sockets::SocketProtectionLevel>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SocketProtectionLevel;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::SocketProtectionLevel is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::Sockets::SocketQualityOfService>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SocketQualityOfService;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::SocketQualityOfService is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::Sockets::SocketSslErrorSeverity>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SocketSslErrorSeverity;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::SocketSslErrorSeverity is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::ControlChannelTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ControlChannelTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::ControlChannelTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::DatagramSocket>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DatagramSocket;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::DatagramSocket is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::DatagramSocketControl>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DatagramSocketControl;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::DatagramSocketControl is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::DatagramSocketInformation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DatagramSocketInformation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::DatagramSocketInformation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DatagramSocketMessageReceivedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::MessageWebSocket>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MessageWebSocket;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::MessageWebSocket is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::MessageWebSocketControl>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MessageWebSocketControl;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::MessageWebSocketControl is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::MessageWebSocketInformation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MessageWebSocketInformation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::MessageWebSocketInformation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MessageWebSocketMessageReceivedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::ServerMessageWebSocket>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ServerMessageWebSocket;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::ServerMessageWebSocket is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::ServerMessageWebSocketControl>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ServerMessageWebSocketControl;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::ServerMessageWebSocketControl is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::ServerMessageWebSocketInformation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ServerMessageWebSocketInformation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::ServerMessageWebSocketInformation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::ServerStreamWebSocket>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ServerStreamWebSocket;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::ServerStreamWebSocket is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::ServerStreamWebSocketInformation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ServerStreamWebSocketInformation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::ServerStreamWebSocketInformation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::SocketActivityContext>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SocketActivityContext;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::SocketActivityContext is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::SocketActivityInformation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SocketActivityInformation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::SocketActivityInformation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::SocketActivityTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SocketActivityTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::SocketActivityTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::SocketError>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SocketError;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::SocketError is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocket>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StreamSocket;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::StreamSocket is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketControl>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StreamSocketControl;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::StreamSocketControl is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketInformation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StreamSocketInformation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::StreamSocketInformation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketListener>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StreamSocketListener;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::StreamSocketListener is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StreamSocketListenerConnectionReceivedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketListenerControl>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StreamSocketListenerControl;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::StreamSocketListenerControl is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketListenerInformation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StreamSocketListenerInformation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::StreamSocketListenerInformation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamWebSocket>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StreamWebSocket;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::StreamWebSocket is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamWebSocketControl>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StreamWebSocketControl;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::StreamWebSocketControl is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamWebSocketInformation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StreamWebSocketInformation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::StreamWebSocketInformation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebSocketClosedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::WebSocketError>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebSocketError;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::WebSocketError is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::WebSocketKeepAlive>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebSocketKeepAlive;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::WebSocketKeepAlive is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebSocketServerCustomValidationRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::IControlChannelTriggerEventDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IControlChannelTriggerEventDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::IControlChannelTriggerEventDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IControlChannelTriggerResetEventDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::IWebSocket>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IWebSocket;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::IWebSocket is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::IWebSocketControl>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IWebSocketControl;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::IWebSocketControl is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::IWebSocketControl2>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IWebSocketControl2;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::IWebSocketControl2 is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::IWebSocketInformation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IWebSocketInformation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::IWebSocketInformation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::IWebSocketInformation2>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IWebSocketInformation2;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::IWebSocketInformation2 is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::BandwidthStatistics>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BandwidthStatistics;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::BandwidthStatistics is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::RoundTripTimeStatistics>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Sockets;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Sockets");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_RoundTripTimeStatistics;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Sockets::RoundTripTimeStatistics is not registered");
        return nullptr;
    }

    return python_type;
}
