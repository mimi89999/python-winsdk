// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.AI.MachineLearning.h"


namespace py::cpp::Windows::AI::MachineLearning
{
    struct module_state
    {
        PyObject* type_LearningModelDeviceKind;
        PyObject* type_LearningModelFeatureKind;
        PyObject* type_LearningModelPixelRange;
        PyObject* type_TensorKind;
        PyTypeObject* type_ImageFeatureDescriptor;
        PyTypeObject* type_ImageFeatureValue;
        PyTypeObject* type_LearningModel;
        PyTypeObject* type_LearningModelBinding;
        PyTypeObject* type_LearningModelDevice;
        PyTypeObject* type_LearningModelEvaluationResult;
        PyTypeObject* type_LearningModelSession;
        PyTypeObject* type_LearningModelSessionOptions;
        PyTypeObject* type_MapFeatureDescriptor;
        PyTypeObject* type_SequenceFeatureDescriptor;
        PyTypeObject* type_TensorBoolean;
        PyTypeObject* type_TensorDouble;
        PyTypeObject* type_TensorFeatureDescriptor;
        PyTypeObject* type_TensorFloat;
        PyTypeObject* type_TensorFloat16Bit;
        PyTypeObject* type_TensorInt16Bit;
        PyTypeObject* type_TensorInt32Bit;
        PyTypeObject* type_TensorInt64Bit;
        PyTypeObject* type_TensorInt8Bit;
        PyTypeObject* type_TensorString;
        PyTypeObject* type_TensorUInt16Bit;
        PyTypeObject* type_TensorUInt32Bit;
        PyTypeObject* type_TensorUInt64Bit;
        PyTypeObject* type_TensorUInt8Bit;
        PyTypeObject* type_ILearningModelFeatureDescriptor;
        PyTypeObject* type_ILearningModelFeatureValue;
        PyTypeObject* type_ILearningModelOperatorProvider;
        PyTypeObject* type_ITensor;
    };

    static PyObject* register_LearningModelDeviceKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_LearningModelDeviceKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_LearningModelDeviceKind = type;
        Py_INCREF(state->type_LearningModelDeviceKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_LearningModelFeatureKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_LearningModelFeatureKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_LearningModelFeatureKind = type;
        Py_INCREF(state->type_LearningModelFeatureKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_LearningModelPixelRange(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_LearningModelPixelRange)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_LearningModelPixelRange = type;
        Py_INCREF(state->type_LearningModelPixelRange);


        Py_RETURN_NONE;
    }

    static PyObject* register_TensorKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TensorKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TensorKind = type;
        Py_INCREF(state->type_TensorKind);


        Py_RETURN_NONE;
    }

    // ----- ImageFeatureDescriptor class --------------------
    static constexpr const char* const type_name_ImageFeatureDescriptor = "ImageFeatureDescriptor";

    static PyObject* _new_ImageFeatureDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ImageFeatureDescriptor);
        return nullptr;
    }

    static void _dealloc_ImageFeatureDescriptor(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageFeatureDescriptor_get_BitmapAlphaMode(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ImageFeatureDescriptor", L"BitmapAlphaMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BitmapAlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_BitmapPixelFormat(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ImageFeatureDescriptor", L"BitmapPixelFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BitmapPixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_Height(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ImageFeatureDescriptor", L"Height"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_Width(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ImageFeatureDescriptor", L"Width"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_PixelRange(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ImageFeatureDescriptor", L"PixelRange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PixelRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_Description(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ImageFeatureDescriptor", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_IsRequired(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ImageFeatureDescriptor", L"IsRequired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_Kind(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ImageFeatureDescriptor", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_Name(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ImageFeatureDescriptor", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ImageFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageFeatureDescriptor[] = {
        { "_assign_array_", _assign_array_ImageFeatureDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageFeatureDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageFeatureDescriptor[] = {
        { "bitmap_alpha_mode", reinterpret_cast<getter>(ImageFeatureDescriptor_get_BitmapAlphaMode), nullptr, nullptr, nullptr },
        { "bitmap_pixel_format", reinterpret_cast<getter>(ImageFeatureDescriptor_get_BitmapPixelFormat), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(ImageFeatureDescriptor_get_Height), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(ImageFeatureDescriptor_get_Width), nullptr, nullptr, nullptr },
        { "pixel_range", reinterpret_cast<getter>(ImageFeatureDescriptor_get_PixelRange), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(ImageFeatureDescriptor_get_Description), nullptr, nullptr, nullptr },
        { "is_required", reinterpret_cast<getter>(ImageFeatureDescriptor_get_IsRequired), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ImageFeatureDescriptor_get_Kind), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(ImageFeatureDescriptor_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageFeatureDescriptor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageFeatureDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageFeatureDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageFeatureDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageFeatureDescriptor) },
        { },
    };

    static PyType_Spec type_spec_ImageFeatureDescriptor =
    {
        "_winsdk_Windows_AI_MachineLearning.ImageFeatureDescriptor",
        sizeof(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageFeatureDescriptor
    };

    // ----- ImageFeatureValue class --------------------
    static constexpr const char* const type_name_ImageFeatureValue = "ImageFeatureValue";

    static PyObject* _new_ImageFeatureValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ImageFeatureValue);
        return nullptr;
    }

    static void _dealloc_ImageFeatureValue(py::wrapper::Windows::AI::MachineLearning::ImageFeatureValue* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageFeatureValue_CreateFromVideoFrame(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.ImageFeatureValue", L"CreateFromVideoFrame", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::VideoFrame>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::ImageFeatureValue::CreateFromVideoFrame(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageFeatureValue_get_VideoFrame(py::wrapper::Windows::AI::MachineLearning::ImageFeatureValue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ImageFeatureValue", L"VideoFrame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureValue_get_Kind(py::wrapper::Windows::AI::MachineLearning::ImageFeatureValue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ImageFeatureValue", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ImageFeatureValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::ImageFeatureValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageFeatureValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::ImageFeatureValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageFeatureValue[] = {
        { "create_from_video_frame", reinterpret_cast<PyCFunction>(ImageFeatureValue_CreateFromVideoFrame), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_ImageFeatureValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageFeatureValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageFeatureValue[] = {
        { "video_frame", reinterpret_cast<getter>(ImageFeatureValue_get_VideoFrame), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ImageFeatureValue_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageFeatureValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageFeatureValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageFeatureValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageFeatureValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageFeatureValue) },
        { },
    };

    static PyType_Spec type_spec_ImageFeatureValue =
    {
        "_winsdk_Windows_AI_MachineLearning.ImageFeatureValue",
        sizeof(py::wrapper::Windows::AI::MachineLearning::ImageFeatureValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageFeatureValue
    };

    // ----- LearningModel class --------------------
    static constexpr const char* const type_name_LearningModel = "LearningModel";

    static PyObject* _new_LearningModel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LearningModel);
        return nullptr;
    }

    static void _dealloc_LearningModel(py::wrapper::Windows::AI::MachineLearning::LearningModel* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LearningModel_Close(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModel", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModel_LoadFromFilePath(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModel", L"LoadFromFilePath", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromFilePath(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModel", L"LoadFromFilePath", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromFilePath(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModel_LoadFromStorageFileAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModel", L"LoadFromStorageFileAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStorageFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModel", L"LoadFromStorageFileAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStorageFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModel_LoadFromStream(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModel", L"LoadFromStream", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStream(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModel", L"LoadFromStream", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStream(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModel_LoadFromStreamAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModel", L"LoadFromStreamAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModel", L"LoadFromStreamAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStreamAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_Author(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModel", L"Author"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Author());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_Description(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModel", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_Domain(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModel", L"Domain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Domain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_InputFeatures(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModel", L"InputFeatures"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputFeatures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_Metadata(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModel", L"Metadata"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Metadata());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_Name(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModel", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_OutputFeatures(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModel", L"OutputFeatures"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutputFeatures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_Version(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModel", L"Version"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LearningModel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::LearningModel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LearningModel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::LearningModel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LearningModel(py::wrapper::Windows::AI::MachineLearning::LearningModel* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_LearningModel(py::wrapper::Windows::AI::MachineLearning::LearningModel* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LearningModel[] = {
        { "close", reinterpret_cast<PyCFunction>(LearningModel_Close), METH_VARARGS, nullptr },
        { "load_from_file_path", reinterpret_cast<PyCFunction>(LearningModel_LoadFromFilePath), METH_VARARGS | METH_STATIC, nullptr },
        { "load_from_storage_file_async", reinterpret_cast<PyCFunction>(LearningModel_LoadFromStorageFileAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "load_from_stream", reinterpret_cast<PyCFunction>(LearningModel_LoadFromStream), METH_VARARGS | METH_STATIC, nullptr },
        { "load_from_stream_async", reinterpret_cast<PyCFunction>(LearningModel_LoadFromStreamAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_LearningModel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LearningModel), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_LearningModel), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_LearningModel), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_LearningModel[] = {
        { "author", reinterpret_cast<getter>(LearningModel_get_Author), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(LearningModel_get_Description), nullptr, nullptr, nullptr },
        { "domain", reinterpret_cast<getter>(LearningModel_get_Domain), nullptr, nullptr, nullptr },
        { "input_features", reinterpret_cast<getter>(LearningModel_get_InputFeatures), nullptr, nullptr, nullptr },
        { "metadata", reinterpret_cast<getter>(LearningModel_get_Metadata), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(LearningModel_get_Name), nullptr, nullptr, nullptr },
        { "output_features", reinterpret_cast<getter>(LearningModel_get_OutputFeatures), nullptr, nullptr, nullptr },
        { "version", reinterpret_cast<getter>(LearningModel_get_Version), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LearningModel[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LearningModel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LearningModel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LearningModel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LearningModel) },
        { },
    };

    static PyType_Spec type_spec_LearningModel =
    {
        "_winsdk_Windows_AI_MachineLearning.LearningModel",
        sizeof(py::wrapper::Windows::AI::MachineLearning::LearningModel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LearningModel
    };

    // ----- LearningModelBinding class --------------------
    static constexpr const char* const type_name_LearningModelBinding = "LearningModelBinding";

    static PyObject* _new_LearningModelBinding(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelSession>(args, 0);

                winrt::Windows::AI::MachineLearning::LearningModelBinding instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LearningModelBinding(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LearningModelBinding_Bind(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelBinding", L"Bind", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.Bind(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelBinding", L"Bind", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);

                self->obj.Bind(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelBinding_Clear(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelBinding", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelBinding_First(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelBinding", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelBinding_HasKey(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelBinding", L"HasKey", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelBinding_Lookup(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelBinding", L"Lookup", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelBinding_Split(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelBinding", L"Split", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable> param0 { nullptr };
                winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable> param1 { nullptr };

                self->obj.Split(param0, param1);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out0.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelBinding_get_Size(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelBinding", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LearningModelBinding(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::LearningModelBinding>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LearningModelBinding(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::LearningModelBinding>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_LearningModelBinding(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self) noexcept
    {
        try
        {
            py::pyobj_handle iter{py::convert(self->obj.First())};
            return py::wrap_mapping_iter(iter.get());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_LearningModelBinding(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* key) noexcept
    {
        try
        {
            return static_cast<int>(self->obj.HasKey(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_LearningModelBinding(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_LearningModelBinding(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* key) noexcept
    {
        try
        {
            auto value = self->obj.TryLookup(py::convert_to<winrt::hstring>(key));

            if (!value) {
                PyErr_SetObject(PyExc_KeyError, key);
                return nullptr;
            }

            return py::convert(value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LearningModelBinding[] = {
        { "bind", reinterpret_cast<PyCFunction>(LearningModelBinding_Bind), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(LearningModelBinding_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(LearningModelBinding_First), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(LearningModelBinding_HasKey), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(LearningModelBinding_Lookup), METH_VARARGS, nullptr },
        { "split", reinterpret_cast<PyCFunction>(LearningModelBinding_Split), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LearningModelBinding, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LearningModelBinding), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LearningModelBinding[] = {
        { "size", reinterpret_cast<getter>(LearningModelBinding_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LearningModelBinding[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LearningModelBinding) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LearningModelBinding) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LearningModelBinding) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LearningModelBinding) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_LearningModelBinding) },
        { Py_sq_contains, reinterpret_cast<void*>(_map_contains_LearningModelBinding) },
        { Py_mp_length, reinterpret_cast<void*>(_map_length_LearningModelBinding) },
        { Py_mp_subscript, reinterpret_cast<void*>(_map_subscript_LearningModelBinding) },
        { },
    };

    static PyType_Spec type_spec_LearningModelBinding =
    {
        "_winsdk_Windows_AI_MachineLearning.LearningModelBinding",
        sizeof(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LearningModelBinding
    };

    // ----- LearningModelDevice class --------------------
    static constexpr const char* const type_name_LearningModelDevice = "LearningModelDevice";

    static PyObject* _new_LearningModelDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelDeviceKind>(args, 0);

                winrt::Windows::AI::MachineLearning::LearningModelDevice instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LearningModelDevice(py::wrapper::Windows::AI::MachineLearning::LearningModelDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LearningModelDevice_CreateFromDirect3D11Device(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelDevice", L"CreateFromDirect3D11Device", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DDevice>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModelDevice::CreateFromDirect3D11Device(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelDevice_get_AdapterId(py::wrapper::Windows::AI::MachineLearning::LearningModelDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelDevice", L"AdapterId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AdapterId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModelDevice_get_Direct3D11Device(py::wrapper::Windows::AI::MachineLearning::LearningModelDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelDevice", L"Direct3D11Device"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Direct3D11Device());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LearningModelDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::LearningModelDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LearningModelDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::LearningModelDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LearningModelDevice[] = {
        { "create_from_direct3_d11_device", reinterpret_cast<PyCFunction>(LearningModelDevice_CreateFromDirect3D11Device), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_LearningModelDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LearningModelDevice), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LearningModelDevice[] = {
        { "adapter_id", reinterpret_cast<getter>(LearningModelDevice_get_AdapterId), nullptr, nullptr, nullptr },
        { "direct3_d11_device", reinterpret_cast<getter>(LearningModelDevice_get_Direct3D11Device), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LearningModelDevice[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LearningModelDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LearningModelDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LearningModelDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LearningModelDevice) },
        { },
    };

    static PyType_Spec type_spec_LearningModelDevice =
    {
        "_winsdk_Windows_AI_MachineLearning.LearningModelDevice",
        sizeof(py::wrapper::Windows::AI::MachineLearning::LearningModelDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LearningModelDevice
    };

    // ----- LearningModelEvaluationResult class --------------------
    static constexpr const char* const type_name_LearningModelEvaluationResult = "LearningModelEvaluationResult";

    static PyObject* _new_LearningModelEvaluationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LearningModelEvaluationResult);
        return nullptr;
    }

    static void _dealloc_LearningModelEvaluationResult(py::wrapper::Windows::AI::MachineLearning::LearningModelEvaluationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LearningModelEvaluationResult_get_CorrelationId(py::wrapper::Windows::AI::MachineLearning::LearningModelEvaluationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelEvaluationResult", L"CorrelationId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CorrelationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModelEvaluationResult_get_ErrorStatus(py::wrapper::Windows::AI::MachineLearning::LearningModelEvaluationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelEvaluationResult", L"ErrorStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModelEvaluationResult_get_Outputs(py::wrapper::Windows::AI::MachineLearning::LearningModelEvaluationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelEvaluationResult", L"Outputs"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Outputs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModelEvaluationResult_get_Succeeded(py::wrapper::Windows::AI::MachineLearning::LearningModelEvaluationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelEvaluationResult", L"Succeeded"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Succeeded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LearningModelEvaluationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LearningModelEvaluationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LearningModelEvaluationResult[] = {
        { "_assign_array_", _assign_array_LearningModelEvaluationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LearningModelEvaluationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LearningModelEvaluationResult[] = {
        { "correlation_id", reinterpret_cast<getter>(LearningModelEvaluationResult_get_CorrelationId), nullptr, nullptr, nullptr },
        { "error_status", reinterpret_cast<getter>(LearningModelEvaluationResult_get_ErrorStatus), nullptr, nullptr, nullptr },
        { "outputs", reinterpret_cast<getter>(LearningModelEvaluationResult_get_Outputs), nullptr, nullptr, nullptr },
        { "succeeded", reinterpret_cast<getter>(LearningModelEvaluationResult_get_Succeeded), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LearningModelEvaluationResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LearningModelEvaluationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LearningModelEvaluationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LearningModelEvaluationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LearningModelEvaluationResult) },
        { },
    };

    static PyType_Spec type_spec_LearningModelEvaluationResult =
    {
        "_winsdk_Windows_AI_MachineLearning.LearningModelEvaluationResult",
        sizeof(py::wrapper::Windows::AI::MachineLearning::LearningModelEvaluationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LearningModelEvaluationResult
    };

    // ----- LearningModelSession class --------------------
    static constexpr const char* const type_name_LearningModelSession = "LearningModelSession";

    static PyObject* _new_LearningModelSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelDevice>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelSessionOptions>(args, 2);

                winrt::Windows::AI::MachineLearning::LearningModelSession instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModel>(args, 0);

                winrt::Windows::AI::MachineLearning::LearningModelSession instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelDevice>(args, 1);

                winrt::Windows::AI::MachineLearning::LearningModelSession instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LearningModelSession(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LearningModelSession_Close(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelSession", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_Evaluate(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelSession", L"Evaluate", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelBinding>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.Evaluate(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_EvaluateAsync(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelSession", L"EvaluateAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelBinding>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.EvaluateAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_EvaluateFeatures(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelSession", L"EvaluateFeatures", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.EvaluateFeatures(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_EvaluateFeaturesAsync(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelSession", L"EvaluateFeaturesAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.EvaluateFeaturesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_get_Device(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelSession", L"Device"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Device());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_get_EvaluationProperties(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelSession", L"EvaluationProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EvaluationProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_get_Model(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelSession", L"Model"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Model());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LearningModelSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::LearningModelSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LearningModelSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::LearningModelSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LearningModelSession(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_LearningModelSession(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LearningModelSession[] = {
        { "close", reinterpret_cast<PyCFunction>(LearningModelSession_Close), METH_VARARGS, nullptr },
        { "evaluate", reinterpret_cast<PyCFunction>(LearningModelSession_Evaluate), METH_VARARGS, nullptr },
        { "evaluate_async", reinterpret_cast<PyCFunction>(LearningModelSession_EvaluateAsync), METH_VARARGS, nullptr },
        { "evaluate_features", reinterpret_cast<PyCFunction>(LearningModelSession_EvaluateFeatures), METH_VARARGS, nullptr },
        { "evaluate_features_async", reinterpret_cast<PyCFunction>(LearningModelSession_EvaluateFeaturesAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LearningModelSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LearningModelSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_LearningModelSession), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_LearningModelSession), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_LearningModelSession[] = {
        { "device", reinterpret_cast<getter>(LearningModelSession_get_Device), nullptr, nullptr, nullptr },
        { "evaluation_properties", reinterpret_cast<getter>(LearningModelSession_get_EvaluationProperties), nullptr, nullptr, nullptr },
        { "model", reinterpret_cast<getter>(LearningModelSession_get_Model), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LearningModelSession[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LearningModelSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LearningModelSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LearningModelSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LearningModelSession) },
        { },
    };

    static PyType_Spec type_spec_LearningModelSession =
    {
        "_winsdk_Windows_AI_MachineLearning.LearningModelSession",
        sizeof(py::wrapper::Windows::AI::MachineLearning::LearningModelSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LearningModelSession
    };

    // ----- LearningModelSessionOptions class --------------------
    static constexpr const char* const type_name_LearningModelSessionOptions = "LearningModelSessionOptions";

    static PyObject* _new_LearningModelSessionOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::AI::MachineLearning::LearningModelSessionOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LearningModelSessionOptions(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LearningModelSessionOptions_OverrideNamedDimension(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelSessionOptions", L"OverrideNamedDimension", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                self->obj.OverrideNamedDimension(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelSessionOptions_get_BatchSizeOverride(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelSessionOptions", L"BatchSizeOverride"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BatchSizeOverride());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LearningModelSessionOptions_put_BatchSizeOverride(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelSessionOptions", L"BatchSizeOverride"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.BatchSizeOverride(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LearningModelSessionOptions_get_CloseModelOnSessionCreation(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelSessionOptions", L"CloseModelOnSessionCreation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CloseModelOnSessionCreation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LearningModelSessionOptions_put_CloseModelOnSessionCreation(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelSessionOptions", L"CloseModelOnSessionCreation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CloseModelOnSessionCreation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_LearningModelSessionOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::LearningModelSessionOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LearningModelSessionOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::LearningModelSessionOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LearningModelSessionOptions[] = {
        { "override_named_dimension", reinterpret_cast<PyCFunction>(LearningModelSessionOptions_OverrideNamedDimension), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LearningModelSessionOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LearningModelSessionOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LearningModelSessionOptions[] = {
        { "batch_size_override", reinterpret_cast<getter>(LearningModelSessionOptions_get_BatchSizeOverride), reinterpret_cast<setter>(LearningModelSessionOptions_put_BatchSizeOverride), nullptr, nullptr },
        { "close_model_on_session_creation", reinterpret_cast<getter>(LearningModelSessionOptions_get_CloseModelOnSessionCreation), reinterpret_cast<setter>(LearningModelSessionOptions_put_CloseModelOnSessionCreation), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LearningModelSessionOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LearningModelSessionOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LearningModelSessionOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LearningModelSessionOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LearningModelSessionOptions) },
        { },
    };

    static PyType_Spec type_spec_LearningModelSessionOptions =
    {
        "_winsdk_Windows_AI_MachineLearning.LearningModelSessionOptions",
        sizeof(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LearningModelSessionOptions
    };

    // ----- MapFeatureDescriptor class --------------------
    static constexpr const char* const type_name_MapFeatureDescriptor = "MapFeatureDescriptor";

    static PyObject* _new_MapFeatureDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MapFeatureDescriptor);
        return nullptr;
    }

    static void _dealloc_MapFeatureDescriptor(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapFeatureDescriptor_get_Description(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.MapFeatureDescriptor", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapFeatureDescriptor_get_IsRequired(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.MapFeatureDescriptor", L"IsRequired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapFeatureDescriptor_get_Kind(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.MapFeatureDescriptor", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapFeatureDescriptor_get_Name(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.MapFeatureDescriptor", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapFeatureDescriptor_get_KeyKind(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.MapFeatureDescriptor", L"KeyKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapFeatureDescriptor_get_ValueDescriptor(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.MapFeatureDescriptor", L"ValueDescriptor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ValueDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapFeatureDescriptor[] = {
        { "_assign_array_", _assign_array_MapFeatureDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapFeatureDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapFeatureDescriptor[] = {
        { "description", reinterpret_cast<getter>(MapFeatureDescriptor_get_Description), nullptr, nullptr, nullptr },
        { "is_required", reinterpret_cast<getter>(MapFeatureDescriptor_get_IsRequired), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(MapFeatureDescriptor_get_Kind), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(MapFeatureDescriptor_get_Name), nullptr, nullptr, nullptr },
        { "key_kind", reinterpret_cast<getter>(MapFeatureDescriptor_get_KeyKind), nullptr, nullptr, nullptr },
        { "value_descriptor", reinterpret_cast<getter>(MapFeatureDescriptor_get_ValueDescriptor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapFeatureDescriptor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapFeatureDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapFeatureDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapFeatureDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapFeatureDescriptor) },
        { },
    };

    static PyType_Spec type_spec_MapFeatureDescriptor =
    {
        "_winsdk_Windows_AI_MachineLearning.MapFeatureDescriptor",
        sizeof(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapFeatureDescriptor
    };

    // ----- SequenceFeatureDescriptor class --------------------
    static constexpr const char* const type_name_SequenceFeatureDescriptor = "SequenceFeatureDescriptor";

    static PyObject* _new_SequenceFeatureDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SequenceFeatureDescriptor);
        return nullptr;
    }

    static void _dealloc_SequenceFeatureDescriptor(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SequenceFeatureDescriptor_get_Description(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.SequenceFeatureDescriptor", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SequenceFeatureDescriptor_get_IsRequired(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.SequenceFeatureDescriptor", L"IsRequired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SequenceFeatureDescriptor_get_Kind(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.SequenceFeatureDescriptor", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SequenceFeatureDescriptor_get_Name(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.SequenceFeatureDescriptor", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SequenceFeatureDescriptor_get_ElementDescriptor(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.SequenceFeatureDescriptor", L"ElementDescriptor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ElementDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SequenceFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SequenceFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SequenceFeatureDescriptor[] = {
        { "_assign_array_", _assign_array_SequenceFeatureDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SequenceFeatureDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SequenceFeatureDescriptor[] = {
        { "description", reinterpret_cast<getter>(SequenceFeatureDescriptor_get_Description), nullptr, nullptr, nullptr },
        { "is_required", reinterpret_cast<getter>(SequenceFeatureDescriptor_get_IsRequired), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(SequenceFeatureDescriptor_get_Kind), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(SequenceFeatureDescriptor_get_Name), nullptr, nullptr, nullptr },
        { "element_descriptor", reinterpret_cast<getter>(SequenceFeatureDescriptor_get_ElementDescriptor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SequenceFeatureDescriptor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SequenceFeatureDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SequenceFeatureDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SequenceFeatureDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SequenceFeatureDescriptor) },
        { },
    };

    static PyType_Spec type_spec_SequenceFeatureDescriptor =
    {
        "_winsdk_Windows_AI_MachineLearning.SequenceFeatureDescriptor",
        sizeof(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SequenceFeatureDescriptor
    };

    // ----- TensorBoolean class --------------------
    static constexpr const char* const type_name_TensorBoolean = "TensorBoolean";

    static PyObject* _new_TensorBoolean(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TensorBoolean);
        return nullptr;
    }

    static void _dealloc_TensorBoolean(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorBoolean_Close(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorBoolean", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorBoolean", L"Create", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorBoolean::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorBoolean", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorBoolean::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorBoolean", L"CreateFromArray", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<bool, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorBoolean::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorBoolean", L"CreateFromBuffer", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorBoolean::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorBoolean", L"CreateFromIterable", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<bool>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorBoolean::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorBoolean", L"CreateFromShapeArrayAndDataArray", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<bool, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorBoolean::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorBoolean", L"CreateReference", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorBoolean", L"GetAsVectorView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorBoolean", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorBoolean", L"Shape"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorBoolean", L"TensorKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorBoolean(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorBoolean>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorBoolean(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorBoolean>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorBoolean(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_TensorBoolean(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorBoolean[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorBoolean_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(TensorBoolean_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorBoolean_CreateFromArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorBoolean_CreateFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorBoolean_CreateFromIterable), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorBoolean_CreateFromShapeArrayAndDataArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorBoolean_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorBoolean_GetAsVectorView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TensorBoolean, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorBoolean), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorBoolean), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_TensorBoolean), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorBoolean[] = {
        { "kind", reinterpret_cast<getter>(TensorBoolean_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorBoolean_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorBoolean_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorBoolean[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorBoolean) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorBoolean) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorBoolean) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorBoolean) },
        { },
    };

    static PyType_Spec type_spec_TensorBoolean =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorBoolean",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorBoolean),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorBoolean
    };

    // ----- TensorDouble class --------------------
    static constexpr const char* const type_name_TensorDouble = "TensorDouble";

    static PyObject* _new_TensorDouble(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TensorDouble);
        return nullptr;
    }

    static void _dealloc_TensorDouble(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorDouble_Close(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorDouble", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorDouble", L"Create", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorDouble::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorDouble", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorDouble::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorDouble", L"CreateFromArray", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<double, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorDouble::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorDouble", L"CreateFromBuffer", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorDouble::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorDouble", L"CreateFromIterable", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<double>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorDouble::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorDouble", L"CreateFromShapeArrayAndDataArray", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<double, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorDouble::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorDouble", L"CreateReference", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorDouble", L"GetAsVectorView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorDouble", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorDouble_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorDouble", L"Shape"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorDouble_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorDouble", L"TensorKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorDouble(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorDouble>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorDouble(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorDouble>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorDouble(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_TensorDouble(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorDouble[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorDouble_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(TensorDouble_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorDouble_CreateFromArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorDouble_CreateFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorDouble_CreateFromIterable), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorDouble_CreateFromShapeArrayAndDataArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorDouble_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorDouble_GetAsVectorView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TensorDouble, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorDouble), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorDouble), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_TensorDouble), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorDouble[] = {
        { "kind", reinterpret_cast<getter>(TensorDouble_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorDouble_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorDouble_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorDouble[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorDouble) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorDouble) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorDouble) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorDouble) },
        { },
    };

    static PyType_Spec type_spec_TensorDouble =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorDouble",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorDouble),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorDouble
    };

    // ----- TensorFeatureDescriptor class --------------------
    static constexpr const char* const type_name_TensorFeatureDescriptor = "TensorFeatureDescriptor";

    static PyObject* _new_TensorFeatureDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TensorFeatureDescriptor);
        return nullptr;
    }

    static void _dealloc_TensorFeatureDescriptor(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorFeatureDescriptor_get_Description(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorFeatureDescriptor", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFeatureDescriptor_get_IsRequired(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorFeatureDescriptor", L"IsRequired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFeatureDescriptor_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorFeatureDescriptor", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFeatureDescriptor_get_Name(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorFeatureDescriptor", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFeatureDescriptor_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorFeatureDescriptor", L"Shape"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFeatureDescriptor_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorFeatureDescriptor", L"TensorKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorFeatureDescriptor[] = {
        { "_assign_array_", _assign_array_TensorFeatureDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorFeatureDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorFeatureDescriptor[] = {
        { "description", reinterpret_cast<getter>(TensorFeatureDescriptor_get_Description), nullptr, nullptr, nullptr },
        { "is_required", reinterpret_cast<getter>(TensorFeatureDescriptor_get_IsRequired), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(TensorFeatureDescriptor_get_Kind), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(TensorFeatureDescriptor_get_Name), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorFeatureDescriptor_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorFeatureDescriptor_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorFeatureDescriptor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorFeatureDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorFeatureDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorFeatureDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorFeatureDescriptor) },
        { },
    };

    static PyType_Spec type_spec_TensorFeatureDescriptor =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorFeatureDescriptor",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorFeatureDescriptor
    };

    // ----- TensorFloat class --------------------
    static constexpr const char* const type_name_TensorFloat = "TensorFloat";

    static PyObject* _new_TensorFloat(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TensorFloat);
        return nullptr;
    }

    static void _dealloc_TensorFloat(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorFloat_Close(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat", L"Create", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat", L"CreateFromArray", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<float, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat", L"CreateFromBuffer", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat", L"CreateFromIterable", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<float>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat", L"CreateFromShapeArrayAndDataArray", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<float, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat", L"CreateReference", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat", L"GetAsVectorView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorFloat", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFloat_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorFloat", L"Shape"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFloat_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorFloat", L"TensorKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorFloat(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorFloat>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorFloat(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorFloat>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorFloat(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_TensorFloat(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorFloat[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorFloat_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(TensorFloat_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorFloat_CreateFromArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorFloat_CreateFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorFloat_CreateFromIterable), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorFloat_CreateFromShapeArrayAndDataArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorFloat_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorFloat_GetAsVectorView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TensorFloat, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorFloat), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorFloat), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_TensorFloat), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorFloat[] = {
        { "kind", reinterpret_cast<getter>(TensorFloat_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorFloat_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorFloat_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorFloat[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorFloat) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorFloat) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorFloat) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorFloat) },
        { },
    };

    static PyType_Spec type_spec_TensorFloat =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorFloat",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorFloat),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorFloat
    };

    // ----- TensorFloat16Bit class --------------------
    static constexpr const char* const type_name_TensorFloat16Bit = "TensorFloat16Bit";

    static PyObject* _new_TensorFloat16Bit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TensorFloat16Bit);
        return nullptr;
    }

    static void _dealloc_TensorFloat16Bit(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorFloat16Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat16Bit", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat16Bit", L"Create", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat16Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat16Bit", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat16Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat16Bit", L"CreateFromArray", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<float, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat16Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat16Bit", L"CreateFromBuffer", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat16Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat16Bit", L"CreateFromIterable", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<float>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat16Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat16Bit", L"CreateFromShapeArrayAndDataArray", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<float, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat16Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat16Bit", L"CreateReference", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat16Bit", L"GetAsVectorView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorFloat16Bit", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorFloat16Bit", L"Shape"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorFloat16Bit", L"TensorKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorFloat16Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorFloat16Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorFloat16Bit(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_TensorFloat16Bit(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorFloat16Bit[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorFloat16Bit_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(TensorFloat16Bit_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorFloat16Bit_CreateFromArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorFloat16Bit_CreateFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorFloat16Bit_CreateFromIterable), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorFloat16Bit_CreateFromShapeArrayAndDataArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorFloat16Bit_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorFloat16Bit_GetAsVectorView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TensorFloat16Bit, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorFloat16Bit), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorFloat16Bit), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_TensorFloat16Bit), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorFloat16Bit[] = {
        { "kind", reinterpret_cast<getter>(TensorFloat16Bit_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorFloat16Bit_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorFloat16Bit_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorFloat16Bit[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorFloat16Bit) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorFloat16Bit) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorFloat16Bit) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorFloat16Bit) },
        { },
    };

    static PyType_Spec type_spec_TensorFloat16Bit =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorFloat16Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorFloat16Bit
    };

    // ----- TensorInt16Bit class --------------------
    static constexpr const char* const type_name_TensorInt16Bit = "TensorInt16Bit";

    static PyObject* _new_TensorInt16Bit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TensorInt16Bit);
        return nullptr;
    }

    static void _dealloc_TensorInt16Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorInt16Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt16Bit", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt16Bit", L"Create", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt16Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt16Bit", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt16Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt16Bit", L"CreateFromArray", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int16_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt16Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt16Bit", L"CreateFromBuffer", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt16Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt16Bit", L"CreateFromIterable", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int16_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt16Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt16Bit", L"CreateFromShapeArrayAndDataArray", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int16_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt16Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt16Bit", L"CreateReference", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt16Bit", L"GetAsVectorView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorInt16Bit", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorInt16Bit", L"Shape"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorInt16Bit", L"TensorKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorInt16Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorInt16Bit>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorInt16Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorInt16Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorInt16Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_TensorInt16Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorInt16Bit[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorInt16Bit_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(TensorInt16Bit_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorInt16Bit_CreateFromArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorInt16Bit_CreateFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorInt16Bit_CreateFromIterable), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorInt16Bit_CreateFromShapeArrayAndDataArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorInt16Bit_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorInt16Bit_GetAsVectorView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TensorInt16Bit, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorInt16Bit), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorInt16Bit), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_TensorInt16Bit), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorInt16Bit[] = {
        { "kind", reinterpret_cast<getter>(TensorInt16Bit_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorInt16Bit_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorInt16Bit_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorInt16Bit[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorInt16Bit) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorInt16Bit) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorInt16Bit) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorInt16Bit) },
        { },
    };

    static PyType_Spec type_spec_TensorInt16Bit =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorInt16Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorInt16Bit
    };

    // ----- TensorInt32Bit class --------------------
    static constexpr const char* const type_name_TensorInt32Bit = "TensorInt32Bit";

    static PyObject* _new_TensorInt32Bit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TensorInt32Bit);
        return nullptr;
    }

    static void _dealloc_TensorInt32Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorInt32Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt32Bit", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt32Bit", L"Create", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt32Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt32Bit", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt32Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt32Bit", L"CreateFromArray", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int32_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt32Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt32Bit", L"CreateFromBuffer", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt32Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt32Bit", L"CreateFromIterable", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int32_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt32Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt32Bit", L"CreateFromShapeArrayAndDataArray", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int32_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt32Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt32Bit", L"CreateReference", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt32Bit", L"GetAsVectorView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorInt32Bit", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorInt32Bit", L"Shape"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorInt32Bit", L"TensorKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorInt32Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorInt32Bit>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorInt32Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorInt32Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorInt32Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_TensorInt32Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorInt32Bit[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorInt32Bit_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(TensorInt32Bit_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorInt32Bit_CreateFromArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorInt32Bit_CreateFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorInt32Bit_CreateFromIterable), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorInt32Bit_CreateFromShapeArrayAndDataArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorInt32Bit_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorInt32Bit_GetAsVectorView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TensorInt32Bit, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorInt32Bit), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorInt32Bit), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_TensorInt32Bit), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorInt32Bit[] = {
        { "kind", reinterpret_cast<getter>(TensorInt32Bit_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorInt32Bit_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorInt32Bit_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorInt32Bit[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorInt32Bit) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorInt32Bit) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorInt32Bit) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorInt32Bit) },
        { },
    };

    static PyType_Spec type_spec_TensorInt32Bit =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorInt32Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorInt32Bit
    };

    // ----- TensorInt64Bit class --------------------
    static constexpr const char* const type_name_TensorInt64Bit = "TensorInt64Bit";

    static PyObject* _new_TensorInt64Bit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TensorInt64Bit);
        return nullptr;
    }

    static void _dealloc_TensorInt64Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorInt64Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt64Bit", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt64Bit", L"Create", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt64Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt64Bit", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt64Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt64Bit", L"CreateFromArray", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt64Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt64Bit", L"CreateFromBuffer", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt64Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt64Bit", L"CreateFromIterable", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt64Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt64Bit", L"CreateFromShapeArrayAndDataArray", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt64Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt64Bit", L"CreateReference", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt64Bit", L"GetAsVectorView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorInt64Bit", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorInt64Bit", L"Shape"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorInt64Bit", L"TensorKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorInt64Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorInt64Bit>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorInt64Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorInt64Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorInt64Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_TensorInt64Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorInt64Bit[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorInt64Bit_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(TensorInt64Bit_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorInt64Bit_CreateFromArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorInt64Bit_CreateFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorInt64Bit_CreateFromIterable), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorInt64Bit_CreateFromShapeArrayAndDataArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorInt64Bit_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorInt64Bit_GetAsVectorView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TensorInt64Bit, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorInt64Bit), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorInt64Bit), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_TensorInt64Bit), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorInt64Bit[] = {
        { "kind", reinterpret_cast<getter>(TensorInt64Bit_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorInt64Bit_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorInt64Bit_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorInt64Bit[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorInt64Bit) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorInt64Bit) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorInt64Bit) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorInt64Bit) },
        { },
    };

    static PyType_Spec type_spec_TensorInt64Bit =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorInt64Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorInt64Bit
    };

    // ----- TensorInt8Bit class --------------------
    static constexpr const char* const type_name_TensorInt8Bit = "TensorInt8Bit";

    static PyObject* _new_TensorInt8Bit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TensorInt8Bit);
        return nullptr;
    }

    static void _dealloc_TensorInt8Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorInt8Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt8Bit", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt8Bit", L"Create", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt8Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt8Bit", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt8Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt8Bit", L"CreateFromArray", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt8Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt8Bit", L"CreateFromBuffer", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt8Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt8Bit", L"CreateFromIterable", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint8_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt8Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt8Bit", L"CreateFromShapeArrayAndDataArray", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt8Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt8Bit", L"CreateReference", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt8Bit", L"GetAsVectorView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorInt8Bit", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorInt8Bit", L"Shape"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorInt8Bit", L"TensorKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorInt8Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorInt8Bit>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorInt8Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorInt8Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorInt8Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_TensorInt8Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorInt8Bit[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorInt8Bit_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(TensorInt8Bit_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorInt8Bit_CreateFromArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorInt8Bit_CreateFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorInt8Bit_CreateFromIterable), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorInt8Bit_CreateFromShapeArrayAndDataArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorInt8Bit_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorInt8Bit_GetAsVectorView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TensorInt8Bit, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorInt8Bit), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorInt8Bit), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_TensorInt8Bit), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorInt8Bit[] = {
        { "kind", reinterpret_cast<getter>(TensorInt8Bit_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorInt8Bit_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorInt8Bit_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorInt8Bit[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorInt8Bit) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorInt8Bit) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorInt8Bit) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorInt8Bit) },
        { },
    };

    static PyType_Spec type_spec_TensorInt8Bit =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorInt8Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorInt8Bit
    };

    // ----- TensorString class --------------------
    static constexpr const char* const type_name_TensorString = "TensorString";

    static PyObject* _new_TensorString(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TensorString);
        return nullptr;
    }

    static void _dealloc_TensorString(py::wrapper::Windows::AI::MachineLearning::TensorString* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorString_Close(py::wrapper::Windows::AI::MachineLearning::TensorString* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorString", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorString", L"Create", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorString::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorString", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorString::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorString", L"CreateFromArray", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::hstring, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorString::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorString", L"CreateFromIterable", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorString::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorString", L"CreateFromShapeArrayAndDataArray", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::hstring, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorString::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorString* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorString", L"CreateReference", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorString* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorString", L"GetAsVectorView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorString* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorString", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorString_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorString* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorString", L"Shape"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorString_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorString* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorString", L"TensorKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorString(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorString>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorString(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorString>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorString(py::wrapper::Windows::AI::MachineLearning::TensorString* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_TensorString(py::wrapper::Windows::AI::MachineLearning::TensorString* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorString[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorString_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(TensorString_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorString_CreateFromArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorString_CreateFromIterable), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorString_CreateFromShapeArrayAndDataArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorString_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorString_GetAsVectorView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TensorString, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorString), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorString), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_TensorString), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorString[] = {
        { "kind", reinterpret_cast<getter>(TensorString_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorString_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorString_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorString[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorString) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorString) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorString) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorString) },
        { },
    };

    static PyType_Spec type_spec_TensorString =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorString",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorString),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorString
    };

    // ----- TensorUInt16Bit class --------------------
    static constexpr const char* const type_name_TensorUInt16Bit = "TensorUInt16Bit";

    static PyObject* _new_TensorUInt16Bit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TensorUInt16Bit);
        return nullptr;
    }

    static void _dealloc_TensorUInt16Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorUInt16Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt16Bit", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt16Bit", L"Create", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt16Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt16Bit", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt16Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt16Bit", L"CreateFromArray", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint16_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt16Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt16Bit", L"CreateFromBuffer", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt16Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt16Bit", L"CreateFromIterable", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint16_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt16Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt16Bit", L"CreateFromShapeArrayAndDataArray", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint16_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt16Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt16Bit", L"CreateReference", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt16Bit", L"GetAsVectorView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorUInt16Bit", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorUInt16Bit", L"Shape"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorUInt16Bit", L"TensorKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorUInt16Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorUInt16Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorUInt16Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_TensorUInt16Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorUInt16Bit[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorUInt16Bit_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(TensorUInt16Bit_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorUInt16Bit_CreateFromArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorUInt16Bit_CreateFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorUInt16Bit_CreateFromIterable), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorUInt16Bit_CreateFromShapeArrayAndDataArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorUInt16Bit_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorUInt16Bit_GetAsVectorView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TensorUInt16Bit, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorUInt16Bit), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorUInt16Bit), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_TensorUInt16Bit), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorUInt16Bit[] = {
        { "kind", reinterpret_cast<getter>(TensorUInt16Bit_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorUInt16Bit_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorUInt16Bit_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorUInt16Bit[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorUInt16Bit) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorUInt16Bit) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorUInt16Bit) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorUInt16Bit) },
        { },
    };

    static PyType_Spec type_spec_TensorUInt16Bit =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorUInt16Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorUInt16Bit
    };

    // ----- TensorUInt32Bit class --------------------
    static constexpr const char* const type_name_TensorUInt32Bit = "TensorUInt32Bit";

    static PyObject* _new_TensorUInt32Bit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TensorUInt32Bit);
        return nullptr;
    }

    static void _dealloc_TensorUInt32Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorUInt32Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt32Bit", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt32Bit", L"Create", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt32Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt32Bit", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt32Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt32Bit", L"CreateFromArray", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint32_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt32Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt32Bit", L"CreateFromBuffer", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt32Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt32Bit", L"CreateFromIterable", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint32_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt32Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt32Bit", L"CreateFromShapeArrayAndDataArray", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint32_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt32Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt32Bit", L"CreateReference", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt32Bit", L"GetAsVectorView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorUInt32Bit", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorUInt32Bit", L"Shape"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorUInt32Bit", L"TensorKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorUInt32Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorUInt32Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorUInt32Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_TensorUInt32Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorUInt32Bit[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorUInt32Bit_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(TensorUInt32Bit_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorUInt32Bit_CreateFromArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorUInt32Bit_CreateFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorUInt32Bit_CreateFromIterable), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorUInt32Bit_CreateFromShapeArrayAndDataArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorUInt32Bit_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorUInt32Bit_GetAsVectorView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TensorUInt32Bit, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorUInt32Bit), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorUInt32Bit), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_TensorUInt32Bit), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorUInt32Bit[] = {
        { "kind", reinterpret_cast<getter>(TensorUInt32Bit_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorUInt32Bit_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorUInt32Bit_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorUInt32Bit[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorUInt32Bit) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorUInt32Bit) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorUInt32Bit) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorUInt32Bit) },
        { },
    };

    static PyType_Spec type_spec_TensorUInt32Bit =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorUInt32Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorUInt32Bit
    };

    // ----- TensorUInt64Bit class --------------------
    static constexpr const char* const type_name_TensorUInt64Bit = "TensorUInt64Bit";

    static PyObject* _new_TensorUInt64Bit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TensorUInt64Bit);
        return nullptr;
    }

    static void _dealloc_TensorUInt64Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorUInt64Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt64Bit", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt64Bit", L"Create", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt64Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt64Bit", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt64Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt64Bit", L"CreateFromArray", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint64_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt64Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt64Bit", L"CreateFromBuffer", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt64Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt64Bit", L"CreateFromIterable", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint64_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt64Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt64Bit", L"CreateFromShapeArrayAndDataArray", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint64_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt64Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt64Bit", L"CreateReference", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt64Bit", L"GetAsVectorView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorUInt64Bit", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorUInt64Bit", L"Shape"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorUInt64Bit", L"TensorKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorUInt64Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorUInt64Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorUInt64Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_TensorUInt64Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorUInt64Bit[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorUInt64Bit_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(TensorUInt64Bit_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorUInt64Bit_CreateFromArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorUInt64Bit_CreateFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorUInt64Bit_CreateFromIterable), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorUInt64Bit_CreateFromShapeArrayAndDataArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorUInt64Bit_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorUInt64Bit_GetAsVectorView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TensorUInt64Bit, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorUInt64Bit), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorUInt64Bit), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_TensorUInt64Bit), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorUInt64Bit[] = {
        { "kind", reinterpret_cast<getter>(TensorUInt64Bit_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorUInt64Bit_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorUInt64Bit_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorUInt64Bit[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorUInt64Bit) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorUInt64Bit) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorUInt64Bit) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorUInt64Bit) },
        { },
    };

    static PyType_Spec type_spec_TensorUInt64Bit =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorUInt64Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorUInt64Bit
    };

    // ----- TensorUInt8Bit class --------------------
    static constexpr const char* const type_name_TensorUInt8Bit = "TensorUInt8Bit";

    static PyObject* _new_TensorUInt8Bit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TensorUInt8Bit);
        return nullptr;
    }

    static void _dealloc_TensorUInt8Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorUInt8Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt8Bit", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt8Bit", L"Create", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt8Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt8Bit", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt8Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt8Bit", L"CreateFromArray", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt8Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt8Bit", L"CreateFromBuffer", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt8Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt8Bit", L"CreateFromIterable", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint8_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt8Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt8Bit", L"CreateFromShapeArrayAndDataArray", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt8Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt8Bit", L"CreateReference", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt8Bit", L"GetAsVectorView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorUInt8Bit", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorUInt8Bit", L"Shape"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorUInt8Bit", L"TensorKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorUInt8Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorUInt8Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorUInt8Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_TensorUInt8Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorUInt8Bit[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorUInt8Bit_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(TensorUInt8Bit_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorUInt8Bit_CreateFromArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorUInt8Bit_CreateFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorUInt8Bit_CreateFromIterable), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorUInt8Bit_CreateFromShapeArrayAndDataArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorUInt8Bit_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorUInt8Bit_GetAsVectorView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TensorUInt8Bit, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorUInt8Bit), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorUInt8Bit), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_TensorUInt8Bit), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorUInt8Bit[] = {
        { "kind", reinterpret_cast<getter>(TensorUInt8Bit_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorUInt8Bit_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorUInt8Bit_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorUInt8Bit[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorUInt8Bit) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorUInt8Bit) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorUInt8Bit) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorUInt8Bit) },
        { },
    };

    static PyType_Spec type_spec_TensorUInt8Bit =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorUInt8Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorUInt8Bit
    };

    // ----- ILearningModelFeatureDescriptor interface --------------------
    static constexpr const char* const type_name_ILearningModelFeatureDescriptor = "ILearningModelFeatureDescriptor";

    static PyObject* _new_ILearningModelFeatureDescriptor(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_ILearningModelFeatureDescriptor);
        return nullptr;
    }

    static void _dealloc_ILearningModelFeatureDescriptor(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ILearningModelFeatureDescriptor_get_Description(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ILearningModelFeatureDescriptor", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILearningModelFeatureDescriptor_get_IsRequired(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ILearningModelFeatureDescriptor", L"IsRequired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILearningModelFeatureDescriptor_get_Kind(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ILearningModelFeatureDescriptor", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILearningModelFeatureDescriptor_get_Name(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ILearningModelFeatureDescriptor", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ILearningModelFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ILearningModelFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILearningModelFeatureDescriptor[] = {
        { "_assign_array_", _assign_array_ILearningModelFeatureDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ILearningModelFeatureDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILearningModelFeatureDescriptor[] = {
        { "description", reinterpret_cast<getter>(ILearningModelFeatureDescriptor_get_Description), nullptr, nullptr, nullptr },
        { "is_required", reinterpret_cast<getter>(ILearningModelFeatureDescriptor_get_IsRequired), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ILearningModelFeatureDescriptor_get_Kind), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(ILearningModelFeatureDescriptor_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ILearningModelFeatureDescriptor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ILearningModelFeatureDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ILearningModelFeatureDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ILearningModelFeatureDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ILearningModelFeatureDescriptor) },
        { },
    };

    static PyType_Spec type_spec_ILearningModelFeatureDescriptor =
    {
        "_winsdk_Windows_AI_MachineLearning.ILearningModelFeatureDescriptor",
        sizeof(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILearningModelFeatureDescriptor
    };

    // ----- ILearningModelFeatureValue interface --------------------
    static constexpr const char* const type_name_ILearningModelFeatureValue = "ILearningModelFeatureValue";

    static PyObject* _new_ILearningModelFeatureValue(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_ILearningModelFeatureValue);
        return nullptr;
    }

    static void _dealloc_ILearningModelFeatureValue(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureValue* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ILearningModelFeatureValue_get_Kind(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureValue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ILearningModelFeatureValue", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ILearningModelFeatureValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::ILearningModelFeatureValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ILearningModelFeatureValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::ILearningModelFeatureValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILearningModelFeatureValue[] = {
        { "_assign_array_", _assign_array_ILearningModelFeatureValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ILearningModelFeatureValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILearningModelFeatureValue[] = {
        { "kind", reinterpret_cast<getter>(ILearningModelFeatureValue_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ILearningModelFeatureValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ILearningModelFeatureValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ILearningModelFeatureValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ILearningModelFeatureValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ILearningModelFeatureValue) },
        { },
    };

    static PyType_Spec type_spec_ILearningModelFeatureValue =
    {
        "_winsdk_Windows_AI_MachineLearning.ILearningModelFeatureValue",
        sizeof(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILearningModelFeatureValue
    };

    // ----- ILearningModelOperatorProvider interface --------------------
    static constexpr const char* const type_name_ILearningModelOperatorProvider = "ILearningModelOperatorProvider";

    static PyObject* _new_ILearningModelOperatorProvider(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_ILearningModelOperatorProvider);
        return nullptr;
    }

    static void _dealloc_ILearningModelOperatorProvider(py::wrapper::Windows::AI::MachineLearning::ILearningModelOperatorProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ILearningModelOperatorProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ILearningModelOperatorProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILearningModelOperatorProvider[] = {
        { "_assign_array_", _assign_array_ILearningModelOperatorProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ILearningModelOperatorProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILearningModelOperatorProvider[] = {
        { }
    };

    static PyType_Slot _type_slots_ILearningModelOperatorProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ILearningModelOperatorProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ILearningModelOperatorProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ILearningModelOperatorProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ILearningModelOperatorProvider) },
        { },
    };

    static PyType_Spec type_spec_ILearningModelOperatorProvider =
    {
        "_winsdk_Windows_AI_MachineLearning.ILearningModelOperatorProvider",
        sizeof(py::wrapper::Windows::AI::MachineLearning::ILearningModelOperatorProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILearningModelOperatorProvider
    };

    // ----- ITensor interface --------------------
    static constexpr const char* const type_name_ITensor = "ITensor";

    static PyObject* _new_ITensor(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_ITensor);
        return nullptr;
    }

    static void _dealloc_ITensor(py::wrapper::Windows::AI::MachineLearning::ITensor* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITensor_get_Shape(py::wrapper::Windows::AI::MachineLearning::ITensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ITensor", L"Shape"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITensor_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::ITensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ITensor", L"TensorKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITensor_get_Kind(py::wrapper::Windows::AI::MachineLearning::ITensor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ILearningModelFeatureValue", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ITensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::ITensor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::ITensor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITensor[] = {
        { "_assign_array_", _assign_array_ITensor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITensor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ITensor[] = {
        { "shape", reinterpret_cast<getter>(ITensor_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(ITensor_get_TensorKind), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ITensor_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ITensor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITensor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITensor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITensor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITensor) },
        { },
    };

    static PyType_Spec type_spec_ITensor =
    {
        "_winsdk_Windows_AI_MachineLearning.ITensor",
        sizeof(py::wrapper::Windows::AI::MachineLearning::ITensor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITensor
    };

    // ----- Windows.AI.MachineLearning Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::AI::MachineLearning");

    static PyMethodDef module_methods[] = {
        {"_register_LearningModelDeviceKind", register_LearningModelDeviceKind, METH_O, "registers type"},
        {"_register_LearningModelFeatureKind", register_LearningModelFeatureKind, METH_O, "registers type"},
        {"_register_LearningModelPixelRange", register_LearningModelPixelRange, METH_O, "registers type"},
        {"_register_TensorKind", register_TensorKind, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_LearningModelDeviceKind);
        Py_VISIT(state->type_LearningModelFeatureKind);
        Py_VISIT(state->type_LearningModelPixelRange);
        Py_VISIT(state->type_TensorKind);
        Py_VISIT(state->type_ImageFeatureDescriptor);
        Py_VISIT(state->type_ImageFeatureValue);
        Py_VISIT(state->type_LearningModel);
        Py_VISIT(state->type_LearningModelBinding);
        Py_VISIT(state->type_LearningModelDevice);
        Py_VISIT(state->type_LearningModelEvaluationResult);
        Py_VISIT(state->type_LearningModelSession);
        Py_VISIT(state->type_LearningModelSessionOptions);
        Py_VISIT(state->type_MapFeatureDescriptor);
        Py_VISIT(state->type_SequenceFeatureDescriptor);
        Py_VISIT(state->type_TensorBoolean);
        Py_VISIT(state->type_TensorDouble);
        Py_VISIT(state->type_TensorFeatureDescriptor);
        Py_VISIT(state->type_TensorFloat);
        Py_VISIT(state->type_TensorFloat16Bit);
        Py_VISIT(state->type_TensorInt16Bit);
        Py_VISIT(state->type_TensorInt32Bit);
        Py_VISIT(state->type_TensorInt64Bit);
        Py_VISIT(state->type_TensorInt8Bit);
        Py_VISIT(state->type_TensorString);
        Py_VISIT(state->type_TensorUInt16Bit);
        Py_VISIT(state->type_TensorUInt32Bit);
        Py_VISIT(state->type_TensorUInt64Bit);
        Py_VISIT(state->type_TensorUInt8Bit);
        Py_VISIT(state->type_ILearningModelFeatureDescriptor);
        Py_VISIT(state->type_ILearningModelFeatureValue);
        Py_VISIT(state->type_ILearningModelOperatorProvider);
        Py_VISIT(state->type_ITensor);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_LearningModelDeviceKind);
        Py_CLEAR(state->type_LearningModelFeatureKind);
        Py_CLEAR(state->type_LearningModelPixelRange);
        Py_CLEAR(state->type_TensorKind);
        Py_CLEAR(state->type_ImageFeatureDescriptor);
        Py_CLEAR(state->type_ImageFeatureValue);
        Py_CLEAR(state->type_LearningModel);
        Py_CLEAR(state->type_LearningModelBinding);
        Py_CLEAR(state->type_LearningModelDevice);
        Py_CLEAR(state->type_LearningModelEvaluationResult);
        Py_CLEAR(state->type_LearningModelSession);
        Py_CLEAR(state->type_LearningModelSessionOptions);
        Py_CLEAR(state->type_MapFeatureDescriptor);
        Py_CLEAR(state->type_SequenceFeatureDescriptor);
        Py_CLEAR(state->type_TensorBoolean);
        Py_CLEAR(state->type_TensorDouble);
        Py_CLEAR(state->type_TensorFeatureDescriptor);
        Py_CLEAR(state->type_TensorFloat);
        Py_CLEAR(state->type_TensorFloat16Bit);
        Py_CLEAR(state->type_TensorInt16Bit);
        Py_CLEAR(state->type_TensorInt32Bit);
        Py_CLEAR(state->type_TensorInt64Bit);
        Py_CLEAR(state->type_TensorInt8Bit);
        Py_CLEAR(state->type_TensorString);
        Py_CLEAR(state->type_TensorUInt16Bit);
        Py_CLEAR(state->type_TensorUInt32Bit);
        Py_CLEAR(state->type_TensorUInt64Bit);
        Py_CLEAR(state->type_TensorUInt8Bit);
        Py_CLEAR(state->type_ILearningModelFeatureDescriptor);
        Py_CLEAR(state->type_ILearningModelFeatureValue);
        Py_CLEAR(state->type_ILearningModelOperatorProvider);
        Py_CLEAR(state->type_ITensor);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_AI_MachineLearning",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::AI::MachineLearning

PyMODINIT_FUNC PyInit__winsdk_Windows_AI_MachineLearning(void) noexcept
{
    using namespace py::cpp::Windows::AI::MachineLearning;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_ImageFeatureDescriptor = py::register_python_type(module.get(), type_name_ImageFeatureDescriptor, &type_spec_ImageFeatureDescriptor, bases.get(), nullptr);
    if (!state->type_ImageFeatureDescriptor)
    {
        return nullptr;
    }

    state->type_ImageFeatureValue = py::register_python_type(module.get(), type_name_ImageFeatureValue, &type_spec_ImageFeatureValue, bases.get(), nullptr);
    if (!state->type_ImageFeatureValue)
    {
        return nullptr;
    }

    state->type_LearningModel = py::register_python_type(module.get(), type_name_LearningModel, &type_spec_LearningModel, bases.get(), nullptr);
    if (!state->type_LearningModel)
    {
        return nullptr;
    }

    state->type_LearningModelBinding = py::register_python_type(module.get(), type_name_LearningModelBinding, &type_spec_LearningModelBinding, mapping_bases.get(), nullptr);
    if (!state->type_LearningModelBinding)
    {
        return nullptr;
    }

    state->type_LearningModelDevice = py::register_python_type(module.get(), type_name_LearningModelDevice, &type_spec_LearningModelDevice, bases.get(), nullptr);
    if (!state->type_LearningModelDevice)
    {
        return nullptr;
    }

    state->type_LearningModelEvaluationResult = py::register_python_type(module.get(), type_name_LearningModelEvaluationResult, &type_spec_LearningModelEvaluationResult, bases.get(), nullptr);
    if (!state->type_LearningModelEvaluationResult)
    {
        return nullptr;
    }

    state->type_LearningModelSession = py::register_python_type(module.get(), type_name_LearningModelSession, &type_spec_LearningModelSession, bases.get(), nullptr);
    if (!state->type_LearningModelSession)
    {
        return nullptr;
    }

    state->type_LearningModelSessionOptions = py::register_python_type(module.get(), type_name_LearningModelSessionOptions, &type_spec_LearningModelSessionOptions, bases.get(), nullptr);
    if (!state->type_LearningModelSessionOptions)
    {
        return nullptr;
    }

    state->type_MapFeatureDescriptor = py::register_python_type(module.get(), type_name_MapFeatureDescriptor, &type_spec_MapFeatureDescriptor, bases.get(), nullptr);
    if (!state->type_MapFeatureDescriptor)
    {
        return nullptr;
    }

    state->type_SequenceFeatureDescriptor = py::register_python_type(module.get(), type_name_SequenceFeatureDescriptor, &type_spec_SequenceFeatureDescriptor, bases.get(), nullptr);
    if (!state->type_SequenceFeatureDescriptor)
    {
        return nullptr;
    }

    state->type_TensorBoolean = py::register_python_type(module.get(), type_name_TensorBoolean, &type_spec_TensorBoolean, bases.get(), nullptr);
    if (!state->type_TensorBoolean)
    {
        return nullptr;
    }

    state->type_TensorDouble = py::register_python_type(module.get(), type_name_TensorDouble, &type_spec_TensorDouble, bases.get(), nullptr);
    if (!state->type_TensorDouble)
    {
        return nullptr;
    }

    state->type_TensorFeatureDescriptor = py::register_python_type(module.get(), type_name_TensorFeatureDescriptor, &type_spec_TensorFeatureDescriptor, bases.get(), nullptr);
    if (!state->type_TensorFeatureDescriptor)
    {
        return nullptr;
    }

    state->type_TensorFloat = py::register_python_type(module.get(), type_name_TensorFloat, &type_spec_TensorFloat, bases.get(), nullptr);
    if (!state->type_TensorFloat)
    {
        return nullptr;
    }

    state->type_TensorFloat16Bit = py::register_python_type(module.get(), type_name_TensorFloat16Bit, &type_spec_TensorFloat16Bit, bases.get(), nullptr);
    if (!state->type_TensorFloat16Bit)
    {
        return nullptr;
    }

    state->type_TensorInt16Bit = py::register_python_type(module.get(), type_name_TensorInt16Bit, &type_spec_TensorInt16Bit, bases.get(), nullptr);
    if (!state->type_TensorInt16Bit)
    {
        return nullptr;
    }

    state->type_TensorInt32Bit = py::register_python_type(module.get(), type_name_TensorInt32Bit, &type_spec_TensorInt32Bit, bases.get(), nullptr);
    if (!state->type_TensorInt32Bit)
    {
        return nullptr;
    }

    state->type_TensorInt64Bit = py::register_python_type(module.get(), type_name_TensorInt64Bit, &type_spec_TensorInt64Bit, bases.get(), nullptr);
    if (!state->type_TensorInt64Bit)
    {
        return nullptr;
    }

    state->type_TensorInt8Bit = py::register_python_type(module.get(), type_name_TensorInt8Bit, &type_spec_TensorInt8Bit, bases.get(), nullptr);
    if (!state->type_TensorInt8Bit)
    {
        return nullptr;
    }

    state->type_TensorString = py::register_python_type(module.get(), type_name_TensorString, &type_spec_TensorString, bases.get(), nullptr);
    if (!state->type_TensorString)
    {
        return nullptr;
    }

    state->type_TensorUInt16Bit = py::register_python_type(module.get(), type_name_TensorUInt16Bit, &type_spec_TensorUInt16Bit, bases.get(), nullptr);
    if (!state->type_TensorUInt16Bit)
    {
        return nullptr;
    }

    state->type_TensorUInt32Bit = py::register_python_type(module.get(), type_name_TensorUInt32Bit, &type_spec_TensorUInt32Bit, bases.get(), nullptr);
    if (!state->type_TensorUInt32Bit)
    {
        return nullptr;
    }

    state->type_TensorUInt64Bit = py::register_python_type(module.get(), type_name_TensorUInt64Bit, &type_spec_TensorUInt64Bit, bases.get(), nullptr);
    if (!state->type_TensorUInt64Bit)
    {
        return nullptr;
    }

    state->type_TensorUInt8Bit = py::register_python_type(module.get(), type_name_TensorUInt8Bit, &type_spec_TensorUInt8Bit, bases.get(), nullptr);
    if (!state->type_TensorUInt8Bit)
    {
        return nullptr;
    }

    state->type_ILearningModelFeatureDescriptor = py::register_python_type(module.get(), type_name_ILearningModelFeatureDescriptor, &type_spec_ILearningModelFeatureDescriptor, bases.get(), nullptr);
    if (!state->type_ILearningModelFeatureDescriptor)
    {
        return nullptr;
    }

    state->type_ILearningModelFeatureValue = py::register_python_type(module.get(), type_name_ILearningModelFeatureValue, &type_spec_ILearningModelFeatureValue, bases.get(), nullptr);
    if (!state->type_ILearningModelFeatureValue)
    {
        return nullptr;
    }

    state->type_ILearningModelOperatorProvider = py::register_python_type(module.get(), type_name_ILearningModelOperatorProvider, &type_spec_ILearningModelOperatorProvider, bases.get(), nullptr);
    if (!state->type_ILearningModelOperatorProvider)
    {
        return nullptr;
    }

    state->type_ITensor = py::register_python_type(module.get(), type_name_ITensor, &type_spec_ITensor, bases.get(), nullptr);
    if (!state->type_ITensor)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::AI::MachineLearning::LearningModelDeviceKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LearningModelDeviceKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::LearningModelDeviceKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::AI::MachineLearning::LearningModelFeatureKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LearningModelFeatureKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::LearningModelFeatureKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::AI::MachineLearning::LearningModelPixelRange>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LearningModelPixelRange;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::LearningModelPixelRange is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::AI::MachineLearning::TensorKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TensorKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::TensorKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ImageFeatureDescriptor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ImageFeatureValue>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ImageFeatureValue;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::ImageFeatureValue is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModel>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LearningModel;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::LearningModel is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelBinding>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LearningModelBinding;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::LearningModelBinding is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelDevice>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LearningModelDevice;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::LearningModelDevice is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LearningModelEvaluationResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelSession>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LearningModelSession;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::LearningModelSession is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelSessionOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LearningModelSessionOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::LearningModelSessionOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MapFeatureDescriptor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::MapFeatureDescriptor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SequenceFeatureDescriptor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorBoolean>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TensorBoolean;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::TensorBoolean is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorDouble>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TensorDouble;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::TensorDouble is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TensorFeatureDescriptor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorFloat>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TensorFloat;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::TensorFloat is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TensorFloat16Bit;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::TensorFloat16Bit is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt16Bit>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TensorInt16Bit;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::TensorInt16Bit is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt32Bit>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TensorInt32Bit;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::TensorInt32Bit is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt64Bit>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TensorInt64Bit;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::TensorInt64Bit is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt8Bit>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TensorInt8Bit;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::TensorInt8Bit is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorString>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TensorString;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::TensorString is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TensorUInt16Bit;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::TensorUInt16Bit is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TensorUInt32Bit;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::TensorUInt32Bit is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TensorUInt64Bit;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::TensorUInt64Bit is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TensorUInt8Bit;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::TensorUInt8Bit is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ILearningModelFeatureDescriptor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ILearningModelFeatureValue>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ILearningModelFeatureValue;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::ILearningModelFeatureValue is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ILearningModelOperatorProvider;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ITensor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::AI::MachineLearning;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::AI::MachineLearning");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ITensor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::AI::MachineLearning::ITensor is not registered");
        return nullptr;
    }

    return python_type;
}
