// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.ApplicationModel.Background.h"


namespace py::cpp::Windows::ApplicationModel::Background
{
    struct module_state
    {
        PyObject* type_AlarmAccessStatus;
        PyObject* type_ApplicationTriggerResult;
        PyObject* type_BackgroundAccessRequestKind;
        PyObject* type_BackgroundAccessStatus;
        PyObject* type_BackgroundTaskCancellationReason;
        PyObject* type_BackgroundTaskThrottleCounter;
        PyObject* type_BackgroundWorkCostValue;
        PyObject* type_CustomSystemEventTriggerRecurrence;
        PyObject* type_DeviceTriggerResult;
        PyObject* type_LocationTriggerType;
        PyObject* type_MediaProcessingTriggerResult;
        PyObject* type_SystemConditionType;
        PyObject* type_SystemTriggerType;
        PyTypeObject* type_ActivitySensorTrigger;
        PyTypeObject* type_AlarmApplicationManager;
        PyTypeObject* type_AppBroadcastTrigger;
        PyTypeObject* type_AppBroadcastTriggerProviderInfo;
        PyTypeObject* type_ApplicationTrigger;
        PyTypeObject* type_ApplicationTriggerDetails;
        PyTypeObject* type_AppointmentStoreNotificationTrigger;
        PyTypeObject* type_BackgroundExecutionManager;
        PyTypeObject* type_BackgroundTaskBuilder;
        PyTypeObject* type_BackgroundTaskCompletedEventArgs;
        PyTypeObject* type_BackgroundTaskDeferral;
        PyTypeObject* type_BackgroundTaskProgressEventArgs;
        PyTypeObject* type_BackgroundTaskRegistration;
        PyTypeObject* type_BackgroundTaskRegistrationGroup;
        PyTypeObject* type_BackgroundWorkCost;
        PyTypeObject* type_BluetoothLEAdvertisementPublisherTrigger;
        PyTypeObject* type_BluetoothLEAdvertisementWatcherTrigger;
        PyTypeObject* type_CachedFileUpdaterTrigger;
        PyTypeObject* type_CachedFileUpdaterTriggerDetails;
        PyTypeObject* type_ChatMessageNotificationTrigger;
        PyTypeObject* type_ChatMessageReceivedNotificationTrigger;
        PyTypeObject* type_CommunicationBlockingAppSetAsActiveTrigger;
        PyTypeObject* type_ContactStoreNotificationTrigger;
        PyTypeObject* type_ContentPrefetchTrigger;
        PyTypeObject* type_ConversationalAgentTrigger;
        PyTypeObject* type_CustomSystemEventTrigger;
        PyTypeObject* type_DeviceConnectionChangeTrigger;
        PyTypeObject* type_DeviceManufacturerNotificationTrigger;
        PyTypeObject* type_DeviceServicingTrigger;
        PyTypeObject* type_DeviceUseTrigger;
        PyTypeObject* type_DeviceWatcherTrigger;
        PyTypeObject* type_EmailStoreNotificationTrigger;
        PyTypeObject* type_GattCharacteristicNotificationTrigger;
        PyTypeObject* type_GattServiceProviderTrigger;
        PyTypeObject* type_GattServiceProviderTriggerResult;
        PyTypeObject* type_GeovisitTrigger;
        PyTypeObject* type_LocationTrigger;
        PyTypeObject* type_MaintenanceTrigger;
        PyTypeObject* type_MediaProcessingTrigger;
        PyTypeObject* type_MobileBroadbandDeviceServiceNotificationTrigger;
        PyTypeObject* type_MobileBroadbandPcoDataChangeTrigger;
        PyTypeObject* type_MobileBroadbandPinLockStateChangeTrigger;
        PyTypeObject* type_MobileBroadbandRadioStateChangeTrigger;
        PyTypeObject* type_MobileBroadbandRegistrationStateChangeTrigger;
        PyTypeObject* type_NetworkOperatorDataUsageTrigger;
        PyTypeObject* type_NetworkOperatorHotspotAuthenticationTrigger;
        PyTypeObject* type_NetworkOperatorNotificationTrigger;
        PyTypeObject* type_PaymentAppCanMakePaymentTrigger;
        PyTypeObject* type_PhoneTrigger;
        PyTypeObject* type_PushNotificationTrigger;
        PyTypeObject* type_RcsEndUserMessageAvailableTrigger;
        PyTypeObject* type_RfcommConnectionTrigger;
        PyTypeObject* type_SecondaryAuthenticationFactorAuthenticationTrigger;
        PyTypeObject* type_SensorDataThresholdTrigger;
        PyTypeObject* type_SmartCardTrigger;
        PyTypeObject* type_SmsMessageReceivedTrigger;
        PyTypeObject* type_SocketActivityTrigger;
        PyTypeObject* type_StorageLibraryChangeTrackerTrigger;
        PyTypeObject* type_StorageLibraryContentChangedTrigger;
        PyTypeObject* type_SystemCondition;
        PyTypeObject* type_SystemTrigger;
        PyTypeObject* type_TetheringEntitlementCheckTrigger;
        PyTypeObject* type_TimeTrigger;
        PyTypeObject* type_ToastNotificationActionTrigger;
        PyTypeObject* type_ToastNotificationHistoryChangedTrigger;
        PyTypeObject* type_UserNotificationChangedTrigger;
        PyTypeObject* type_WiFiOnDemandHotspotConnectTrigger;
        PyTypeObject* type_WiFiOnDemandHotspotUpdateMetadataTrigger;
        PyTypeObject* type_IBackgroundCondition;
        PyTypeObject* type_IBackgroundTask;
        PyTypeObject* type_IBackgroundTaskInstance;
        PyTypeObject* type_IBackgroundTaskInstance2;
        PyTypeObject* type_IBackgroundTaskInstance4;
        PyTypeObject* type_IBackgroundTaskRegistration;
        PyTypeObject* type_IBackgroundTaskRegistration2;
        PyTypeObject* type_IBackgroundTaskRegistration3;
        PyTypeObject* type_IBackgroundTrigger;
    };

    static PyObject* register_AlarmAccessStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AlarmAccessStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AlarmAccessStatus = type;
        Py_INCREF(state->type_AlarmAccessStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_ApplicationTriggerResult(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ApplicationTriggerResult)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ApplicationTriggerResult = type;
        Py_INCREF(state->type_ApplicationTriggerResult);


        Py_RETURN_NONE;
    }

    static PyObject* register_BackgroundAccessRequestKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_BackgroundAccessRequestKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_BackgroundAccessRequestKind = type;
        Py_INCREF(state->type_BackgroundAccessRequestKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_BackgroundAccessStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_BackgroundAccessStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_BackgroundAccessStatus = type;
        Py_INCREF(state->type_BackgroundAccessStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_BackgroundTaskCancellationReason(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_BackgroundTaskCancellationReason)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_BackgroundTaskCancellationReason = type;
        Py_INCREF(state->type_BackgroundTaskCancellationReason);


        Py_RETURN_NONE;
    }

    static PyObject* register_BackgroundTaskThrottleCounter(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_BackgroundTaskThrottleCounter)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_BackgroundTaskThrottleCounter = type;
        Py_INCREF(state->type_BackgroundTaskThrottleCounter);


        Py_RETURN_NONE;
    }

    static PyObject* register_BackgroundWorkCostValue(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_BackgroundWorkCostValue)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_BackgroundWorkCostValue = type;
        Py_INCREF(state->type_BackgroundWorkCostValue);


        Py_RETURN_NONE;
    }

    static PyObject* register_CustomSystemEventTriggerRecurrence(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CustomSystemEventTriggerRecurrence)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CustomSystemEventTriggerRecurrence = type;
        Py_INCREF(state->type_CustomSystemEventTriggerRecurrence);


        Py_RETURN_NONE;
    }

    static PyObject* register_DeviceTriggerResult(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DeviceTriggerResult)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DeviceTriggerResult = type;
        Py_INCREF(state->type_DeviceTriggerResult);


        Py_RETURN_NONE;
    }

    static PyObject* register_LocationTriggerType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_LocationTriggerType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_LocationTriggerType = type;
        Py_INCREF(state->type_LocationTriggerType);


        Py_RETURN_NONE;
    }

    static PyObject* register_MediaProcessingTriggerResult(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MediaProcessingTriggerResult)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MediaProcessingTriggerResult = type;
        Py_INCREF(state->type_MediaProcessingTriggerResult);


        Py_RETURN_NONE;
    }

    static PyObject* register_SystemConditionType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SystemConditionType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SystemConditionType = type;
        Py_INCREF(state->type_SystemConditionType);


        Py_RETURN_NONE;
    }

    static PyObject* register_SystemTriggerType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SystemTriggerType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SystemTriggerType = type;
        Py_INCREF(state->type_SystemTriggerType);


        Py_RETURN_NONE;
    }

    // ----- ActivitySensorTrigger class --------------------
    static constexpr const char* const type_name_ActivitySensorTrigger = "ActivitySensorTrigger";

    static PyObject* _new_ActivitySensorTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::ApplicationModel::Background::ActivitySensorTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ActivitySensorTrigger(py::wrapper::Windows::ApplicationModel::Background::ActivitySensorTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActivitySensorTrigger_get_MinimumReportInterval(py::wrapper::Windows::ApplicationModel::Background::ActivitySensorTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.ActivitySensorTrigger", L"MinimumReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensorTrigger_get_ReportInterval(py::wrapper::Windows::ApplicationModel::Background::ActivitySensorTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.ActivitySensorTrigger", L"ReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensorTrigger_get_SubscribedActivities(py::wrapper::Windows::ApplicationModel::Background::ActivitySensorTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.ActivitySensorTrigger", L"SubscribedActivities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SubscribedActivities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensorTrigger_get_SupportedActivities(py::wrapper::Windows::ApplicationModel::Background::ActivitySensorTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.ActivitySensorTrigger", L"SupportedActivities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedActivities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ActivitySensorTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::ActivitySensorTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ActivitySensorTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ActivitySensorTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivitySensorTrigger[] = {
        { "_assign_array_", _assign_array_ActivitySensorTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActivitySensorTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ActivitySensorTrigger[] = {
        { "minimum_report_interval", reinterpret_cast<getter>(ActivitySensorTrigger_get_MinimumReportInterval), nullptr, nullptr, nullptr },
        { "report_interval", reinterpret_cast<getter>(ActivitySensorTrigger_get_ReportInterval), nullptr, nullptr, nullptr },
        { "subscribed_activities", reinterpret_cast<getter>(ActivitySensorTrigger_get_SubscribedActivities), nullptr, nullptr, nullptr },
        { "supported_activities", reinterpret_cast<getter>(ActivitySensorTrigger_get_SupportedActivities), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ActivitySensorTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ActivitySensorTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ActivitySensorTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ActivitySensorTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ActivitySensorTrigger) },
        { },
    };

    static PyType_Spec type_spec_ActivitySensorTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.ActivitySensorTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ActivitySensorTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivitySensorTrigger
    };

    // ----- AlarmApplicationManager class --------------------
    static constexpr const char* const type_name_AlarmApplicationManager = "AlarmApplicationManager";

    static PyObject* _new_AlarmApplicationManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AlarmApplicationManager);
        return nullptr;
    }

    static PyObject* AlarmApplicationManager_GetAccessStatus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.AlarmApplicationManager", L"GetAccessStatus", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Background::AlarmApplicationManager::GetAccessStatus());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AlarmApplicationManager_RequestAccessAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.AlarmApplicationManager", L"RequestAccessAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Background::AlarmApplicationManager::RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_AlarmApplicationManager[] = {
        { "get_access_status", reinterpret_cast<PyCFunction>(AlarmApplicationManager_GetAccessStatus), METH_VARARGS | METH_STATIC, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(AlarmApplicationManager_RequestAccessAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AlarmApplicationManager[] = {
        { }
    };

    static PyType_Slot _type_slots_AlarmApplicationManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AlarmApplicationManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AlarmApplicationManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AlarmApplicationManager) },
        { },
    };

    static PyType_Spec type_spec_AlarmApplicationManager =
    {
        "_winsdk_Windows_ApplicationModel_Background.AlarmApplicationManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AlarmApplicationManager
    };

    // ----- AppBroadcastTrigger class --------------------
    static constexpr const char* const type_name_AppBroadcastTrigger = "AppBroadcastTrigger";

    static PyObject* _new_AppBroadcastTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Background::AppBroadcastTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppBroadcastTrigger(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastTrigger_get_ProviderInfo(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTrigger", L"ProviderInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastTrigger_put_ProviderInfo(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTrigger", L"ProviderInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo>(arg);

            self->obj.ProviderInfo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AppBroadcastTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::AppBroadcastTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::AppBroadcastTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastTrigger[] = {
        { "_assign_array_", _assign_array_AppBroadcastTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastTrigger[] = {
        { "provider_info", reinterpret_cast<getter>(AppBroadcastTrigger_get_ProviderInfo), reinterpret_cast<setter>(AppBroadcastTrigger_put_ProviderInfo), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastTrigger) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.AppBroadcastTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastTrigger
    };

    // ----- AppBroadcastTriggerProviderInfo class --------------------
    static constexpr const char* const type_name_AppBroadcastTriggerProviderInfo = "AppBroadcastTriggerProviderInfo";

    static PyObject* _new_AppBroadcastTriggerProviderInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastTriggerProviderInfo);
        return nullptr;
    }

    static void _dealloc_AppBroadcastTriggerProviderInfo(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastTriggerProviderInfo_get_VideoKeyFrameInterval(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTriggerProviderInfo", L"VideoKeyFrameInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoKeyFrameInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastTriggerProviderInfo_put_VideoKeyFrameInterval(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTriggerProviderInfo", L"VideoKeyFrameInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.VideoKeyFrameInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastTriggerProviderInfo_get_MaxVideoWidth(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTriggerProviderInfo", L"MaxVideoWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxVideoWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastTriggerProviderInfo_put_MaxVideoWidth(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTriggerProviderInfo", L"MaxVideoWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.MaxVideoWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastTriggerProviderInfo_get_MaxVideoHeight(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTriggerProviderInfo", L"MaxVideoHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxVideoHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastTriggerProviderInfo_put_MaxVideoHeight(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTriggerProviderInfo", L"MaxVideoHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.MaxVideoHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastTriggerProviderInfo_get_MaxVideoBitrate(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTriggerProviderInfo", L"MaxVideoBitrate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxVideoBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastTriggerProviderInfo_put_MaxVideoBitrate(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTriggerProviderInfo", L"MaxVideoBitrate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.MaxVideoBitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastTriggerProviderInfo_get_LogoResource(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTriggerProviderInfo", L"LogoResource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LogoResource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastTriggerProviderInfo_put_LogoResource(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTriggerProviderInfo", L"LogoResource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.LogoResource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastTriggerProviderInfo_get_DisplayNameResource(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTriggerProviderInfo", L"DisplayNameResource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayNameResource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastTriggerProviderInfo_put_DisplayNameResource(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTriggerProviderInfo", L"DisplayNameResource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayNameResource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AppBroadcastTriggerProviderInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastTriggerProviderInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastTriggerProviderInfo[] = {
        { "_assign_array_", _assign_array_AppBroadcastTriggerProviderInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastTriggerProviderInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastTriggerProviderInfo[] = {
        { "video_key_frame_interval", reinterpret_cast<getter>(AppBroadcastTriggerProviderInfo_get_VideoKeyFrameInterval), reinterpret_cast<setter>(AppBroadcastTriggerProviderInfo_put_VideoKeyFrameInterval), nullptr, nullptr },
        { "max_video_width", reinterpret_cast<getter>(AppBroadcastTriggerProviderInfo_get_MaxVideoWidth), reinterpret_cast<setter>(AppBroadcastTriggerProviderInfo_put_MaxVideoWidth), nullptr, nullptr },
        { "max_video_height", reinterpret_cast<getter>(AppBroadcastTriggerProviderInfo_get_MaxVideoHeight), reinterpret_cast<setter>(AppBroadcastTriggerProviderInfo_put_MaxVideoHeight), nullptr, nullptr },
        { "max_video_bitrate", reinterpret_cast<getter>(AppBroadcastTriggerProviderInfo_get_MaxVideoBitrate), reinterpret_cast<setter>(AppBroadcastTriggerProviderInfo_put_MaxVideoBitrate), nullptr, nullptr },
        { "logo_resource", reinterpret_cast<getter>(AppBroadcastTriggerProviderInfo_get_LogoResource), reinterpret_cast<setter>(AppBroadcastTriggerProviderInfo_put_LogoResource), nullptr, nullptr },
        { "display_name_resource", reinterpret_cast<getter>(AppBroadcastTriggerProviderInfo_get_DisplayNameResource), reinterpret_cast<setter>(AppBroadcastTriggerProviderInfo_put_DisplayNameResource), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastTriggerProviderInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastTriggerProviderInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastTriggerProviderInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastTriggerProviderInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastTriggerProviderInfo) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastTriggerProviderInfo =
    {
        "_winsdk_Windows_ApplicationModel_Background.AppBroadcastTriggerProviderInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastTriggerProviderInfo
    };

    // ----- ApplicationTrigger class --------------------
    static constexpr const char* const type_name_ApplicationTrigger = "ApplicationTrigger";

    static PyObject* _new_ApplicationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::ApplicationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ApplicationTrigger(py::wrapper::Windows::ApplicationModel::Background::ApplicationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ApplicationTrigger_RequestAsync(py::wrapper::Windows::ApplicationModel::Background::ApplicationTrigger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.ApplicationTrigger", L"RequestAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RequestAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.ApplicationTrigger", L"RequestAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 0);

                return py::convert(self->obj.RequestAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ApplicationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::ApplicationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ApplicationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ApplicationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationTrigger[] = {
        { "request_async", reinterpret_cast<PyCFunction>(ApplicationTrigger_RequestAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ApplicationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ApplicationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ApplicationTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_ApplicationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ApplicationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ApplicationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ApplicationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ApplicationTrigger) },
        { },
    };

    static PyType_Spec type_spec_ApplicationTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.ApplicationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ApplicationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationTrigger
    };

    // ----- ApplicationTriggerDetails class --------------------
    static constexpr const char* const type_name_ApplicationTriggerDetails = "ApplicationTriggerDetails";

    static PyObject* _new_ApplicationTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ApplicationTriggerDetails);
        return nullptr;
    }

    static void _dealloc_ApplicationTriggerDetails(py::wrapper::Windows::ApplicationModel::Background::ApplicationTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ApplicationTriggerDetails_get_Arguments(py::wrapper::Windows::ApplicationModel::Background::ApplicationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.ApplicationTriggerDetails", L"Arguments"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ApplicationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::ApplicationTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ApplicationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ApplicationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationTriggerDetails[] = {
        { "_assign_array_", _assign_array_ApplicationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ApplicationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ApplicationTriggerDetails[] = {
        { "arguments", reinterpret_cast<getter>(ApplicationTriggerDetails_get_Arguments), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ApplicationTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ApplicationTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ApplicationTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ApplicationTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ApplicationTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_ApplicationTriggerDetails =
    {
        "_winsdk_Windows_ApplicationModel_Background.ApplicationTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ApplicationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationTriggerDetails
    };

    // ----- AppointmentStoreNotificationTrigger class --------------------
    static constexpr const char* const type_name_AppointmentStoreNotificationTrigger = "AppointmentStoreNotificationTrigger";

    static PyObject* _new_AppointmentStoreNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::AppointmentStoreNotificationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppointmentStoreNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::AppointmentStoreNotificationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_AppointmentStoreNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::AppointmentStoreNotificationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppointmentStoreNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::AppointmentStoreNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentStoreNotificationTrigger[] = {
        { "_assign_array_", _assign_array_AppointmentStoreNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentStoreNotificationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentStoreNotificationTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_AppointmentStoreNotificationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentStoreNotificationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppointmentStoreNotificationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentStoreNotificationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentStoreNotificationTrigger) },
        { },
    };

    static PyType_Spec type_spec_AppointmentStoreNotificationTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.AppointmentStoreNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::AppointmentStoreNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentStoreNotificationTrigger
    };

    // ----- BackgroundExecutionManager class --------------------
    static constexpr const char* const type_name_BackgroundExecutionManager = "BackgroundExecutionManager";

    static PyObject* _new_BackgroundExecutionManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BackgroundExecutionManager);
        return nullptr;
    }

    static PyObject* BackgroundExecutionManager_GetAccessStatus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundExecutionManager", L"GetAccessStatus", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::GetAccessStatus());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundExecutionManager", L"GetAccessStatus", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::GetAccessStatus(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundExecutionManager_GetAccessStatusForModernStandby(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundExecutionManager", L"GetAccessStatusForModernStandby", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::GetAccessStatusForModernStandby());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundExecutionManager", L"GetAccessStatusForModernStandby", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::GetAccessStatusForModernStandby(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundExecutionManager_RemoveAccess(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundExecutionManager", L"RemoveAccess", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::RemoveAccess();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundExecutionManager", L"RemoveAccess", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::RemoveAccess(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundExecutionManager_RequestAccessAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundExecutionManager", L"RequestAccessAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundExecutionManager", L"RequestAccessAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::RequestAccessAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundExecutionManager_RequestAccessKindAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundExecutionManager", L"RequestAccessKindAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundAccessRequestKind>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::RequestAccessKindAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundExecutionManager_RequestAccessKindForModernStandbyAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundExecutionManager", L"RequestAccessKindForModernStandbyAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundAccessRequestKind>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::RequestAccessKindForModernStandbyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundExecutionManager[] = {
        { "get_access_status", reinterpret_cast<PyCFunction>(BackgroundExecutionManager_GetAccessStatus), METH_VARARGS | METH_STATIC, nullptr },
        { "get_access_status_for_modern_standby", reinterpret_cast<PyCFunction>(BackgroundExecutionManager_GetAccessStatusForModernStandby), METH_VARARGS | METH_STATIC, nullptr },
        { "remove_access", reinterpret_cast<PyCFunction>(BackgroundExecutionManager_RemoveAccess), METH_VARARGS | METH_STATIC, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(BackgroundExecutionManager_RequestAccessAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "request_access_kind_async", reinterpret_cast<PyCFunction>(BackgroundExecutionManager_RequestAccessKindAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "request_access_kind_for_modern_standby_async", reinterpret_cast<PyCFunction>(BackgroundExecutionManager_RequestAccessKindForModernStandbyAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundExecutionManager[] = {
        { }
    };

    static PyType_Slot _type_slots_BackgroundExecutionManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundExecutionManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundExecutionManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundExecutionManager) },
        { },
    };

    static PyType_Spec type_spec_BackgroundExecutionManager =
    {
        "_winsdk_Windows_ApplicationModel_Background.BackgroundExecutionManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundExecutionManager
    };

    // ----- BackgroundTaskBuilder class --------------------
    static constexpr const char* const type_name_BackgroundTaskBuilder = "BackgroundTaskBuilder";

    static PyObject* _new_BackgroundTaskBuilder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::BackgroundTaskBuilder instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BackgroundTaskBuilder(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundTaskBuilder_AddCondition(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"AddCondition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::IBackgroundCondition>(args, 0);

                self->obj.AddCondition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskBuilder_Register(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"Register", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Register());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskBuilder_SetTaskEntryPointClsid(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"SetTaskEntryPointClsid", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.SetTaskEntryPointClsid(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskBuilder_SetTrigger(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"SetTrigger", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::IBackgroundTrigger>(args, 0);

                self->obj.SetTrigger(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskBuilder_get_TaskEntryPoint(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"TaskEntryPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TaskEntryPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundTaskBuilder_put_TaskEntryPoint(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"TaskEntryPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TaskEntryPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundTaskBuilder_get_Name(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundTaskBuilder_put_Name(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundTaskBuilder_get_CancelOnConditionLoss(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"CancelOnConditionLoss"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CancelOnConditionLoss());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundTaskBuilder_put_CancelOnConditionLoss(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"CancelOnConditionLoss"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CancelOnConditionLoss(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundTaskBuilder_get_IsNetworkRequested(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"IsNetworkRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsNetworkRequested());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundTaskBuilder_put_IsNetworkRequested(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"IsNetworkRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsNetworkRequested(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundTaskBuilder_get_TaskGroup(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"TaskGroup"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TaskGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundTaskBuilder_put_TaskGroup(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"TaskGroup"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup>(arg);

            self->obj.TaskGroup(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_BackgroundTaskBuilder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::BackgroundTaskBuilder>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundTaskBuilder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::BackgroundTaskBuilder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTaskBuilder[] = {
        { "add_condition", reinterpret_cast<PyCFunction>(BackgroundTaskBuilder_AddCondition), METH_VARARGS, nullptr },
        { "register", reinterpret_cast<PyCFunction>(BackgroundTaskBuilder_Register), METH_VARARGS, nullptr },
        { "set_task_entry_point_clsid", reinterpret_cast<PyCFunction>(BackgroundTaskBuilder_SetTaskEntryPointClsid), METH_VARARGS, nullptr },
        { "set_trigger", reinterpret_cast<PyCFunction>(BackgroundTaskBuilder_SetTrigger), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BackgroundTaskBuilder, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundTaskBuilder), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTaskBuilder[] = {
        { "task_entry_point", reinterpret_cast<getter>(BackgroundTaskBuilder_get_TaskEntryPoint), reinterpret_cast<setter>(BackgroundTaskBuilder_put_TaskEntryPoint), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(BackgroundTaskBuilder_get_Name), reinterpret_cast<setter>(BackgroundTaskBuilder_put_Name), nullptr, nullptr },
        { "cancel_on_condition_loss", reinterpret_cast<getter>(BackgroundTaskBuilder_get_CancelOnConditionLoss), reinterpret_cast<setter>(BackgroundTaskBuilder_put_CancelOnConditionLoss), nullptr, nullptr },
        { "is_network_requested", reinterpret_cast<getter>(BackgroundTaskBuilder_get_IsNetworkRequested), reinterpret_cast<setter>(BackgroundTaskBuilder_put_IsNetworkRequested), nullptr, nullptr },
        { "task_group", reinterpret_cast<getter>(BackgroundTaskBuilder_get_TaskGroup), reinterpret_cast<setter>(BackgroundTaskBuilder_put_TaskGroup), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundTaskBuilder[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundTaskBuilder) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundTaskBuilder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundTaskBuilder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundTaskBuilder) },
        { },
    };

    static PyType_Spec type_spec_BackgroundTaskBuilder =
    {
        "_winsdk_Windows_ApplicationModel_Background.BackgroundTaskBuilder",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTaskBuilder
    };

    // ----- BackgroundTaskCompletedEventArgs class --------------------
    static constexpr const char* const type_name_BackgroundTaskCompletedEventArgs = "BackgroundTaskCompletedEventArgs";

    static PyObject* _new_BackgroundTaskCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BackgroundTaskCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_BackgroundTaskCompletedEventArgs(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundTaskCompletedEventArgs_CheckResult(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundTaskCompletedEventArgs", L"CheckResult", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.CheckResult();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskCompletedEventArgs_get_InstanceId(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskCompletedEventArgs", L"InstanceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackgroundTaskCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundTaskCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTaskCompletedEventArgs[] = {
        { "check_result", reinterpret_cast<PyCFunction>(BackgroundTaskCompletedEventArgs_CheckResult), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BackgroundTaskCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundTaskCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTaskCompletedEventArgs[] = {
        { "instance_id", reinterpret_cast<getter>(BackgroundTaskCompletedEventArgs_get_InstanceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundTaskCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundTaskCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundTaskCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundTaskCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundTaskCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_BackgroundTaskCompletedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Background.BackgroundTaskCompletedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTaskCompletedEventArgs
    };

    // ----- BackgroundTaskDeferral class --------------------
    static constexpr const char* const type_name_BackgroundTaskDeferral = "BackgroundTaskDeferral";

    static PyObject* _new_BackgroundTaskDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BackgroundTaskDeferral);
        return nullptr;
    }

    static void _dealloc_BackgroundTaskDeferral(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundTaskDeferral_Complete(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundTaskDeferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackgroundTaskDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::BackgroundTaskDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundTaskDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::BackgroundTaskDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTaskDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(BackgroundTaskDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BackgroundTaskDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundTaskDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTaskDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_BackgroundTaskDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundTaskDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundTaskDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundTaskDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundTaskDeferral) },
        { },
    };

    static PyType_Spec type_spec_BackgroundTaskDeferral =
    {
        "_winsdk_Windows_ApplicationModel_Background.BackgroundTaskDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTaskDeferral
    };

    // ----- BackgroundTaskProgressEventArgs class --------------------
    static constexpr const char* const type_name_BackgroundTaskProgressEventArgs = "BackgroundTaskProgressEventArgs";

    static PyObject* _new_BackgroundTaskProgressEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BackgroundTaskProgressEventArgs);
        return nullptr;
    }

    static void _dealloc_BackgroundTaskProgressEventArgs(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskProgressEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundTaskProgressEventArgs_get_InstanceId(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskProgressEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskProgressEventArgs", L"InstanceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskProgressEventArgs_get_Progress(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskProgressEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskProgressEventArgs", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackgroundTaskProgressEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::BackgroundTaskProgressEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundTaskProgressEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::BackgroundTaskProgressEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTaskProgressEventArgs[] = {
        { "_assign_array_", _assign_array_BackgroundTaskProgressEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundTaskProgressEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTaskProgressEventArgs[] = {
        { "instance_id", reinterpret_cast<getter>(BackgroundTaskProgressEventArgs_get_InstanceId), nullptr, nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(BackgroundTaskProgressEventArgs_get_Progress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundTaskProgressEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundTaskProgressEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundTaskProgressEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundTaskProgressEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundTaskProgressEventArgs) },
        { },
    };

    static PyType_Spec type_spec_BackgroundTaskProgressEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Background.BackgroundTaskProgressEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskProgressEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTaskProgressEventArgs
    };

    // ----- BackgroundTaskRegistration class --------------------
    static constexpr const char* const type_name_BackgroundTaskRegistration = "BackgroundTaskRegistration";

    static PyObject* _new_BackgroundTaskRegistration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BackgroundTaskRegistration);
        return nullptr;
    }

    static void _dealloc_BackgroundTaskRegistration(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundTaskRegistration_GetTaskGroup(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistration", L"GetTaskGroup", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistration::GetTaskGroup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_Unregister(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistration", L"Unregister", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.Unregister(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_get_Name(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistration", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_get_TaskId(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistration", L"TaskId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_get_Trigger(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistration", L"Trigger"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Trigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_get_TaskGroup(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistration", L"TaskGroup"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TaskGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_get_AllTasks(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistration", L"AllTasks"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistration::AllTasks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_get_AllTaskGroups(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistration", L"AllTaskGroups"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistration::AllTaskGroups());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_add_Completed(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistration", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventHandler>(arg);

            return py::convert(self->obj.Completed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_remove_Completed(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistration", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_add_Progress(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistration", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskProgressEventHandler>(arg);

            return py::convert(self->obj.Progress(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_remove_Progress(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistration", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Progress(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackgroundTaskRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundTaskRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTaskRegistration[] = {
        { "get_task_group", reinterpret_cast<PyCFunction>(BackgroundTaskRegistration_GetTaskGroup), METH_VARARGS | METH_STATIC, nullptr },
        { "unregister", reinterpret_cast<PyCFunction>(BackgroundTaskRegistration_Unregister), METH_VARARGS, nullptr },
        { "add_completed", reinterpret_cast<PyCFunction>(BackgroundTaskRegistration_add_Completed), METH_O, nullptr },
        { "remove_completed", reinterpret_cast<PyCFunction>(BackgroundTaskRegistration_remove_Completed), METH_O, nullptr },
        { "add_progress", reinterpret_cast<PyCFunction>(BackgroundTaskRegistration_add_Progress), METH_O, nullptr },
        { "remove_progress", reinterpret_cast<PyCFunction>(BackgroundTaskRegistration_remove_Progress), METH_O, nullptr },
        { "_assign_array_", _assign_array_BackgroundTaskRegistration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundTaskRegistration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTaskRegistration[] = {
        { "name", reinterpret_cast<getter>(BackgroundTaskRegistration_get_Name), nullptr, nullptr, nullptr },
        { "task_id", reinterpret_cast<getter>(BackgroundTaskRegistration_get_TaskId), nullptr, nullptr, nullptr },
        { "trigger", reinterpret_cast<getter>(BackgroundTaskRegistration_get_Trigger), nullptr, nullptr, nullptr },
        { "task_group", reinterpret_cast<getter>(BackgroundTaskRegistration_get_TaskGroup), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundTaskRegistration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundTaskRegistration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundTaskRegistration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundTaskRegistration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundTaskRegistration) },
        { },
    };

    static PyType_Spec type_spec_BackgroundTaskRegistration =
    {
        "_winsdk_Windows_ApplicationModel_Background.BackgroundTaskRegistration",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTaskRegistration
    };

    static PyGetSetDef getset_BackgroundTaskRegistration_Meta[] = {
        { "all_tasks", reinterpret_cast<getter>(BackgroundTaskRegistration_get_AllTasks), nullptr, nullptr, nullptr },
        { "all_task_groups", reinterpret_cast<getter>(BackgroundTaskRegistration_get_AllTaskGroups), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_BackgroundTaskRegistration_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BackgroundTaskRegistration_Meta) },
        { }
    };

    static PyType_Spec type_spec_BackgroundTaskRegistration_Meta =
    {
        "_winsdk_Windows_ApplicationModel_Background.BackgroundTaskRegistration_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BackgroundTaskRegistration_Meta
    };

    // ----- BackgroundTaskRegistrationGroup class --------------------
    static constexpr const char* const type_name_BackgroundTaskRegistrationGroup = "BackgroundTaskRegistrationGroup";

    static PyObject* _new_BackgroundTaskRegistrationGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BackgroundTaskRegistrationGroup(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundTaskRegistrationGroup_get_AllTasks(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistrationGroup", L"AllTasks"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllTasks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistrationGroup_get_Id(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistrationGroup", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistrationGroup_get_Name(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistrationGroup", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistrationGroup_add_BackgroundActivated(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistrationGroup", L"BackgroundActivated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup, winrt::Windows::ApplicationModel::Activation::BackgroundActivatedEventArgs>>(arg);

            return py::convert(self->obj.BackgroundActivated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistrationGroup_remove_BackgroundActivated(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistrationGroup", L"BackgroundActivated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BackgroundActivated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackgroundTaskRegistrationGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundTaskRegistrationGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTaskRegistrationGroup[] = {
        { "add_background_activated", reinterpret_cast<PyCFunction>(BackgroundTaskRegistrationGroup_add_BackgroundActivated), METH_O, nullptr },
        { "remove_background_activated", reinterpret_cast<PyCFunction>(BackgroundTaskRegistrationGroup_remove_BackgroundActivated), METH_O, nullptr },
        { "_assign_array_", _assign_array_BackgroundTaskRegistrationGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundTaskRegistrationGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTaskRegistrationGroup[] = {
        { "all_tasks", reinterpret_cast<getter>(BackgroundTaskRegistrationGroup_get_AllTasks), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(BackgroundTaskRegistrationGroup_get_Id), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(BackgroundTaskRegistrationGroup_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundTaskRegistrationGroup[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundTaskRegistrationGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundTaskRegistrationGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundTaskRegistrationGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundTaskRegistrationGroup) },
        { },
    };

    static PyType_Spec type_spec_BackgroundTaskRegistrationGroup =
    {
        "_winsdk_Windows_ApplicationModel_Background.BackgroundTaskRegistrationGroup",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTaskRegistrationGroup
    };

    // ----- BackgroundWorkCost class --------------------
    static constexpr const char* const type_name_BackgroundWorkCost = "BackgroundWorkCost";

    static PyObject* _new_BackgroundWorkCost(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BackgroundWorkCost);
        return nullptr;
    }

    static PyObject* BackgroundWorkCost_get_CurrentBackgroundWorkCost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundWorkCost", L"CurrentBackgroundWorkCost"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundWorkCost::CurrentBackgroundWorkCost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundWorkCost[] = {
        { }
    };

    static PyGetSetDef _getset_BackgroundWorkCost[] = {
        { }
    };

    static PyType_Slot _type_slots_BackgroundWorkCost[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundWorkCost) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundWorkCost) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundWorkCost) },
        { },
    };

    static PyType_Spec type_spec_BackgroundWorkCost =
    {
        "_winsdk_Windows_ApplicationModel_Background.BackgroundWorkCost",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundWorkCost
    };

    static PyGetSetDef getset_BackgroundWorkCost_Meta[] = {
        { "current_background_work_cost", reinterpret_cast<getter>(BackgroundWorkCost_get_CurrentBackgroundWorkCost), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_BackgroundWorkCost_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BackgroundWorkCost_Meta) },
        { }
    };

    static PyType_Spec type_spec_BackgroundWorkCost_Meta =
    {
        "_winsdk_Windows_ApplicationModel_Background.BackgroundWorkCost_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BackgroundWorkCost_Meta
    };

    // ----- BluetoothLEAdvertisementPublisherTrigger class --------------------
    static constexpr const char* const type_name_BluetoothLEAdvertisementPublisherTrigger = "BluetoothLEAdvertisementPublisherTrigger";

    static PyObject* _new_BluetoothLEAdvertisementPublisherTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BluetoothLEAdvertisementPublisherTrigger(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEAdvertisementPublisherTrigger_get_Advertisement(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementPublisherTrigger", L"Advertisement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Advertisement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementPublisherTrigger_get_UseExtendedFormat(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementPublisherTrigger", L"UseExtendedFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UseExtendedFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementPublisherTrigger_put_UseExtendedFormat(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementPublisherTrigger", L"UseExtendedFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.UseExtendedFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementPublisherTrigger_get_PreferredTransmitPowerLevelInDBm(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementPublisherTrigger", L"PreferredTransmitPowerLevelInDBm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreferredTransmitPowerLevelInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementPublisherTrigger_put_PreferredTransmitPowerLevelInDBm(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementPublisherTrigger", L"PreferredTransmitPowerLevelInDBm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int16_t>>(arg);

            self->obj.PreferredTransmitPowerLevelInDBm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementPublisherTrigger_get_IsAnonymous(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementPublisherTrigger", L"IsAnonymous"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsAnonymous());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementPublisherTrigger_put_IsAnonymous(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementPublisherTrigger", L"IsAnonymous"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAnonymous(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementPublisherTrigger_get_IncludeTransmitPowerLevel(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementPublisherTrigger", L"IncludeTransmitPowerLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IncludeTransmitPowerLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementPublisherTrigger_put_IncludeTransmitPowerLevel(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementPublisherTrigger", L"IncludeTransmitPowerLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IncludeTransmitPowerLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_BluetoothLEAdvertisementPublisherTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BluetoothLEAdvertisementPublisherTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEAdvertisementPublisherTrigger[] = {
        { "_assign_array_", _assign_array_BluetoothLEAdvertisementPublisherTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEAdvertisementPublisherTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothLEAdvertisementPublisherTrigger[] = {
        { "advertisement", reinterpret_cast<getter>(BluetoothLEAdvertisementPublisherTrigger_get_Advertisement), nullptr, nullptr, nullptr },
        { "use_extended_format", reinterpret_cast<getter>(BluetoothLEAdvertisementPublisherTrigger_get_UseExtendedFormat), reinterpret_cast<setter>(BluetoothLEAdvertisementPublisherTrigger_put_UseExtendedFormat), nullptr, nullptr },
        { "preferred_transmit_power_level_in_d_bm", reinterpret_cast<getter>(BluetoothLEAdvertisementPublisherTrigger_get_PreferredTransmitPowerLevelInDBm), reinterpret_cast<setter>(BluetoothLEAdvertisementPublisherTrigger_put_PreferredTransmitPowerLevelInDBm), nullptr, nullptr },
        { "is_anonymous", reinterpret_cast<getter>(BluetoothLEAdvertisementPublisherTrigger_get_IsAnonymous), reinterpret_cast<setter>(BluetoothLEAdvertisementPublisherTrigger_put_IsAnonymous), nullptr, nullptr },
        { "include_transmit_power_level", reinterpret_cast<getter>(BluetoothLEAdvertisementPublisherTrigger_get_IncludeTransmitPowerLevel), reinterpret_cast<setter>(BluetoothLEAdvertisementPublisherTrigger_put_IncludeTransmitPowerLevel), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothLEAdvertisementPublisherTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothLEAdvertisementPublisherTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BluetoothLEAdvertisementPublisherTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothLEAdvertisementPublisherTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothLEAdvertisementPublisherTrigger) },
        { },
    };

    static PyType_Spec type_spec_BluetoothLEAdvertisementPublisherTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.BluetoothLEAdvertisementPublisherTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEAdvertisementPublisherTrigger
    };

    // ----- BluetoothLEAdvertisementWatcherTrigger class --------------------
    static constexpr const char* const type_name_BluetoothLEAdvertisementWatcherTrigger = "BluetoothLEAdvertisementWatcherTrigger";

    static PyObject* _new_BluetoothLEAdvertisementWatcherTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BluetoothLEAdvertisementWatcherTrigger(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEAdvertisementWatcherTrigger_get_SignalStrengthFilter(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger", L"SignalStrengthFilter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SignalStrengthFilter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementWatcherTrigger_put_SignalStrengthFilter(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger", L"SignalStrengthFilter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter>(arg);

            self->obj.SignalStrengthFilter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcherTrigger_get_AdvertisementFilter(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger", L"AdvertisementFilter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AdvertisementFilter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementWatcherTrigger_put_AdvertisementFilter(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger", L"AdvertisementFilter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter>(arg);

            self->obj.AdvertisementFilter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcherTrigger_get_MaxOutOfRangeTimeout(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger", L"MaxOutOfRangeTimeout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxOutOfRangeTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcherTrigger_get_MaxSamplingInterval(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger", L"MaxSamplingInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxSamplingInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcherTrigger_get_MinOutOfRangeTimeout(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger", L"MinOutOfRangeTimeout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinOutOfRangeTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcherTrigger_get_MinSamplingInterval(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger", L"MinSamplingInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinSamplingInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcherTrigger_get_AllowExtendedAdvertisements(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger", L"AllowExtendedAdvertisements"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowExtendedAdvertisements());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementWatcherTrigger_put_AllowExtendedAdvertisements(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger", L"AllowExtendedAdvertisements"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowExtendedAdvertisements(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_BluetoothLEAdvertisementWatcherTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BluetoothLEAdvertisementWatcherTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEAdvertisementWatcherTrigger[] = {
        { "_assign_array_", _assign_array_BluetoothLEAdvertisementWatcherTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEAdvertisementWatcherTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothLEAdvertisementWatcherTrigger[] = {
        { "signal_strength_filter", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcherTrigger_get_SignalStrengthFilter), reinterpret_cast<setter>(BluetoothLEAdvertisementWatcherTrigger_put_SignalStrengthFilter), nullptr, nullptr },
        { "advertisement_filter", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcherTrigger_get_AdvertisementFilter), reinterpret_cast<setter>(BluetoothLEAdvertisementWatcherTrigger_put_AdvertisementFilter), nullptr, nullptr },
        { "max_out_of_range_timeout", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcherTrigger_get_MaxOutOfRangeTimeout), nullptr, nullptr, nullptr },
        { "max_sampling_interval", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcherTrigger_get_MaxSamplingInterval), nullptr, nullptr, nullptr },
        { "min_out_of_range_timeout", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcherTrigger_get_MinOutOfRangeTimeout), nullptr, nullptr, nullptr },
        { "min_sampling_interval", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcherTrigger_get_MinSamplingInterval), nullptr, nullptr, nullptr },
        { "allow_extended_advertisements", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcherTrigger_get_AllowExtendedAdvertisements), reinterpret_cast<setter>(BluetoothLEAdvertisementWatcherTrigger_put_AllowExtendedAdvertisements), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothLEAdvertisementWatcherTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothLEAdvertisementWatcherTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BluetoothLEAdvertisementWatcherTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothLEAdvertisementWatcherTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothLEAdvertisementWatcherTrigger) },
        { },
    };

    static PyType_Spec type_spec_BluetoothLEAdvertisementWatcherTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.BluetoothLEAdvertisementWatcherTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEAdvertisementWatcherTrigger
    };

    // ----- CachedFileUpdaterTrigger class --------------------
    static constexpr const char* const type_name_CachedFileUpdaterTrigger = "CachedFileUpdaterTrigger";

    static PyObject* _new_CachedFileUpdaterTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::CachedFileUpdaterTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CachedFileUpdaterTrigger(py::wrapper::Windows::ApplicationModel::Background::CachedFileUpdaterTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CachedFileUpdaterTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::CachedFileUpdaterTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CachedFileUpdaterTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::CachedFileUpdaterTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CachedFileUpdaterTrigger[] = {
        { "_assign_array_", _assign_array_CachedFileUpdaterTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CachedFileUpdaterTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CachedFileUpdaterTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_CachedFileUpdaterTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CachedFileUpdaterTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CachedFileUpdaterTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CachedFileUpdaterTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CachedFileUpdaterTrigger) },
        { },
    };

    static PyType_Spec type_spec_CachedFileUpdaterTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.CachedFileUpdaterTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::CachedFileUpdaterTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CachedFileUpdaterTrigger
    };

    // ----- CachedFileUpdaterTriggerDetails class --------------------
    static constexpr const char* const type_name_CachedFileUpdaterTriggerDetails = "CachedFileUpdaterTriggerDetails";

    static PyObject* _new_CachedFileUpdaterTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CachedFileUpdaterTriggerDetails);
        return nullptr;
    }

    static void _dealloc_CachedFileUpdaterTriggerDetails(py::wrapper::Windows::ApplicationModel::Background::CachedFileUpdaterTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CachedFileUpdaterTriggerDetails_get_CanRequestUserInput(py::wrapper::Windows::ApplicationModel::Background::CachedFileUpdaterTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.CachedFileUpdaterTriggerDetails", L"CanRequestUserInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanRequestUserInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterTriggerDetails_get_UpdateRequest(py::wrapper::Windows::ApplicationModel::Background::CachedFileUpdaterTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.CachedFileUpdaterTriggerDetails", L"UpdateRequest"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UpdateRequest());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterTriggerDetails_get_UpdateTarget(py::wrapper::Windows::ApplicationModel::Background::CachedFileUpdaterTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.CachedFileUpdaterTriggerDetails", L"UpdateTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UpdateTarget());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CachedFileUpdaterTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::CachedFileUpdaterTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CachedFileUpdaterTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::CachedFileUpdaterTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CachedFileUpdaterTriggerDetails[] = {
        { "_assign_array_", _assign_array_CachedFileUpdaterTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CachedFileUpdaterTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CachedFileUpdaterTriggerDetails[] = {
        { "can_request_user_input", reinterpret_cast<getter>(CachedFileUpdaterTriggerDetails_get_CanRequestUserInput), nullptr, nullptr, nullptr },
        { "update_request", reinterpret_cast<getter>(CachedFileUpdaterTriggerDetails_get_UpdateRequest), nullptr, nullptr, nullptr },
        { "update_target", reinterpret_cast<getter>(CachedFileUpdaterTriggerDetails_get_UpdateTarget), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CachedFileUpdaterTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CachedFileUpdaterTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CachedFileUpdaterTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CachedFileUpdaterTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CachedFileUpdaterTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_CachedFileUpdaterTriggerDetails =
    {
        "_winsdk_Windows_ApplicationModel_Background.CachedFileUpdaterTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::CachedFileUpdaterTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CachedFileUpdaterTriggerDetails
    };

    // ----- ChatMessageNotificationTrigger class --------------------
    static constexpr const char* const type_name_ChatMessageNotificationTrigger = "ChatMessageNotificationTrigger";

    static PyObject* _new_ChatMessageNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::ChatMessageNotificationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChatMessageNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::ChatMessageNotificationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ChatMessageNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::ChatMessageNotificationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ChatMessageNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageNotificationTrigger[] = {
        { "_assign_array_", _assign_array_ChatMessageNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageNotificationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageNotificationTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_ChatMessageNotificationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageNotificationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageNotificationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageNotificationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageNotificationTrigger) },
        { },
    };

    static PyType_Spec type_spec_ChatMessageNotificationTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.ChatMessageNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ChatMessageNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageNotificationTrigger
    };

    // ----- ChatMessageReceivedNotificationTrigger class --------------------
    static constexpr const char* const type_name_ChatMessageReceivedNotificationTrigger = "ChatMessageReceivedNotificationTrigger";

    static PyObject* _new_ChatMessageReceivedNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::ChatMessageReceivedNotificationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChatMessageReceivedNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::ChatMessageReceivedNotificationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ChatMessageReceivedNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::ChatMessageReceivedNotificationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageReceivedNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ChatMessageReceivedNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageReceivedNotificationTrigger[] = {
        { "_assign_array_", _assign_array_ChatMessageReceivedNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageReceivedNotificationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageReceivedNotificationTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_ChatMessageReceivedNotificationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageReceivedNotificationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageReceivedNotificationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageReceivedNotificationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageReceivedNotificationTrigger) },
        { },
    };

    static PyType_Spec type_spec_ChatMessageReceivedNotificationTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.ChatMessageReceivedNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ChatMessageReceivedNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageReceivedNotificationTrigger
    };

    // ----- CommunicationBlockingAppSetAsActiveTrigger class --------------------
    static constexpr const char* const type_name_CommunicationBlockingAppSetAsActiveTrigger = "CommunicationBlockingAppSetAsActiveTrigger";

    static PyObject* _new_CommunicationBlockingAppSetAsActiveTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::CommunicationBlockingAppSetAsActiveTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CommunicationBlockingAppSetAsActiveTrigger(py::wrapper::Windows::ApplicationModel::Background::CommunicationBlockingAppSetAsActiveTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CommunicationBlockingAppSetAsActiveTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::CommunicationBlockingAppSetAsActiveTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CommunicationBlockingAppSetAsActiveTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::CommunicationBlockingAppSetAsActiveTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CommunicationBlockingAppSetAsActiveTrigger[] = {
        { "_assign_array_", _assign_array_CommunicationBlockingAppSetAsActiveTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CommunicationBlockingAppSetAsActiveTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CommunicationBlockingAppSetAsActiveTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_CommunicationBlockingAppSetAsActiveTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CommunicationBlockingAppSetAsActiveTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CommunicationBlockingAppSetAsActiveTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CommunicationBlockingAppSetAsActiveTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CommunicationBlockingAppSetAsActiveTrigger) },
        { },
    };

    static PyType_Spec type_spec_CommunicationBlockingAppSetAsActiveTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.CommunicationBlockingAppSetAsActiveTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::CommunicationBlockingAppSetAsActiveTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CommunicationBlockingAppSetAsActiveTrigger
    };

    // ----- ContactStoreNotificationTrigger class --------------------
    static constexpr const char* const type_name_ContactStoreNotificationTrigger = "ContactStoreNotificationTrigger";

    static PyObject* _new_ContactStoreNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::ContactStoreNotificationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactStoreNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::ContactStoreNotificationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ContactStoreNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::ContactStoreNotificationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactStoreNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ContactStoreNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactStoreNotificationTrigger[] = {
        { "_assign_array_", _assign_array_ContactStoreNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactStoreNotificationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactStoreNotificationTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactStoreNotificationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactStoreNotificationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactStoreNotificationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactStoreNotificationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactStoreNotificationTrigger) },
        { },
    };

    static PyType_Spec type_spec_ContactStoreNotificationTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.ContactStoreNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ContactStoreNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactStoreNotificationTrigger
    };

    // ----- ContentPrefetchTrigger class --------------------
    static constexpr const char* const type_name_ContentPrefetchTrigger = "ContentPrefetchTrigger";

    static PyObject* _new_ContentPrefetchTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                winrt::Windows::ApplicationModel::Background::ContentPrefetchTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::ContentPrefetchTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContentPrefetchTrigger(py::wrapper::Windows::ApplicationModel::Background::ContentPrefetchTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentPrefetchTrigger_get_WaitInterval(py::wrapper::Windows::ApplicationModel::Background::ContentPrefetchTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.ContentPrefetchTrigger", L"WaitInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WaitInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContentPrefetchTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::ContentPrefetchTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentPrefetchTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ContentPrefetchTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentPrefetchTrigger[] = {
        { "_assign_array_", _assign_array_ContentPrefetchTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentPrefetchTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContentPrefetchTrigger[] = {
        { "wait_interval", reinterpret_cast<getter>(ContentPrefetchTrigger_get_WaitInterval), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContentPrefetchTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentPrefetchTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentPrefetchTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentPrefetchTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentPrefetchTrigger) },
        { },
    };

    static PyType_Spec type_spec_ContentPrefetchTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.ContentPrefetchTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ContentPrefetchTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentPrefetchTrigger
    };

    // ----- ConversationalAgentTrigger class --------------------
    static constexpr const char* const type_name_ConversationalAgentTrigger = "ConversationalAgentTrigger";

    static PyObject* _new_ConversationalAgentTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::ConversationalAgentTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ConversationalAgentTrigger(py::wrapper::Windows::ApplicationModel::Background::ConversationalAgentTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ConversationalAgentTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::ConversationalAgentTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ConversationalAgentTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ConversationalAgentTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConversationalAgentTrigger[] = {
        { "_assign_array_", _assign_array_ConversationalAgentTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ConversationalAgentTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConversationalAgentTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_ConversationalAgentTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ConversationalAgentTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ConversationalAgentTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ConversationalAgentTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ConversationalAgentTrigger) },
        { },
    };

    static PyType_Spec type_spec_ConversationalAgentTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.ConversationalAgentTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ConversationalAgentTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConversationalAgentTrigger
    };

    // ----- CustomSystemEventTrigger class --------------------
    static constexpr const char* const type_name_CustomSystemEventTrigger = "CustomSystemEventTrigger";

    static PyObject* _new_CustomSystemEventTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Background::CustomSystemEventTriggerRecurrence>(args, 1);

                winrt::Windows::ApplicationModel::Background::CustomSystemEventTrigger instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CustomSystemEventTrigger(py::wrapper::Windows::ApplicationModel::Background::CustomSystemEventTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CustomSystemEventTrigger_get_Recurrence(py::wrapper::Windows::ApplicationModel::Background::CustomSystemEventTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.CustomSystemEventTrigger", L"Recurrence"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Recurrence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CustomSystemEventTrigger_get_TriggerId(py::wrapper::Windows::ApplicationModel::Background::CustomSystemEventTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.CustomSystemEventTrigger", L"TriggerId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TriggerId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CustomSystemEventTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::CustomSystemEventTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CustomSystemEventTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::CustomSystemEventTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CustomSystemEventTrigger[] = {
        { "_assign_array_", _assign_array_CustomSystemEventTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CustomSystemEventTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CustomSystemEventTrigger[] = {
        { "recurrence", reinterpret_cast<getter>(CustomSystemEventTrigger_get_Recurrence), nullptr, nullptr, nullptr },
        { "trigger_id", reinterpret_cast<getter>(CustomSystemEventTrigger_get_TriggerId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CustomSystemEventTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CustomSystemEventTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CustomSystemEventTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CustomSystemEventTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CustomSystemEventTrigger) },
        { },
    };

    static PyType_Spec type_spec_CustomSystemEventTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.CustomSystemEventTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::CustomSystemEventTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CustomSystemEventTrigger
    };

    // ----- DeviceConnectionChangeTrigger class --------------------
    static constexpr const char* const type_name_DeviceConnectionChangeTrigger = "DeviceConnectionChangeTrigger";

    static PyObject* _new_DeviceConnectionChangeTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DeviceConnectionChangeTrigger);
        return nullptr;
    }

    static void _dealloc_DeviceConnectionChangeTrigger(py::wrapper::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceConnectionChangeTrigger_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.DeviceConnectionChangeTrigger", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceConnectionChangeTrigger_get_MaintainConnection(py::wrapper::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.DeviceConnectionChangeTrigger", L"MaintainConnection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaintainConnection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceConnectionChangeTrigger_put_MaintainConnection(py::wrapper::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.DeviceConnectionChangeTrigger", L"MaintainConnection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.MaintainConnection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceConnectionChangeTrigger_get_CanMaintainConnection(py::wrapper::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.DeviceConnectionChangeTrigger", L"CanMaintainConnection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanMaintainConnection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceConnectionChangeTrigger_get_DeviceId(py::wrapper::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.DeviceConnectionChangeTrigger", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceConnectionChangeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceConnectionChangeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceConnectionChangeTrigger[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(DeviceConnectionChangeTrigger_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_DeviceConnectionChangeTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceConnectionChangeTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceConnectionChangeTrigger[] = {
        { "maintain_connection", reinterpret_cast<getter>(DeviceConnectionChangeTrigger_get_MaintainConnection), reinterpret_cast<setter>(DeviceConnectionChangeTrigger_put_MaintainConnection), nullptr, nullptr },
        { "can_maintain_connection", reinterpret_cast<getter>(DeviceConnectionChangeTrigger_get_CanMaintainConnection), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(DeviceConnectionChangeTrigger_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceConnectionChangeTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceConnectionChangeTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceConnectionChangeTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceConnectionChangeTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceConnectionChangeTrigger) },
        { },
    };

    static PyType_Spec type_spec_DeviceConnectionChangeTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.DeviceConnectionChangeTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceConnectionChangeTrigger
    };

    // ----- DeviceManufacturerNotificationTrigger class --------------------
    static constexpr const char* const type_name_DeviceManufacturerNotificationTrigger = "DeviceManufacturerNotificationTrigger";

    static PyObject* _new_DeviceManufacturerNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::ApplicationModel::Background::DeviceManufacturerNotificationTrigger instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DeviceManufacturerNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::DeviceManufacturerNotificationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceManufacturerNotificationTrigger_get_OneShot(py::wrapper::Windows::ApplicationModel::Background::DeviceManufacturerNotificationTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.DeviceManufacturerNotificationTrigger", L"OneShot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OneShot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceManufacturerNotificationTrigger_get_TriggerQualifier(py::wrapper::Windows::ApplicationModel::Background::DeviceManufacturerNotificationTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.DeviceManufacturerNotificationTrigger", L"TriggerQualifier"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TriggerQualifier());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceManufacturerNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::DeviceManufacturerNotificationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceManufacturerNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::DeviceManufacturerNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceManufacturerNotificationTrigger[] = {
        { "_assign_array_", _assign_array_DeviceManufacturerNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceManufacturerNotificationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceManufacturerNotificationTrigger[] = {
        { "one_shot", reinterpret_cast<getter>(DeviceManufacturerNotificationTrigger_get_OneShot), nullptr, nullptr, nullptr },
        { "trigger_qualifier", reinterpret_cast<getter>(DeviceManufacturerNotificationTrigger_get_TriggerQualifier), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceManufacturerNotificationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceManufacturerNotificationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceManufacturerNotificationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceManufacturerNotificationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceManufacturerNotificationTrigger) },
        { },
    };

    static PyType_Spec type_spec_DeviceManufacturerNotificationTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.DeviceManufacturerNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::DeviceManufacturerNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceManufacturerNotificationTrigger
    };

    // ----- DeviceServicingTrigger class --------------------
    static constexpr const char* const type_name_DeviceServicingTrigger = "DeviceServicingTrigger";

    static PyObject* _new_DeviceServicingTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::DeviceServicingTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DeviceServicingTrigger(py::wrapper::Windows::ApplicationModel::Background::DeviceServicingTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceServicingTrigger_RequestAsync(py::wrapper::Windows::ApplicationModel::Background::DeviceServicingTrigger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.DeviceServicingTrigger", L"RequestAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(self->obj.RequestAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.DeviceServicingTrigger", L"RequestAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.RequestAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceServicingTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::DeviceServicingTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceServicingTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::DeviceServicingTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceServicingTrigger[] = {
        { "request_async", reinterpret_cast<PyCFunction>(DeviceServicingTrigger_RequestAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DeviceServicingTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceServicingTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceServicingTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_DeviceServicingTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceServicingTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceServicingTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceServicingTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceServicingTrigger) },
        { },
    };

    static PyType_Spec type_spec_DeviceServicingTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.DeviceServicingTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::DeviceServicingTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceServicingTrigger
    };

    // ----- DeviceUseTrigger class --------------------
    static constexpr const char* const type_name_DeviceUseTrigger = "DeviceUseTrigger";

    static PyObject* _new_DeviceUseTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::DeviceUseTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DeviceUseTrigger(py::wrapper::Windows::ApplicationModel::Background::DeviceUseTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceUseTrigger_RequestAsync(py::wrapper::Windows::ApplicationModel::Background::DeviceUseTrigger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.DeviceUseTrigger", L"RequestAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RequestAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.DeviceUseTrigger", L"RequestAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.RequestAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceUseTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::DeviceUseTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceUseTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::DeviceUseTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceUseTrigger[] = {
        { "request_async", reinterpret_cast<PyCFunction>(DeviceUseTrigger_RequestAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DeviceUseTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceUseTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceUseTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_DeviceUseTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceUseTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceUseTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceUseTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceUseTrigger) },
        { },
    };

    static PyType_Spec type_spec_DeviceUseTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.DeviceUseTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::DeviceUseTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceUseTrigger
    };

    // ----- DeviceWatcherTrigger class --------------------
    static constexpr const char* const type_name_DeviceWatcherTrigger = "DeviceWatcherTrigger";

    static PyObject* _new_DeviceWatcherTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DeviceWatcherTrigger);
        return nullptr;
    }

    static void _dealloc_DeviceWatcherTrigger(py::wrapper::Windows::ApplicationModel::Background::DeviceWatcherTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DeviceWatcherTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::DeviceWatcherTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceWatcherTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::DeviceWatcherTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceWatcherTrigger[] = {
        { "_assign_array_", _assign_array_DeviceWatcherTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceWatcherTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceWatcherTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_DeviceWatcherTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceWatcherTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceWatcherTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceWatcherTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceWatcherTrigger) },
        { },
    };

    static PyType_Spec type_spec_DeviceWatcherTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.DeviceWatcherTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::DeviceWatcherTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceWatcherTrigger
    };

    // ----- EmailStoreNotificationTrigger class --------------------
    static constexpr const char* const type_name_EmailStoreNotificationTrigger = "EmailStoreNotificationTrigger";

    static PyObject* _new_EmailStoreNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::EmailStoreNotificationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailStoreNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::EmailStoreNotificationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_EmailStoreNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::EmailStoreNotificationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailStoreNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::EmailStoreNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailStoreNotificationTrigger[] = {
        { "_assign_array_", _assign_array_EmailStoreNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailStoreNotificationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailStoreNotificationTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_EmailStoreNotificationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailStoreNotificationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailStoreNotificationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailStoreNotificationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailStoreNotificationTrigger) },
        { },
    };

    static PyType_Spec type_spec_EmailStoreNotificationTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.EmailStoreNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::EmailStoreNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailStoreNotificationTrigger
    };

    // ----- GattCharacteristicNotificationTrigger class --------------------
    static constexpr const char* const type_name_GattCharacteristicNotificationTrigger = "GattCharacteristicNotificationTrigger";

    static PyObject* _new_GattCharacteristicNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::Background::BluetoothEventTriggeringMode>(args, 1);

                winrt::Windows::ApplicationModel::Background::GattCharacteristicNotificationTrigger instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic>(args, 0);

                winrt::Windows::ApplicationModel::Background::GattCharacteristicNotificationTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GattCharacteristicNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::GattCharacteristicNotificationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattCharacteristicNotificationTrigger_get_Characteristic(py::wrapper::Windows::ApplicationModel::Background::GattCharacteristicNotificationTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.GattCharacteristicNotificationTrigger", L"Characteristic"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Characteristic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicNotificationTrigger_get_EventTriggeringMode(py::wrapper::Windows::ApplicationModel::Background::GattCharacteristicNotificationTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.GattCharacteristicNotificationTrigger", L"EventTriggeringMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EventTriggeringMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattCharacteristicNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::GattCharacteristicNotificationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattCharacteristicNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::GattCharacteristicNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattCharacteristicNotificationTrigger[] = {
        { "_assign_array_", _assign_array_GattCharacteristicNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattCharacteristicNotificationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattCharacteristicNotificationTrigger[] = {
        { "characteristic", reinterpret_cast<getter>(GattCharacteristicNotificationTrigger_get_Characteristic), nullptr, nullptr, nullptr },
        { "event_triggering_mode", reinterpret_cast<getter>(GattCharacteristicNotificationTrigger_get_EventTriggeringMode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattCharacteristicNotificationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattCharacteristicNotificationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattCharacteristicNotificationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattCharacteristicNotificationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattCharacteristicNotificationTrigger) },
        { },
    };

    static PyType_Spec type_spec_GattCharacteristicNotificationTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.GattCharacteristicNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::GattCharacteristicNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattCharacteristicNotificationTrigger
    };

    // ----- GattServiceProviderTrigger class --------------------
    static constexpr const char* const type_name_GattServiceProviderTrigger = "GattServiceProviderTrigger";

    static PyObject* _new_GattServiceProviderTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_GattServiceProviderTrigger);
        return nullptr;
    }

    static void _dealloc_GattServiceProviderTrigger(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattServiceProviderTrigger_CreateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.GattServiceProviderTrigger", L"CreateAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Background::GattServiceProviderTrigger::CreateAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattServiceProviderTrigger_get_AdvertisingParameters(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.GattServiceProviderTrigger", L"AdvertisingParameters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AdvertisingParameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GattServiceProviderTrigger_put_AdvertisingParameters(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.GattServiceProviderTrigger", L"AdvertisingParameters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters>(arg);

            self->obj.AdvertisingParameters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GattServiceProviderTrigger_get_Service(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.GattServiceProviderTrigger", L"Service"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Service());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceProviderTrigger_get_TriggerId(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.GattServiceProviderTrigger", L"TriggerId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TriggerId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattServiceProviderTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::GattServiceProviderTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattServiceProviderTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::GattServiceProviderTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattServiceProviderTrigger[] = {
        { "create_async", reinterpret_cast<PyCFunction>(GattServiceProviderTrigger_CreateAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_GattServiceProviderTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattServiceProviderTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattServiceProviderTrigger[] = {
        { "advertising_parameters", reinterpret_cast<getter>(GattServiceProviderTrigger_get_AdvertisingParameters), reinterpret_cast<setter>(GattServiceProviderTrigger_put_AdvertisingParameters), nullptr, nullptr },
        { "service", reinterpret_cast<getter>(GattServiceProviderTrigger_get_Service), nullptr, nullptr, nullptr },
        { "trigger_id", reinterpret_cast<getter>(GattServiceProviderTrigger_get_TriggerId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattServiceProviderTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattServiceProviderTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattServiceProviderTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattServiceProviderTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattServiceProviderTrigger) },
        { },
    };

    static PyType_Spec type_spec_GattServiceProviderTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.GattServiceProviderTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattServiceProviderTrigger
    };

    // ----- GattServiceProviderTriggerResult class --------------------
    static constexpr const char* const type_name_GattServiceProviderTriggerResult = "GattServiceProviderTriggerResult";

    static PyObject* _new_GattServiceProviderTriggerResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_GattServiceProviderTriggerResult);
        return nullptr;
    }

    static void _dealloc_GattServiceProviderTriggerResult(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTriggerResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattServiceProviderTriggerResult_get_Error(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTriggerResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.GattServiceProviderTriggerResult", L"Error"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceProviderTriggerResult_get_Trigger(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTriggerResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.GattServiceProviderTriggerResult", L"Trigger"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Trigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattServiceProviderTriggerResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::GattServiceProviderTriggerResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattServiceProviderTriggerResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::GattServiceProviderTriggerResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattServiceProviderTriggerResult[] = {
        { "_assign_array_", _assign_array_GattServiceProviderTriggerResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattServiceProviderTriggerResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattServiceProviderTriggerResult[] = {
        { "error", reinterpret_cast<getter>(GattServiceProviderTriggerResult_get_Error), nullptr, nullptr, nullptr },
        { "trigger", reinterpret_cast<getter>(GattServiceProviderTriggerResult_get_Trigger), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattServiceProviderTriggerResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattServiceProviderTriggerResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattServiceProviderTriggerResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattServiceProviderTriggerResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattServiceProviderTriggerResult) },
        { },
    };

    static PyType_Spec type_spec_GattServiceProviderTriggerResult =
    {
        "_winsdk_Windows_ApplicationModel_Background.GattServiceProviderTriggerResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTriggerResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattServiceProviderTriggerResult
    };

    // ----- GeovisitTrigger class --------------------
    static constexpr const char* const type_name_GeovisitTrigger = "GeovisitTrigger";

    static PyObject* _new_GeovisitTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::GeovisitTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GeovisitTrigger(py::wrapper::Windows::ApplicationModel::Background::GeovisitTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GeovisitTrigger_get_MonitoringScope(py::wrapper::Windows::ApplicationModel::Background::GeovisitTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.GeovisitTrigger", L"MonitoringScope"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MonitoringScope());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GeovisitTrigger_put_MonitoringScope(py::wrapper::Windows::ApplicationModel::Background::GeovisitTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.GeovisitTrigger", L"MonitoringScope"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::VisitMonitoringScope>(arg);

            self->obj.MonitoringScope(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_GeovisitTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::GeovisitTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GeovisitTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::GeovisitTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GeovisitTrigger[] = {
        { "_assign_array_", _assign_array_GeovisitTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GeovisitTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GeovisitTrigger[] = {
        { "monitoring_scope", reinterpret_cast<getter>(GeovisitTrigger_get_MonitoringScope), reinterpret_cast<setter>(GeovisitTrigger_put_MonitoringScope), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GeovisitTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GeovisitTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GeovisitTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GeovisitTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GeovisitTrigger) },
        { },
    };

    static PyType_Spec type_spec_GeovisitTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.GeovisitTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::GeovisitTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GeovisitTrigger
    };

    // ----- LocationTrigger class --------------------
    static constexpr const char* const type_name_LocationTrigger = "LocationTrigger";

    static PyObject* _new_LocationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::LocationTriggerType>(args, 0);

                winrt::Windows::ApplicationModel::Background::LocationTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LocationTrigger(py::wrapper::Windows::ApplicationModel::Background::LocationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LocationTrigger_get_TriggerType(py::wrapper::Windows::ApplicationModel::Background::LocationTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.LocationTrigger", L"TriggerType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TriggerType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LocationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::LocationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LocationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::LocationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LocationTrigger[] = {
        { "_assign_array_", _assign_array_LocationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LocationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LocationTrigger[] = {
        { "trigger_type", reinterpret_cast<getter>(LocationTrigger_get_TriggerType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LocationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LocationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LocationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LocationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LocationTrigger) },
        { },
    };

    static PyType_Spec type_spec_LocationTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.LocationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::LocationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LocationTrigger
    };

    // ----- MaintenanceTrigger class --------------------
    static constexpr const char* const type_name_MaintenanceTrigger = "MaintenanceTrigger";

    static PyObject* _new_MaintenanceTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::ApplicationModel::Background::MaintenanceTrigger instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MaintenanceTrigger(py::wrapper::Windows::ApplicationModel::Background::MaintenanceTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MaintenanceTrigger_get_FreshnessTime(py::wrapper::Windows::ApplicationModel::Background::MaintenanceTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.MaintenanceTrigger", L"FreshnessTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FreshnessTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MaintenanceTrigger_get_OneShot(py::wrapper::Windows::ApplicationModel::Background::MaintenanceTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.MaintenanceTrigger", L"OneShot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OneShot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MaintenanceTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::MaintenanceTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MaintenanceTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::MaintenanceTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MaintenanceTrigger[] = {
        { "_assign_array_", _assign_array_MaintenanceTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MaintenanceTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MaintenanceTrigger[] = {
        { "freshness_time", reinterpret_cast<getter>(MaintenanceTrigger_get_FreshnessTime), nullptr, nullptr, nullptr },
        { "one_shot", reinterpret_cast<getter>(MaintenanceTrigger_get_OneShot), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MaintenanceTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MaintenanceTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MaintenanceTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MaintenanceTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MaintenanceTrigger) },
        { },
    };

    static PyType_Spec type_spec_MaintenanceTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.MaintenanceTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::MaintenanceTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MaintenanceTrigger
    };

    // ----- MediaProcessingTrigger class --------------------
    static constexpr const char* const type_name_MediaProcessingTrigger = "MediaProcessingTrigger";

    static PyObject* _new_MediaProcessingTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::MediaProcessingTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaProcessingTrigger(py::wrapper::Windows::ApplicationModel::Background::MediaProcessingTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaProcessingTrigger_RequestAsync(py::wrapper::Windows::ApplicationModel::Background::MediaProcessingTrigger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.MediaProcessingTrigger", L"RequestAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RequestAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.MediaProcessingTrigger", L"RequestAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 0);

                return py::convert(self->obj.RequestAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaProcessingTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::MediaProcessingTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaProcessingTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::MediaProcessingTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaProcessingTrigger[] = {
        { "request_async", reinterpret_cast<PyCFunction>(MediaProcessingTrigger_RequestAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaProcessingTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaProcessingTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaProcessingTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaProcessingTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaProcessingTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaProcessingTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaProcessingTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaProcessingTrigger) },
        { },
    };

    static PyType_Spec type_spec_MediaProcessingTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.MediaProcessingTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::MediaProcessingTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaProcessingTrigger
    };

    // ----- MobileBroadbandDeviceServiceNotificationTrigger class --------------------
    static constexpr const char* const type_name_MobileBroadbandDeviceServiceNotificationTrigger = "MobileBroadbandDeviceServiceNotificationTrigger";

    static PyObject* _new_MobileBroadbandDeviceServiceNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::MobileBroadbandDeviceServiceNotificationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MobileBroadbandDeviceServiceNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandDeviceServiceNotificationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MobileBroadbandDeviceServiceNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::MobileBroadbandDeviceServiceNotificationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandDeviceServiceNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::MobileBroadbandDeviceServiceNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandDeviceServiceNotificationTrigger[] = {
        { "_assign_array_", _assign_array_MobileBroadbandDeviceServiceNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandDeviceServiceNotificationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandDeviceServiceNotificationTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandDeviceServiceNotificationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandDeviceServiceNotificationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandDeviceServiceNotificationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandDeviceServiceNotificationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandDeviceServiceNotificationTrigger) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandDeviceServiceNotificationTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.MobileBroadbandDeviceServiceNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandDeviceServiceNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandDeviceServiceNotificationTrigger
    };

    // ----- MobileBroadbandPcoDataChangeTrigger class --------------------
    static constexpr const char* const type_name_MobileBroadbandPcoDataChangeTrigger = "MobileBroadbandPcoDataChangeTrigger";

    static PyObject* _new_MobileBroadbandPcoDataChangeTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::MobileBroadbandPcoDataChangeTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MobileBroadbandPcoDataChangeTrigger(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandPcoDataChangeTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MobileBroadbandPcoDataChangeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::MobileBroadbandPcoDataChangeTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandPcoDataChangeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::MobileBroadbandPcoDataChangeTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandPcoDataChangeTrigger[] = {
        { "_assign_array_", _assign_array_MobileBroadbandPcoDataChangeTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandPcoDataChangeTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandPcoDataChangeTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandPcoDataChangeTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandPcoDataChangeTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandPcoDataChangeTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandPcoDataChangeTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandPcoDataChangeTrigger) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandPcoDataChangeTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.MobileBroadbandPcoDataChangeTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandPcoDataChangeTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandPcoDataChangeTrigger
    };

    // ----- MobileBroadbandPinLockStateChangeTrigger class --------------------
    static constexpr const char* const type_name_MobileBroadbandPinLockStateChangeTrigger = "MobileBroadbandPinLockStateChangeTrigger";

    static PyObject* _new_MobileBroadbandPinLockStateChangeTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::MobileBroadbandPinLockStateChangeTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MobileBroadbandPinLockStateChangeTrigger(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandPinLockStateChangeTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MobileBroadbandPinLockStateChangeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::MobileBroadbandPinLockStateChangeTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandPinLockStateChangeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::MobileBroadbandPinLockStateChangeTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandPinLockStateChangeTrigger[] = {
        { "_assign_array_", _assign_array_MobileBroadbandPinLockStateChangeTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandPinLockStateChangeTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandPinLockStateChangeTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandPinLockStateChangeTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandPinLockStateChangeTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandPinLockStateChangeTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandPinLockStateChangeTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandPinLockStateChangeTrigger) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandPinLockStateChangeTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.MobileBroadbandPinLockStateChangeTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandPinLockStateChangeTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandPinLockStateChangeTrigger
    };

    // ----- MobileBroadbandRadioStateChangeTrigger class --------------------
    static constexpr const char* const type_name_MobileBroadbandRadioStateChangeTrigger = "MobileBroadbandRadioStateChangeTrigger";

    static PyObject* _new_MobileBroadbandRadioStateChangeTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::MobileBroadbandRadioStateChangeTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MobileBroadbandRadioStateChangeTrigger(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandRadioStateChangeTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MobileBroadbandRadioStateChangeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::MobileBroadbandRadioStateChangeTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandRadioStateChangeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::MobileBroadbandRadioStateChangeTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandRadioStateChangeTrigger[] = {
        { "_assign_array_", _assign_array_MobileBroadbandRadioStateChangeTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandRadioStateChangeTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandRadioStateChangeTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandRadioStateChangeTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandRadioStateChangeTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandRadioStateChangeTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandRadioStateChangeTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandRadioStateChangeTrigger) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandRadioStateChangeTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.MobileBroadbandRadioStateChangeTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandRadioStateChangeTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandRadioStateChangeTrigger
    };

    // ----- MobileBroadbandRegistrationStateChangeTrigger class --------------------
    static constexpr const char* const type_name_MobileBroadbandRegistrationStateChangeTrigger = "MobileBroadbandRegistrationStateChangeTrigger";

    static PyObject* _new_MobileBroadbandRegistrationStateChangeTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::MobileBroadbandRegistrationStateChangeTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MobileBroadbandRegistrationStateChangeTrigger(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandRegistrationStateChangeTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MobileBroadbandRegistrationStateChangeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::MobileBroadbandRegistrationStateChangeTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandRegistrationStateChangeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::MobileBroadbandRegistrationStateChangeTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandRegistrationStateChangeTrigger[] = {
        { "_assign_array_", _assign_array_MobileBroadbandRegistrationStateChangeTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandRegistrationStateChangeTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandRegistrationStateChangeTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandRegistrationStateChangeTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandRegistrationStateChangeTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandRegistrationStateChangeTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandRegistrationStateChangeTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandRegistrationStateChangeTrigger) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandRegistrationStateChangeTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.MobileBroadbandRegistrationStateChangeTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandRegistrationStateChangeTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandRegistrationStateChangeTrigger
    };

    // ----- NetworkOperatorDataUsageTrigger class --------------------
    static constexpr const char* const type_name_NetworkOperatorDataUsageTrigger = "NetworkOperatorDataUsageTrigger";

    static PyObject* _new_NetworkOperatorDataUsageTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::NetworkOperatorDataUsageTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NetworkOperatorDataUsageTrigger(py::wrapper::Windows::ApplicationModel::Background::NetworkOperatorDataUsageTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NetworkOperatorDataUsageTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::NetworkOperatorDataUsageTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NetworkOperatorDataUsageTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::NetworkOperatorDataUsageTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkOperatorDataUsageTrigger[] = {
        { "_assign_array_", _assign_array_NetworkOperatorDataUsageTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkOperatorDataUsageTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkOperatorDataUsageTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_NetworkOperatorDataUsageTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NetworkOperatorDataUsageTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NetworkOperatorDataUsageTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NetworkOperatorDataUsageTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NetworkOperatorDataUsageTrigger) },
        { },
    };

    static PyType_Spec type_spec_NetworkOperatorDataUsageTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.NetworkOperatorDataUsageTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::NetworkOperatorDataUsageTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkOperatorDataUsageTrigger
    };

    // ----- NetworkOperatorHotspotAuthenticationTrigger class --------------------
    static constexpr const char* const type_name_NetworkOperatorHotspotAuthenticationTrigger = "NetworkOperatorHotspotAuthenticationTrigger";

    static PyObject* _new_NetworkOperatorHotspotAuthenticationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::NetworkOperatorHotspotAuthenticationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NetworkOperatorHotspotAuthenticationTrigger(py::wrapper::Windows::ApplicationModel::Background::NetworkOperatorHotspotAuthenticationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NetworkOperatorHotspotAuthenticationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::NetworkOperatorHotspotAuthenticationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NetworkOperatorHotspotAuthenticationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::NetworkOperatorHotspotAuthenticationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkOperatorHotspotAuthenticationTrigger[] = {
        { "_assign_array_", _assign_array_NetworkOperatorHotspotAuthenticationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkOperatorHotspotAuthenticationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkOperatorHotspotAuthenticationTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_NetworkOperatorHotspotAuthenticationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NetworkOperatorHotspotAuthenticationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NetworkOperatorHotspotAuthenticationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NetworkOperatorHotspotAuthenticationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NetworkOperatorHotspotAuthenticationTrigger) },
        { },
    };

    static PyType_Spec type_spec_NetworkOperatorHotspotAuthenticationTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.NetworkOperatorHotspotAuthenticationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::NetworkOperatorHotspotAuthenticationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkOperatorHotspotAuthenticationTrigger
    };

    // ----- NetworkOperatorNotificationTrigger class --------------------
    static constexpr const char* const type_name_NetworkOperatorNotificationTrigger = "NetworkOperatorNotificationTrigger";

    static PyObject* _new_NetworkOperatorNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Background::NetworkOperatorNotificationTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NetworkOperatorNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::NetworkOperatorNotificationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkOperatorNotificationTrigger_get_NetworkAccountId(py::wrapper::Windows::ApplicationModel::Background::NetworkOperatorNotificationTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.NetworkOperatorNotificationTrigger", L"NetworkAccountId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NetworkOperatorNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::NetworkOperatorNotificationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NetworkOperatorNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::NetworkOperatorNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkOperatorNotificationTrigger[] = {
        { "_assign_array_", _assign_array_NetworkOperatorNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkOperatorNotificationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkOperatorNotificationTrigger[] = {
        { "network_account_id", reinterpret_cast<getter>(NetworkOperatorNotificationTrigger_get_NetworkAccountId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkOperatorNotificationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NetworkOperatorNotificationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NetworkOperatorNotificationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NetworkOperatorNotificationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NetworkOperatorNotificationTrigger) },
        { },
    };

    static PyType_Spec type_spec_NetworkOperatorNotificationTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.NetworkOperatorNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::NetworkOperatorNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkOperatorNotificationTrigger
    };

    // ----- PaymentAppCanMakePaymentTrigger class --------------------
    static constexpr const char* const type_name_PaymentAppCanMakePaymentTrigger = "PaymentAppCanMakePaymentTrigger";

    static PyObject* _new_PaymentAppCanMakePaymentTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::PaymentAppCanMakePaymentTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentAppCanMakePaymentTrigger(py::wrapper::Windows::ApplicationModel::Background::PaymentAppCanMakePaymentTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PaymentAppCanMakePaymentTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::PaymentAppCanMakePaymentTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentAppCanMakePaymentTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::PaymentAppCanMakePaymentTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentAppCanMakePaymentTrigger[] = {
        { "_assign_array_", _assign_array_PaymentAppCanMakePaymentTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentAppCanMakePaymentTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentAppCanMakePaymentTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_PaymentAppCanMakePaymentTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentAppCanMakePaymentTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentAppCanMakePaymentTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentAppCanMakePaymentTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentAppCanMakePaymentTrigger) },
        { },
    };

    static PyType_Spec type_spec_PaymentAppCanMakePaymentTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.PaymentAppCanMakePaymentTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::PaymentAppCanMakePaymentTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentAppCanMakePaymentTrigger
    };

    // ----- PhoneTrigger class --------------------
    static constexpr const char* const type_name_PhoneTrigger = "PhoneTrigger";

    static PyObject* _new_PhoneTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::Background::PhoneTriggerType>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::ApplicationModel::Background::PhoneTrigger instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PhoneTrigger(py::wrapper::Windows::ApplicationModel::Background::PhoneTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneTrigger_get_OneShot(py::wrapper::Windows::ApplicationModel::Background::PhoneTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.PhoneTrigger", L"OneShot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OneShot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneTrigger_get_TriggerType(py::wrapper::Windows::ApplicationModel::Background::PhoneTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.PhoneTrigger", L"TriggerType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TriggerType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::PhoneTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::PhoneTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneTrigger[] = {
        { "_assign_array_", _assign_array_PhoneTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneTrigger[] = {
        { "one_shot", reinterpret_cast<getter>(PhoneTrigger_get_OneShot), nullptr, nullptr, nullptr },
        { "trigger_type", reinterpret_cast<getter>(PhoneTrigger_get_TriggerType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneTrigger) },
        { },
    };

    static PyType_Spec type_spec_PhoneTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.PhoneTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::PhoneTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneTrigger
    };

    // ----- PushNotificationTrigger class --------------------
    static constexpr const char* const type_name_PushNotificationTrigger = "PushNotificationTrigger";

    static PyObject* _new_PushNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Background::PushNotificationTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::PushNotificationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PushNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::PushNotificationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PushNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::PushNotificationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PushNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::PushNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PushNotificationTrigger[] = {
        { "_assign_array_", _assign_array_PushNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PushNotificationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PushNotificationTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_PushNotificationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PushNotificationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PushNotificationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PushNotificationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PushNotificationTrigger) },
        { },
    };

    static PyType_Spec type_spec_PushNotificationTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.PushNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::PushNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PushNotificationTrigger
    };

    // ----- RcsEndUserMessageAvailableTrigger class --------------------
    static constexpr const char* const type_name_RcsEndUserMessageAvailableTrigger = "RcsEndUserMessageAvailableTrigger";

    static PyObject* _new_RcsEndUserMessageAvailableTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::RcsEndUserMessageAvailableTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RcsEndUserMessageAvailableTrigger(py::wrapper::Windows::ApplicationModel::Background::RcsEndUserMessageAvailableTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RcsEndUserMessageAvailableTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::RcsEndUserMessageAvailableTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RcsEndUserMessageAvailableTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::RcsEndUserMessageAvailableTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsEndUserMessageAvailableTrigger[] = {
        { "_assign_array_", _assign_array_RcsEndUserMessageAvailableTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RcsEndUserMessageAvailableTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RcsEndUserMessageAvailableTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_RcsEndUserMessageAvailableTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RcsEndUserMessageAvailableTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RcsEndUserMessageAvailableTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RcsEndUserMessageAvailableTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RcsEndUserMessageAvailableTrigger) },
        { },
    };

    static PyType_Spec type_spec_RcsEndUserMessageAvailableTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.RcsEndUserMessageAvailableTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::RcsEndUserMessageAvailableTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsEndUserMessageAvailableTrigger
    };

    // ----- RfcommConnectionTrigger class --------------------
    static constexpr const char* const type_name_RfcommConnectionTrigger = "RfcommConnectionTrigger";

    static PyObject* _new_RfcommConnectionTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::RfcommConnectionTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RfcommConnectionTrigger(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RfcommConnectionTrigger_get_RemoteHostName(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.RfcommConnectionTrigger", L"RemoteHostName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteHostName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RfcommConnectionTrigger_put_RemoteHostName(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.RfcommConnectionTrigger", L"RemoteHostName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(arg);

            self->obj.RemoteHostName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RfcommConnectionTrigger_get_ProtectionLevel(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.RfcommConnectionTrigger", L"ProtectionLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RfcommConnectionTrigger_put_ProtectionLevel(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.RfcommConnectionTrigger", L"ProtectionLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketProtectionLevel>(arg);

            self->obj.ProtectionLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RfcommConnectionTrigger_get_AllowMultipleConnections(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.RfcommConnectionTrigger", L"AllowMultipleConnections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowMultipleConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RfcommConnectionTrigger_put_AllowMultipleConnections(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.RfcommConnectionTrigger", L"AllowMultipleConnections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowMultipleConnections(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RfcommConnectionTrigger_get_InboundConnection(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.RfcommConnectionTrigger", L"InboundConnection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InboundConnection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RfcommConnectionTrigger_get_OutboundConnection(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.RfcommConnectionTrigger", L"OutboundConnection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutboundConnection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RfcommConnectionTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::RfcommConnectionTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RfcommConnectionTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::RfcommConnectionTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RfcommConnectionTrigger[] = {
        { "_assign_array_", _assign_array_RfcommConnectionTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RfcommConnectionTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RfcommConnectionTrigger[] = {
        { "remote_host_name", reinterpret_cast<getter>(RfcommConnectionTrigger_get_RemoteHostName), reinterpret_cast<setter>(RfcommConnectionTrigger_put_RemoteHostName), nullptr, nullptr },
        { "protection_level", reinterpret_cast<getter>(RfcommConnectionTrigger_get_ProtectionLevel), reinterpret_cast<setter>(RfcommConnectionTrigger_put_ProtectionLevel), nullptr, nullptr },
        { "allow_multiple_connections", reinterpret_cast<getter>(RfcommConnectionTrigger_get_AllowMultipleConnections), reinterpret_cast<setter>(RfcommConnectionTrigger_put_AllowMultipleConnections), nullptr, nullptr },
        { "inbound_connection", reinterpret_cast<getter>(RfcommConnectionTrigger_get_InboundConnection), nullptr, nullptr, nullptr },
        { "outbound_connection", reinterpret_cast<getter>(RfcommConnectionTrigger_get_OutboundConnection), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RfcommConnectionTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RfcommConnectionTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RfcommConnectionTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RfcommConnectionTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RfcommConnectionTrigger) },
        { },
    };

    static PyType_Spec type_spec_RfcommConnectionTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.RfcommConnectionTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RfcommConnectionTrigger
    };

    // ----- SecondaryAuthenticationFactorAuthenticationTrigger class --------------------
    static constexpr const char* const type_name_SecondaryAuthenticationFactorAuthenticationTrigger = "SecondaryAuthenticationFactorAuthenticationTrigger";

    static PyObject* _new_SecondaryAuthenticationFactorAuthenticationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::SecondaryAuthenticationFactorAuthenticationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SecondaryAuthenticationFactorAuthenticationTrigger(py::wrapper::Windows::ApplicationModel::Background::SecondaryAuthenticationFactorAuthenticationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SecondaryAuthenticationFactorAuthenticationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::SecondaryAuthenticationFactorAuthenticationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SecondaryAuthenticationFactorAuthenticationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::SecondaryAuthenticationFactorAuthenticationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SecondaryAuthenticationFactorAuthenticationTrigger[] = {
        { "_assign_array_", _assign_array_SecondaryAuthenticationFactorAuthenticationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SecondaryAuthenticationFactorAuthenticationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SecondaryAuthenticationFactorAuthenticationTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_SecondaryAuthenticationFactorAuthenticationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SecondaryAuthenticationFactorAuthenticationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SecondaryAuthenticationFactorAuthenticationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SecondaryAuthenticationFactorAuthenticationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SecondaryAuthenticationFactorAuthenticationTrigger) },
        { },
    };

    static PyType_Spec type_spec_SecondaryAuthenticationFactorAuthenticationTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.SecondaryAuthenticationFactorAuthenticationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::SecondaryAuthenticationFactorAuthenticationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SecondaryAuthenticationFactorAuthenticationTrigger
    };

    // ----- SensorDataThresholdTrigger class --------------------
    static constexpr const char* const type_name_SensorDataThresholdTrigger = "SensorDataThresholdTrigger";

    static PyObject* _new_SensorDataThresholdTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::ISensorDataThreshold>(args, 0);

                winrt::Windows::ApplicationModel::Background::SensorDataThresholdTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SensorDataThresholdTrigger(py::wrapper::Windows::ApplicationModel::Background::SensorDataThresholdTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SensorDataThresholdTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::SensorDataThresholdTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SensorDataThresholdTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::SensorDataThresholdTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SensorDataThresholdTrigger[] = {
        { "_assign_array_", _assign_array_SensorDataThresholdTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SensorDataThresholdTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SensorDataThresholdTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_SensorDataThresholdTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SensorDataThresholdTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SensorDataThresholdTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SensorDataThresholdTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SensorDataThresholdTrigger) },
        { },
    };

    static PyType_Spec type_spec_SensorDataThresholdTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.SensorDataThresholdTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::SensorDataThresholdTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SensorDataThresholdTrigger
    };

    // ----- SmartCardTrigger class --------------------
    static constexpr const char* const type_name_SmartCardTrigger = "SmartCardTrigger";

    static PyObject* _new_SmartCardTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardTriggerType>(args, 0);

                winrt::Windows::ApplicationModel::Background::SmartCardTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmartCardTrigger(py::wrapper::Windows::ApplicationModel::Background::SmartCardTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardTrigger_get_TriggerType(py::wrapper::Windows::ApplicationModel::Background::SmartCardTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.SmartCardTrigger", L"TriggerType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TriggerType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::SmartCardTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::SmartCardTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardTrigger[] = {
        { "_assign_array_", _assign_array_SmartCardTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardTrigger[] = {
        { "trigger_type", reinterpret_cast<getter>(SmartCardTrigger_get_TriggerType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardTrigger) },
        { },
    };

    static PyType_Spec type_spec_SmartCardTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.SmartCardTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::SmartCardTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardTrigger
    };

    // ----- SmsMessageReceivedTrigger class --------------------
    static constexpr const char* const type_name_SmsMessageReceivedTrigger = "SmsMessageReceivedTrigger";

    static PyObject* _new_SmsMessageReceivedTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsFilterRules>(args, 0);

                winrt::Windows::ApplicationModel::Background::SmsMessageReceivedTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmsMessageReceivedTrigger(py::wrapper::Windows::ApplicationModel::Background::SmsMessageReceivedTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SmsMessageReceivedTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::SmsMessageReceivedTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsMessageReceivedTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::SmsMessageReceivedTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsMessageReceivedTrigger[] = {
        { "_assign_array_", _assign_array_SmsMessageReceivedTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsMessageReceivedTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsMessageReceivedTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_SmsMessageReceivedTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsMessageReceivedTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsMessageReceivedTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsMessageReceivedTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsMessageReceivedTrigger) },
        { },
    };

    static PyType_Spec type_spec_SmsMessageReceivedTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.SmsMessageReceivedTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::SmsMessageReceivedTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsMessageReceivedTrigger
    };

    // ----- SocketActivityTrigger class --------------------
    static constexpr const char* const type_name_SocketActivityTrigger = "SocketActivityTrigger";

    static PyObject* _new_SocketActivityTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::SocketActivityTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SocketActivityTrigger(py::wrapper::Windows::ApplicationModel::Background::SocketActivityTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SocketActivityTrigger_get_IsWakeFromLowPowerSupported(py::wrapper::Windows::ApplicationModel::Background::SocketActivityTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.SocketActivityTrigger", L"IsWakeFromLowPowerSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsWakeFromLowPowerSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SocketActivityTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::SocketActivityTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SocketActivityTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::SocketActivityTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SocketActivityTrigger[] = {
        { "_assign_array_", _assign_array_SocketActivityTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SocketActivityTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SocketActivityTrigger[] = {
        { "is_wake_from_low_power_supported", reinterpret_cast<getter>(SocketActivityTrigger_get_IsWakeFromLowPowerSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SocketActivityTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SocketActivityTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SocketActivityTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SocketActivityTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SocketActivityTrigger) },
        { },
    };

    static PyType_Spec type_spec_SocketActivityTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.SocketActivityTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::SocketActivityTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SocketActivityTrigger
    };

    // ----- StorageLibraryChangeTrackerTrigger class --------------------
    static constexpr const char* const type_name_StorageLibraryChangeTrackerTrigger = "StorageLibraryChangeTrackerTrigger";

    static PyObject* _new_StorageLibraryChangeTrackerTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageLibraryChangeTracker>(args, 0);

                winrt::Windows::ApplicationModel::Background::StorageLibraryChangeTrackerTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageLibraryChangeTrackerTrigger(py::wrapper::Windows::ApplicationModel::Background::StorageLibraryChangeTrackerTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_StorageLibraryChangeTrackerTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::StorageLibraryChangeTrackerTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageLibraryChangeTrackerTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::StorageLibraryChangeTrackerTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibraryChangeTrackerTrigger[] = {
        { "_assign_array_", _assign_array_StorageLibraryChangeTrackerTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageLibraryChangeTrackerTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageLibraryChangeTrackerTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_StorageLibraryChangeTrackerTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageLibraryChangeTrackerTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageLibraryChangeTrackerTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageLibraryChangeTrackerTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageLibraryChangeTrackerTrigger) },
        { },
    };

    static PyType_Spec type_spec_StorageLibraryChangeTrackerTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.StorageLibraryChangeTrackerTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::StorageLibraryChangeTrackerTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibraryChangeTrackerTrigger
    };

    // ----- StorageLibraryContentChangedTrigger class --------------------
    static constexpr const char* const type_name_StorageLibraryContentChangedTrigger = "StorageLibraryContentChangedTrigger";

    static PyObject* _new_StorageLibraryContentChangedTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StorageLibraryContentChangedTrigger);
        return nullptr;
    }

    static void _dealloc_StorageLibraryContentChangedTrigger(py::wrapper::Windows::ApplicationModel::Background::StorageLibraryContentChangedTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageLibraryContentChangedTrigger_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.StorageLibraryContentChangedTrigger", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageLibrary>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Background::StorageLibraryContentChangedTrigger::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryContentChangedTrigger_CreateFromLibraries(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.StorageLibraryContentChangedTrigger", L"CreateFromLibraries", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::StorageLibrary>>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Background::StorageLibraryContentChangedTrigger::CreateFromLibraries(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageLibraryContentChangedTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::StorageLibraryContentChangedTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageLibraryContentChangedTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::StorageLibraryContentChangedTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibraryContentChangedTrigger[] = {
        { "create", reinterpret_cast<PyCFunction>(StorageLibraryContentChangedTrigger_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_libraries", reinterpret_cast<PyCFunction>(StorageLibraryContentChangedTrigger_CreateFromLibraries), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_StorageLibraryContentChangedTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageLibraryContentChangedTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageLibraryContentChangedTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_StorageLibraryContentChangedTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageLibraryContentChangedTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageLibraryContentChangedTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageLibraryContentChangedTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageLibraryContentChangedTrigger) },
        { },
    };

    static PyType_Spec type_spec_StorageLibraryContentChangedTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.StorageLibraryContentChangedTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::StorageLibraryContentChangedTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibraryContentChangedTrigger
    };

    // ----- SystemCondition class --------------------
    static constexpr const char* const type_name_SystemCondition = "SystemCondition";

    static PyObject* _new_SystemCondition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::SystemConditionType>(args, 0);

                winrt::Windows::ApplicationModel::Background::SystemCondition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SystemCondition(py::wrapper::Windows::ApplicationModel::Background::SystemCondition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemCondition_get_ConditionType(py::wrapper::Windows::ApplicationModel::Background::SystemCondition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.SystemCondition", L"ConditionType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConditionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemCondition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::SystemCondition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemCondition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::SystemCondition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemCondition[] = {
        { "_assign_array_", _assign_array_SystemCondition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemCondition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemCondition[] = {
        { "condition_type", reinterpret_cast<getter>(SystemCondition_get_ConditionType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemCondition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemCondition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemCondition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemCondition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemCondition) },
        { },
    };

    static PyType_Spec type_spec_SystemCondition =
    {
        "_winsdk_Windows_ApplicationModel_Background.SystemCondition",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::SystemCondition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemCondition
    };

    // ----- SystemTrigger class --------------------
    static constexpr const char* const type_name_SystemTrigger = "SystemTrigger";

    static PyObject* _new_SystemTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::SystemTriggerType>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::ApplicationModel::Background::SystemTrigger instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SystemTrigger(py::wrapper::Windows::ApplicationModel::Background::SystemTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemTrigger_get_OneShot(py::wrapper::Windows::ApplicationModel::Background::SystemTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.SystemTrigger", L"OneShot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OneShot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemTrigger_get_TriggerType(py::wrapper::Windows::ApplicationModel::Background::SystemTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.SystemTrigger", L"TriggerType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TriggerType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::SystemTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::SystemTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemTrigger[] = {
        { "_assign_array_", _assign_array_SystemTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemTrigger[] = {
        { "one_shot", reinterpret_cast<getter>(SystemTrigger_get_OneShot), nullptr, nullptr, nullptr },
        { "trigger_type", reinterpret_cast<getter>(SystemTrigger_get_TriggerType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemTrigger) },
        { },
    };

    static PyType_Spec type_spec_SystemTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.SystemTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::SystemTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemTrigger
    };

    // ----- TetheringEntitlementCheckTrigger class --------------------
    static constexpr const char* const type_name_TetheringEntitlementCheckTrigger = "TetheringEntitlementCheckTrigger";

    static PyObject* _new_TetheringEntitlementCheckTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::TetheringEntitlementCheckTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TetheringEntitlementCheckTrigger(py::wrapper::Windows::ApplicationModel::Background::TetheringEntitlementCheckTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TetheringEntitlementCheckTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::TetheringEntitlementCheckTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TetheringEntitlementCheckTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::TetheringEntitlementCheckTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TetheringEntitlementCheckTrigger[] = {
        { "_assign_array_", _assign_array_TetheringEntitlementCheckTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TetheringEntitlementCheckTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TetheringEntitlementCheckTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_TetheringEntitlementCheckTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TetheringEntitlementCheckTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TetheringEntitlementCheckTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TetheringEntitlementCheckTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TetheringEntitlementCheckTrigger) },
        { },
    };

    static PyType_Spec type_spec_TetheringEntitlementCheckTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.TetheringEntitlementCheckTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::TetheringEntitlementCheckTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TetheringEntitlementCheckTrigger
    };

    // ----- TimeTrigger class --------------------
    static constexpr const char* const type_name_TimeTrigger = "TimeTrigger";

    static PyObject* _new_TimeTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::ApplicationModel::Background::TimeTrigger instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimeTrigger(py::wrapper::Windows::ApplicationModel::Background::TimeTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimeTrigger_get_FreshnessTime(py::wrapper::Windows::ApplicationModel::Background::TimeTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.TimeTrigger", L"FreshnessTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FreshnessTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimeTrigger_get_OneShot(py::wrapper::Windows::ApplicationModel::Background::TimeTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.TimeTrigger", L"OneShot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OneShot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::TimeTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::TimeTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimeTrigger[] = {
        { "_assign_array_", _assign_array_TimeTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimeTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimeTrigger[] = {
        { "freshness_time", reinterpret_cast<getter>(TimeTrigger_get_FreshnessTime), nullptr, nullptr, nullptr },
        { "one_shot", reinterpret_cast<getter>(TimeTrigger_get_OneShot), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimeTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimeTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimeTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimeTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimeTrigger) },
        { },
    };

    static PyType_Spec type_spec_TimeTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.TimeTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::TimeTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimeTrigger
    };

    // ----- ToastNotificationActionTrigger class --------------------
    static constexpr const char* const type_name_ToastNotificationActionTrigger = "ToastNotificationActionTrigger";

    static PyObject* _new_ToastNotificationActionTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Background::ToastNotificationActionTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::ToastNotificationActionTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToastNotificationActionTrigger(py::wrapper::Windows::ApplicationModel::Background::ToastNotificationActionTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ToastNotificationActionTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::ToastNotificationActionTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastNotificationActionTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ToastNotificationActionTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotificationActionTrigger[] = {
        { "_assign_array_", _assign_array_ToastNotificationActionTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastNotificationActionTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToastNotificationActionTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_ToastNotificationActionTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastNotificationActionTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastNotificationActionTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastNotificationActionTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastNotificationActionTrigger) },
        { },
    };

    static PyType_Spec type_spec_ToastNotificationActionTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.ToastNotificationActionTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ToastNotificationActionTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotificationActionTrigger
    };

    // ----- ToastNotificationHistoryChangedTrigger class --------------------
    static constexpr const char* const type_name_ToastNotificationHistoryChangedTrigger = "ToastNotificationHistoryChangedTrigger";

    static PyObject* _new_ToastNotificationHistoryChangedTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Background::ToastNotificationHistoryChangedTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::ToastNotificationHistoryChangedTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToastNotificationHistoryChangedTrigger(py::wrapper::Windows::ApplicationModel::Background::ToastNotificationHistoryChangedTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ToastNotificationHistoryChangedTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::ToastNotificationHistoryChangedTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastNotificationHistoryChangedTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ToastNotificationHistoryChangedTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotificationHistoryChangedTrigger[] = {
        { "_assign_array_", _assign_array_ToastNotificationHistoryChangedTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastNotificationHistoryChangedTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToastNotificationHistoryChangedTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_ToastNotificationHistoryChangedTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastNotificationHistoryChangedTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastNotificationHistoryChangedTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastNotificationHistoryChangedTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastNotificationHistoryChangedTrigger) },
        { },
    };

    static PyType_Spec type_spec_ToastNotificationHistoryChangedTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.ToastNotificationHistoryChangedTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ToastNotificationHistoryChangedTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotificationHistoryChangedTrigger
    };

    // ----- UserNotificationChangedTrigger class --------------------
    static constexpr const char* const type_name_UserNotificationChangedTrigger = "UserNotificationChangedTrigger";

    static PyObject* _new_UserNotificationChangedTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::NotificationKinds>(args, 0);

                winrt::Windows::ApplicationModel::Background::UserNotificationChangedTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UserNotificationChangedTrigger(py::wrapper::Windows::ApplicationModel::Background::UserNotificationChangedTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_UserNotificationChangedTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::UserNotificationChangedTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UserNotificationChangedTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::UserNotificationChangedTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserNotificationChangedTrigger[] = {
        { "_assign_array_", _assign_array_UserNotificationChangedTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserNotificationChangedTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserNotificationChangedTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_UserNotificationChangedTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserNotificationChangedTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UserNotificationChangedTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserNotificationChangedTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserNotificationChangedTrigger) },
        { },
    };

    static PyType_Spec type_spec_UserNotificationChangedTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.UserNotificationChangedTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::UserNotificationChangedTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserNotificationChangedTrigger
    };

    // ----- WiFiOnDemandHotspotConnectTrigger class --------------------
    static constexpr const char* const type_name_WiFiOnDemandHotspotConnectTrigger = "WiFiOnDemandHotspotConnectTrigger";

    static PyObject* _new_WiFiOnDemandHotspotConnectTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::WiFiOnDemandHotspotConnectTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WiFiOnDemandHotspotConnectTrigger(py::wrapper::Windows::ApplicationModel::Background::WiFiOnDemandHotspotConnectTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_WiFiOnDemandHotspotConnectTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::WiFiOnDemandHotspotConnectTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WiFiOnDemandHotspotConnectTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::WiFiOnDemandHotspotConnectTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WiFiOnDemandHotspotConnectTrigger[] = {
        { "_assign_array_", _assign_array_WiFiOnDemandHotspotConnectTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WiFiOnDemandHotspotConnectTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WiFiOnDemandHotspotConnectTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_WiFiOnDemandHotspotConnectTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WiFiOnDemandHotspotConnectTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WiFiOnDemandHotspotConnectTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WiFiOnDemandHotspotConnectTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WiFiOnDemandHotspotConnectTrigger) },
        { },
    };

    static PyType_Spec type_spec_WiFiOnDemandHotspotConnectTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.WiFiOnDemandHotspotConnectTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::WiFiOnDemandHotspotConnectTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WiFiOnDemandHotspotConnectTrigger
    };

    // ----- WiFiOnDemandHotspotUpdateMetadataTrigger class --------------------
    static constexpr const char* const type_name_WiFiOnDemandHotspotUpdateMetadataTrigger = "WiFiOnDemandHotspotUpdateMetadataTrigger";

    static PyObject* _new_WiFiOnDemandHotspotUpdateMetadataTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::WiFiOnDemandHotspotUpdateMetadataTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WiFiOnDemandHotspotUpdateMetadataTrigger(py::wrapper::Windows::ApplicationModel::Background::WiFiOnDemandHotspotUpdateMetadataTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_WiFiOnDemandHotspotUpdateMetadataTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::WiFiOnDemandHotspotUpdateMetadataTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WiFiOnDemandHotspotUpdateMetadataTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::WiFiOnDemandHotspotUpdateMetadataTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WiFiOnDemandHotspotUpdateMetadataTrigger[] = {
        { "_assign_array_", _assign_array_WiFiOnDemandHotspotUpdateMetadataTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WiFiOnDemandHotspotUpdateMetadataTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WiFiOnDemandHotspotUpdateMetadataTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_WiFiOnDemandHotspotUpdateMetadataTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WiFiOnDemandHotspotUpdateMetadataTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WiFiOnDemandHotspotUpdateMetadataTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WiFiOnDemandHotspotUpdateMetadataTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WiFiOnDemandHotspotUpdateMetadataTrigger) },
        { },
    };

    static PyType_Spec type_spec_WiFiOnDemandHotspotUpdateMetadataTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.WiFiOnDemandHotspotUpdateMetadataTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::WiFiOnDemandHotspotUpdateMetadataTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WiFiOnDemandHotspotUpdateMetadataTrigger
    };

    // ----- IBackgroundCondition interface --------------------
    static constexpr const char* const type_name_IBackgroundCondition = "IBackgroundCondition";

    static PyObject* _new_IBackgroundCondition(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IBackgroundCondition);
        return nullptr;
    }

    static void _dealloc_IBackgroundCondition(py::wrapper::Windows::ApplicationModel::Background::IBackgroundCondition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_IBackgroundCondition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::IBackgroundCondition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundCondition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::IBackgroundCondition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundCondition[] = {
        { "_assign_array_", _assign_array_IBackgroundCondition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundCondition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundCondition[] = {
        { }
    };

    static PyType_Slot _type_slots_IBackgroundCondition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundCondition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundCondition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundCondition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundCondition) },
        { },
    };

    static PyType_Spec type_spec_IBackgroundCondition =
    {
        "_winsdk_Windows_ApplicationModel_Background.IBackgroundCondition",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::IBackgroundCondition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundCondition
    };

    // ----- IBackgroundTask interface --------------------
    static constexpr const char* const type_name_IBackgroundTask = "IBackgroundTask";

    static PyObject* _new_IBackgroundTask(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IBackgroundTask);
        return nullptr;
    }

    static void _dealloc_IBackgroundTask(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTask* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundTask_Run(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTask* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.IBackgroundTask", L"Run", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance>(args, 0);

                self->obj.Run(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBackgroundTask(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::IBackgroundTask>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundTask(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::IBackgroundTask>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTask[] = {
        { "run", reinterpret_cast<PyCFunction>(IBackgroundTask_Run), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IBackgroundTask, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTask), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTask[] = {
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTask[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundTask) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundTask) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundTask) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundTask) },
        { },
    };

    static PyType_Spec type_spec_IBackgroundTask =
    {
        "_winsdk_Windows_ApplicationModel_Background.IBackgroundTask",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTask),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTask
    };

    // ----- IBackgroundTaskInstance interface --------------------
    static constexpr const char* const type_name_IBackgroundTaskInstance = "IBackgroundTaskInstance";

    static PyObject* _new_IBackgroundTaskInstance(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IBackgroundTaskInstance);
        return nullptr;
    }

    static void _dealloc_IBackgroundTaskInstance(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundTaskInstance_GetDeferral(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance_get_InstanceId(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"InstanceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance_get_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTaskInstance_put_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Progress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTaskInstance_get_SuspendedCount(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"SuspendedCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SuspendedCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance_get_Task(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Task"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Task());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance_get_TriggerDetails(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"TriggerDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TriggerDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance_add_Canceled(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Canceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskCanceledEventHandler>(arg);

            return py::convert(self->obj.Canceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance_remove_Canceled(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Canceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Canceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBackgroundTaskInstance(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundTaskInstance(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTaskInstance[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(IBackgroundTaskInstance_GetDeferral), METH_VARARGS, nullptr },
        { "add_canceled", reinterpret_cast<PyCFunction>(IBackgroundTaskInstance_add_Canceled), METH_O, nullptr },
        { "remove_canceled", reinterpret_cast<PyCFunction>(IBackgroundTaskInstance_remove_Canceled), METH_O, nullptr },
        { "_assign_array_", _assign_array_IBackgroundTaskInstance, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTaskInstance), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTaskInstance[] = {
        { "instance_id", reinterpret_cast<getter>(IBackgroundTaskInstance_get_InstanceId), nullptr, nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(IBackgroundTaskInstance_get_Progress), reinterpret_cast<setter>(IBackgroundTaskInstance_put_Progress), nullptr, nullptr },
        { "suspended_count", reinterpret_cast<getter>(IBackgroundTaskInstance_get_SuspendedCount), nullptr, nullptr, nullptr },
        { "task", reinterpret_cast<getter>(IBackgroundTaskInstance_get_Task), nullptr, nullptr, nullptr },
        { "trigger_details", reinterpret_cast<getter>(IBackgroundTaskInstance_get_TriggerDetails), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTaskInstance[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundTaskInstance) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundTaskInstance) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundTaskInstance) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundTaskInstance) },
        { },
    };

    static PyType_Spec type_spec_IBackgroundTaskInstance =
    {
        "_winsdk_Windows_ApplicationModel_Background.IBackgroundTaskInstance",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTaskInstance
    };

    // ----- IBackgroundTaskInstance2 interface --------------------
    static constexpr const char* const type_name_IBackgroundTaskInstance2 = "IBackgroundTaskInstance2";

    static PyObject* _new_IBackgroundTaskInstance2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IBackgroundTaskInstance2);
        return nullptr;
    }

    static void _dealloc_IBackgroundTaskInstance2(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundTaskInstance2_GetDeferral(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance2_GetThrottleCount(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance2", L"GetThrottleCount", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskThrottleCounter>(args, 0);

                return py::convert(self->obj.GetThrottleCount(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance2_get_InstanceId(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"InstanceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance2_get_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTaskInstance2_put_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Progress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTaskInstance2_get_SuspendedCount(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"SuspendedCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SuspendedCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance2_get_Task(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Task"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Task());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance2_get_TriggerDetails(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"TriggerDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TriggerDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance2_add_Canceled(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Canceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskCanceledEventHandler>(arg);

            return py::convert(self->obj.Canceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance2_remove_Canceled(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Canceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Canceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBackgroundTaskInstance2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundTaskInstance2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTaskInstance2[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(IBackgroundTaskInstance2_GetDeferral), METH_VARARGS, nullptr },
        { "get_throttle_count", reinterpret_cast<PyCFunction>(IBackgroundTaskInstance2_GetThrottleCount), METH_VARARGS, nullptr },
        { "add_canceled", reinterpret_cast<PyCFunction>(IBackgroundTaskInstance2_add_Canceled), METH_O, nullptr },
        { "remove_canceled", reinterpret_cast<PyCFunction>(IBackgroundTaskInstance2_remove_Canceled), METH_O, nullptr },
        { "_assign_array_", _assign_array_IBackgroundTaskInstance2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTaskInstance2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTaskInstance2[] = {
        { "instance_id", reinterpret_cast<getter>(IBackgroundTaskInstance2_get_InstanceId), nullptr, nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(IBackgroundTaskInstance2_get_Progress), reinterpret_cast<setter>(IBackgroundTaskInstance2_put_Progress), nullptr, nullptr },
        { "suspended_count", reinterpret_cast<getter>(IBackgroundTaskInstance2_get_SuspendedCount), nullptr, nullptr, nullptr },
        { "task", reinterpret_cast<getter>(IBackgroundTaskInstance2_get_Task), nullptr, nullptr, nullptr },
        { "trigger_details", reinterpret_cast<getter>(IBackgroundTaskInstance2_get_TriggerDetails), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTaskInstance2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundTaskInstance2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundTaskInstance2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundTaskInstance2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundTaskInstance2) },
        { },
    };

    static PyType_Spec type_spec_IBackgroundTaskInstance2 =
    {
        "_winsdk_Windows_ApplicationModel_Background.IBackgroundTaskInstance2",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTaskInstance2
    };

    // ----- IBackgroundTaskInstance4 interface --------------------
    static constexpr const char* const type_name_IBackgroundTaskInstance4 = "IBackgroundTaskInstance4";

    static PyObject* _new_IBackgroundTaskInstance4(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IBackgroundTaskInstance4);
        return nullptr;
    }

    static void _dealloc_IBackgroundTaskInstance4(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundTaskInstance4_GetDeferral(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance4_get_User(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance4", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance4_get_InstanceId(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"InstanceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance4_get_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTaskInstance4_put_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Progress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTaskInstance4_get_SuspendedCount(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"SuspendedCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SuspendedCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance4_get_Task(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Task"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Task());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance4_get_TriggerDetails(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"TriggerDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TriggerDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance4_add_Canceled(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Canceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskCanceledEventHandler>(arg);

            return py::convert(self->obj.Canceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance4_remove_Canceled(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Canceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Canceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBackgroundTaskInstance4(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance4>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundTaskInstance4(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance4>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTaskInstance4[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(IBackgroundTaskInstance4_GetDeferral), METH_VARARGS, nullptr },
        { "add_canceled", reinterpret_cast<PyCFunction>(IBackgroundTaskInstance4_add_Canceled), METH_O, nullptr },
        { "remove_canceled", reinterpret_cast<PyCFunction>(IBackgroundTaskInstance4_remove_Canceled), METH_O, nullptr },
        { "_assign_array_", _assign_array_IBackgroundTaskInstance4, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTaskInstance4), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTaskInstance4[] = {
        { "user", reinterpret_cast<getter>(IBackgroundTaskInstance4_get_User), nullptr, nullptr, nullptr },
        { "instance_id", reinterpret_cast<getter>(IBackgroundTaskInstance4_get_InstanceId), nullptr, nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(IBackgroundTaskInstance4_get_Progress), reinterpret_cast<setter>(IBackgroundTaskInstance4_put_Progress), nullptr, nullptr },
        { "suspended_count", reinterpret_cast<getter>(IBackgroundTaskInstance4_get_SuspendedCount), nullptr, nullptr, nullptr },
        { "task", reinterpret_cast<getter>(IBackgroundTaskInstance4_get_Task), nullptr, nullptr, nullptr },
        { "trigger_details", reinterpret_cast<getter>(IBackgroundTaskInstance4_get_TriggerDetails), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTaskInstance4[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundTaskInstance4) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundTaskInstance4) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundTaskInstance4) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundTaskInstance4) },
        { },
    };

    static PyType_Spec type_spec_IBackgroundTaskInstance4 =
    {
        "_winsdk_Windows_ApplicationModel_Background.IBackgroundTaskInstance4",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTaskInstance4
    };

    // ----- IBackgroundTaskRegistration interface --------------------
    static constexpr const char* const type_name_IBackgroundTaskRegistration = "IBackgroundTaskRegistration";

    static PyObject* _new_IBackgroundTaskRegistration(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IBackgroundTaskRegistration);
        return nullptr;
    }

    static void _dealloc_IBackgroundTaskRegistration(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundTaskRegistration_Unregister(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Unregister", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.Unregister(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration_get_Name(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration_get_TaskId(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"TaskId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration_add_Completed(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventHandler>(arg);

            return py::convert(self->obj.Completed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration_remove_Completed(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration_add_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskProgressEventHandler>(arg);

            return py::convert(self->obj.Progress(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration_remove_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Progress(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBackgroundTaskRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundTaskRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTaskRegistration[] = {
        { "unregister", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration_Unregister), METH_VARARGS, nullptr },
        { "add_completed", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration_add_Completed), METH_O, nullptr },
        { "remove_completed", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration_remove_Completed), METH_O, nullptr },
        { "add_progress", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration_add_Progress), METH_O, nullptr },
        { "remove_progress", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration_remove_Progress), METH_O, nullptr },
        { "_assign_array_", _assign_array_IBackgroundTaskRegistration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTaskRegistration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTaskRegistration[] = {
        { "name", reinterpret_cast<getter>(IBackgroundTaskRegistration_get_Name), nullptr, nullptr, nullptr },
        { "task_id", reinterpret_cast<getter>(IBackgroundTaskRegistration_get_TaskId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTaskRegistration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundTaskRegistration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundTaskRegistration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundTaskRegistration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundTaskRegistration) },
        { },
    };

    static PyType_Spec type_spec_IBackgroundTaskRegistration =
    {
        "_winsdk_Windows_ApplicationModel_Background.IBackgroundTaskRegistration",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTaskRegistration
    };

    // ----- IBackgroundTaskRegistration2 interface --------------------
    static constexpr const char* const type_name_IBackgroundTaskRegistration2 = "IBackgroundTaskRegistration2";

    static PyObject* _new_IBackgroundTaskRegistration2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IBackgroundTaskRegistration2);
        return nullptr;
    }

    static void _dealloc_IBackgroundTaskRegistration2(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundTaskRegistration2_Unregister(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Unregister", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.Unregister(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration2_get_Trigger(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration2", L"Trigger"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Trigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration2_get_Name(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration2_get_TaskId(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"TaskId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration2_add_Completed(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventHandler>(arg);

            return py::convert(self->obj.Completed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration2_remove_Completed(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration2_add_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskProgressEventHandler>(arg);

            return py::convert(self->obj.Progress(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration2_remove_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Progress(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBackgroundTaskRegistration2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundTaskRegistration2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTaskRegistration2[] = {
        { "unregister", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration2_Unregister), METH_VARARGS, nullptr },
        { "add_completed", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration2_add_Completed), METH_O, nullptr },
        { "remove_completed", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration2_remove_Completed), METH_O, nullptr },
        { "add_progress", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration2_add_Progress), METH_O, nullptr },
        { "remove_progress", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration2_remove_Progress), METH_O, nullptr },
        { "_assign_array_", _assign_array_IBackgroundTaskRegistration2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTaskRegistration2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTaskRegistration2[] = {
        { "trigger", reinterpret_cast<getter>(IBackgroundTaskRegistration2_get_Trigger), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IBackgroundTaskRegistration2_get_Name), nullptr, nullptr, nullptr },
        { "task_id", reinterpret_cast<getter>(IBackgroundTaskRegistration2_get_TaskId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTaskRegistration2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundTaskRegistration2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundTaskRegistration2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundTaskRegistration2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundTaskRegistration2) },
        { },
    };

    static PyType_Spec type_spec_IBackgroundTaskRegistration2 =
    {
        "_winsdk_Windows_ApplicationModel_Background.IBackgroundTaskRegistration2",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTaskRegistration2
    };

    // ----- IBackgroundTaskRegistration3 interface --------------------
    static constexpr const char* const type_name_IBackgroundTaskRegistration3 = "IBackgroundTaskRegistration3";

    static PyObject* _new_IBackgroundTaskRegistration3(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IBackgroundTaskRegistration3);
        return nullptr;
    }

    static void _dealloc_IBackgroundTaskRegistration3(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundTaskRegistration3_Unregister(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Unregister", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.Unregister(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration3_get_TaskGroup(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration3", L"TaskGroup"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TaskGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration3_get_Name(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration3_get_TaskId(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"TaskId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration3_add_Completed(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventHandler>(arg);

            return py::convert(self->obj.Completed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration3_remove_Completed(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration3_add_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskProgressEventHandler>(arg);

            return py::convert(self->obj.Progress(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration3_remove_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Progress(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBackgroundTaskRegistration3(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundTaskRegistration3(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTaskRegistration3[] = {
        { "unregister", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration3_Unregister), METH_VARARGS, nullptr },
        { "add_completed", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration3_add_Completed), METH_O, nullptr },
        { "remove_completed", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration3_remove_Completed), METH_O, nullptr },
        { "add_progress", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration3_add_Progress), METH_O, nullptr },
        { "remove_progress", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration3_remove_Progress), METH_O, nullptr },
        { "_assign_array_", _assign_array_IBackgroundTaskRegistration3, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTaskRegistration3), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTaskRegistration3[] = {
        { "task_group", reinterpret_cast<getter>(IBackgroundTaskRegistration3_get_TaskGroup), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IBackgroundTaskRegistration3_get_Name), nullptr, nullptr, nullptr },
        { "task_id", reinterpret_cast<getter>(IBackgroundTaskRegistration3_get_TaskId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTaskRegistration3[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundTaskRegistration3) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundTaskRegistration3) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundTaskRegistration3) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundTaskRegistration3) },
        { },
    };

    static PyType_Spec type_spec_IBackgroundTaskRegistration3 =
    {
        "_winsdk_Windows_ApplicationModel_Background.IBackgroundTaskRegistration3",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTaskRegistration3
    };

    // ----- IBackgroundTrigger interface --------------------
    static constexpr const char* const type_name_IBackgroundTrigger = "IBackgroundTrigger";

    static PyObject* _new_IBackgroundTrigger(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IBackgroundTrigger);
        return nullptr;
    }

    static void _dealloc_IBackgroundTrigger(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_IBackgroundTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::IBackgroundTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::IBackgroundTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTrigger[] = {
        { "_assign_array_", _assign_array_IBackgroundTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundTrigger) },
        { },
    };

    static PyType_Spec type_spec_IBackgroundTrigger =
    {
        "_winsdk_Windows_ApplicationModel_Background.IBackgroundTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTrigger
    };

    // ----- Windows.ApplicationModel.Background Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::ApplicationModel::Background");

    static PyMethodDef module_methods[] = {
        {"_register_AlarmAccessStatus", register_AlarmAccessStatus, METH_O, "registers type"},
        {"_register_ApplicationTriggerResult", register_ApplicationTriggerResult, METH_O, "registers type"},
        {"_register_BackgroundAccessRequestKind", register_BackgroundAccessRequestKind, METH_O, "registers type"},
        {"_register_BackgroundAccessStatus", register_BackgroundAccessStatus, METH_O, "registers type"},
        {"_register_BackgroundTaskCancellationReason", register_BackgroundTaskCancellationReason, METH_O, "registers type"},
        {"_register_BackgroundTaskThrottleCounter", register_BackgroundTaskThrottleCounter, METH_O, "registers type"},
        {"_register_BackgroundWorkCostValue", register_BackgroundWorkCostValue, METH_O, "registers type"},
        {"_register_CustomSystemEventTriggerRecurrence", register_CustomSystemEventTriggerRecurrence, METH_O, "registers type"},
        {"_register_DeviceTriggerResult", register_DeviceTriggerResult, METH_O, "registers type"},
        {"_register_LocationTriggerType", register_LocationTriggerType, METH_O, "registers type"},
        {"_register_MediaProcessingTriggerResult", register_MediaProcessingTriggerResult, METH_O, "registers type"},
        {"_register_SystemConditionType", register_SystemConditionType, METH_O, "registers type"},
        {"_register_SystemTriggerType", register_SystemTriggerType, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_AlarmAccessStatus);
        Py_VISIT(state->type_ApplicationTriggerResult);
        Py_VISIT(state->type_BackgroundAccessRequestKind);
        Py_VISIT(state->type_BackgroundAccessStatus);
        Py_VISIT(state->type_BackgroundTaskCancellationReason);
        Py_VISIT(state->type_BackgroundTaskThrottleCounter);
        Py_VISIT(state->type_BackgroundWorkCostValue);
        Py_VISIT(state->type_CustomSystemEventTriggerRecurrence);
        Py_VISIT(state->type_DeviceTriggerResult);
        Py_VISIT(state->type_LocationTriggerType);
        Py_VISIT(state->type_MediaProcessingTriggerResult);
        Py_VISIT(state->type_SystemConditionType);
        Py_VISIT(state->type_SystemTriggerType);
        Py_VISIT(state->type_ActivitySensorTrigger);
        Py_VISIT(state->type_AlarmApplicationManager);
        Py_VISIT(state->type_AppBroadcastTrigger);
        Py_VISIT(state->type_AppBroadcastTriggerProviderInfo);
        Py_VISIT(state->type_ApplicationTrigger);
        Py_VISIT(state->type_ApplicationTriggerDetails);
        Py_VISIT(state->type_AppointmentStoreNotificationTrigger);
        Py_VISIT(state->type_BackgroundExecutionManager);
        Py_VISIT(state->type_BackgroundTaskBuilder);
        Py_VISIT(state->type_BackgroundTaskCompletedEventArgs);
        Py_VISIT(state->type_BackgroundTaskDeferral);
        Py_VISIT(state->type_BackgroundTaskProgressEventArgs);
        Py_VISIT(state->type_BackgroundTaskRegistration);
        Py_VISIT(state->type_BackgroundTaskRegistrationGroup);
        Py_VISIT(state->type_BackgroundWorkCost);
        Py_VISIT(state->type_BluetoothLEAdvertisementPublisherTrigger);
        Py_VISIT(state->type_BluetoothLEAdvertisementWatcherTrigger);
        Py_VISIT(state->type_CachedFileUpdaterTrigger);
        Py_VISIT(state->type_CachedFileUpdaterTriggerDetails);
        Py_VISIT(state->type_ChatMessageNotificationTrigger);
        Py_VISIT(state->type_ChatMessageReceivedNotificationTrigger);
        Py_VISIT(state->type_CommunicationBlockingAppSetAsActiveTrigger);
        Py_VISIT(state->type_ContactStoreNotificationTrigger);
        Py_VISIT(state->type_ContentPrefetchTrigger);
        Py_VISIT(state->type_ConversationalAgentTrigger);
        Py_VISIT(state->type_CustomSystemEventTrigger);
        Py_VISIT(state->type_DeviceConnectionChangeTrigger);
        Py_VISIT(state->type_DeviceManufacturerNotificationTrigger);
        Py_VISIT(state->type_DeviceServicingTrigger);
        Py_VISIT(state->type_DeviceUseTrigger);
        Py_VISIT(state->type_DeviceWatcherTrigger);
        Py_VISIT(state->type_EmailStoreNotificationTrigger);
        Py_VISIT(state->type_GattCharacteristicNotificationTrigger);
        Py_VISIT(state->type_GattServiceProviderTrigger);
        Py_VISIT(state->type_GattServiceProviderTriggerResult);
        Py_VISIT(state->type_GeovisitTrigger);
        Py_VISIT(state->type_LocationTrigger);
        Py_VISIT(state->type_MaintenanceTrigger);
        Py_VISIT(state->type_MediaProcessingTrigger);
        Py_VISIT(state->type_MobileBroadbandDeviceServiceNotificationTrigger);
        Py_VISIT(state->type_MobileBroadbandPcoDataChangeTrigger);
        Py_VISIT(state->type_MobileBroadbandPinLockStateChangeTrigger);
        Py_VISIT(state->type_MobileBroadbandRadioStateChangeTrigger);
        Py_VISIT(state->type_MobileBroadbandRegistrationStateChangeTrigger);
        Py_VISIT(state->type_NetworkOperatorDataUsageTrigger);
        Py_VISIT(state->type_NetworkOperatorHotspotAuthenticationTrigger);
        Py_VISIT(state->type_NetworkOperatorNotificationTrigger);
        Py_VISIT(state->type_PaymentAppCanMakePaymentTrigger);
        Py_VISIT(state->type_PhoneTrigger);
        Py_VISIT(state->type_PushNotificationTrigger);
        Py_VISIT(state->type_RcsEndUserMessageAvailableTrigger);
        Py_VISIT(state->type_RfcommConnectionTrigger);
        Py_VISIT(state->type_SecondaryAuthenticationFactorAuthenticationTrigger);
        Py_VISIT(state->type_SensorDataThresholdTrigger);
        Py_VISIT(state->type_SmartCardTrigger);
        Py_VISIT(state->type_SmsMessageReceivedTrigger);
        Py_VISIT(state->type_SocketActivityTrigger);
        Py_VISIT(state->type_StorageLibraryChangeTrackerTrigger);
        Py_VISIT(state->type_StorageLibraryContentChangedTrigger);
        Py_VISIT(state->type_SystemCondition);
        Py_VISIT(state->type_SystemTrigger);
        Py_VISIT(state->type_TetheringEntitlementCheckTrigger);
        Py_VISIT(state->type_TimeTrigger);
        Py_VISIT(state->type_ToastNotificationActionTrigger);
        Py_VISIT(state->type_ToastNotificationHistoryChangedTrigger);
        Py_VISIT(state->type_UserNotificationChangedTrigger);
        Py_VISIT(state->type_WiFiOnDemandHotspotConnectTrigger);
        Py_VISIT(state->type_WiFiOnDemandHotspotUpdateMetadataTrigger);
        Py_VISIT(state->type_IBackgroundCondition);
        Py_VISIT(state->type_IBackgroundTask);
        Py_VISIT(state->type_IBackgroundTaskInstance);
        Py_VISIT(state->type_IBackgroundTaskInstance2);
        Py_VISIT(state->type_IBackgroundTaskInstance4);
        Py_VISIT(state->type_IBackgroundTaskRegistration);
        Py_VISIT(state->type_IBackgroundTaskRegistration2);
        Py_VISIT(state->type_IBackgroundTaskRegistration3);
        Py_VISIT(state->type_IBackgroundTrigger);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_AlarmAccessStatus);
        Py_CLEAR(state->type_ApplicationTriggerResult);
        Py_CLEAR(state->type_BackgroundAccessRequestKind);
        Py_CLEAR(state->type_BackgroundAccessStatus);
        Py_CLEAR(state->type_BackgroundTaskCancellationReason);
        Py_CLEAR(state->type_BackgroundTaskThrottleCounter);
        Py_CLEAR(state->type_BackgroundWorkCostValue);
        Py_CLEAR(state->type_CustomSystemEventTriggerRecurrence);
        Py_CLEAR(state->type_DeviceTriggerResult);
        Py_CLEAR(state->type_LocationTriggerType);
        Py_CLEAR(state->type_MediaProcessingTriggerResult);
        Py_CLEAR(state->type_SystemConditionType);
        Py_CLEAR(state->type_SystemTriggerType);
        Py_CLEAR(state->type_ActivitySensorTrigger);
        Py_CLEAR(state->type_AlarmApplicationManager);
        Py_CLEAR(state->type_AppBroadcastTrigger);
        Py_CLEAR(state->type_AppBroadcastTriggerProviderInfo);
        Py_CLEAR(state->type_ApplicationTrigger);
        Py_CLEAR(state->type_ApplicationTriggerDetails);
        Py_CLEAR(state->type_AppointmentStoreNotificationTrigger);
        Py_CLEAR(state->type_BackgroundExecutionManager);
        Py_CLEAR(state->type_BackgroundTaskBuilder);
        Py_CLEAR(state->type_BackgroundTaskCompletedEventArgs);
        Py_CLEAR(state->type_BackgroundTaskDeferral);
        Py_CLEAR(state->type_BackgroundTaskProgressEventArgs);
        Py_CLEAR(state->type_BackgroundTaskRegistration);
        Py_CLEAR(state->type_BackgroundTaskRegistrationGroup);
        Py_CLEAR(state->type_BackgroundWorkCost);
        Py_CLEAR(state->type_BluetoothLEAdvertisementPublisherTrigger);
        Py_CLEAR(state->type_BluetoothLEAdvertisementWatcherTrigger);
        Py_CLEAR(state->type_CachedFileUpdaterTrigger);
        Py_CLEAR(state->type_CachedFileUpdaterTriggerDetails);
        Py_CLEAR(state->type_ChatMessageNotificationTrigger);
        Py_CLEAR(state->type_ChatMessageReceivedNotificationTrigger);
        Py_CLEAR(state->type_CommunicationBlockingAppSetAsActiveTrigger);
        Py_CLEAR(state->type_ContactStoreNotificationTrigger);
        Py_CLEAR(state->type_ContentPrefetchTrigger);
        Py_CLEAR(state->type_ConversationalAgentTrigger);
        Py_CLEAR(state->type_CustomSystemEventTrigger);
        Py_CLEAR(state->type_DeviceConnectionChangeTrigger);
        Py_CLEAR(state->type_DeviceManufacturerNotificationTrigger);
        Py_CLEAR(state->type_DeviceServicingTrigger);
        Py_CLEAR(state->type_DeviceUseTrigger);
        Py_CLEAR(state->type_DeviceWatcherTrigger);
        Py_CLEAR(state->type_EmailStoreNotificationTrigger);
        Py_CLEAR(state->type_GattCharacteristicNotificationTrigger);
        Py_CLEAR(state->type_GattServiceProviderTrigger);
        Py_CLEAR(state->type_GattServiceProviderTriggerResult);
        Py_CLEAR(state->type_GeovisitTrigger);
        Py_CLEAR(state->type_LocationTrigger);
        Py_CLEAR(state->type_MaintenanceTrigger);
        Py_CLEAR(state->type_MediaProcessingTrigger);
        Py_CLEAR(state->type_MobileBroadbandDeviceServiceNotificationTrigger);
        Py_CLEAR(state->type_MobileBroadbandPcoDataChangeTrigger);
        Py_CLEAR(state->type_MobileBroadbandPinLockStateChangeTrigger);
        Py_CLEAR(state->type_MobileBroadbandRadioStateChangeTrigger);
        Py_CLEAR(state->type_MobileBroadbandRegistrationStateChangeTrigger);
        Py_CLEAR(state->type_NetworkOperatorDataUsageTrigger);
        Py_CLEAR(state->type_NetworkOperatorHotspotAuthenticationTrigger);
        Py_CLEAR(state->type_NetworkOperatorNotificationTrigger);
        Py_CLEAR(state->type_PaymentAppCanMakePaymentTrigger);
        Py_CLEAR(state->type_PhoneTrigger);
        Py_CLEAR(state->type_PushNotificationTrigger);
        Py_CLEAR(state->type_RcsEndUserMessageAvailableTrigger);
        Py_CLEAR(state->type_RfcommConnectionTrigger);
        Py_CLEAR(state->type_SecondaryAuthenticationFactorAuthenticationTrigger);
        Py_CLEAR(state->type_SensorDataThresholdTrigger);
        Py_CLEAR(state->type_SmartCardTrigger);
        Py_CLEAR(state->type_SmsMessageReceivedTrigger);
        Py_CLEAR(state->type_SocketActivityTrigger);
        Py_CLEAR(state->type_StorageLibraryChangeTrackerTrigger);
        Py_CLEAR(state->type_StorageLibraryContentChangedTrigger);
        Py_CLEAR(state->type_SystemCondition);
        Py_CLEAR(state->type_SystemTrigger);
        Py_CLEAR(state->type_TetheringEntitlementCheckTrigger);
        Py_CLEAR(state->type_TimeTrigger);
        Py_CLEAR(state->type_ToastNotificationActionTrigger);
        Py_CLEAR(state->type_ToastNotificationHistoryChangedTrigger);
        Py_CLEAR(state->type_UserNotificationChangedTrigger);
        Py_CLEAR(state->type_WiFiOnDemandHotspotConnectTrigger);
        Py_CLEAR(state->type_WiFiOnDemandHotspotUpdateMetadataTrigger);
        Py_CLEAR(state->type_IBackgroundCondition);
        Py_CLEAR(state->type_IBackgroundTask);
        Py_CLEAR(state->type_IBackgroundTaskInstance);
        Py_CLEAR(state->type_IBackgroundTaskInstance2);
        Py_CLEAR(state->type_IBackgroundTaskInstance4);
        Py_CLEAR(state->type_IBackgroundTaskRegistration);
        Py_CLEAR(state->type_IBackgroundTaskRegistration2);
        Py_CLEAR(state->type_IBackgroundTaskRegistration3);
        Py_CLEAR(state->type_IBackgroundTrigger);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_ApplicationModel_Background",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::ApplicationModel::Background

PyMODINIT_FUNC PyInit__winsdk_Windows_ApplicationModel_Background(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::Background;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_ActivitySensorTrigger = py::register_python_type(module.get(), type_name_ActivitySensorTrigger, &type_spec_ActivitySensorTrigger, bases.get(), nullptr);
    if (!state->type_ActivitySensorTrigger)
    {
        return nullptr;
    }

    state->type_AlarmApplicationManager = py::register_python_type(module.get(), type_name_AlarmApplicationManager, &type_spec_AlarmApplicationManager, nullptr, nullptr);
    if (!state->type_AlarmApplicationManager)
    {
        return nullptr;
    }

    state->type_AppBroadcastTrigger = py::register_python_type(module.get(), type_name_AppBroadcastTrigger, &type_spec_AppBroadcastTrigger, bases.get(), nullptr);
    if (!state->type_AppBroadcastTrigger)
    {
        return nullptr;
    }

    state->type_AppBroadcastTriggerProviderInfo = py::register_python_type(module.get(), type_name_AppBroadcastTriggerProviderInfo, &type_spec_AppBroadcastTriggerProviderInfo, bases.get(), nullptr);
    if (!state->type_AppBroadcastTriggerProviderInfo)
    {
        return nullptr;
    }

    state->type_ApplicationTrigger = py::register_python_type(module.get(), type_name_ApplicationTrigger, &type_spec_ApplicationTrigger, bases.get(), nullptr);
    if (!state->type_ApplicationTrigger)
    {
        return nullptr;
    }

    state->type_ApplicationTriggerDetails = py::register_python_type(module.get(), type_name_ApplicationTriggerDetails, &type_spec_ApplicationTriggerDetails, bases.get(), nullptr);
    if (!state->type_ApplicationTriggerDetails)
    {
        return nullptr;
    }

    state->type_AppointmentStoreNotificationTrigger = py::register_python_type(module.get(), type_name_AppointmentStoreNotificationTrigger, &type_spec_AppointmentStoreNotificationTrigger, bases.get(), nullptr);
    if (!state->type_AppointmentStoreNotificationTrigger)
    {
        return nullptr;
    }

    state->type_BackgroundExecutionManager = py::register_python_type(module.get(), type_name_BackgroundExecutionManager, &type_spec_BackgroundExecutionManager, nullptr, nullptr);
    if (!state->type_BackgroundExecutionManager)
    {
        return nullptr;
    }

    state->type_BackgroundTaskBuilder = py::register_python_type(module.get(), type_name_BackgroundTaskBuilder, &type_spec_BackgroundTaskBuilder, bases.get(), nullptr);
    if (!state->type_BackgroundTaskBuilder)
    {
        return nullptr;
    }

    state->type_BackgroundTaskCompletedEventArgs = py::register_python_type(module.get(), type_name_BackgroundTaskCompletedEventArgs, &type_spec_BackgroundTaskCompletedEventArgs, bases.get(), nullptr);
    if (!state->type_BackgroundTaskCompletedEventArgs)
    {
        return nullptr;
    }

    state->type_BackgroundTaskDeferral = py::register_python_type(module.get(), type_name_BackgroundTaskDeferral, &type_spec_BackgroundTaskDeferral, bases.get(), nullptr);
    if (!state->type_BackgroundTaskDeferral)
    {
        return nullptr;
    }

    state->type_BackgroundTaskProgressEventArgs = py::register_python_type(module.get(), type_name_BackgroundTaskProgressEventArgs, &type_spec_BackgroundTaskProgressEventArgs, bases.get(), nullptr);
    if (!state->type_BackgroundTaskProgressEventArgs)
    {
        return nullptr;
    }

    py::pyobj_handle type_BackgroundTaskRegistration_Meta{PyType_FromSpec(&type_spec_BackgroundTaskRegistration_Meta)};
    if (!type_BackgroundTaskRegistration_Meta)
    {
        return nullptr;
    }

    state->type_BackgroundTaskRegistration = py::register_python_type(module.get(), type_name_BackgroundTaskRegistration, &type_spec_BackgroundTaskRegistration, bases.get(), reinterpret_cast<PyTypeObject*>(type_BackgroundTaskRegistration_Meta.get()));
    if (!state->type_BackgroundTaskRegistration)
    {
        return nullptr;
    }

    state->type_BackgroundTaskRegistrationGroup = py::register_python_type(module.get(), type_name_BackgroundTaskRegistrationGroup, &type_spec_BackgroundTaskRegistrationGroup, bases.get(), nullptr);
    if (!state->type_BackgroundTaskRegistrationGroup)
    {
        return nullptr;
    }

    py::pyobj_handle type_BackgroundWorkCost_Meta{PyType_FromSpec(&type_spec_BackgroundWorkCost_Meta)};
    if (!type_BackgroundWorkCost_Meta)
    {
        return nullptr;
    }

    state->type_BackgroundWorkCost = py::register_python_type(module.get(), type_name_BackgroundWorkCost, &type_spec_BackgroundWorkCost, nullptr, reinterpret_cast<PyTypeObject*>(type_BackgroundWorkCost_Meta.get()));
    if (!state->type_BackgroundWorkCost)
    {
        return nullptr;
    }

    state->type_BluetoothLEAdvertisementPublisherTrigger = py::register_python_type(module.get(), type_name_BluetoothLEAdvertisementPublisherTrigger, &type_spec_BluetoothLEAdvertisementPublisherTrigger, bases.get(), nullptr);
    if (!state->type_BluetoothLEAdvertisementPublisherTrigger)
    {
        return nullptr;
    }

    state->type_BluetoothLEAdvertisementWatcherTrigger = py::register_python_type(module.get(), type_name_BluetoothLEAdvertisementWatcherTrigger, &type_spec_BluetoothLEAdvertisementWatcherTrigger, bases.get(), nullptr);
    if (!state->type_BluetoothLEAdvertisementWatcherTrigger)
    {
        return nullptr;
    }

    state->type_CachedFileUpdaterTrigger = py::register_python_type(module.get(), type_name_CachedFileUpdaterTrigger, &type_spec_CachedFileUpdaterTrigger, bases.get(), nullptr);
    if (!state->type_CachedFileUpdaterTrigger)
    {
        return nullptr;
    }

    state->type_CachedFileUpdaterTriggerDetails = py::register_python_type(module.get(), type_name_CachedFileUpdaterTriggerDetails, &type_spec_CachedFileUpdaterTriggerDetails, bases.get(), nullptr);
    if (!state->type_CachedFileUpdaterTriggerDetails)
    {
        return nullptr;
    }

    state->type_ChatMessageNotificationTrigger = py::register_python_type(module.get(), type_name_ChatMessageNotificationTrigger, &type_spec_ChatMessageNotificationTrigger, bases.get(), nullptr);
    if (!state->type_ChatMessageNotificationTrigger)
    {
        return nullptr;
    }

    state->type_ChatMessageReceivedNotificationTrigger = py::register_python_type(module.get(), type_name_ChatMessageReceivedNotificationTrigger, &type_spec_ChatMessageReceivedNotificationTrigger, bases.get(), nullptr);
    if (!state->type_ChatMessageReceivedNotificationTrigger)
    {
        return nullptr;
    }

    state->type_CommunicationBlockingAppSetAsActiveTrigger = py::register_python_type(module.get(), type_name_CommunicationBlockingAppSetAsActiveTrigger, &type_spec_CommunicationBlockingAppSetAsActiveTrigger, bases.get(), nullptr);
    if (!state->type_CommunicationBlockingAppSetAsActiveTrigger)
    {
        return nullptr;
    }

    state->type_ContactStoreNotificationTrigger = py::register_python_type(module.get(), type_name_ContactStoreNotificationTrigger, &type_spec_ContactStoreNotificationTrigger, bases.get(), nullptr);
    if (!state->type_ContactStoreNotificationTrigger)
    {
        return nullptr;
    }

    state->type_ContentPrefetchTrigger = py::register_python_type(module.get(), type_name_ContentPrefetchTrigger, &type_spec_ContentPrefetchTrigger, bases.get(), nullptr);
    if (!state->type_ContentPrefetchTrigger)
    {
        return nullptr;
    }

    state->type_ConversationalAgentTrigger = py::register_python_type(module.get(), type_name_ConversationalAgentTrigger, &type_spec_ConversationalAgentTrigger, bases.get(), nullptr);
    if (!state->type_ConversationalAgentTrigger)
    {
        return nullptr;
    }

    state->type_CustomSystemEventTrigger = py::register_python_type(module.get(), type_name_CustomSystemEventTrigger, &type_spec_CustomSystemEventTrigger, bases.get(), nullptr);
    if (!state->type_CustomSystemEventTrigger)
    {
        return nullptr;
    }

    state->type_DeviceConnectionChangeTrigger = py::register_python_type(module.get(), type_name_DeviceConnectionChangeTrigger, &type_spec_DeviceConnectionChangeTrigger, bases.get(), nullptr);
    if (!state->type_DeviceConnectionChangeTrigger)
    {
        return nullptr;
    }

    state->type_DeviceManufacturerNotificationTrigger = py::register_python_type(module.get(), type_name_DeviceManufacturerNotificationTrigger, &type_spec_DeviceManufacturerNotificationTrigger, bases.get(), nullptr);
    if (!state->type_DeviceManufacturerNotificationTrigger)
    {
        return nullptr;
    }

    state->type_DeviceServicingTrigger = py::register_python_type(module.get(), type_name_DeviceServicingTrigger, &type_spec_DeviceServicingTrigger, bases.get(), nullptr);
    if (!state->type_DeviceServicingTrigger)
    {
        return nullptr;
    }

    state->type_DeviceUseTrigger = py::register_python_type(module.get(), type_name_DeviceUseTrigger, &type_spec_DeviceUseTrigger, bases.get(), nullptr);
    if (!state->type_DeviceUseTrigger)
    {
        return nullptr;
    }

    state->type_DeviceWatcherTrigger = py::register_python_type(module.get(), type_name_DeviceWatcherTrigger, &type_spec_DeviceWatcherTrigger, bases.get(), nullptr);
    if (!state->type_DeviceWatcherTrigger)
    {
        return nullptr;
    }

    state->type_EmailStoreNotificationTrigger = py::register_python_type(module.get(), type_name_EmailStoreNotificationTrigger, &type_spec_EmailStoreNotificationTrigger, bases.get(), nullptr);
    if (!state->type_EmailStoreNotificationTrigger)
    {
        return nullptr;
    }

    state->type_GattCharacteristicNotificationTrigger = py::register_python_type(module.get(), type_name_GattCharacteristicNotificationTrigger, &type_spec_GattCharacteristicNotificationTrigger, bases.get(), nullptr);
    if (!state->type_GattCharacteristicNotificationTrigger)
    {
        return nullptr;
    }

    state->type_GattServiceProviderTrigger = py::register_python_type(module.get(), type_name_GattServiceProviderTrigger, &type_spec_GattServiceProviderTrigger, bases.get(), nullptr);
    if (!state->type_GattServiceProviderTrigger)
    {
        return nullptr;
    }

    state->type_GattServiceProviderTriggerResult = py::register_python_type(module.get(), type_name_GattServiceProviderTriggerResult, &type_spec_GattServiceProviderTriggerResult, bases.get(), nullptr);
    if (!state->type_GattServiceProviderTriggerResult)
    {
        return nullptr;
    }

    state->type_GeovisitTrigger = py::register_python_type(module.get(), type_name_GeovisitTrigger, &type_spec_GeovisitTrigger, bases.get(), nullptr);
    if (!state->type_GeovisitTrigger)
    {
        return nullptr;
    }

    state->type_LocationTrigger = py::register_python_type(module.get(), type_name_LocationTrigger, &type_spec_LocationTrigger, bases.get(), nullptr);
    if (!state->type_LocationTrigger)
    {
        return nullptr;
    }

    state->type_MaintenanceTrigger = py::register_python_type(module.get(), type_name_MaintenanceTrigger, &type_spec_MaintenanceTrigger, bases.get(), nullptr);
    if (!state->type_MaintenanceTrigger)
    {
        return nullptr;
    }

    state->type_MediaProcessingTrigger = py::register_python_type(module.get(), type_name_MediaProcessingTrigger, &type_spec_MediaProcessingTrigger, bases.get(), nullptr);
    if (!state->type_MediaProcessingTrigger)
    {
        return nullptr;
    }

    state->type_MobileBroadbandDeviceServiceNotificationTrigger = py::register_python_type(module.get(), type_name_MobileBroadbandDeviceServiceNotificationTrigger, &type_spec_MobileBroadbandDeviceServiceNotificationTrigger, bases.get(), nullptr);
    if (!state->type_MobileBroadbandDeviceServiceNotificationTrigger)
    {
        return nullptr;
    }

    state->type_MobileBroadbandPcoDataChangeTrigger = py::register_python_type(module.get(), type_name_MobileBroadbandPcoDataChangeTrigger, &type_spec_MobileBroadbandPcoDataChangeTrigger, bases.get(), nullptr);
    if (!state->type_MobileBroadbandPcoDataChangeTrigger)
    {
        return nullptr;
    }

    state->type_MobileBroadbandPinLockStateChangeTrigger = py::register_python_type(module.get(), type_name_MobileBroadbandPinLockStateChangeTrigger, &type_spec_MobileBroadbandPinLockStateChangeTrigger, bases.get(), nullptr);
    if (!state->type_MobileBroadbandPinLockStateChangeTrigger)
    {
        return nullptr;
    }

    state->type_MobileBroadbandRadioStateChangeTrigger = py::register_python_type(module.get(), type_name_MobileBroadbandRadioStateChangeTrigger, &type_spec_MobileBroadbandRadioStateChangeTrigger, bases.get(), nullptr);
    if (!state->type_MobileBroadbandRadioStateChangeTrigger)
    {
        return nullptr;
    }

    state->type_MobileBroadbandRegistrationStateChangeTrigger = py::register_python_type(module.get(), type_name_MobileBroadbandRegistrationStateChangeTrigger, &type_spec_MobileBroadbandRegistrationStateChangeTrigger, bases.get(), nullptr);
    if (!state->type_MobileBroadbandRegistrationStateChangeTrigger)
    {
        return nullptr;
    }

    state->type_NetworkOperatorDataUsageTrigger = py::register_python_type(module.get(), type_name_NetworkOperatorDataUsageTrigger, &type_spec_NetworkOperatorDataUsageTrigger, bases.get(), nullptr);
    if (!state->type_NetworkOperatorDataUsageTrigger)
    {
        return nullptr;
    }

    state->type_NetworkOperatorHotspotAuthenticationTrigger = py::register_python_type(module.get(), type_name_NetworkOperatorHotspotAuthenticationTrigger, &type_spec_NetworkOperatorHotspotAuthenticationTrigger, bases.get(), nullptr);
    if (!state->type_NetworkOperatorHotspotAuthenticationTrigger)
    {
        return nullptr;
    }

    state->type_NetworkOperatorNotificationTrigger = py::register_python_type(module.get(), type_name_NetworkOperatorNotificationTrigger, &type_spec_NetworkOperatorNotificationTrigger, bases.get(), nullptr);
    if (!state->type_NetworkOperatorNotificationTrigger)
    {
        return nullptr;
    }

    state->type_PaymentAppCanMakePaymentTrigger = py::register_python_type(module.get(), type_name_PaymentAppCanMakePaymentTrigger, &type_spec_PaymentAppCanMakePaymentTrigger, bases.get(), nullptr);
    if (!state->type_PaymentAppCanMakePaymentTrigger)
    {
        return nullptr;
    }

    state->type_PhoneTrigger = py::register_python_type(module.get(), type_name_PhoneTrigger, &type_spec_PhoneTrigger, bases.get(), nullptr);
    if (!state->type_PhoneTrigger)
    {
        return nullptr;
    }

    state->type_PushNotificationTrigger = py::register_python_type(module.get(), type_name_PushNotificationTrigger, &type_spec_PushNotificationTrigger, bases.get(), nullptr);
    if (!state->type_PushNotificationTrigger)
    {
        return nullptr;
    }

    state->type_RcsEndUserMessageAvailableTrigger = py::register_python_type(module.get(), type_name_RcsEndUserMessageAvailableTrigger, &type_spec_RcsEndUserMessageAvailableTrigger, bases.get(), nullptr);
    if (!state->type_RcsEndUserMessageAvailableTrigger)
    {
        return nullptr;
    }

    state->type_RfcommConnectionTrigger = py::register_python_type(module.get(), type_name_RfcommConnectionTrigger, &type_spec_RfcommConnectionTrigger, bases.get(), nullptr);
    if (!state->type_RfcommConnectionTrigger)
    {
        return nullptr;
    }

    state->type_SecondaryAuthenticationFactorAuthenticationTrigger = py::register_python_type(module.get(), type_name_SecondaryAuthenticationFactorAuthenticationTrigger, &type_spec_SecondaryAuthenticationFactorAuthenticationTrigger, bases.get(), nullptr);
    if (!state->type_SecondaryAuthenticationFactorAuthenticationTrigger)
    {
        return nullptr;
    }

    state->type_SensorDataThresholdTrigger = py::register_python_type(module.get(), type_name_SensorDataThresholdTrigger, &type_spec_SensorDataThresholdTrigger, bases.get(), nullptr);
    if (!state->type_SensorDataThresholdTrigger)
    {
        return nullptr;
    }

    state->type_SmartCardTrigger = py::register_python_type(module.get(), type_name_SmartCardTrigger, &type_spec_SmartCardTrigger, bases.get(), nullptr);
    if (!state->type_SmartCardTrigger)
    {
        return nullptr;
    }

    state->type_SmsMessageReceivedTrigger = py::register_python_type(module.get(), type_name_SmsMessageReceivedTrigger, &type_spec_SmsMessageReceivedTrigger, bases.get(), nullptr);
    if (!state->type_SmsMessageReceivedTrigger)
    {
        return nullptr;
    }

    state->type_SocketActivityTrigger = py::register_python_type(module.get(), type_name_SocketActivityTrigger, &type_spec_SocketActivityTrigger, bases.get(), nullptr);
    if (!state->type_SocketActivityTrigger)
    {
        return nullptr;
    }

    state->type_StorageLibraryChangeTrackerTrigger = py::register_python_type(module.get(), type_name_StorageLibraryChangeTrackerTrigger, &type_spec_StorageLibraryChangeTrackerTrigger, bases.get(), nullptr);
    if (!state->type_StorageLibraryChangeTrackerTrigger)
    {
        return nullptr;
    }

    state->type_StorageLibraryContentChangedTrigger = py::register_python_type(module.get(), type_name_StorageLibraryContentChangedTrigger, &type_spec_StorageLibraryContentChangedTrigger, bases.get(), nullptr);
    if (!state->type_StorageLibraryContentChangedTrigger)
    {
        return nullptr;
    }

    state->type_SystemCondition = py::register_python_type(module.get(), type_name_SystemCondition, &type_spec_SystemCondition, bases.get(), nullptr);
    if (!state->type_SystemCondition)
    {
        return nullptr;
    }

    state->type_SystemTrigger = py::register_python_type(module.get(), type_name_SystemTrigger, &type_spec_SystemTrigger, bases.get(), nullptr);
    if (!state->type_SystemTrigger)
    {
        return nullptr;
    }

    state->type_TetheringEntitlementCheckTrigger = py::register_python_type(module.get(), type_name_TetheringEntitlementCheckTrigger, &type_spec_TetheringEntitlementCheckTrigger, bases.get(), nullptr);
    if (!state->type_TetheringEntitlementCheckTrigger)
    {
        return nullptr;
    }

    state->type_TimeTrigger = py::register_python_type(module.get(), type_name_TimeTrigger, &type_spec_TimeTrigger, bases.get(), nullptr);
    if (!state->type_TimeTrigger)
    {
        return nullptr;
    }

    state->type_ToastNotificationActionTrigger = py::register_python_type(module.get(), type_name_ToastNotificationActionTrigger, &type_spec_ToastNotificationActionTrigger, bases.get(), nullptr);
    if (!state->type_ToastNotificationActionTrigger)
    {
        return nullptr;
    }

    state->type_ToastNotificationHistoryChangedTrigger = py::register_python_type(module.get(), type_name_ToastNotificationHistoryChangedTrigger, &type_spec_ToastNotificationHistoryChangedTrigger, bases.get(), nullptr);
    if (!state->type_ToastNotificationHistoryChangedTrigger)
    {
        return nullptr;
    }

    state->type_UserNotificationChangedTrigger = py::register_python_type(module.get(), type_name_UserNotificationChangedTrigger, &type_spec_UserNotificationChangedTrigger, bases.get(), nullptr);
    if (!state->type_UserNotificationChangedTrigger)
    {
        return nullptr;
    }

    state->type_WiFiOnDemandHotspotConnectTrigger = py::register_python_type(module.get(), type_name_WiFiOnDemandHotspotConnectTrigger, &type_spec_WiFiOnDemandHotspotConnectTrigger, bases.get(), nullptr);
    if (!state->type_WiFiOnDemandHotspotConnectTrigger)
    {
        return nullptr;
    }

    state->type_WiFiOnDemandHotspotUpdateMetadataTrigger = py::register_python_type(module.get(), type_name_WiFiOnDemandHotspotUpdateMetadataTrigger, &type_spec_WiFiOnDemandHotspotUpdateMetadataTrigger, bases.get(), nullptr);
    if (!state->type_WiFiOnDemandHotspotUpdateMetadataTrigger)
    {
        return nullptr;
    }

    state->type_IBackgroundCondition = py::register_python_type(module.get(), type_name_IBackgroundCondition, &type_spec_IBackgroundCondition, bases.get(), nullptr);
    if (!state->type_IBackgroundCondition)
    {
        return nullptr;
    }

    state->type_IBackgroundTask = py::register_python_type(module.get(), type_name_IBackgroundTask, &type_spec_IBackgroundTask, bases.get(), nullptr);
    if (!state->type_IBackgroundTask)
    {
        return nullptr;
    }

    state->type_IBackgroundTaskInstance = py::register_python_type(module.get(), type_name_IBackgroundTaskInstance, &type_spec_IBackgroundTaskInstance, bases.get(), nullptr);
    if (!state->type_IBackgroundTaskInstance)
    {
        return nullptr;
    }

    state->type_IBackgroundTaskInstance2 = py::register_python_type(module.get(), type_name_IBackgroundTaskInstance2, &type_spec_IBackgroundTaskInstance2, bases.get(), nullptr);
    if (!state->type_IBackgroundTaskInstance2)
    {
        return nullptr;
    }

    state->type_IBackgroundTaskInstance4 = py::register_python_type(module.get(), type_name_IBackgroundTaskInstance4, &type_spec_IBackgroundTaskInstance4, bases.get(), nullptr);
    if (!state->type_IBackgroundTaskInstance4)
    {
        return nullptr;
    }

    state->type_IBackgroundTaskRegistration = py::register_python_type(module.get(), type_name_IBackgroundTaskRegistration, &type_spec_IBackgroundTaskRegistration, bases.get(), nullptr);
    if (!state->type_IBackgroundTaskRegistration)
    {
        return nullptr;
    }

    state->type_IBackgroundTaskRegistration2 = py::register_python_type(module.get(), type_name_IBackgroundTaskRegistration2, &type_spec_IBackgroundTaskRegistration2, bases.get(), nullptr);
    if (!state->type_IBackgroundTaskRegistration2)
    {
        return nullptr;
    }

    state->type_IBackgroundTaskRegistration3 = py::register_python_type(module.get(), type_name_IBackgroundTaskRegistration3, &type_spec_IBackgroundTaskRegistration3, bases.get(), nullptr);
    if (!state->type_IBackgroundTaskRegistration3)
    {
        return nullptr;
    }

    state->type_IBackgroundTrigger = py::register_python_type(module.get(), type_name_IBackgroundTrigger, &type_spec_IBackgroundTrigger, bases.get(), nullptr);
    if (!state->type_IBackgroundTrigger)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Background::AlarmAccessStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AlarmAccessStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::AlarmAccessStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Background::ApplicationTriggerResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ApplicationTriggerResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::ApplicationTriggerResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Background::BackgroundAccessRequestKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundAccessRequestKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::BackgroundAccessRequestKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Background::BackgroundAccessStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundAccessStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::BackgroundAccessStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskCancellationReason>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundTaskCancellationReason;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::BackgroundTaskCancellationReason is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskThrottleCounter>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundTaskThrottleCounter;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::BackgroundTaskThrottleCounter is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Background::BackgroundWorkCostValue>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundWorkCostValue;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::BackgroundWorkCostValue is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Background::CustomSystemEventTriggerRecurrence>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CustomSystemEventTriggerRecurrence;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::CustomSystemEventTriggerRecurrence is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Background::DeviceTriggerResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceTriggerResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::DeviceTriggerResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Background::LocationTriggerType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LocationTriggerType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::LocationTriggerType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Background::MediaProcessingTriggerResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaProcessingTriggerResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::MediaProcessingTriggerResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Background::SystemConditionType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SystemConditionType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::SystemConditionType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Background::SystemTriggerType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SystemTriggerType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::SystemTriggerType is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::ActivitySensorTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ActivitySensorTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::ActivitySensorTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::AlarmApplicationManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AlarmApplicationManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::AlarmApplicationManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::AppBroadcastTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::AppBroadcastTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastTriggerProviderInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::ApplicationTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ApplicationTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::ApplicationTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::ApplicationTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ApplicationTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::ApplicationTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::AppointmentStoreNotificationTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppointmentStoreNotificationTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::AppointmentStoreNotificationTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundExecutionManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskBuilder>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundTaskBuilder;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::BackgroundTaskBuilder is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundTaskCompletedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskDeferral>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundTaskDeferral;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::BackgroundTaskDeferral is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskProgressEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundTaskProgressEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::BackgroundTaskProgressEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistration>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundTaskRegistration;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistration is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundTaskRegistrationGroup;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::BackgroundWorkCost>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundWorkCost;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::BackgroundWorkCost is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BluetoothLEAdvertisementPublisherTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BluetoothLEAdvertisementWatcherTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::CachedFileUpdaterTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CachedFileUpdaterTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::CachedFileUpdaterTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::CachedFileUpdaterTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CachedFileUpdaterTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::CachedFileUpdaterTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::ChatMessageNotificationTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ChatMessageNotificationTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::ChatMessageNotificationTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::ChatMessageReceivedNotificationTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ChatMessageReceivedNotificationTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::ChatMessageReceivedNotificationTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::CommunicationBlockingAppSetAsActiveTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CommunicationBlockingAppSetAsActiveTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::CommunicationBlockingAppSetAsActiveTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::ContactStoreNotificationTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactStoreNotificationTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::ContactStoreNotificationTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::ContentPrefetchTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContentPrefetchTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::ContentPrefetchTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::ConversationalAgentTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ConversationalAgentTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::ConversationalAgentTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::CustomSystemEventTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CustomSystemEventTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::CustomSystemEventTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceConnectionChangeTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::DeviceManufacturerNotificationTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceManufacturerNotificationTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::DeviceManufacturerNotificationTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::DeviceServicingTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceServicingTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::DeviceServicingTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::DeviceUseTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceUseTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::DeviceUseTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::DeviceWatcherTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceWatcherTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::DeviceWatcherTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::EmailStoreNotificationTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailStoreNotificationTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::EmailStoreNotificationTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::GattCharacteristicNotificationTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GattCharacteristicNotificationTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::GattCharacteristicNotificationTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::GattServiceProviderTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GattServiceProviderTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::GattServiceProviderTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::GattServiceProviderTriggerResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GattServiceProviderTriggerResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::GattServiceProviderTriggerResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::GeovisitTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GeovisitTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::GeovisitTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::LocationTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LocationTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::LocationTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::MaintenanceTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MaintenanceTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::MaintenanceTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::MediaProcessingTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaProcessingTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::MediaProcessingTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::MobileBroadbandDeviceServiceNotificationTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandDeviceServiceNotificationTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::MobileBroadbandDeviceServiceNotificationTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::MobileBroadbandPcoDataChangeTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandPcoDataChangeTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::MobileBroadbandPcoDataChangeTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::MobileBroadbandPinLockStateChangeTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandPinLockStateChangeTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::MobileBroadbandPinLockStateChangeTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::MobileBroadbandRadioStateChangeTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandRadioStateChangeTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::MobileBroadbandRadioStateChangeTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::MobileBroadbandRegistrationStateChangeTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandRegistrationStateChangeTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::MobileBroadbandRegistrationStateChangeTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::NetworkOperatorDataUsageTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkOperatorDataUsageTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::NetworkOperatorDataUsageTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::NetworkOperatorHotspotAuthenticationTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkOperatorHotspotAuthenticationTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::NetworkOperatorHotspotAuthenticationTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::NetworkOperatorNotificationTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkOperatorNotificationTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::NetworkOperatorNotificationTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::PaymentAppCanMakePaymentTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PaymentAppCanMakePaymentTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::PaymentAppCanMakePaymentTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::PhoneTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::PhoneTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::PushNotificationTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PushNotificationTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::PushNotificationTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::RcsEndUserMessageAvailableTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_RcsEndUserMessageAvailableTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::RcsEndUserMessageAvailableTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::RfcommConnectionTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_RfcommConnectionTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::RfcommConnectionTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::SecondaryAuthenticationFactorAuthenticationTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SecondaryAuthenticationFactorAuthenticationTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::SecondaryAuthenticationFactorAuthenticationTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::SensorDataThresholdTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SensorDataThresholdTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::SensorDataThresholdTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::SmartCardTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::SmartCardTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::SmsMessageReceivedTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmsMessageReceivedTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::SmsMessageReceivedTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::SocketActivityTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SocketActivityTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::SocketActivityTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::StorageLibraryChangeTrackerTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorageLibraryChangeTrackerTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::StorageLibraryChangeTrackerTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::StorageLibraryContentChangedTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorageLibraryContentChangedTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::StorageLibraryContentChangedTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::SystemCondition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SystemCondition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::SystemCondition is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::SystemTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SystemTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::SystemTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::TetheringEntitlementCheckTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TetheringEntitlementCheckTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::TetheringEntitlementCheckTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::TimeTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimeTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::TimeTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::ToastNotificationActionTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ToastNotificationActionTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::ToastNotificationActionTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::ToastNotificationHistoryChangedTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ToastNotificationHistoryChangedTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::ToastNotificationHistoryChangedTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::UserNotificationChangedTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UserNotificationChangedTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::UserNotificationChangedTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::WiFiOnDemandHotspotConnectTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WiFiOnDemandHotspotConnectTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::WiFiOnDemandHotspotConnectTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::WiFiOnDemandHotspotUpdateMetadataTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WiFiOnDemandHotspotUpdateMetadataTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::WiFiOnDemandHotspotUpdateMetadataTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::IBackgroundCondition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IBackgroundCondition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::IBackgroundCondition is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::IBackgroundTask>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IBackgroundTask;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::IBackgroundTask is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IBackgroundTaskInstance;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance2>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IBackgroundTaskInstance2;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance2 is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance4>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IBackgroundTaskInstance4;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance4 is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IBackgroundTaskRegistration;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IBackgroundTaskRegistration2;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2 is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IBackgroundTaskRegistration3;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3 is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::IBackgroundTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Background;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Background");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IBackgroundTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Background::IBackgroundTrigger is not registered");
        return nullptr;
    }

    return python_type;
}
