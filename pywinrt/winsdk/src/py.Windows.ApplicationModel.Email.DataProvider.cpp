// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.ApplicationModel.Email.DataProvider.h"


namespace py::cpp::Windows::ApplicationModel::Email::DataProvider
{
    struct module_state
    {
        PyTypeObject* type_EmailDataProviderConnection;
        PyTypeObject* type_EmailDataProviderTriggerDetails;
        PyTypeObject* type_EmailMailboxCreateFolderRequest;
        PyTypeObject* type_EmailMailboxCreateFolderRequestEventArgs;
        PyTypeObject* type_EmailMailboxDeleteFolderRequest;
        PyTypeObject* type_EmailMailboxDeleteFolderRequestEventArgs;
        PyTypeObject* type_EmailMailboxDownloadAttachmentRequest;
        PyTypeObject* type_EmailMailboxDownloadAttachmentRequestEventArgs;
        PyTypeObject* type_EmailMailboxDownloadMessageRequest;
        PyTypeObject* type_EmailMailboxDownloadMessageRequestEventArgs;
        PyTypeObject* type_EmailMailboxEmptyFolderRequest;
        PyTypeObject* type_EmailMailboxEmptyFolderRequestEventArgs;
        PyTypeObject* type_EmailMailboxForwardMeetingRequest;
        PyTypeObject* type_EmailMailboxForwardMeetingRequestEventArgs;
        PyTypeObject* type_EmailMailboxGetAutoReplySettingsRequest;
        PyTypeObject* type_EmailMailboxGetAutoReplySettingsRequestEventArgs;
        PyTypeObject* type_EmailMailboxMoveFolderRequest;
        PyTypeObject* type_EmailMailboxMoveFolderRequestEventArgs;
        PyTypeObject* type_EmailMailboxProposeNewTimeForMeetingRequest;
        PyTypeObject* type_EmailMailboxProposeNewTimeForMeetingRequestEventArgs;
        PyTypeObject* type_EmailMailboxResolveRecipientsRequest;
        PyTypeObject* type_EmailMailboxResolveRecipientsRequestEventArgs;
        PyTypeObject* type_EmailMailboxServerSearchReadBatchRequest;
        PyTypeObject* type_EmailMailboxServerSearchReadBatchRequestEventArgs;
        PyTypeObject* type_EmailMailboxSetAutoReplySettingsRequest;
        PyTypeObject* type_EmailMailboxSetAutoReplySettingsRequestEventArgs;
        PyTypeObject* type_EmailMailboxSyncManagerSyncRequest;
        PyTypeObject* type_EmailMailboxSyncManagerSyncRequestEventArgs;
        PyTypeObject* type_EmailMailboxUpdateMeetingResponseRequest;
        PyTypeObject* type_EmailMailboxUpdateMeetingResponseRequestEventArgs;
        PyTypeObject* type_EmailMailboxValidateCertificatesRequest;
        PyTypeObject* type_EmailMailboxValidateCertificatesRequestEventArgs;
    };

    // ----- EmailDataProviderConnection class --------------------
    static constexpr const char* const type_name_EmailDataProviderConnection = "EmailDataProviderConnection";

    static PyObject* _new_EmailDataProviderConnection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailDataProviderConnection);
        return nullptr;
    }

    static void _dealloc_EmailDataProviderConnection(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailDataProviderConnection_Start(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_CreateFolderRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"CreateFolderRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequestEventArgs>>(arg);

            return py::convert(self->obj.CreateFolderRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_CreateFolderRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"CreateFolderRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CreateFolderRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_DeleteFolderRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"DeleteFolderRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequestEventArgs>>(arg);

            return py::convert(self->obj.DeleteFolderRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_DeleteFolderRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"DeleteFolderRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DeleteFolderRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_DownloadAttachmentRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"DownloadAttachmentRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequestEventArgs>>(arg);

            return py::convert(self->obj.DownloadAttachmentRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_DownloadAttachmentRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"DownloadAttachmentRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DownloadAttachmentRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_DownloadMessageRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"DownloadMessageRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequestEventArgs>>(arg);

            return py::convert(self->obj.DownloadMessageRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_DownloadMessageRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"DownloadMessageRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DownloadMessageRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_EmptyFolderRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"EmptyFolderRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequestEventArgs>>(arg);

            return py::convert(self->obj.EmptyFolderRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_EmptyFolderRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"EmptyFolderRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EmptyFolderRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_ForwardMeetingRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"ForwardMeetingRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequestEventArgs>>(arg);

            return py::convert(self->obj.ForwardMeetingRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_ForwardMeetingRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"ForwardMeetingRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ForwardMeetingRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_GetAutoReplySettingsRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"GetAutoReplySettingsRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequestEventArgs>>(arg);

            return py::convert(self->obj.GetAutoReplySettingsRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_GetAutoReplySettingsRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"GetAutoReplySettingsRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.GetAutoReplySettingsRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_MailboxSyncRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"MailboxSyncRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequestEventArgs>>(arg);

            return py::convert(self->obj.MailboxSyncRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_MailboxSyncRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"MailboxSyncRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MailboxSyncRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_MoveFolderRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"MoveFolderRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequestEventArgs>>(arg);

            return py::convert(self->obj.MoveFolderRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_MoveFolderRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"MoveFolderRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MoveFolderRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_ProposeNewTimeForMeetingRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"ProposeNewTimeForMeetingRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequestEventArgs>>(arg);

            return py::convert(self->obj.ProposeNewTimeForMeetingRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_ProposeNewTimeForMeetingRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"ProposeNewTimeForMeetingRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ProposeNewTimeForMeetingRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_ResolveRecipientsRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"ResolveRecipientsRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequestEventArgs>>(arg);

            return py::convert(self->obj.ResolveRecipientsRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_ResolveRecipientsRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"ResolveRecipientsRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ResolveRecipientsRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_ServerSearchReadBatchRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"ServerSearchReadBatchRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequestEventArgs>>(arg);

            return py::convert(self->obj.ServerSearchReadBatchRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_ServerSearchReadBatchRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"ServerSearchReadBatchRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ServerSearchReadBatchRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_SetAutoReplySettingsRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"SetAutoReplySettingsRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequestEventArgs>>(arg);

            return py::convert(self->obj.SetAutoReplySettingsRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_SetAutoReplySettingsRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"SetAutoReplySettingsRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SetAutoReplySettingsRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_UpdateMeetingResponseRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"UpdateMeetingResponseRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequestEventArgs>>(arg);

            return py::convert(self->obj.UpdateMeetingResponseRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_UpdateMeetingResponseRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"UpdateMeetingResponseRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UpdateMeetingResponseRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_ValidateCertificatesRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"ValidateCertificatesRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequestEventArgs>>(arg);

            return py::convert(self->obj.ValidateCertificatesRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_ValidateCertificatesRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"ValidateCertificatesRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ValidateCertificatesRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailDataProviderConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailDataProviderConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailDataProviderConnection[] = {
        { "start", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_Start), METH_VARARGS, nullptr },
        { "add_create_folder_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_CreateFolderRequested), METH_O, nullptr },
        { "remove_create_folder_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_CreateFolderRequested), METH_O, nullptr },
        { "add_delete_folder_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_DeleteFolderRequested), METH_O, nullptr },
        { "remove_delete_folder_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_DeleteFolderRequested), METH_O, nullptr },
        { "add_download_attachment_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_DownloadAttachmentRequested), METH_O, nullptr },
        { "remove_download_attachment_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_DownloadAttachmentRequested), METH_O, nullptr },
        { "add_download_message_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_DownloadMessageRequested), METH_O, nullptr },
        { "remove_download_message_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_DownloadMessageRequested), METH_O, nullptr },
        { "add_empty_folder_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_EmptyFolderRequested), METH_O, nullptr },
        { "remove_empty_folder_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_EmptyFolderRequested), METH_O, nullptr },
        { "add_forward_meeting_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_ForwardMeetingRequested), METH_O, nullptr },
        { "remove_forward_meeting_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_ForwardMeetingRequested), METH_O, nullptr },
        { "add_get_auto_reply_settings_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_GetAutoReplySettingsRequested), METH_O, nullptr },
        { "remove_get_auto_reply_settings_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_GetAutoReplySettingsRequested), METH_O, nullptr },
        { "add_mailbox_sync_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_MailboxSyncRequested), METH_O, nullptr },
        { "remove_mailbox_sync_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_MailboxSyncRequested), METH_O, nullptr },
        { "add_move_folder_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_MoveFolderRequested), METH_O, nullptr },
        { "remove_move_folder_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_MoveFolderRequested), METH_O, nullptr },
        { "add_propose_new_time_for_meeting_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_ProposeNewTimeForMeetingRequested), METH_O, nullptr },
        { "remove_propose_new_time_for_meeting_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_ProposeNewTimeForMeetingRequested), METH_O, nullptr },
        { "add_resolve_recipients_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_ResolveRecipientsRequested), METH_O, nullptr },
        { "remove_resolve_recipients_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_ResolveRecipientsRequested), METH_O, nullptr },
        { "add_server_search_read_batch_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_ServerSearchReadBatchRequested), METH_O, nullptr },
        { "remove_server_search_read_batch_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_ServerSearchReadBatchRequested), METH_O, nullptr },
        { "add_set_auto_reply_settings_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_SetAutoReplySettingsRequested), METH_O, nullptr },
        { "remove_set_auto_reply_settings_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_SetAutoReplySettingsRequested), METH_O, nullptr },
        { "add_update_meeting_response_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_UpdateMeetingResponseRequested), METH_O, nullptr },
        { "remove_update_meeting_response_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_UpdateMeetingResponseRequested), METH_O, nullptr },
        { "add_validate_certificates_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_ValidateCertificatesRequested), METH_O, nullptr },
        { "remove_validate_certificates_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_ValidateCertificatesRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_EmailDataProviderConnection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailDataProviderConnection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailDataProviderConnection[] = {
        { }
    };

    static PyType_Slot _type_slots_EmailDataProviderConnection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailDataProviderConnection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailDataProviderConnection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailDataProviderConnection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailDataProviderConnection) },
        { },
    };

    static PyType_Spec type_spec_EmailDataProviderConnection =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailDataProviderConnection",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailDataProviderConnection
    };

    // ----- EmailDataProviderTriggerDetails class --------------------
    static constexpr const char* const type_name_EmailDataProviderTriggerDetails = "EmailDataProviderTriggerDetails";

    static PyObject* _new_EmailDataProviderTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailDataProviderTriggerDetails);
        return nullptr;
    }

    static void _dealloc_EmailDataProviderTriggerDetails(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailDataProviderTriggerDetails_get_Connection(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderTriggerDetails", L"Connection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Connection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailDataProviderTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailDataProviderTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailDataProviderTriggerDetails[] = {
        { "_assign_array_", _assign_array_EmailDataProviderTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailDataProviderTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailDataProviderTriggerDetails[] = {
        { "connection", reinterpret_cast<getter>(EmailDataProviderTriggerDetails_get_Connection), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailDataProviderTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailDataProviderTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailDataProviderTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailDataProviderTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailDataProviderTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_EmailDataProviderTriggerDetails =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailDataProviderTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailDataProviderTriggerDetails
    };

    // ----- EmailMailboxCreateFolderRequest class --------------------
    static constexpr const char* const type_name_EmailMailboxCreateFolderRequest = "EmailMailboxCreateFolderRequest";

    static PyObject* _new_EmailMailboxCreateFolderRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxCreateFolderRequest);
        return nullptr;
    }

    static void _dealloc_EmailMailboxCreateFolderRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxCreateFolderRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxCreateFolderRequest", L"ReportCompletedAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailFolder>(args, 0);

                return py::convert(self->obj.ReportCompletedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxCreateFolderRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxCreateFolderRequest", L"ReportFailedAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxCreateFolderStatus>(args, 0);

                return py::convert(self->obj.ReportFailedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxCreateFolderRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxCreateFolderRequest", L"EmailMailboxId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxCreateFolderRequest_get_Name(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxCreateFolderRequest", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxCreateFolderRequest_get_ParentFolderId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxCreateFolderRequest", L"ParentFolderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ParentFolderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxCreateFolderRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxCreateFolderRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxCreateFolderRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxCreateFolderRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxCreateFolderRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxCreateFolderRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxCreateFolderRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxCreateFolderRequest[] = {
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxCreateFolderRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(EmailMailboxCreateFolderRequest_get_Name), nullptr, nullptr, nullptr },
        { "parent_folder_id", reinterpret_cast<getter>(EmailMailboxCreateFolderRequest_get_ParentFolderId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxCreateFolderRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxCreateFolderRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxCreateFolderRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxCreateFolderRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxCreateFolderRequest) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxCreateFolderRequest =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxCreateFolderRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxCreateFolderRequest
    };

    // ----- EmailMailboxCreateFolderRequestEventArgs class --------------------
    static constexpr const char* const type_name_EmailMailboxCreateFolderRequestEventArgs = "EmailMailboxCreateFolderRequestEventArgs";

    static PyObject* _new_EmailMailboxCreateFolderRequestEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxCreateFolderRequestEventArgs);
        return nullptr;
    }

    static void _dealloc_EmailMailboxCreateFolderRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxCreateFolderRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxCreateFolderRequestEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxCreateFolderRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequestEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxCreateFolderRequestEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxCreateFolderRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxCreateFolderRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxCreateFolderRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxCreateFolderRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxCreateFolderRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxCreateFolderRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxCreateFolderRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxCreateFolderRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxCreateFolderRequestEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxCreateFolderRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxCreateFolderRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxCreateFolderRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxCreateFolderRequestEventArgs) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxCreateFolderRequestEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxCreateFolderRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxCreateFolderRequestEventArgs
    };

    // ----- EmailMailboxDeleteFolderRequest class --------------------
    static constexpr const char* const type_name_EmailMailboxDeleteFolderRequest = "EmailMailboxDeleteFolderRequest";

    static PyObject* _new_EmailMailboxDeleteFolderRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxDeleteFolderRequest);
        return nullptr;
    }

    static void _dealloc_EmailMailboxDeleteFolderRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxDeleteFolderRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDeleteFolderRequest", L"ReportCompletedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxDeleteFolderRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDeleteFolderRequest", L"ReportFailedAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxDeleteFolderStatus>(args, 0);

                return py::convert(self->obj.ReportFailedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxDeleteFolderRequest_get_EmailFolderId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDeleteFolderRequest", L"EmailFolderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailFolderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxDeleteFolderRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDeleteFolderRequest", L"EmailMailboxId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxDeleteFolderRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxDeleteFolderRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxDeleteFolderRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxDeleteFolderRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxDeleteFolderRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxDeleteFolderRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxDeleteFolderRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxDeleteFolderRequest[] = {
        { "email_folder_id", reinterpret_cast<getter>(EmailMailboxDeleteFolderRequest_get_EmailFolderId), nullptr, nullptr, nullptr },
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxDeleteFolderRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxDeleteFolderRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxDeleteFolderRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxDeleteFolderRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxDeleteFolderRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxDeleteFolderRequest) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxDeleteFolderRequest =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxDeleteFolderRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxDeleteFolderRequest
    };

    // ----- EmailMailboxDeleteFolderRequestEventArgs class --------------------
    static constexpr const char* const type_name_EmailMailboxDeleteFolderRequestEventArgs = "EmailMailboxDeleteFolderRequestEventArgs";

    static PyObject* _new_EmailMailboxDeleteFolderRequestEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxDeleteFolderRequestEventArgs);
        return nullptr;
    }

    static void _dealloc_EmailMailboxDeleteFolderRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxDeleteFolderRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDeleteFolderRequestEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxDeleteFolderRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequestEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDeleteFolderRequestEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxDeleteFolderRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxDeleteFolderRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxDeleteFolderRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxDeleteFolderRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxDeleteFolderRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxDeleteFolderRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxDeleteFolderRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxDeleteFolderRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxDeleteFolderRequestEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxDeleteFolderRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxDeleteFolderRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxDeleteFolderRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxDeleteFolderRequestEventArgs) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxDeleteFolderRequestEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxDeleteFolderRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxDeleteFolderRequestEventArgs
    };

    // ----- EmailMailboxDownloadAttachmentRequest class --------------------
    static constexpr const char* const type_name_EmailMailboxDownloadAttachmentRequest = "EmailMailboxDownloadAttachmentRequest";

    static PyObject* _new_EmailMailboxDownloadAttachmentRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxDownloadAttachmentRequest);
        return nullptr;
    }

    static void _dealloc_EmailMailboxDownloadAttachmentRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxDownloadAttachmentRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDownloadAttachmentRequest", L"ReportCompletedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxDownloadAttachmentRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDownloadAttachmentRequest", L"ReportFailedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxDownloadAttachmentRequest_get_EmailAttachmentId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDownloadAttachmentRequest", L"EmailAttachmentId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailAttachmentId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxDownloadAttachmentRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDownloadAttachmentRequest", L"EmailMailboxId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxDownloadAttachmentRequest_get_EmailMessageId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDownloadAttachmentRequest", L"EmailMessageId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailMessageId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxDownloadAttachmentRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxDownloadAttachmentRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxDownloadAttachmentRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxDownloadAttachmentRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxDownloadAttachmentRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxDownloadAttachmentRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxDownloadAttachmentRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxDownloadAttachmentRequest[] = {
        { "email_attachment_id", reinterpret_cast<getter>(EmailMailboxDownloadAttachmentRequest_get_EmailAttachmentId), nullptr, nullptr, nullptr },
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxDownloadAttachmentRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { "email_message_id", reinterpret_cast<getter>(EmailMailboxDownloadAttachmentRequest_get_EmailMessageId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxDownloadAttachmentRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxDownloadAttachmentRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxDownloadAttachmentRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxDownloadAttachmentRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxDownloadAttachmentRequest) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxDownloadAttachmentRequest =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxDownloadAttachmentRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxDownloadAttachmentRequest
    };

    // ----- EmailMailboxDownloadAttachmentRequestEventArgs class --------------------
    static constexpr const char* const type_name_EmailMailboxDownloadAttachmentRequestEventArgs = "EmailMailboxDownloadAttachmentRequestEventArgs";

    static PyObject* _new_EmailMailboxDownloadAttachmentRequestEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxDownloadAttachmentRequestEventArgs);
        return nullptr;
    }

    static void _dealloc_EmailMailboxDownloadAttachmentRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxDownloadAttachmentRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDownloadAttachmentRequestEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxDownloadAttachmentRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequestEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDownloadAttachmentRequestEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxDownloadAttachmentRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxDownloadAttachmentRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxDownloadAttachmentRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxDownloadAttachmentRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxDownloadAttachmentRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxDownloadAttachmentRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxDownloadAttachmentRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxDownloadAttachmentRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxDownloadAttachmentRequestEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxDownloadAttachmentRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxDownloadAttachmentRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxDownloadAttachmentRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxDownloadAttachmentRequestEventArgs) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxDownloadAttachmentRequestEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxDownloadAttachmentRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxDownloadAttachmentRequestEventArgs
    };

    // ----- EmailMailboxDownloadMessageRequest class --------------------
    static constexpr const char* const type_name_EmailMailboxDownloadMessageRequest = "EmailMailboxDownloadMessageRequest";

    static PyObject* _new_EmailMailboxDownloadMessageRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxDownloadMessageRequest);
        return nullptr;
    }

    static void _dealloc_EmailMailboxDownloadMessageRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxDownloadMessageRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDownloadMessageRequest", L"ReportCompletedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxDownloadMessageRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDownloadMessageRequest", L"ReportFailedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxDownloadMessageRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDownloadMessageRequest", L"EmailMailboxId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxDownloadMessageRequest_get_EmailMessageId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDownloadMessageRequest", L"EmailMessageId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailMessageId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxDownloadMessageRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxDownloadMessageRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxDownloadMessageRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxDownloadMessageRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxDownloadMessageRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxDownloadMessageRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxDownloadMessageRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxDownloadMessageRequest[] = {
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxDownloadMessageRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { "email_message_id", reinterpret_cast<getter>(EmailMailboxDownloadMessageRequest_get_EmailMessageId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxDownloadMessageRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxDownloadMessageRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxDownloadMessageRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxDownloadMessageRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxDownloadMessageRequest) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxDownloadMessageRequest =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxDownloadMessageRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxDownloadMessageRequest
    };

    // ----- EmailMailboxDownloadMessageRequestEventArgs class --------------------
    static constexpr const char* const type_name_EmailMailboxDownloadMessageRequestEventArgs = "EmailMailboxDownloadMessageRequestEventArgs";

    static PyObject* _new_EmailMailboxDownloadMessageRequestEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxDownloadMessageRequestEventArgs);
        return nullptr;
    }

    static void _dealloc_EmailMailboxDownloadMessageRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxDownloadMessageRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDownloadMessageRequestEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxDownloadMessageRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequestEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDownloadMessageRequestEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxDownloadMessageRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxDownloadMessageRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxDownloadMessageRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxDownloadMessageRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxDownloadMessageRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxDownloadMessageRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxDownloadMessageRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxDownloadMessageRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxDownloadMessageRequestEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxDownloadMessageRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxDownloadMessageRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxDownloadMessageRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxDownloadMessageRequestEventArgs) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxDownloadMessageRequestEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxDownloadMessageRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxDownloadMessageRequestEventArgs
    };

    // ----- EmailMailboxEmptyFolderRequest class --------------------
    static constexpr const char* const type_name_EmailMailboxEmptyFolderRequest = "EmailMailboxEmptyFolderRequest";

    static PyObject* _new_EmailMailboxEmptyFolderRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxEmptyFolderRequest);
        return nullptr;
    }

    static void _dealloc_EmailMailboxEmptyFolderRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxEmptyFolderRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxEmptyFolderRequest", L"ReportCompletedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxEmptyFolderRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxEmptyFolderRequest", L"ReportFailedAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxEmptyFolderStatus>(args, 0);

                return py::convert(self->obj.ReportFailedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxEmptyFolderRequest_get_EmailFolderId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxEmptyFolderRequest", L"EmailFolderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailFolderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxEmptyFolderRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxEmptyFolderRequest", L"EmailMailboxId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxEmptyFolderRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxEmptyFolderRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxEmptyFolderRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxEmptyFolderRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxEmptyFolderRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxEmptyFolderRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxEmptyFolderRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxEmptyFolderRequest[] = {
        { "email_folder_id", reinterpret_cast<getter>(EmailMailboxEmptyFolderRequest_get_EmailFolderId), nullptr, nullptr, nullptr },
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxEmptyFolderRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxEmptyFolderRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxEmptyFolderRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxEmptyFolderRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxEmptyFolderRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxEmptyFolderRequest) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxEmptyFolderRequest =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxEmptyFolderRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxEmptyFolderRequest
    };

    // ----- EmailMailboxEmptyFolderRequestEventArgs class --------------------
    static constexpr const char* const type_name_EmailMailboxEmptyFolderRequestEventArgs = "EmailMailboxEmptyFolderRequestEventArgs";

    static PyObject* _new_EmailMailboxEmptyFolderRequestEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxEmptyFolderRequestEventArgs);
        return nullptr;
    }

    static void _dealloc_EmailMailboxEmptyFolderRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxEmptyFolderRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxEmptyFolderRequestEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxEmptyFolderRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequestEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxEmptyFolderRequestEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxEmptyFolderRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxEmptyFolderRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxEmptyFolderRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxEmptyFolderRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxEmptyFolderRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxEmptyFolderRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxEmptyFolderRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxEmptyFolderRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxEmptyFolderRequestEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxEmptyFolderRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxEmptyFolderRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxEmptyFolderRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxEmptyFolderRequestEventArgs) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxEmptyFolderRequestEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxEmptyFolderRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxEmptyFolderRequestEventArgs
    };

    // ----- EmailMailboxForwardMeetingRequest class --------------------
    static constexpr const char* const type_name_EmailMailboxForwardMeetingRequest = "EmailMailboxForwardMeetingRequest";

    static PyObject* _new_EmailMailboxForwardMeetingRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxForwardMeetingRequest);
        return nullptr;
    }

    static void _dealloc_EmailMailboxForwardMeetingRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxForwardMeetingRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxForwardMeetingRequest", L"ReportCompletedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxForwardMeetingRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxForwardMeetingRequest", L"ReportFailedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxForwardMeetingRequest_get_Comment(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxForwardMeetingRequest", L"Comment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Comment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxForwardMeetingRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxForwardMeetingRequest", L"EmailMailboxId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxForwardMeetingRequest_get_EmailMessageId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxForwardMeetingRequest", L"EmailMessageId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailMessageId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxForwardMeetingRequest_get_ForwardHeader(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxForwardMeetingRequest", L"ForwardHeader"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ForwardHeader());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxForwardMeetingRequest_get_ForwardHeaderType(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxForwardMeetingRequest", L"ForwardHeaderType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ForwardHeaderType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxForwardMeetingRequest_get_Recipients(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxForwardMeetingRequest", L"Recipients"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Recipients());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxForwardMeetingRequest_get_Subject(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxForwardMeetingRequest", L"Subject"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxForwardMeetingRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxForwardMeetingRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxForwardMeetingRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxForwardMeetingRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxForwardMeetingRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxForwardMeetingRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxForwardMeetingRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxForwardMeetingRequest[] = {
        { "comment", reinterpret_cast<getter>(EmailMailboxForwardMeetingRequest_get_Comment), nullptr, nullptr, nullptr },
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxForwardMeetingRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { "email_message_id", reinterpret_cast<getter>(EmailMailboxForwardMeetingRequest_get_EmailMessageId), nullptr, nullptr, nullptr },
        { "forward_header", reinterpret_cast<getter>(EmailMailboxForwardMeetingRequest_get_ForwardHeader), nullptr, nullptr, nullptr },
        { "forward_header_type", reinterpret_cast<getter>(EmailMailboxForwardMeetingRequest_get_ForwardHeaderType), nullptr, nullptr, nullptr },
        { "recipients", reinterpret_cast<getter>(EmailMailboxForwardMeetingRequest_get_Recipients), nullptr, nullptr, nullptr },
        { "subject", reinterpret_cast<getter>(EmailMailboxForwardMeetingRequest_get_Subject), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxForwardMeetingRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxForwardMeetingRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxForwardMeetingRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxForwardMeetingRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxForwardMeetingRequest) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxForwardMeetingRequest =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxForwardMeetingRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxForwardMeetingRequest
    };

    // ----- EmailMailboxForwardMeetingRequestEventArgs class --------------------
    static constexpr const char* const type_name_EmailMailboxForwardMeetingRequestEventArgs = "EmailMailboxForwardMeetingRequestEventArgs";

    static PyObject* _new_EmailMailboxForwardMeetingRequestEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxForwardMeetingRequestEventArgs);
        return nullptr;
    }

    static void _dealloc_EmailMailboxForwardMeetingRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxForwardMeetingRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxForwardMeetingRequestEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxForwardMeetingRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequestEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxForwardMeetingRequestEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxForwardMeetingRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxForwardMeetingRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxForwardMeetingRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxForwardMeetingRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxForwardMeetingRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxForwardMeetingRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxForwardMeetingRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxForwardMeetingRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxForwardMeetingRequestEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxForwardMeetingRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxForwardMeetingRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxForwardMeetingRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxForwardMeetingRequestEventArgs) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxForwardMeetingRequestEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxForwardMeetingRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxForwardMeetingRequestEventArgs
    };

    // ----- EmailMailboxGetAutoReplySettingsRequest class --------------------
    static constexpr const char* const type_name_EmailMailboxGetAutoReplySettingsRequest = "EmailMailboxGetAutoReplySettingsRequest";

    static PyObject* _new_EmailMailboxGetAutoReplySettingsRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxGetAutoReplySettingsRequest);
        return nullptr;
    }

    static void _dealloc_EmailMailboxGetAutoReplySettingsRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxGetAutoReplySettingsRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxGetAutoReplySettingsRequest", L"ReportCompletedAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings>(args, 0);

                return py::convert(self->obj.ReportCompletedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxGetAutoReplySettingsRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxGetAutoReplySettingsRequest", L"ReportFailedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxGetAutoReplySettingsRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxGetAutoReplySettingsRequest", L"EmailMailboxId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxGetAutoReplySettingsRequest_get_RequestedFormat(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxGetAutoReplySettingsRequest", L"RequestedFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestedFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxGetAutoReplySettingsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxGetAutoReplySettingsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxGetAutoReplySettingsRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxGetAutoReplySettingsRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxGetAutoReplySettingsRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxGetAutoReplySettingsRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxGetAutoReplySettingsRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxGetAutoReplySettingsRequest[] = {
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxGetAutoReplySettingsRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { "requested_format", reinterpret_cast<getter>(EmailMailboxGetAutoReplySettingsRequest_get_RequestedFormat), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxGetAutoReplySettingsRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxGetAutoReplySettingsRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxGetAutoReplySettingsRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxGetAutoReplySettingsRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxGetAutoReplySettingsRequest) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxGetAutoReplySettingsRequest =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxGetAutoReplySettingsRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxGetAutoReplySettingsRequest
    };

    // ----- EmailMailboxGetAutoReplySettingsRequestEventArgs class --------------------
    static constexpr const char* const type_name_EmailMailboxGetAutoReplySettingsRequestEventArgs = "EmailMailboxGetAutoReplySettingsRequestEventArgs";

    static PyObject* _new_EmailMailboxGetAutoReplySettingsRequestEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxGetAutoReplySettingsRequestEventArgs);
        return nullptr;
    }

    static void _dealloc_EmailMailboxGetAutoReplySettingsRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxGetAutoReplySettingsRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxGetAutoReplySettingsRequestEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxGetAutoReplySettingsRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequestEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxGetAutoReplySettingsRequestEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxGetAutoReplySettingsRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxGetAutoReplySettingsRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxGetAutoReplySettingsRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxGetAutoReplySettingsRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxGetAutoReplySettingsRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxGetAutoReplySettingsRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxGetAutoReplySettingsRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxGetAutoReplySettingsRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxGetAutoReplySettingsRequestEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxGetAutoReplySettingsRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxGetAutoReplySettingsRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxGetAutoReplySettingsRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxGetAutoReplySettingsRequestEventArgs) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxGetAutoReplySettingsRequestEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxGetAutoReplySettingsRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxGetAutoReplySettingsRequestEventArgs
    };

    // ----- EmailMailboxMoveFolderRequest class --------------------
    static constexpr const char* const type_name_EmailMailboxMoveFolderRequest = "EmailMailboxMoveFolderRequest";

    static PyObject* _new_EmailMailboxMoveFolderRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxMoveFolderRequest);
        return nullptr;
    }

    static void _dealloc_EmailMailboxMoveFolderRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxMoveFolderRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxMoveFolderRequest", L"ReportCompletedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxMoveFolderRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxMoveFolderRequest", L"ReportFailedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxMoveFolderRequest_get_EmailFolderId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxMoveFolderRequest", L"EmailFolderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailFolderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxMoveFolderRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxMoveFolderRequest", L"EmailMailboxId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxMoveFolderRequest_get_NewFolderName(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxMoveFolderRequest", L"NewFolderName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewFolderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxMoveFolderRequest_get_NewParentFolderId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxMoveFolderRequest", L"NewParentFolderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewParentFolderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxMoveFolderRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxMoveFolderRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxMoveFolderRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxMoveFolderRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxMoveFolderRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxMoveFolderRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxMoveFolderRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxMoveFolderRequest[] = {
        { "email_folder_id", reinterpret_cast<getter>(EmailMailboxMoveFolderRequest_get_EmailFolderId), nullptr, nullptr, nullptr },
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxMoveFolderRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { "new_folder_name", reinterpret_cast<getter>(EmailMailboxMoveFolderRequest_get_NewFolderName), nullptr, nullptr, nullptr },
        { "new_parent_folder_id", reinterpret_cast<getter>(EmailMailboxMoveFolderRequest_get_NewParentFolderId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxMoveFolderRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxMoveFolderRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxMoveFolderRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxMoveFolderRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxMoveFolderRequest) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxMoveFolderRequest =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxMoveFolderRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxMoveFolderRequest
    };

    // ----- EmailMailboxMoveFolderRequestEventArgs class --------------------
    static constexpr const char* const type_name_EmailMailboxMoveFolderRequestEventArgs = "EmailMailboxMoveFolderRequestEventArgs";

    static PyObject* _new_EmailMailboxMoveFolderRequestEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxMoveFolderRequestEventArgs);
        return nullptr;
    }

    static void _dealloc_EmailMailboxMoveFolderRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxMoveFolderRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxMoveFolderRequestEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxMoveFolderRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequestEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxMoveFolderRequestEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxMoveFolderRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxMoveFolderRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxMoveFolderRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxMoveFolderRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxMoveFolderRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxMoveFolderRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxMoveFolderRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxMoveFolderRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxMoveFolderRequestEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxMoveFolderRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxMoveFolderRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxMoveFolderRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxMoveFolderRequestEventArgs) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxMoveFolderRequestEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxMoveFolderRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxMoveFolderRequestEventArgs
    };

    // ----- EmailMailboxProposeNewTimeForMeetingRequest class --------------------
    static constexpr const char* const type_name_EmailMailboxProposeNewTimeForMeetingRequest = "EmailMailboxProposeNewTimeForMeetingRequest";

    static PyObject* _new_EmailMailboxProposeNewTimeForMeetingRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxProposeNewTimeForMeetingRequest);
        return nullptr;
    }

    static void _dealloc_EmailMailboxProposeNewTimeForMeetingRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxProposeNewTimeForMeetingRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxProposeNewTimeForMeetingRequest", L"ReportCompletedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxProposeNewTimeForMeetingRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxProposeNewTimeForMeetingRequest", L"ReportFailedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxProposeNewTimeForMeetingRequest_get_Comment(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxProposeNewTimeForMeetingRequest", L"Comment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Comment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxProposeNewTimeForMeetingRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxProposeNewTimeForMeetingRequest", L"EmailMailboxId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxProposeNewTimeForMeetingRequest_get_EmailMessageId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxProposeNewTimeForMeetingRequest", L"EmailMessageId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailMessageId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxProposeNewTimeForMeetingRequest_get_NewDuration(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxProposeNewTimeForMeetingRequest", L"NewDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxProposeNewTimeForMeetingRequest_get_NewStartTime(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxProposeNewTimeForMeetingRequest", L"NewStartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewStartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxProposeNewTimeForMeetingRequest_get_Subject(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxProposeNewTimeForMeetingRequest", L"Subject"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxProposeNewTimeForMeetingRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxProposeNewTimeForMeetingRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxProposeNewTimeForMeetingRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxProposeNewTimeForMeetingRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxProposeNewTimeForMeetingRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxProposeNewTimeForMeetingRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxProposeNewTimeForMeetingRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxProposeNewTimeForMeetingRequest[] = {
        { "comment", reinterpret_cast<getter>(EmailMailboxProposeNewTimeForMeetingRequest_get_Comment), nullptr, nullptr, nullptr },
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxProposeNewTimeForMeetingRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { "email_message_id", reinterpret_cast<getter>(EmailMailboxProposeNewTimeForMeetingRequest_get_EmailMessageId), nullptr, nullptr, nullptr },
        { "new_duration", reinterpret_cast<getter>(EmailMailboxProposeNewTimeForMeetingRequest_get_NewDuration), nullptr, nullptr, nullptr },
        { "new_start_time", reinterpret_cast<getter>(EmailMailboxProposeNewTimeForMeetingRequest_get_NewStartTime), nullptr, nullptr, nullptr },
        { "subject", reinterpret_cast<getter>(EmailMailboxProposeNewTimeForMeetingRequest_get_Subject), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxProposeNewTimeForMeetingRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxProposeNewTimeForMeetingRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxProposeNewTimeForMeetingRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxProposeNewTimeForMeetingRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxProposeNewTimeForMeetingRequest) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxProposeNewTimeForMeetingRequest =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxProposeNewTimeForMeetingRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxProposeNewTimeForMeetingRequest
    };

    // ----- EmailMailboxProposeNewTimeForMeetingRequestEventArgs class --------------------
    static constexpr const char* const type_name_EmailMailboxProposeNewTimeForMeetingRequestEventArgs = "EmailMailboxProposeNewTimeForMeetingRequestEventArgs";

    static PyObject* _new_EmailMailboxProposeNewTimeForMeetingRequestEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxProposeNewTimeForMeetingRequestEventArgs);
        return nullptr;
    }

    static void _dealloc_EmailMailboxProposeNewTimeForMeetingRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxProposeNewTimeForMeetingRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxProposeNewTimeForMeetingRequestEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxProposeNewTimeForMeetingRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequestEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxProposeNewTimeForMeetingRequestEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxProposeNewTimeForMeetingRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxProposeNewTimeForMeetingRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxProposeNewTimeForMeetingRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxProposeNewTimeForMeetingRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxProposeNewTimeForMeetingRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxProposeNewTimeForMeetingRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxProposeNewTimeForMeetingRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxProposeNewTimeForMeetingRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxProposeNewTimeForMeetingRequestEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxProposeNewTimeForMeetingRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxProposeNewTimeForMeetingRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxProposeNewTimeForMeetingRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxProposeNewTimeForMeetingRequestEventArgs) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxProposeNewTimeForMeetingRequestEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxProposeNewTimeForMeetingRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxProposeNewTimeForMeetingRequestEventArgs
    };

    // ----- EmailMailboxResolveRecipientsRequest class --------------------
    static constexpr const char* const type_name_EmailMailboxResolveRecipientsRequest = "EmailMailboxResolveRecipientsRequest";

    static PyObject* _new_EmailMailboxResolveRecipientsRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxResolveRecipientsRequest);
        return nullptr;
    }

    static void _dealloc_EmailMailboxResolveRecipientsRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxResolveRecipientsRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxResolveRecipientsRequest", L"ReportCompletedAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Email::EmailRecipientResolutionResult>>(args, 0);

                return py::convert(self->obj.ReportCompletedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxResolveRecipientsRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxResolveRecipientsRequest", L"ReportFailedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxResolveRecipientsRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxResolveRecipientsRequest", L"EmailMailboxId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxResolveRecipientsRequest_get_Recipients(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxResolveRecipientsRequest", L"Recipients"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Recipients());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxResolveRecipientsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxResolveRecipientsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxResolveRecipientsRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxResolveRecipientsRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxResolveRecipientsRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxResolveRecipientsRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxResolveRecipientsRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxResolveRecipientsRequest[] = {
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxResolveRecipientsRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { "recipients", reinterpret_cast<getter>(EmailMailboxResolveRecipientsRequest_get_Recipients), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxResolveRecipientsRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxResolveRecipientsRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxResolveRecipientsRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxResolveRecipientsRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxResolveRecipientsRequest) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxResolveRecipientsRequest =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxResolveRecipientsRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxResolveRecipientsRequest
    };

    // ----- EmailMailboxResolveRecipientsRequestEventArgs class --------------------
    static constexpr const char* const type_name_EmailMailboxResolveRecipientsRequestEventArgs = "EmailMailboxResolveRecipientsRequestEventArgs";

    static PyObject* _new_EmailMailboxResolveRecipientsRequestEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxResolveRecipientsRequestEventArgs);
        return nullptr;
    }

    static void _dealloc_EmailMailboxResolveRecipientsRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxResolveRecipientsRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxResolveRecipientsRequestEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxResolveRecipientsRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequestEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxResolveRecipientsRequestEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxResolveRecipientsRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxResolveRecipientsRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxResolveRecipientsRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxResolveRecipientsRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxResolveRecipientsRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxResolveRecipientsRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxResolveRecipientsRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxResolveRecipientsRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxResolveRecipientsRequestEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxResolveRecipientsRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxResolveRecipientsRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxResolveRecipientsRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxResolveRecipientsRequestEventArgs) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxResolveRecipientsRequestEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxResolveRecipientsRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxResolveRecipientsRequestEventArgs
    };

    // ----- EmailMailboxServerSearchReadBatchRequest class --------------------
    static constexpr const char* const type_name_EmailMailboxServerSearchReadBatchRequest = "EmailMailboxServerSearchReadBatchRequest";

    static PyObject* _new_EmailMailboxServerSearchReadBatchRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxServerSearchReadBatchRequest);
        return nullptr;
    }

    static void _dealloc_EmailMailboxServerSearchReadBatchRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxServerSearchReadBatchRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxServerSearchReadBatchRequest", L"ReportCompletedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxServerSearchReadBatchRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxServerSearchReadBatchRequest", L"ReportFailedAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailBatchStatus>(args, 0);

                return py::convert(self->obj.ReportFailedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxServerSearchReadBatchRequest_SaveMessageAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxServerSearchReadBatchRequest", L"SaveMessageAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);

                return py::convert(self->obj.SaveMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxServerSearchReadBatchRequest_get_EmailFolderId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxServerSearchReadBatchRequest", L"EmailFolderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailFolderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxServerSearchReadBatchRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxServerSearchReadBatchRequest", L"EmailMailboxId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxServerSearchReadBatchRequest_get_Options(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxServerSearchReadBatchRequest", L"Options"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Options());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxServerSearchReadBatchRequest_get_SessionId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxServerSearchReadBatchRequest", L"SessionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SessionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxServerSearchReadBatchRequest_get_SuggestedBatchSize(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxServerSearchReadBatchRequest", L"SuggestedBatchSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SuggestedBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxServerSearchReadBatchRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxServerSearchReadBatchRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxServerSearchReadBatchRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxServerSearchReadBatchRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxServerSearchReadBatchRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "save_message_async", reinterpret_cast<PyCFunction>(EmailMailboxServerSearchReadBatchRequest_SaveMessageAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxServerSearchReadBatchRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxServerSearchReadBatchRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxServerSearchReadBatchRequest[] = {
        { "email_folder_id", reinterpret_cast<getter>(EmailMailboxServerSearchReadBatchRequest_get_EmailFolderId), nullptr, nullptr, nullptr },
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxServerSearchReadBatchRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { "options", reinterpret_cast<getter>(EmailMailboxServerSearchReadBatchRequest_get_Options), nullptr, nullptr, nullptr },
        { "session_id", reinterpret_cast<getter>(EmailMailboxServerSearchReadBatchRequest_get_SessionId), nullptr, nullptr, nullptr },
        { "suggested_batch_size", reinterpret_cast<getter>(EmailMailboxServerSearchReadBatchRequest_get_SuggestedBatchSize), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxServerSearchReadBatchRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxServerSearchReadBatchRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxServerSearchReadBatchRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxServerSearchReadBatchRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxServerSearchReadBatchRequest) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxServerSearchReadBatchRequest =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxServerSearchReadBatchRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxServerSearchReadBatchRequest
    };

    // ----- EmailMailboxServerSearchReadBatchRequestEventArgs class --------------------
    static constexpr const char* const type_name_EmailMailboxServerSearchReadBatchRequestEventArgs = "EmailMailboxServerSearchReadBatchRequestEventArgs";

    static PyObject* _new_EmailMailboxServerSearchReadBatchRequestEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxServerSearchReadBatchRequestEventArgs);
        return nullptr;
    }

    static void _dealloc_EmailMailboxServerSearchReadBatchRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxServerSearchReadBatchRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxServerSearchReadBatchRequestEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxServerSearchReadBatchRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequestEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxServerSearchReadBatchRequestEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxServerSearchReadBatchRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxServerSearchReadBatchRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxServerSearchReadBatchRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxServerSearchReadBatchRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxServerSearchReadBatchRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxServerSearchReadBatchRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxServerSearchReadBatchRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxServerSearchReadBatchRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxServerSearchReadBatchRequestEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxServerSearchReadBatchRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxServerSearchReadBatchRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxServerSearchReadBatchRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxServerSearchReadBatchRequestEventArgs) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxServerSearchReadBatchRequestEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxServerSearchReadBatchRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxServerSearchReadBatchRequestEventArgs
    };

    // ----- EmailMailboxSetAutoReplySettingsRequest class --------------------
    static constexpr const char* const type_name_EmailMailboxSetAutoReplySettingsRequest = "EmailMailboxSetAutoReplySettingsRequest";

    static PyObject* _new_EmailMailboxSetAutoReplySettingsRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxSetAutoReplySettingsRequest);
        return nullptr;
    }

    static void _dealloc_EmailMailboxSetAutoReplySettingsRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxSetAutoReplySettingsRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxSetAutoReplySettingsRequest", L"ReportCompletedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxSetAutoReplySettingsRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxSetAutoReplySettingsRequest", L"ReportFailedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxSetAutoReplySettingsRequest_get_AutoReplySettings(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxSetAutoReplySettingsRequest", L"AutoReplySettings"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoReplySettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxSetAutoReplySettingsRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxSetAutoReplySettingsRequest", L"EmailMailboxId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxSetAutoReplySettingsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxSetAutoReplySettingsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxSetAutoReplySettingsRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxSetAutoReplySettingsRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxSetAutoReplySettingsRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxSetAutoReplySettingsRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxSetAutoReplySettingsRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxSetAutoReplySettingsRequest[] = {
        { "auto_reply_settings", reinterpret_cast<getter>(EmailMailboxSetAutoReplySettingsRequest_get_AutoReplySettings), nullptr, nullptr, nullptr },
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxSetAutoReplySettingsRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxSetAutoReplySettingsRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxSetAutoReplySettingsRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxSetAutoReplySettingsRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxSetAutoReplySettingsRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxSetAutoReplySettingsRequest) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxSetAutoReplySettingsRequest =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxSetAutoReplySettingsRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxSetAutoReplySettingsRequest
    };

    // ----- EmailMailboxSetAutoReplySettingsRequestEventArgs class --------------------
    static constexpr const char* const type_name_EmailMailboxSetAutoReplySettingsRequestEventArgs = "EmailMailboxSetAutoReplySettingsRequestEventArgs";

    static PyObject* _new_EmailMailboxSetAutoReplySettingsRequestEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxSetAutoReplySettingsRequestEventArgs);
        return nullptr;
    }

    static void _dealloc_EmailMailboxSetAutoReplySettingsRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxSetAutoReplySettingsRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxSetAutoReplySettingsRequestEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxSetAutoReplySettingsRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequestEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxSetAutoReplySettingsRequestEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxSetAutoReplySettingsRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxSetAutoReplySettingsRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxSetAutoReplySettingsRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxSetAutoReplySettingsRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxSetAutoReplySettingsRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxSetAutoReplySettingsRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxSetAutoReplySettingsRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxSetAutoReplySettingsRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxSetAutoReplySettingsRequestEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxSetAutoReplySettingsRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxSetAutoReplySettingsRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxSetAutoReplySettingsRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxSetAutoReplySettingsRequestEventArgs) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxSetAutoReplySettingsRequestEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxSetAutoReplySettingsRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxSetAutoReplySettingsRequestEventArgs
    };

    // ----- EmailMailboxSyncManagerSyncRequest class --------------------
    static constexpr const char* const type_name_EmailMailboxSyncManagerSyncRequest = "EmailMailboxSyncManagerSyncRequest";

    static PyObject* _new_EmailMailboxSyncManagerSyncRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxSyncManagerSyncRequest);
        return nullptr;
    }

    static void _dealloc_EmailMailboxSyncManagerSyncRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxSyncManagerSyncRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxSyncManagerSyncRequest", L"ReportCompletedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxSyncManagerSyncRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxSyncManagerSyncRequest", L"ReportFailedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxSyncManagerSyncRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxSyncManagerSyncRequest", L"EmailMailboxId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxSyncManagerSyncRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxSyncManagerSyncRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxSyncManagerSyncRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxSyncManagerSyncRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxSyncManagerSyncRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxSyncManagerSyncRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxSyncManagerSyncRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxSyncManagerSyncRequest[] = {
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxSyncManagerSyncRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxSyncManagerSyncRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxSyncManagerSyncRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxSyncManagerSyncRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxSyncManagerSyncRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxSyncManagerSyncRequest) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxSyncManagerSyncRequest =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxSyncManagerSyncRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxSyncManagerSyncRequest
    };

    // ----- EmailMailboxSyncManagerSyncRequestEventArgs class --------------------
    static constexpr const char* const type_name_EmailMailboxSyncManagerSyncRequestEventArgs = "EmailMailboxSyncManagerSyncRequestEventArgs";

    static PyObject* _new_EmailMailboxSyncManagerSyncRequestEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxSyncManagerSyncRequestEventArgs);
        return nullptr;
    }

    static void _dealloc_EmailMailboxSyncManagerSyncRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxSyncManagerSyncRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxSyncManagerSyncRequestEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxSyncManagerSyncRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequestEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxSyncManagerSyncRequestEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxSyncManagerSyncRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxSyncManagerSyncRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxSyncManagerSyncRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxSyncManagerSyncRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxSyncManagerSyncRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxSyncManagerSyncRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxSyncManagerSyncRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxSyncManagerSyncRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxSyncManagerSyncRequestEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxSyncManagerSyncRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxSyncManagerSyncRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxSyncManagerSyncRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxSyncManagerSyncRequestEventArgs) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxSyncManagerSyncRequestEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxSyncManagerSyncRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxSyncManagerSyncRequestEventArgs
    };

    // ----- EmailMailboxUpdateMeetingResponseRequest class --------------------
    static constexpr const char* const type_name_EmailMailboxUpdateMeetingResponseRequest = "EmailMailboxUpdateMeetingResponseRequest";

    static PyObject* _new_EmailMailboxUpdateMeetingResponseRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxUpdateMeetingResponseRequest);
        return nullptr;
    }

    static void _dealloc_EmailMailboxUpdateMeetingResponseRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxUpdateMeetingResponseRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxUpdateMeetingResponseRequest", L"ReportCompletedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxUpdateMeetingResponseRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxUpdateMeetingResponseRequest", L"ReportFailedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxUpdateMeetingResponseRequest_get_Comment(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxUpdateMeetingResponseRequest", L"Comment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Comment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxUpdateMeetingResponseRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxUpdateMeetingResponseRequest", L"EmailMailboxId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxUpdateMeetingResponseRequest_get_EmailMessageId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxUpdateMeetingResponseRequest", L"EmailMessageId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailMessageId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxUpdateMeetingResponseRequest_get_Response(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxUpdateMeetingResponseRequest", L"Response"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Response());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxUpdateMeetingResponseRequest_get_SendUpdate(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxUpdateMeetingResponseRequest", L"SendUpdate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SendUpdate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxUpdateMeetingResponseRequest_get_Subject(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxUpdateMeetingResponseRequest", L"Subject"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxUpdateMeetingResponseRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxUpdateMeetingResponseRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxUpdateMeetingResponseRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxUpdateMeetingResponseRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxUpdateMeetingResponseRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxUpdateMeetingResponseRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxUpdateMeetingResponseRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxUpdateMeetingResponseRequest[] = {
        { "comment", reinterpret_cast<getter>(EmailMailboxUpdateMeetingResponseRequest_get_Comment), nullptr, nullptr, nullptr },
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxUpdateMeetingResponseRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { "email_message_id", reinterpret_cast<getter>(EmailMailboxUpdateMeetingResponseRequest_get_EmailMessageId), nullptr, nullptr, nullptr },
        { "response", reinterpret_cast<getter>(EmailMailboxUpdateMeetingResponseRequest_get_Response), nullptr, nullptr, nullptr },
        { "send_update", reinterpret_cast<getter>(EmailMailboxUpdateMeetingResponseRequest_get_SendUpdate), nullptr, nullptr, nullptr },
        { "subject", reinterpret_cast<getter>(EmailMailboxUpdateMeetingResponseRequest_get_Subject), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxUpdateMeetingResponseRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxUpdateMeetingResponseRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxUpdateMeetingResponseRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxUpdateMeetingResponseRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxUpdateMeetingResponseRequest) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxUpdateMeetingResponseRequest =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxUpdateMeetingResponseRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxUpdateMeetingResponseRequest
    };

    // ----- EmailMailboxUpdateMeetingResponseRequestEventArgs class --------------------
    static constexpr const char* const type_name_EmailMailboxUpdateMeetingResponseRequestEventArgs = "EmailMailboxUpdateMeetingResponseRequestEventArgs";

    static PyObject* _new_EmailMailboxUpdateMeetingResponseRequestEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxUpdateMeetingResponseRequestEventArgs);
        return nullptr;
    }

    static void _dealloc_EmailMailboxUpdateMeetingResponseRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxUpdateMeetingResponseRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxUpdateMeetingResponseRequestEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxUpdateMeetingResponseRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequestEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxUpdateMeetingResponseRequestEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxUpdateMeetingResponseRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxUpdateMeetingResponseRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxUpdateMeetingResponseRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxUpdateMeetingResponseRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxUpdateMeetingResponseRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxUpdateMeetingResponseRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxUpdateMeetingResponseRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxUpdateMeetingResponseRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxUpdateMeetingResponseRequestEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxUpdateMeetingResponseRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxUpdateMeetingResponseRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxUpdateMeetingResponseRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxUpdateMeetingResponseRequestEventArgs) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxUpdateMeetingResponseRequestEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxUpdateMeetingResponseRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxUpdateMeetingResponseRequestEventArgs
    };

    // ----- EmailMailboxValidateCertificatesRequest class --------------------
    static constexpr const char* const type_name_EmailMailboxValidateCertificatesRequest = "EmailMailboxValidateCertificatesRequest";

    static PyObject* _new_EmailMailboxValidateCertificatesRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxValidateCertificatesRequest);
        return nullptr;
    }

    static void _dealloc_EmailMailboxValidateCertificatesRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxValidateCertificatesRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxValidateCertificatesRequest", L"ReportCompletedAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Email::EmailCertificateValidationStatus>>(args, 0);

                return py::convert(self->obj.ReportCompletedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxValidateCertificatesRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxValidateCertificatesRequest", L"ReportFailedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxValidateCertificatesRequest_get_Certificates(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxValidateCertificatesRequest", L"Certificates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Certificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxValidateCertificatesRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxValidateCertificatesRequest", L"EmailMailboxId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxValidateCertificatesRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxValidateCertificatesRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxValidateCertificatesRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxValidateCertificatesRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxValidateCertificatesRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxValidateCertificatesRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxValidateCertificatesRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxValidateCertificatesRequest[] = {
        { "certificates", reinterpret_cast<getter>(EmailMailboxValidateCertificatesRequest_get_Certificates), nullptr, nullptr, nullptr },
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxValidateCertificatesRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxValidateCertificatesRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxValidateCertificatesRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxValidateCertificatesRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxValidateCertificatesRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxValidateCertificatesRequest) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxValidateCertificatesRequest =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxValidateCertificatesRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxValidateCertificatesRequest
    };

    // ----- EmailMailboxValidateCertificatesRequestEventArgs class --------------------
    static constexpr const char* const type_name_EmailMailboxValidateCertificatesRequestEventArgs = "EmailMailboxValidateCertificatesRequestEventArgs";

    static PyObject* _new_EmailMailboxValidateCertificatesRequestEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EmailMailboxValidateCertificatesRequestEventArgs);
        return nullptr;
    }

    static void _dealloc_EmailMailboxValidateCertificatesRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxValidateCertificatesRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxValidateCertificatesRequestEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxValidateCertificatesRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequestEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxValidateCertificatesRequestEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxValidateCertificatesRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxValidateCertificatesRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxValidateCertificatesRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxValidateCertificatesRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxValidateCertificatesRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxValidateCertificatesRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxValidateCertificatesRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxValidateCertificatesRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxValidateCertificatesRequestEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxValidateCertificatesRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxValidateCertificatesRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxValidateCertificatesRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxValidateCertificatesRequestEventArgs) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxValidateCertificatesRequestEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Email_DataProvider.EmailMailboxValidateCertificatesRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxValidateCertificatesRequestEventArgs
    };

    // ----- Windows.ApplicationModel.Email.DataProvider Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::ApplicationModel::Email::DataProvider");

    static PyMethodDef module_methods[] = {
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_EmailDataProviderConnection);
        Py_VISIT(state->type_EmailDataProviderTriggerDetails);
        Py_VISIT(state->type_EmailMailboxCreateFolderRequest);
        Py_VISIT(state->type_EmailMailboxCreateFolderRequestEventArgs);
        Py_VISIT(state->type_EmailMailboxDeleteFolderRequest);
        Py_VISIT(state->type_EmailMailboxDeleteFolderRequestEventArgs);
        Py_VISIT(state->type_EmailMailboxDownloadAttachmentRequest);
        Py_VISIT(state->type_EmailMailboxDownloadAttachmentRequestEventArgs);
        Py_VISIT(state->type_EmailMailboxDownloadMessageRequest);
        Py_VISIT(state->type_EmailMailboxDownloadMessageRequestEventArgs);
        Py_VISIT(state->type_EmailMailboxEmptyFolderRequest);
        Py_VISIT(state->type_EmailMailboxEmptyFolderRequestEventArgs);
        Py_VISIT(state->type_EmailMailboxForwardMeetingRequest);
        Py_VISIT(state->type_EmailMailboxForwardMeetingRequestEventArgs);
        Py_VISIT(state->type_EmailMailboxGetAutoReplySettingsRequest);
        Py_VISIT(state->type_EmailMailboxGetAutoReplySettingsRequestEventArgs);
        Py_VISIT(state->type_EmailMailboxMoveFolderRequest);
        Py_VISIT(state->type_EmailMailboxMoveFolderRequestEventArgs);
        Py_VISIT(state->type_EmailMailboxProposeNewTimeForMeetingRequest);
        Py_VISIT(state->type_EmailMailboxProposeNewTimeForMeetingRequestEventArgs);
        Py_VISIT(state->type_EmailMailboxResolveRecipientsRequest);
        Py_VISIT(state->type_EmailMailboxResolveRecipientsRequestEventArgs);
        Py_VISIT(state->type_EmailMailboxServerSearchReadBatchRequest);
        Py_VISIT(state->type_EmailMailboxServerSearchReadBatchRequestEventArgs);
        Py_VISIT(state->type_EmailMailboxSetAutoReplySettingsRequest);
        Py_VISIT(state->type_EmailMailboxSetAutoReplySettingsRequestEventArgs);
        Py_VISIT(state->type_EmailMailboxSyncManagerSyncRequest);
        Py_VISIT(state->type_EmailMailboxSyncManagerSyncRequestEventArgs);
        Py_VISIT(state->type_EmailMailboxUpdateMeetingResponseRequest);
        Py_VISIT(state->type_EmailMailboxUpdateMeetingResponseRequestEventArgs);
        Py_VISIT(state->type_EmailMailboxValidateCertificatesRequest);
        Py_VISIT(state->type_EmailMailboxValidateCertificatesRequestEventArgs);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_EmailDataProviderConnection);
        Py_CLEAR(state->type_EmailDataProviderTriggerDetails);
        Py_CLEAR(state->type_EmailMailboxCreateFolderRequest);
        Py_CLEAR(state->type_EmailMailboxCreateFolderRequestEventArgs);
        Py_CLEAR(state->type_EmailMailboxDeleteFolderRequest);
        Py_CLEAR(state->type_EmailMailboxDeleteFolderRequestEventArgs);
        Py_CLEAR(state->type_EmailMailboxDownloadAttachmentRequest);
        Py_CLEAR(state->type_EmailMailboxDownloadAttachmentRequestEventArgs);
        Py_CLEAR(state->type_EmailMailboxDownloadMessageRequest);
        Py_CLEAR(state->type_EmailMailboxDownloadMessageRequestEventArgs);
        Py_CLEAR(state->type_EmailMailboxEmptyFolderRequest);
        Py_CLEAR(state->type_EmailMailboxEmptyFolderRequestEventArgs);
        Py_CLEAR(state->type_EmailMailboxForwardMeetingRequest);
        Py_CLEAR(state->type_EmailMailboxForwardMeetingRequestEventArgs);
        Py_CLEAR(state->type_EmailMailboxGetAutoReplySettingsRequest);
        Py_CLEAR(state->type_EmailMailboxGetAutoReplySettingsRequestEventArgs);
        Py_CLEAR(state->type_EmailMailboxMoveFolderRequest);
        Py_CLEAR(state->type_EmailMailboxMoveFolderRequestEventArgs);
        Py_CLEAR(state->type_EmailMailboxProposeNewTimeForMeetingRequest);
        Py_CLEAR(state->type_EmailMailboxProposeNewTimeForMeetingRequestEventArgs);
        Py_CLEAR(state->type_EmailMailboxResolveRecipientsRequest);
        Py_CLEAR(state->type_EmailMailboxResolveRecipientsRequestEventArgs);
        Py_CLEAR(state->type_EmailMailboxServerSearchReadBatchRequest);
        Py_CLEAR(state->type_EmailMailboxServerSearchReadBatchRequestEventArgs);
        Py_CLEAR(state->type_EmailMailboxSetAutoReplySettingsRequest);
        Py_CLEAR(state->type_EmailMailboxSetAutoReplySettingsRequestEventArgs);
        Py_CLEAR(state->type_EmailMailboxSyncManagerSyncRequest);
        Py_CLEAR(state->type_EmailMailboxSyncManagerSyncRequestEventArgs);
        Py_CLEAR(state->type_EmailMailboxUpdateMeetingResponseRequest);
        Py_CLEAR(state->type_EmailMailboxUpdateMeetingResponseRequestEventArgs);
        Py_CLEAR(state->type_EmailMailboxValidateCertificatesRequest);
        Py_CLEAR(state->type_EmailMailboxValidateCertificatesRequestEventArgs);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_ApplicationModel_Email_DataProvider",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::ApplicationModel::Email::DataProvider

PyMODINIT_FUNC PyInit__winsdk_Windows_ApplicationModel_Email_DataProvider(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_EmailDataProviderConnection = py::register_python_type(module.get(), type_name_EmailDataProviderConnection, &type_spec_EmailDataProviderConnection, bases.get(), nullptr);
    if (!state->type_EmailDataProviderConnection)
    {
        return nullptr;
    }

    state->type_EmailDataProviderTriggerDetails = py::register_python_type(module.get(), type_name_EmailDataProviderTriggerDetails, &type_spec_EmailDataProviderTriggerDetails, bases.get(), nullptr);
    if (!state->type_EmailDataProviderTriggerDetails)
    {
        return nullptr;
    }

    state->type_EmailMailboxCreateFolderRequest = py::register_python_type(module.get(), type_name_EmailMailboxCreateFolderRequest, &type_spec_EmailMailboxCreateFolderRequest, bases.get(), nullptr);
    if (!state->type_EmailMailboxCreateFolderRequest)
    {
        return nullptr;
    }

    state->type_EmailMailboxCreateFolderRequestEventArgs = py::register_python_type(module.get(), type_name_EmailMailboxCreateFolderRequestEventArgs, &type_spec_EmailMailboxCreateFolderRequestEventArgs, bases.get(), nullptr);
    if (!state->type_EmailMailboxCreateFolderRequestEventArgs)
    {
        return nullptr;
    }

    state->type_EmailMailboxDeleteFolderRequest = py::register_python_type(module.get(), type_name_EmailMailboxDeleteFolderRequest, &type_spec_EmailMailboxDeleteFolderRequest, bases.get(), nullptr);
    if (!state->type_EmailMailboxDeleteFolderRequest)
    {
        return nullptr;
    }

    state->type_EmailMailboxDeleteFolderRequestEventArgs = py::register_python_type(module.get(), type_name_EmailMailboxDeleteFolderRequestEventArgs, &type_spec_EmailMailboxDeleteFolderRequestEventArgs, bases.get(), nullptr);
    if (!state->type_EmailMailboxDeleteFolderRequestEventArgs)
    {
        return nullptr;
    }

    state->type_EmailMailboxDownloadAttachmentRequest = py::register_python_type(module.get(), type_name_EmailMailboxDownloadAttachmentRequest, &type_spec_EmailMailboxDownloadAttachmentRequest, bases.get(), nullptr);
    if (!state->type_EmailMailboxDownloadAttachmentRequest)
    {
        return nullptr;
    }

    state->type_EmailMailboxDownloadAttachmentRequestEventArgs = py::register_python_type(module.get(), type_name_EmailMailboxDownloadAttachmentRequestEventArgs, &type_spec_EmailMailboxDownloadAttachmentRequestEventArgs, bases.get(), nullptr);
    if (!state->type_EmailMailboxDownloadAttachmentRequestEventArgs)
    {
        return nullptr;
    }

    state->type_EmailMailboxDownloadMessageRequest = py::register_python_type(module.get(), type_name_EmailMailboxDownloadMessageRequest, &type_spec_EmailMailboxDownloadMessageRequest, bases.get(), nullptr);
    if (!state->type_EmailMailboxDownloadMessageRequest)
    {
        return nullptr;
    }

    state->type_EmailMailboxDownloadMessageRequestEventArgs = py::register_python_type(module.get(), type_name_EmailMailboxDownloadMessageRequestEventArgs, &type_spec_EmailMailboxDownloadMessageRequestEventArgs, bases.get(), nullptr);
    if (!state->type_EmailMailboxDownloadMessageRequestEventArgs)
    {
        return nullptr;
    }

    state->type_EmailMailboxEmptyFolderRequest = py::register_python_type(module.get(), type_name_EmailMailboxEmptyFolderRequest, &type_spec_EmailMailboxEmptyFolderRequest, bases.get(), nullptr);
    if (!state->type_EmailMailboxEmptyFolderRequest)
    {
        return nullptr;
    }

    state->type_EmailMailboxEmptyFolderRequestEventArgs = py::register_python_type(module.get(), type_name_EmailMailboxEmptyFolderRequestEventArgs, &type_spec_EmailMailboxEmptyFolderRequestEventArgs, bases.get(), nullptr);
    if (!state->type_EmailMailboxEmptyFolderRequestEventArgs)
    {
        return nullptr;
    }

    state->type_EmailMailboxForwardMeetingRequest = py::register_python_type(module.get(), type_name_EmailMailboxForwardMeetingRequest, &type_spec_EmailMailboxForwardMeetingRequest, bases.get(), nullptr);
    if (!state->type_EmailMailboxForwardMeetingRequest)
    {
        return nullptr;
    }

    state->type_EmailMailboxForwardMeetingRequestEventArgs = py::register_python_type(module.get(), type_name_EmailMailboxForwardMeetingRequestEventArgs, &type_spec_EmailMailboxForwardMeetingRequestEventArgs, bases.get(), nullptr);
    if (!state->type_EmailMailboxForwardMeetingRequestEventArgs)
    {
        return nullptr;
    }

    state->type_EmailMailboxGetAutoReplySettingsRequest = py::register_python_type(module.get(), type_name_EmailMailboxGetAutoReplySettingsRequest, &type_spec_EmailMailboxGetAutoReplySettingsRequest, bases.get(), nullptr);
    if (!state->type_EmailMailboxGetAutoReplySettingsRequest)
    {
        return nullptr;
    }

    state->type_EmailMailboxGetAutoReplySettingsRequestEventArgs = py::register_python_type(module.get(), type_name_EmailMailboxGetAutoReplySettingsRequestEventArgs, &type_spec_EmailMailboxGetAutoReplySettingsRequestEventArgs, bases.get(), nullptr);
    if (!state->type_EmailMailboxGetAutoReplySettingsRequestEventArgs)
    {
        return nullptr;
    }

    state->type_EmailMailboxMoveFolderRequest = py::register_python_type(module.get(), type_name_EmailMailboxMoveFolderRequest, &type_spec_EmailMailboxMoveFolderRequest, bases.get(), nullptr);
    if (!state->type_EmailMailboxMoveFolderRequest)
    {
        return nullptr;
    }

    state->type_EmailMailboxMoveFolderRequestEventArgs = py::register_python_type(module.get(), type_name_EmailMailboxMoveFolderRequestEventArgs, &type_spec_EmailMailboxMoveFolderRequestEventArgs, bases.get(), nullptr);
    if (!state->type_EmailMailboxMoveFolderRequestEventArgs)
    {
        return nullptr;
    }

    state->type_EmailMailboxProposeNewTimeForMeetingRequest = py::register_python_type(module.get(), type_name_EmailMailboxProposeNewTimeForMeetingRequest, &type_spec_EmailMailboxProposeNewTimeForMeetingRequest, bases.get(), nullptr);
    if (!state->type_EmailMailboxProposeNewTimeForMeetingRequest)
    {
        return nullptr;
    }

    state->type_EmailMailboxProposeNewTimeForMeetingRequestEventArgs = py::register_python_type(module.get(), type_name_EmailMailboxProposeNewTimeForMeetingRequestEventArgs, &type_spec_EmailMailboxProposeNewTimeForMeetingRequestEventArgs, bases.get(), nullptr);
    if (!state->type_EmailMailboxProposeNewTimeForMeetingRequestEventArgs)
    {
        return nullptr;
    }

    state->type_EmailMailboxResolveRecipientsRequest = py::register_python_type(module.get(), type_name_EmailMailboxResolveRecipientsRequest, &type_spec_EmailMailboxResolveRecipientsRequest, bases.get(), nullptr);
    if (!state->type_EmailMailboxResolveRecipientsRequest)
    {
        return nullptr;
    }

    state->type_EmailMailboxResolveRecipientsRequestEventArgs = py::register_python_type(module.get(), type_name_EmailMailboxResolveRecipientsRequestEventArgs, &type_spec_EmailMailboxResolveRecipientsRequestEventArgs, bases.get(), nullptr);
    if (!state->type_EmailMailboxResolveRecipientsRequestEventArgs)
    {
        return nullptr;
    }

    state->type_EmailMailboxServerSearchReadBatchRequest = py::register_python_type(module.get(), type_name_EmailMailboxServerSearchReadBatchRequest, &type_spec_EmailMailboxServerSearchReadBatchRequest, bases.get(), nullptr);
    if (!state->type_EmailMailboxServerSearchReadBatchRequest)
    {
        return nullptr;
    }

    state->type_EmailMailboxServerSearchReadBatchRequestEventArgs = py::register_python_type(module.get(), type_name_EmailMailboxServerSearchReadBatchRequestEventArgs, &type_spec_EmailMailboxServerSearchReadBatchRequestEventArgs, bases.get(), nullptr);
    if (!state->type_EmailMailboxServerSearchReadBatchRequestEventArgs)
    {
        return nullptr;
    }

    state->type_EmailMailboxSetAutoReplySettingsRequest = py::register_python_type(module.get(), type_name_EmailMailboxSetAutoReplySettingsRequest, &type_spec_EmailMailboxSetAutoReplySettingsRequest, bases.get(), nullptr);
    if (!state->type_EmailMailboxSetAutoReplySettingsRequest)
    {
        return nullptr;
    }

    state->type_EmailMailboxSetAutoReplySettingsRequestEventArgs = py::register_python_type(module.get(), type_name_EmailMailboxSetAutoReplySettingsRequestEventArgs, &type_spec_EmailMailboxSetAutoReplySettingsRequestEventArgs, bases.get(), nullptr);
    if (!state->type_EmailMailboxSetAutoReplySettingsRequestEventArgs)
    {
        return nullptr;
    }

    state->type_EmailMailboxSyncManagerSyncRequest = py::register_python_type(module.get(), type_name_EmailMailboxSyncManagerSyncRequest, &type_spec_EmailMailboxSyncManagerSyncRequest, bases.get(), nullptr);
    if (!state->type_EmailMailboxSyncManagerSyncRequest)
    {
        return nullptr;
    }

    state->type_EmailMailboxSyncManagerSyncRequestEventArgs = py::register_python_type(module.get(), type_name_EmailMailboxSyncManagerSyncRequestEventArgs, &type_spec_EmailMailboxSyncManagerSyncRequestEventArgs, bases.get(), nullptr);
    if (!state->type_EmailMailboxSyncManagerSyncRequestEventArgs)
    {
        return nullptr;
    }

    state->type_EmailMailboxUpdateMeetingResponseRequest = py::register_python_type(module.get(), type_name_EmailMailboxUpdateMeetingResponseRequest, &type_spec_EmailMailboxUpdateMeetingResponseRequest, bases.get(), nullptr);
    if (!state->type_EmailMailboxUpdateMeetingResponseRequest)
    {
        return nullptr;
    }

    state->type_EmailMailboxUpdateMeetingResponseRequestEventArgs = py::register_python_type(module.get(), type_name_EmailMailboxUpdateMeetingResponseRequestEventArgs, &type_spec_EmailMailboxUpdateMeetingResponseRequestEventArgs, bases.get(), nullptr);
    if (!state->type_EmailMailboxUpdateMeetingResponseRequestEventArgs)
    {
        return nullptr;
    }

    state->type_EmailMailboxValidateCertificatesRequest = py::register_python_type(module.get(), type_name_EmailMailboxValidateCertificatesRequest, &type_spec_EmailMailboxValidateCertificatesRequest, bases.get(), nullptr);
    if (!state->type_EmailMailboxValidateCertificatesRequest)
    {
        return nullptr;
    }

    state->type_EmailMailboxValidateCertificatesRequestEventArgs = py::register_python_type(module.get(), type_name_EmailMailboxValidateCertificatesRequestEventArgs, &type_spec_EmailMailboxValidateCertificatesRequestEventArgs, bases.get(), nullptr);
    if (!state->type_EmailMailboxValidateCertificatesRequestEventArgs)
    {
        return nullptr;
    }


    return module.detach();
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailDataProviderConnection;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailDataProviderTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxCreateFolderRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequestEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxCreateFolderRequestEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequestEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxDeleteFolderRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequestEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxDeleteFolderRequestEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequestEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxDownloadAttachmentRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequestEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxDownloadAttachmentRequestEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequestEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxDownloadMessageRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequestEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxDownloadMessageRequestEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequestEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxEmptyFolderRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequestEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxEmptyFolderRequestEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequestEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxForwardMeetingRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequestEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxForwardMeetingRequestEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequestEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxGetAutoReplySettingsRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequestEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxGetAutoReplySettingsRequestEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequestEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxMoveFolderRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequestEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxMoveFolderRequestEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequestEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxProposeNewTimeForMeetingRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequestEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxProposeNewTimeForMeetingRequestEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequestEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxResolveRecipientsRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequestEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxResolveRecipientsRequestEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequestEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxServerSearchReadBatchRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequestEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxServerSearchReadBatchRequestEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequestEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxSetAutoReplySettingsRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequestEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxSetAutoReplySettingsRequestEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequestEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxSyncManagerSyncRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequestEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxSyncManagerSyncRequestEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequestEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxUpdateMeetingResponseRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequestEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxUpdateMeetingResponseRequestEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequestEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxValidateCertificatesRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequestEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Email::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EmailMailboxValidateCertificatesRequestEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequestEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}
