// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.Media.Audio.h"


namespace py::cpp::Windows::Media::Audio
{
    struct module_state
    {
        PyObject* type_AudioDeviceNodeCreationStatus;
        PyObject* type_AudioFileNodeCreationStatus;
        PyObject* type_AudioGraphCreationStatus;
        PyObject* type_AudioGraphUnrecoverableError;
        PyObject* type_AudioNodeEmitterDecayKind;
        PyObject* type_AudioNodeEmitterSettings;
        PyObject* type_AudioNodeEmitterShapeKind;
        PyObject* type_AudioPlaybackConnectionOpenResultStatus;
        PyObject* type_AudioPlaybackConnectionState;
        PyObject* type_MediaSourceAudioInputNodeCreationStatus;
        PyObject* type_MixedRealitySpatialAudioFormatPolicy;
        PyObject* type_QuantumSizeSelectionMode;
        PyObject* type_SetDefaultSpatialAudioFormatStatus;
        PyObject* type_SpatialAudioModel;
        PyTypeObject* type_AudioDeviceInputNode;
        PyTypeObject* type_AudioDeviceOutputNode;
        PyTypeObject* type_AudioFileInputNode;
        PyTypeObject* type_AudioFileOutputNode;
        PyTypeObject* type_AudioFrameCompletedEventArgs;
        PyTypeObject* type_AudioFrameInputNode;
        PyTypeObject* type_AudioFrameOutputNode;
        PyTypeObject* type_AudioGraph;
        PyTypeObject* type_AudioGraphBatchUpdater;
        PyTypeObject* type_AudioGraphConnection;
        PyTypeObject* type_AudioGraphSettings;
        PyTypeObject* type_AudioGraphUnrecoverableErrorOccurredEventArgs;
        PyTypeObject* type_AudioNodeEmitter;
        PyTypeObject* type_AudioNodeEmitterConeProperties;
        PyTypeObject* type_AudioNodeEmitterDecayModel;
        PyTypeObject* type_AudioNodeEmitterNaturalDecayModelProperties;
        PyTypeObject* type_AudioNodeEmitterShape;
        PyTypeObject* type_AudioNodeListener;
        PyTypeObject* type_AudioPlaybackConnection;
        PyTypeObject* type_AudioPlaybackConnectionOpenResult;
        PyTypeObject* type_AudioStateMonitor;
        PyTypeObject* type_AudioSubmixNode;
        PyTypeObject* type_CreateAudioDeviceInputNodeResult;
        PyTypeObject* type_CreateAudioDeviceOutputNodeResult;
        PyTypeObject* type_CreateAudioFileInputNodeResult;
        PyTypeObject* type_CreateAudioFileOutputNodeResult;
        PyTypeObject* type_CreateAudioGraphResult;
        PyTypeObject* type_CreateMediaSourceAudioInputNodeResult;
        PyTypeObject* type_EchoEffectDefinition;
        PyTypeObject* type_EqualizerBand;
        PyTypeObject* type_EqualizerEffectDefinition;
        PyTypeObject* type_FrameInputNodeQuantumStartedEventArgs;
        PyTypeObject* type_LimiterEffectDefinition;
        PyTypeObject* type_MediaSourceAudioInputNode;
        PyTypeObject* type_ReverbEffectDefinition;
        PyTypeObject* type_SetDefaultSpatialAudioFormatResult;
        PyTypeObject* type_SpatialAudioDeviceConfiguration;
        PyTypeObject* type_SpatialAudioFormatConfiguration;
        PyTypeObject* type_SpatialAudioFormatSubtype;
        PyTypeObject* type_IAudioInputNode;
        PyTypeObject* type_IAudioInputNode2;
        PyTypeObject* type_IAudioNode;
        PyTypeObject* type_IAudioNodeWithListener;
    };

    static PyObject* register_AudioDeviceNodeCreationStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AudioDeviceNodeCreationStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AudioDeviceNodeCreationStatus = type;
        Py_INCREF(state->type_AudioDeviceNodeCreationStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_AudioFileNodeCreationStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AudioFileNodeCreationStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AudioFileNodeCreationStatus = type;
        Py_INCREF(state->type_AudioFileNodeCreationStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_AudioGraphCreationStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AudioGraphCreationStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AudioGraphCreationStatus = type;
        Py_INCREF(state->type_AudioGraphCreationStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_AudioGraphUnrecoverableError(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AudioGraphUnrecoverableError)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AudioGraphUnrecoverableError = type;
        Py_INCREF(state->type_AudioGraphUnrecoverableError);


        Py_RETURN_NONE;
    }

    static PyObject* register_AudioNodeEmitterDecayKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AudioNodeEmitterDecayKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AudioNodeEmitterDecayKind = type;
        Py_INCREF(state->type_AudioNodeEmitterDecayKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_AudioNodeEmitterSettings(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AudioNodeEmitterSettings)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AudioNodeEmitterSettings = type;
        Py_INCREF(state->type_AudioNodeEmitterSettings);


        Py_RETURN_NONE;
    }

    static PyObject* register_AudioNodeEmitterShapeKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AudioNodeEmitterShapeKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AudioNodeEmitterShapeKind = type;
        Py_INCREF(state->type_AudioNodeEmitterShapeKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_AudioPlaybackConnectionOpenResultStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AudioPlaybackConnectionOpenResultStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AudioPlaybackConnectionOpenResultStatus = type;
        Py_INCREF(state->type_AudioPlaybackConnectionOpenResultStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_AudioPlaybackConnectionState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AudioPlaybackConnectionState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AudioPlaybackConnectionState = type;
        Py_INCREF(state->type_AudioPlaybackConnectionState);


        Py_RETURN_NONE;
    }

    static PyObject* register_MediaSourceAudioInputNodeCreationStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MediaSourceAudioInputNodeCreationStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MediaSourceAudioInputNodeCreationStatus = type;
        Py_INCREF(state->type_MediaSourceAudioInputNodeCreationStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_MixedRealitySpatialAudioFormatPolicy(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MixedRealitySpatialAudioFormatPolicy)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MixedRealitySpatialAudioFormatPolicy = type;
        Py_INCREF(state->type_MixedRealitySpatialAudioFormatPolicy);


        Py_RETURN_NONE;
    }

    static PyObject* register_QuantumSizeSelectionMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_QuantumSizeSelectionMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_QuantumSizeSelectionMode = type;
        Py_INCREF(state->type_QuantumSizeSelectionMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_SetDefaultSpatialAudioFormatStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SetDefaultSpatialAudioFormatStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SetDefaultSpatialAudioFormatStatus = type;
        Py_INCREF(state->type_SetDefaultSpatialAudioFormatStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_SpatialAudioModel(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SpatialAudioModel)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SpatialAudioModel = type;
        Py_INCREF(state->type_SpatialAudioModel);


        Py_RETURN_NONE;
    }

    // ----- AudioDeviceInputNode class --------------------
    static constexpr const char* const type_name_AudioDeviceInputNode = "AudioDeviceInputNode";

    static PyObject* _new_AudioDeviceInputNode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioDeviceInputNode);
        return nullptr;
    }

    static void _dealloc_AudioDeviceInputNode(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioDeviceInputNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"AddOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"AddOutgoingConnection", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_Close(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"DisableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"EnableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"RemoveOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_Reset(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"Reset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_Start(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_Stop(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_get_Device(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"Device"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Device());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"OutgoingConnections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_get_Emitter(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"Emitter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Emitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceInputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioDeviceInputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceInputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioDeviceInputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"EffectDefinitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioDeviceInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioDeviceInputNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioDeviceInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioDeviceInputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioDeviceInputNode(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_AudioDeviceInputNode(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioDeviceInputNode[] = {
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_Stop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AudioDeviceInputNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioDeviceInputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioDeviceInputNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioDeviceInputNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioDeviceInputNode[] = {
        { "device", reinterpret_cast<getter>(AudioDeviceInputNode_get_Device), nullptr, nullptr, nullptr },
        { "outgoing_connections", reinterpret_cast<getter>(AudioDeviceInputNode_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { "emitter", reinterpret_cast<getter>(AudioDeviceInputNode_get_Emitter), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(AudioDeviceInputNode_get_OutgoingGain), reinterpret_cast<setter>(AudioDeviceInputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioDeviceInputNode_get_ConsumeInput), reinterpret_cast<setter>(AudioDeviceInputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioDeviceInputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioDeviceInputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioDeviceInputNode[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioDeviceInputNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioDeviceInputNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioDeviceInputNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioDeviceInputNode) },
        { },
    };

    static PyType_Spec type_spec_AudioDeviceInputNode =
    {
        "_winsdk_Windows_Media_Audio.AudioDeviceInputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioDeviceInputNode
    };

    // ----- AudioDeviceOutputNode class --------------------
    static constexpr const char* const type_name_AudioDeviceOutputNode = "AudioDeviceOutputNode";

    static PyObject* _new_AudioDeviceOutputNode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioDeviceOutputNode);
        return nullptr;
    }

    static void _dealloc_AudioDeviceOutputNode(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioDeviceOutputNode_Close(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"DisableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"EnableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_Reset(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"Reset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_Start(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_Stop(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_Device(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"Device"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Device());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceOutputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceOutputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"EffectDefinitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_Listener(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"Listener"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Listener());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceOutputNode_put_Listener(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"Listener"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeListener>(arg);

            self->obj.Listener(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AudioDeviceOutputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioDeviceOutputNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioDeviceOutputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioDeviceOutputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioDeviceOutputNode(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_AudioDeviceOutputNode(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioDeviceOutputNode[] = {
        { "close", reinterpret_cast<PyCFunction>(AudioDeviceOutputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioDeviceOutputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioDeviceOutputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioDeviceOutputNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioDeviceOutputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioDeviceOutputNode_Stop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AudioDeviceOutputNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioDeviceOutputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioDeviceOutputNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioDeviceOutputNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioDeviceOutputNode[] = {
        { "device", reinterpret_cast<getter>(AudioDeviceOutputNode_get_Device), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(AudioDeviceOutputNode_get_OutgoingGain), reinterpret_cast<setter>(AudioDeviceOutputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioDeviceOutputNode_get_ConsumeInput), reinterpret_cast<setter>(AudioDeviceOutputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioDeviceOutputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioDeviceOutputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "listener", reinterpret_cast<getter>(AudioDeviceOutputNode_get_Listener), reinterpret_cast<setter>(AudioDeviceOutputNode_put_Listener), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioDeviceOutputNode[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioDeviceOutputNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioDeviceOutputNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioDeviceOutputNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioDeviceOutputNode) },
        { },
    };

    static PyType_Spec type_spec_AudioDeviceOutputNode =
    {
        "_winsdk_Windows_Media_Audio.AudioDeviceOutputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioDeviceOutputNode
    };

    // ----- AudioFileInputNode class --------------------
    static constexpr const char* const type_name_AudioFileInputNode = "AudioFileInputNode";

    static PyObject* _new_AudioFileInputNode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioFileInputNode);
        return nullptr;
    }

    static void _dealloc_AudioFileInputNode(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioFileInputNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"AddOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"AddOutgoingConnection", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_Close(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"DisableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"EnableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"RemoveOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_Reset(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"Reset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_Seek(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"Seek", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_Start(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_Stop(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"PlaybackSpeedFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackSpeedFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"PlaybackSpeedFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.PlaybackSpeedFactor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_LoopCount(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"LoopCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LoopCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_LoopCount(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"LoopCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.LoopCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_EndTime(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"EndTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_EndTime(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"EndTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.EndTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_StartTime(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_StartTime(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_Position(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_SourceFile(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"SourceFile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceFile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_Duration(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"OutgoingConnections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_Emitter(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"Emitter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Emitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"EffectDefinitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_add_FileCompleted(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioFileInputNode", L"FileCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioFileInputNode, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.FileCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_remove_FileCompleted(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioFileInputNode", L"FileCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FileCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioFileInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioFileInputNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioFileInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioFileInputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioFileInputNode(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_AudioFileInputNode(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioFileInputNode[] = {
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(AudioFileInputNode_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(AudioFileInputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFileInputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFileInputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(AudioFileInputNode_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioFileInputNode_Reset), METH_VARARGS, nullptr },
        { "seek", reinterpret_cast<PyCFunction>(AudioFileInputNode_Seek), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioFileInputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioFileInputNode_Stop), METH_VARARGS, nullptr },
        { "add_file_completed", reinterpret_cast<PyCFunction>(AudioFileInputNode_add_FileCompleted), METH_O, nullptr },
        { "remove_file_completed", reinterpret_cast<PyCFunction>(AudioFileInputNode_remove_FileCompleted), METH_O, nullptr },
        { "_assign_array_", _assign_array_AudioFileInputNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioFileInputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioFileInputNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioFileInputNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioFileInputNode[] = {
        { "playback_speed_factor", reinterpret_cast<getter>(AudioFileInputNode_get_PlaybackSpeedFactor), reinterpret_cast<setter>(AudioFileInputNode_put_PlaybackSpeedFactor), nullptr, nullptr },
        { "loop_count", reinterpret_cast<getter>(AudioFileInputNode_get_LoopCount), reinterpret_cast<setter>(AudioFileInputNode_put_LoopCount), nullptr, nullptr },
        { "end_time", reinterpret_cast<getter>(AudioFileInputNode_get_EndTime), reinterpret_cast<setter>(AudioFileInputNode_put_EndTime), nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(AudioFileInputNode_get_StartTime), reinterpret_cast<setter>(AudioFileInputNode_put_StartTime), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(AudioFileInputNode_get_Position), nullptr, nullptr, nullptr },
        { "source_file", reinterpret_cast<getter>(AudioFileInputNode_get_SourceFile), nullptr, nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(AudioFileInputNode_get_Duration), nullptr, nullptr, nullptr },
        { "outgoing_connections", reinterpret_cast<getter>(AudioFileInputNode_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { "emitter", reinterpret_cast<getter>(AudioFileInputNode_get_Emitter), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(AudioFileInputNode_get_OutgoingGain), reinterpret_cast<setter>(AudioFileInputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioFileInputNode_get_ConsumeInput), reinterpret_cast<setter>(AudioFileInputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioFileInputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioFileInputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioFileInputNode[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioFileInputNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioFileInputNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioFileInputNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioFileInputNode) },
        { },
    };

    static PyType_Spec type_spec_AudioFileInputNode =
    {
        "_winsdk_Windows_Media_Audio.AudioFileInputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioFileInputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioFileInputNode
    };

    // ----- AudioFileOutputNode class --------------------
    static constexpr const char* const type_name_AudioFileOutputNode = "AudioFileOutputNode";

    static PyObject* _new_AudioFileOutputNode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioFileOutputNode);
        return nullptr;
    }

    static void _dealloc_AudioFileOutputNode(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioFileOutputNode_Close(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"DisableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"EnableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_FinalizeAsync(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"FinalizeAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FinalizeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_Reset(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"Reset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_Start(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_Stop(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_get_File(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"File"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.File());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_get_FileEncodingProfile(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"FileEncodingProfile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FileEncodingProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileOutputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileOutputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileOutputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileOutputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"EffectDefinitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioFileOutputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioFileOutputNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioFileOutputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioFileOutputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioFileOutputNode(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_AudioFileOutputNode(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioFileOutputNode[] = {
        { "close", reinterpret_cast<PyCFunction>(AudioFileOutputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFileOutputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFileOutputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "finalize_async", reinterpret_cast<PyCFunction>(AudioFileOutputNode_FinalizeAsync), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioFileOutputNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioFileOutputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioFileOutputNode_Stop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AudioFileOutputNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioFileOutputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioFileOutputNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioFileOutputNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioFileOutputNode[] = {
        { "file", reinterpret_cast<getter>(AudioFileOutputNode_get_File), nullptr, nullptr, nullptr },
        { "file_encoding_profile", reinterpret_cast<getter>(AudioFileOutputNode_get_FileEncodingProfile), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(AudioFileOutputNode_get_OutgoingGain), reinterpret_cast<setter>(AudioFileOutputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioFileOutputNode_get_ConsumeInput), reinterpret_cast<setter>(AudioFileOutputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioFileOutputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioFileOutputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioFileOutputNode[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioFileOutputNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioFileOutputNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioFileOutputNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioFileOutputNode) },
        { },
    };

    static PyType_Spec type_spec_AudioFileOutputNode =
    {
        "_winsdk_Windows_Media_Audio.AudioFileOutputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioFileOutputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioFileOutputNode
    };

    // ----- AudioFrameCompletedEventArgs class --------------------
    static constexpr const char* const type_name_AudioFrameCompletedEventArgs = "AudioFrameCompletedEventArgs";

    static PyObject* _new_AudioFrameCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioFrameCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_AudioFrameCompletedEventArgs(py::wrapper::Windows::Media::Audio::AudioFrameCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioFrameCompletedEventArgs_get_Frame(py::wrapper::Windows::Media::Audio::AudioFrameCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameCompletedEventArgs", L"Frame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioFrameCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioFrameCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioFrameCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioFrameCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioFrameCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_AudioFrameCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioFrameCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioFrameCompletedEventArgs[] = {
        { "frame", reinterpret_cast<getter>(AudioFrameCompletedEventArgs_get_Frame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioFrameCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioFrameCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioFrameCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioFrameCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioFrameCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AudioFrameCompletedEventArgs =
    {
        "_winsdk_Windows_Media_Audio.AudioFrameCompletedEventArgs",
        sizeof(py::wrapper::Windows::Media::Audio::AudioFrameCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioFrameCompletedEventArgs
    };

    // ----- AudioFrameInputNode class --------------------
    static constexpr const char* const type_name_AudioFrameInputNode = "AudioFrameInputNode";

    static PyObject* _new_AudioFrameInputNode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioFrameInputNode);
        return nullptr;
    }

    static void _dealloc_AudioFrameInputNode(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioFrameInputNode_AddFrame(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"AddFrame", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::AudioFrame>(args, 0);

                self->obj.AddFrame(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"AddOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"AddOutgoingConnection", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_Close(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"DisableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_DiscardQueuedFrames(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"DiscardQueuedFrames", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.DiscardQueuedFrames();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"EnableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"RemoveOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_Reset(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"Reset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_Start(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_Stop(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_get_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"PlaybackSpeedFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackSpeedFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrameInputNode_put_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"PlaybackSpeedFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.PlaybackSpeedFactor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrameInputNode_get_QueuedSampleCount(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"QueuedSampleCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QueuedSampleCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"OutgoingConnections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_get_Emitter(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"Emitter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Emitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrameInputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrameInputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrameInputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrameInputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"EffectDefinitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_add_AudioFrameCompleted(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"AudioFrameCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioFrameInputNode, winrt::Windows::Media::Audio::AudioFrameCompletedEventArgs>>(arg);

            return py::convert(self->obj.AudioFrameCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_remove_AudioFrameCompleted(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"AudioFrameCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AudioFrameCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_add_QuantumStarted(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"QuantumStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioFrameInputNode, winrt::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs>>(arg);

            return py::convert(self->obj.QuantumStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_remove_QuantumStarted(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"QuantumStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.QuantumStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioFrameInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioFrameInputNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioFrameInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioFrameInputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioFrameInputNode(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_AudioFrameInputNode(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioFrameInputNode[] = {
        { "add_frame", reinterpret_cast<PyCFunction>(AudioFrameInputNode_AddFrame), METH_VARARGS, nullptr },
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(AudioFrameInputNode_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(AudioFrameInputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFrameInputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "discard_queued_frames", reinterpret_cast<PyCFunction>(AudioFrameInputNode_DiscardQueuedFrames), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFrameInputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(AudioFrameInputNode_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioFrameInputNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioFrameInputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioFrameInputNode_Stop), METH_VARARGS, nullptr },
        { "add_audio_frame_completed", reinterpret_cast<PyCFunction>(AudioFrameInputNode_add_AudioFrameCompleted), METH_O, nullptr },
        { "remove_audio_frame_completed", reinterpret_cast<PyCFunction>(AudioFrameInputNode_remove_AudioFrameCompleted), METH_O, nullptr },
        { "add_quantum_started", reinterpret_cast<PyCFunction>(AudioFrameInputNode_add_QuantumStarted), METH_O, nullptr },
        { "remove_quantum_started", reinterpret_cast<PyCFunction>(AudioFrameInputNode_remove_QuantumStarted), METH_O, nullptr },
        { "_assign_array_", _assign_array_AudioFrameInputNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioFrameInputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioFrameInputNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioFrameInputNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioFrameInputNode[] = {
        { "playback_speed_factor", reinterpret_cast<getter>(AudioFrameInputNode_get_PlaybackSpeedFactor), reinterpret_cast<setter>(AudioFrameInputNode_put_PlaybackSpeedFactor), nullptr, nullptr },
        { "queued_sample_count", reinterpret_cast<getter>(AudioFrameInputNode_get_QueuedSampleCount), nullptr, nullptr, nullptr },
        { "outgoing_connections", reinterpret_cast<getter>(AudioFrameInputNode_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { "emitter", reinterpret_cast<getter>(AudioFrameInputNode_get_Emitter), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(AudioFrameInputNode_get_OutgoingGain), reinterpret_cast<setter>(AudioFrameInputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioFrameInputNode_get_ConsumeInput), reinterpret_cast<setter>(AudioFrameInputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioFrameInputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioFrameInputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioFrameInputNode[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioFrameInputNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioFrameInputNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioFrameInputNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioFrameInputNode) },
        { },
    };

    static PyType_Spec type_spec_AudioFrameInputNode =
    {
        "_winsdk_Windows_Media_Audio.AudioFrameInputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioFrameInputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioFrameInputNode
    };

    // ----- AudioFrameOutputNode class --------------------
    static constexpr const char* const type_name_AudioFrameOutputNode = "AudioFrameOutputNode";

    static PyObject* _new_AudioFrameOutputNode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioFrameOutputNode);
        return nullptr;
    }

    static void _dealloc_AudioFrameOutputNode(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioFrameOutputNode_Close(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"DisableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"EnableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_GetFrame(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"GetFrame", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_Reset(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"Reset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_Start(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_Stop(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrameOutputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrameOutputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrameOutputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrameOutputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"EffectDefinitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioFrameOutputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioFrameOutputNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioFrameOutputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioFrameOutputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioFrameOutputNode(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_AudioFrameOutputNode(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioFrameOutputNode[] = {
        { "close", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "get_frame", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_GetFrame), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_Stop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AudioFrameOutputNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioFrameOutputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioFrameOutputNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioFrameOutputNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioFrameOutputNode[] = {
        { "outgoing_gain", reinterpret_cast<getter>(AudioFrameOutputNode_get_OutgoingGain), reinterpret_cast<setter>(AudioFrameOutputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioFrameOutputNode_get_ConsumeInput), reinterpret_cast<setter>(AudioFrameOutputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioFrameOutputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioFrameOutputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioFrameOutputNode[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioFrameOutputNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioFrameOutputNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioFrameOutputNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioFrameOutputNode) },
        { },
    };

    static PyType_Spec type_spec_AudioFrameOutputNode =
    {
        "_winsdk_Windows_Media_Audio.AudioFrameOutputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioFrameOutputNode
    };

    // ----- AudioGraph class --------------------
    static constexpr const char* const type_name_AudioGraph = "AudioGraph";

    static PyObject* _new_AudioGraph(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioGraph);
        return nullptr;
    }

    static void _dealloc_AudioGraph(py::wrapper::Windows::Media::Audio::AudioGraph* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioGraph_Close(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraphSettings>(args, 0);

                return py::convert(winrt::Windows::Media::Audio::AudioGraph::CreateAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateBatchUpdater(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateBatchUpdater", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateBatchUpdater());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateDeviceInputNodeAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateDeviceInputNodeAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);

                return py::convert(self->obj.CreateDeviceInputNodeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateDeviceInputNodeAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 1);

                return py::convert(self->obj.CreateDeviceInputNodeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateDeviceInputNodeAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(args, 2);

                return py::convert(self->obj.CreateDeviceInputNodeAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateDeviceInputNodeAsync", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitter>(args, 3);

                return py::convert(self->obj.CreateDeviceInputNodeAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateDeviceOutputNodeAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateDeviceOutputNodeAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateDeviceOutputNodeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateFileInputNodeAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateFileInputNodeAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(self->obj.CreateFileInputNodeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateFileInputNodeAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitter>(args, 1);

                return py::convert(self->obj.CreateFileInputNodeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateFileOutputNodeAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateFileOutputNodeAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(self->obj.CreateFileOutputNodeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateFileOutputNodeAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 1);

                return py::convert(self->obj.CreateFileOutputNodeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateFrameInputNode(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateFrameInputNode", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateFrameInputNode());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateFrameInputNode", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);

                return py::convert(self->obj.CreateFrameInputNode(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateFrameInputNode", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitter>(args, 1);

                return py::convert(self->obj.CreateFrameInputNode(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateFrameOutputNode(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateFrameOutputNode", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateFrameOutputNode());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateFrameOutputNode", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);

                return py::convert(self->obj.CreateFrameOutputNode(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateMediaSourceAudioInputNodeAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateMediaSourceAudioInputNodeAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaSource>(args, 0);

                return py::convert(self->obj.CreateMediaSourceAudioInputNodeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateMediaSourceAudioInputNodeAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaSource>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitter>(args, 1);

                return py::convert(self->obj.CreateMediaSourceAudioInputNodeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateSubmixNode(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateSubmixNode", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateSubmixNode());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateSubmixNode", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);

                return py::convert(self->obj.CreateSubmixNode(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateSubmixNode", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitter>(args, 1);

                return py::convert(self->obj.CreateSubmixNode(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_ResetAllNodes(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"ResetAllNodes", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ResetAllNodes();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_Start(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_Stop(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_CompletedQuantumCount(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraph", L"CompletedQuantumCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CompletedQuantumCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraph", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_LatencyInSamples(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraph", L"LatencyInSamples"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LatencyInSamples());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_PrimaryRenderDevice(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraph", L"PrimaryRenderDevice"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PrimaryRenderDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_RenderDeviceAudioProcessing(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraph", L"RenderDeviceAudioProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RenderDeviceAudioProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_SamplesPerQuantum(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraph", L"SamplesPerQuantum"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SamplesPerQuantum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_add_QuantumProcessed(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioGraph", L"QuantumProcessed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioGraph, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.QuantumProcessed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_remove_QuantumProcessed(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioGraph", L"QuantumProcessed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.QuantumProcessed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_add_QuantumStarted(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioGraph", L"QuantumStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioGraph, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.QuantumStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_remove_QuantumStarted(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioGraph", L"QuantumStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.QuantumStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_add_UnrecoverableErrorOccurred(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioGraph", L"UnrecoverableErrorOccurred"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioGraph, winrt::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs>>(arg);

            return py::convert(self->obj.UnrecoverableErrorOccurred(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_remove_UnrecoverableErrorOccurred(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioGraph", L"UnrecoverableErrorOccurred"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UnrecoverableErrorOccurred(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioGraph(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioGraph>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioGraph(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioGraph>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioGraph(py::wrapper::Windows::Media::Audio::AudioGraph* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_AudioGraph(py::wrapper::Windows::Media::Audio::AudioGraph* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioGraph[] = {
        { "close", reinterpret_cast<PyCFunction>(AudioGraph_Close), METH_VARARGS, nullptr },
        { "create_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "create_batch_updater", reinterpret_cast<PyCFunction>(AudioGraph_CreateBatchUpdater), METH_VARARGS, nullptr },
        { "create_device_input_node_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateDeviceInputNodeAsync), METH_VARARGS, nullptr },
        { "create_device_output_node_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateDeviceOutputNodeAsync), METH_VARARGS, nullptr },
        { "create_file_input_node_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateFileInputNodeAsync), METH_VARARGS, nullptr },
        { "create_file_output_node_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateFileOutputNodeAsync), METH_VARARGS, nullptr },
        { "create_frame_input_node", reinterpret_cast<PyCFunction>(AudioGraph_CreateFrameInputNode), METH_VARARGS, nullptr },
        { "create_frame_output_node", reinterpret_cast<PyCFunction>(AudioGraph_CreateFrameOutputNode), METH_VARARGS, nullptr },
        { "create_media_source_audio_input_node_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateMediaSourceAudioInputNodeAsync), METH_VARARGS, nullptr },
        { "create_submix_node", reinterpret_cast<PyCFunction>(AudioGraph_CreateSubmixNode), METH_VARARGS, nullptr },
        { "reset_all_nodes", reinterpret_cast<PyCFunction>(AudioGraph_ResetAllNodes), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioGraph_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioGraph_Stop), METH_VARARGS, nullptr },
        { "add_quantum_processed", reinterpret_cast<PyCFunction>(AudioGraph_add_QuantumProcessed), METH_O, nullptr },
        { "remove_quantum_processed", reinterpret_cast<PyCFunction>(AudioGraph_remove_QuantumProcessed), METH_O, nullptr },
        { "add_quantum_started", reinterpret_cast<PyCFunction>(AudioGraph_add_QuantumStarted), METH_O, nullptr },
        { "remove_quantum_started", reinterpret_cast<PyCFunction>(AudioGraph_remove_QuantumStarted), METH_O, nullptr },
        { "add_unrecoverable_error_occurred", reinterpret_cast<PyCFunction>(AudioGraph_add_UnrecoverableErrorOccurred), METH_O, nullptr },
        { "remove_unrecoverable_error_occurred", reinterpret_cast<PyCFunction>(AudioGraph_remove_UnrecoverableErrorOccurred), METH_O, nullptr },
        { "_assign_array_", _assign_array_AudioGraph, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioGraph), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioGraph), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioGraph), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioGraph[] = {
        { "completed_quantum_count", reinterpret_cast<getter>(AudioGraph_get_CompletedQuantumCount), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioGraph_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "latency_in_samples", reinterpret_cast<getter>(AudioGraph_get_LatencyInSamples), nullptr, nullptr, nullptr },
        { "primary_render_device", reinterpret_cast<getter>(AudioGraph_get_PrimaryRenderDevice), nullptr, nullptr, nullptr },
        { "render_device_audio_processing", reinterpret_cast<getter>(AudioGraph_get_RenderDeviceAudioProcessing), nullptr, nullptr, nullptr },
        { "samples_per_quantum", reinterpret_cast<getter>(AudioGraph_get_SamplesPerQuantum), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioGraph[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioGraph) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioGraph) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioGraph) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioGraph) },
        { },
    };

    static PyType_Spec type_spec_AudioGraph =
    {
        "_winsdk_Windows_Media_Audio.AudioGraph",
        sizeof(py::wrapper::Windows::Media::Audio::AudioGraph),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioGraph
    };

    // ----- AudioGraphBatchUpdater class --------------------
    static constexpr const char* const type_name_AudioGraphBatchUpdater = "AudioGraphBatchUpdater";

    static PyObject* _new_AudioGraphBatchUpdater(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioGraphBatchUpdater);
        return nullptr;
    }

    static void _dealloc_AudioGraphBatchUpdater(py::wrapper::Windows::Media::Audio::AudioGraphBatchUpdater* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioGraphBatchUpdater_Close(py::wrapper::Windows::Media::Audio::AudioGraphBatchUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraphBatchUpdater", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioGraphBatchUpdater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioGraphBatchUpdater>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioGraphBatchUpdater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioGraphBatchUpdater>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioGraphBatchUpdater(py::wrapper::Windows::Media::Audio::AudioGraphBatchUpdater* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_AudioGraphBatchUpdater(py::wrapper::Windows::Media::Audio::AudioGraphBatchUpdater* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioGraphBatchUpdater[] = {
        { "close", reinterpret_cast<PyCFunction>(AudioGraphBatchUpdater_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AudioGraphBatchUpdater, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioGraphBatchUpdater), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioGraphBatchUpdater), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioGraphBatchUpdater), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioGraphBatchUpdater[] = {
        { }
    };

    static PyType_Slot _type_slots_AudioGraphBatchUpdater[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioGraphBatchUpdater) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioGraphBatchUpdater) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioGraphBatchUpdater) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioGraphBatchUpdater) },
        { },
    };

    static PyType_Spec type_spec_AudioGraphBatchUpdater =
    {
        "_winsdk_Windows_Media_Audio.AudioGraphBatchUpdater",
        sizeof(py::wrapper::Windows::Media::Audio::AudioGraphBatchUpdater),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioGraphBatchUpdater
    };

    // ----- AudioGraphConnection class --------------------
    static constexpr const char* const type_name_AudioGraphConnection = "AudioGraphConnection";

    static PyObject* _new_AudioGraphConnection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioGraphConnection);
        return nullptr;
    }

    static void _dealloc_AudioGraphConnection(py::wrapper::Windows::Media::Audio::AudioGraphConnection* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioGraphConnection_get_Gain(py::wrapper::Windows::Media::Audio::AudioGraphConnection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphConnection", L"Gain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Gain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphConnection_put_Gain(py::wrapper::Windows::Media::Audio::AudioGraphConnection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphConnection", L"Gain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Gain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphConnection_get_Destination(py::wrapper::Windows::Media::Audio::AudioGraphConnection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphConnection", L"Destination"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Destination());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioGraphConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioGraphConnection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioGraphConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioGraphConnection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioGraphConnection[] = {
        { "_assign_array_", _assign_array_AudioGraphConnection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioGraphConnection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioGraphConnection[] = {
        { "gain", reinterpret_cast<getter>(AudioGraphConnection_get_Gain), reinterpret_cast<setter>(AudioGraphConnection_put_Gain), nullptr, nullptr },
        { "destination", reinterpret_cast<getter>(AudioGraphConnection_get_Destination), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioGraphConnection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioGraphConnection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioGraphConnection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioGraphConnection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioGraphConnection) },
        { },
    };

    static PyType_Spec type_spec_AudioGraphConnection =
    {
        "_winsdk_Windows_Media_Audio.AudioGraphConnection",
        sizeof(py::wrapper::Windows::Media::Audio::AudioGraphConnection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioGraphConnection
    };

    // ----- AudioGraphSettings class --------------------
    static constexpr const char* const type_name_AudioGraphSettings = "AudioGraphSettings";

    static PyObject* _new_AudioGraphSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(args, 0);

                winrt::Windows::Media::Audio::AudioGraphSettings instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioGraphSettings(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioGraphSettings_get_QuantumSizeSelectionMode(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"QuantumSizeSelectionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QuantumSizeSelectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_QuantumSizeSelectionMode(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"QuantumSizeSelectionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Audio::QuantumSizeSelectionMode>(arg);

            self->obj.QuantumSizeSelectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_PrimaryRenderDevice(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"PrimaryRenderDevice"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PrimaryRenderDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_PrimaryRenderDevice(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"PrimaryRenderDevice"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(arg);

            self->obj.PrimaryRenderDevice(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(arg);

            self->obj.EncodingProperties(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_DesiredSamplesPerQuantum(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"DesiredSamplesPerQuantum"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredSamplesPerQuantum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_DesiredSamplesPerQuantum(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"DesiredSamplesPerQuantum"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.DesiredSamplesPerQuantum(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_DesiredRenderDeviceAudioProcessing(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"DesiredRenderDeviceAudioProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredRenderDeviceAudioProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_DesiredRenderDeviceAudioProcessing(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"DesiredRenderDeviceAudioProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::AudioProcessing>(arg);

            self->obj.DesiredRenderDeviceAudioProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_AudioRenderCategory(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"AudioRenderCategory"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioRenderCategory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_AudioRenderCategory(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"AudioRenderCategory"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(arg);

            self->obj.AudioRenderCategory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_MaxPlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"MaxPlaybackSpeedFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxPlaybackSpeedFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_MaxPlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"MaxPlaybackSpeedFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.MaxPlaybackSpeedFactor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AudioGraphSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioGraphSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioGraphSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioGraphSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioGraphSettings[] = {
        { "_assign_array_", _assign_array_AudioGraphSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioGraphSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioGraphSettings[] = {
        { "quantum_size_selection_mode", reinterpret_cast<getter>(AudioGraphSettings_get_QuantumSizeSelectionMode), reinterpret_cast<setter>(AudioGraphSettings_put_QuantumSizeSelectionMode), nullptr, nullptr },
        { "primary_render_device", reinterpret_cast<getter>(AudioGraphSettings_get_PrimaryRenderDevice), reinterpret_cast<setter>(AudioGraphSettings_put_PrimaryRenderDevice), nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioGraphSettings_get_EncodingProperties), reinterpret_cast<setter>(AudioGraphSettings_put_EncodingProperties), nullptr, nullptr },
        { "desired_samples_per_quantum", reinterpret_cast<getter>(AudioGraphSettings_get_DesiredSamplesPerQuantum), reinterpret_cast<setter>(AudioGraphSettings_put_DesiredSamplesPerQuantum), nullptr, nullptr },
        { "desired_render_device_audio_processing", reinterpret_cast<getter>(AudioGraphSettings_get_DesiredRenderDeviceAudioProcessing), reinterpret_cast<setter>(AudioGraphSettings_put_DesiredRenderDeviceAudioProcessing), nullptr, nullptr },
        { "audio_render_category", reinterpret_cast<getter>(AudioGraphSettings_get_AudioRenderCategory), reinterpret_cast<setter>(AudioGraphSettings_put_AudioRenderCategory), nullptr, nullptr },
        { "max_playback_speed_factor", reinterpret_cast<getter>(AudioGraphSettings_get_MaxPlaybackSpeedFactor), reinterpret_cast<setter>(AudioGraphSettings_put_MaxPlaybackSpeedFactor), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioGraphSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioGraphSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioGraphSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioGraphSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioGraphSettings) },
        { },
    };

    static PyType_Spec type_spec_AudioGraphSettings =
    {
        "_winsdk_Windows_Media_Audio.AudioGraphSettings",
        sizeof(py::wrapper::Windows::Media::Audio::AudioGraphSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioGraphSettings
    };

    // ----- AudioGraphUnrecoverableErrorOccurredEventArgs class --------------------
    static constexpr const char* const type_name_AudioGraphUnrecoverableErrorOccurredEventArgs = "AudioGraphUnrecoverableErrorOccurredEventArgs";

    static PyObject* _new_AudioGraphUnrecoverableErrorOccurredEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioGraphUnrecoverableErrorOccurredEventArgs);
        return nullptr;
    }

    static void _dealloc_AudioGraphUnrecoverableErrorOccurredEventArgs(py::wrapper::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioGraphUnrecoverableErrorOccurredEventArgs_get_Error(py::wrapper::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphUnrecoverableErrorOccurredEventArgs", L"Error"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioGraphUnrecoverableErrorOccurredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioGraphUnrecoverableErrorOccurredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioGraphUnrecoverableErrorOccurredEventArgs[] = {
        { "_assign_array_", _assign_array_AudioGraphUnrecoverableErrorOccurredEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioGraphUnrecoverableErrorOccurredEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioGraphUnrecoverableErrorOccurredEventArgs[] = {
        { "error", reinterpret_cast<getter>(AudioGraphUnrecoverableErrorOccurredEventArgs_get_Error), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioGraphUnrecoverableErrorOccurredEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioGraphUnrecoverableErrorOccurredEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioGraphUnrecoverableErrorOccurredEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioGraphUnrecoverableErrorOccurredEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioGraphUnrecoverableErrorOccurredEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AudioGraphUnrecoverableErrorOccurredEventArgs =
    {
        "_winsdk_Windows_Media_Audio.AudioGraphUnrecoverableErrorOccurredEventArgs",
        sizeof(py::wrapper::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioGraphUnrecoverableErrorOccurredEventArgs
    };

    // ----- AudioNodeEmitter class --------------------
    static constexpr const char* const type_name_AudioNodeEmitter = "AudioNodeEmitter";

    static PyObject* _new_AudioNodeEmitter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitterShape>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitterSettings>(args, 2);

                winrt::Windows::Media::Audio::AudioNodeEmitter instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Audio::AudioNodeEmitter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioNodeEmitter(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioNodeEmitter_get_Position(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_Position(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_Gain(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"Gain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Gain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_Gain(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"Gain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Gain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_DopplerVelocity(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"DopplerVelocity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DopplerVelocity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_DopplerVelocity(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"DopplerVelocity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.DopplerVelocity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_DopplerScale(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"DopplerScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DopplerScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_DopplerScale(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"DopplerScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DopplerScale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_DistanceScale(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"DistanceScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DistanceScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_DistanceScale(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"DistanceScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DistanceScale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_Direction(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"Direction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Direction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_Direction(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"Direction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.Direction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_DecayModel(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"DecayModel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DecayModel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitter_get_IsDopplerDisabled(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"IsDopplerDisabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDopplerDisabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitter_get_Shape(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"Shape"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitter_get_SpatialAudioModel(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"SpatialAudioModel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SpatialAudioModel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_SpatialAudioModel(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"SpatialAudioModel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Audio::SpatialAudioModel>(arg);

            self->obj.SpatialAudioModel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AudioNodeEmitter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioNodeEmitter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioNodeEmitter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeEmitter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeEmitter[] = {
        { "_assign_array_", _assign_array_AudioNodeEmitter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioNodeEmitter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioNodeEmitter[] = {
        { "position", reinterpret_cast<getter>(AudioNodeEmitter_get_Position), reinterpret_cast<setter>(AudioNodeEmitter_put_Position), nullptr, nullptr },
        { "gain", reinterpret_cast<getter>(AudioNodeEmitter_get_Gain), reinterpret_cast<setter>(AudioNodeEmitter_put_Gain), nullptr, nullptr },
        { "doppler_velocity", reinterpret_cast<getter>(AudioNodeEmitter_get_DopplerVelocity), reinterpret_cast<setter>(AudioNodeEmitter_put_DopplerVelocity), nullptr, nullptr },
        { "doppler_scale", reinterpret_cast<getter>(AudioNodeEmitter_get_DopplerScale), reinterpret_cast<setter>(AudioNodeEmitter_put_DopplerScale), nullptr, nullptr },
        { "distance_scale", reinterpret_cast<getter>(AudioNodeEmitter_get_DistanceScale), reinterpret_cast<setter>(AudioNodeEmitter_put_DistanceScale), nullptr, nullptr },
        { "direction", reinterpret_cast<getter>(AudioNodeEmitter_get_Direction), reinterpret_cast<setter>(AudioNodeEmitter_put_Direction), nullptr, nullptr },
        { "decay_model", reinterpret_cast<getter>(AudioNodeEmitter_get_DecayModel), nullptr, nullptr, nullptr },
        { "is_doppler_disabled", reinterpret_cast<getter>(AudioNodeEmitter_get_IsDopplerDisabled), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(AudioNodeEmitter_get_Shape), nullptr, nullptr, nullptr },
        { "spatial_audio_model", reinterpret_cast<getter>(AudioNodeEmitter_get_SpatialAudioModel), reinterpret_cast<setter>(AudioNodeEmitter_put_SpatialAudioModel), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioNodeEmitter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioNodeEmitter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioNodeEmitter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioNodeEmitter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioNodeEmitter) },
        { },
    };

    static PyType_Spec type_spec_AudioNodeEmitter =
    {
        "_winsdk_Windows_Media_Audio.AudioNodeEmitter",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeEmitter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeEmitter
    };

    // ----- AudioNodeEmitterConeProperties class --------------------
    static constexpr const char* const type_name_AudioNodeEmitterConeProperties = "AudioNodeEmitterConeProperties";

    static PyObject* _new_AudioNodeEmitterConeProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioNodeEmitterConeProperties);
        return nullptr;
    }

    static void _dealloc_AudioNodeEmitterConeProperties(py::wrapper::Windows::Media::Audio::AudioNodeEmitterConeProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioNodeEmitterConeProperties_get_InnerAngle(py::wrapper::Windows::Media::Audio::AudioNodeEmitterConeProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterConeProperties", L"InnerAngle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InnerAngle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterConeProperties_get_OuterAngle(py::wrapper::Windows::Media::Audio::AudioNodeEmitterConeProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterConeProperties", L"OuterAngle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OuterAngle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterConeProperties_get_OuterAngleGain(py::wrapper::Windows::Media::Audio::AudioNodeEmitterConeProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterConeProperties", L"OuterAngleGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OuterAngleGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioNodeEmitterConeProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioNodeEmitterConeProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioNodeEmitterConeProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeEmitterConeProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeEmitterConeProperties[] = {
        { "_assign_array_", _assign_array_AudioNodeEmitterConeProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioNodeEmitterConeProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioNodeEmitterConeProperties[] = {
        { "inner_angle", reinterpret_cast<getter>(AudioNodeEmitterConeProperties_get_InnerAngle), nullptr, nullptr, nullptr },
        { "outer_angle", reinterpret_cast<getter>(AudioNodeEmitterConeProperties_get_OuterAngle), nullptr, nullptr, nullptr },
        { "outer_angle_gain", reinterpret_cast<getter>(AudioNodeEmitterConeProperties_get_OuterAngleGain), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioNodeEmitterConeProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioNodeEmitterConeProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioNodeEmitterConeProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioNodeEmitterConeProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioNodeEmitterConeProperties) },
        { },
    };

    static PyType_Spec type_spec_AudioNodeEmitterConeProperties =
    {
        "_winsdk_Windows_Media_Audio.AudioNodeEmitterConeProperties",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeEmitterConeProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeEmitterConeProperties
    };

    // ----- AudioNodeEmitterDecayModel class --------------------
    static constexpr const char* const type_name_AudioNodeEmitterDecayModel = "AudioNodeEmitterDecayModel";

    static PyObject* _new_AudioNodeEmitterDecayModel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioNodeEmitterDecayModel);
        return nullptr;
    }

    static void _dealloc_AudioNodeEmitterDecayModel(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioNodeEmitterDecayModel_CreateCustom(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioNodeEmitterDecayModel", L"CreateCustom", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                return py::convert(winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel::CreateCustom(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterDecayModel_CreateNatural(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioNodeEmitterDecayModel", L"CreateNatural", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);
                auto param3 = py::convert_to<double>(args, 3);

                return py::convert(winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel::CreateNatural(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterDecayModel_get_Kind(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterDecayModel", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterDecayModel_get_MaxGain(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterDecayModel", L"MaxGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterDecayModel_get_MinGain(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterDecayModel", L"MinGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterDecayModel_get_NaturalProperties(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterDecayModel", L"NaturalProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NaturalProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioNodeEmitterDecayModel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioNodeEmitterDecayModel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeEmitterDecayModel[] = {
        { "create_custom", reinterpret_cast<PyCFunction>(AudioNodeEmitterDecayModel_CreateCustom), METH_VARARGS | METH_STATIC, nullptr },
        { "create_natural", reinterpret_cast<PyCFunction>(AudioNodeEmitterDecayModel_CreateNatural), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_AudioNodeEmitterDecayModel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioNodeEmitterDecayModel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioNodeEmitterDecayModel[] = {
        { "kind", reinterpret_cast<getter>(AudioNodeEmitterDecayModel_get_Kind), nullptr, nullptr, nullptr },
        { "max_gain", reinterpret_cast<getter>(AudioNodeEmitterDecayModel_get_MaxGain), nullptr, nullptr, nullptr },
        { "min_gain", reinterpret_cast<getter>(AudioNodeEmitterDecayModel_get_MinGain), nullptr, nullptr, nullptr },
        { "natural_properties", reinterpret_cast<getter>(AudioNodeEmitterDecayModel_get_NaturalProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioNodeEmitterDecayModel[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioNodeEmitterDecayModel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioNodeEmitterDecayModel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioNodeEmitterDecayModel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioNodeEmitterDecayModel) },
        { },
    };

    static PyType_Spec type_spec_AudioNodeEmitterDecayModel =
    {
        "_winsdk_Windows_Media_Audio.AudioNodeEmitterDecayModel",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeEmitterDecayModel
    };

    // ----- AudioNodeEmitterNaturalDecayModelProperties class --------------------
    static constexpr const char* const type_name_AudioNodeEmitterNaturalDecayModelProperties = "AudioNodeEmitterNaturalDecayModelProperties";

    static PyObject* _new_AudioNodeEmitterNaturalDecayModelProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioNodeEmitterNaturalDecayModelProperties);
        return nullptr;
    }

    static void _dealloc_AudioNodeEmitterNaturalDecayModelProperties(py::wrapper::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioNodeEmitterNaturalDecayModelProperties_get_CutoffDistance(py::wrapper::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterNaturalDecayModelProperties", L"CutoffDistance"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CutoffDistance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterNaturalDecayModelProperties_get_UnityGainDistance(py::wrapper::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterNaturalDecayModelProperties", L"UnityGainDistance"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UnityGainDistance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioNodeEmitterNaturalDecayModelProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioNodeEmitterNaturalDecayModelProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeEmitterNaturalDecayModelProperties[] = {
        { "_assign_array_", _assign_array_AudioNodeEmitterNaturalDecayModelProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioNodeEmitterNaturalDecayModelProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioNodeEmitterNaturalDecayModelProperties[] = {
        { "cutoff_distance", reinterpret_cast<getter>(AudioNodeEmitterNaturalDecayModelProperties_get_CutoffDistance), nullptr, nullptr, nullptr },
        { "unity_gain_distance", reinterpret_cast<getter>(AudioNodeEmitterNaturalDecayModelProperties_get_UnityGainDistance), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioNodeEmitterNaturalDecayModelProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioNodeEmitterNaturalDecayModelProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioNodeEmitterNaturalDecayModelProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioNodeEmitterNaturalDecayModelProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioNodeEmitterNaturalDecayModelProperties) },
        { },
    };

    static PyType_Spec type_spec_AudioNodeEmitterNaturalDecayModelProperties =
    {
        "_winsdk_Windows_Media_Audio.AudioNodeEmitterNaturalDecayModelProperties",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeEmitterNaturalDecayModelProperties
    };

    // ----- AudioNodeEmitterShape class --------------------
    static constexpr const char* const type_name_AudioNodeEmitterShape = "AudioNodeEmitterShape";

    static PyObject* _new_AudioNodeEmitterShape(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioNodeEmitterShape);
        return nullptr;
    }

    static void _dealloc_AudioNodeEmitterShape(py::wrapper::Windows::Media::Audio::AudioNodeEmitterShape* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioNodeEmitterShape_CreateCone(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioNodeEmitterShape", L"CreateCone", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);

                return py::convert(winrt::Windows::Media::Audio::AudioNodeEmitterShape::CreateCone(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterShape_CreateOmnidirectional(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioNodeEmitterShape", L"CreateOmnidirectional", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::Audio::AudioNodeEmitterShape::CreateOmnidirectional());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterShape_get_ConeProperties(py::wrapper::Windows::Media::Audio::AudioNodeEmitterShape* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterShape", L"ConeProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConeProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterShape_get_Kind(py::wrapper::Windows::Media::Audio::AudioNodeEmitterShape* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterShape", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioNodeEmitterShape(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioNodeEmitterShape>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioNodeEmitterShape(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeEmitterShape>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeEmitterShape[] = {
        { "create_cone", reinterpret_cast<PyCFunction>(AudioNodeEmitterShape_CreateCone), METH_VARARGS | METH_STATIC, nullptr },
        { "create_omnidirectional", reinterpret_cast<PyCFunction>(AudioNodeEmitterShape_CreateOmnidirectional), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_AudioNodeEmitterShape, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioNodeEmitterShape), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioNodeEmitterShape[] = {
        { "cone_properties", reinterpret_cast<getter>(AudioNodeEmitterShape_get_ConeProperties), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(AudioNodeEmitterShape_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioNodeEmitterShape[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioNodeEmitterShape) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioNodeEmitterShape) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioNodeEmitterShape) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioNodeEmitterShape) },
        { },
    };

    static PyType_Spec type_spec_AudioNodeEmitterShape =
    {
        "_winsdk_Windows_Media_Audio.AudioNodeEmitterShape",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeEmitterShape),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeEmitterShape
    };

    // ----- AudioNodeListener class --------------------
    static constexpr const char* const type_name_AudioNodeListener = "AudioNodeListener";

    static PyObject* _new_AudioNodeListener(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Audio::AudioNodeListener instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioNodeListener(py::wrapper::Windows::Media::Audio::AudioNodeListener* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioNodeListener_get_SpeedOfSound(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeListener", L"SpeedOfSound"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SpeedOfSound());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeListener_put_SpeedOfSound(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeListener", L"SpeedOfSound"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.SpeedOfSound(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeListener_get_Position(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeListener", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeListener_put_Position(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeListener", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeListener_get_Orientation(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeListener", L"Orientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeListener_put_Orientation(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeListener", L"Orientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(arg);

            self->obj.Orientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeListener_get_DopplerVelocity(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeListener", L"DopplerVelocity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DopplerVelocity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeListener_put_DopplerVelocity(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeListener", L"DopplerVelocity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.DopplerVelocity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AudioNodeListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioNodeListener>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioNodeListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeListener[] = {
        { "_assign_array_", _assign_array_AudioNodeListener, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioNodeListener), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioNodeListener[] = {
        { "speed_of_sound", reinterpret_cast<getter>(AudioNodeListener_get_SpeedOfSound), reinterpret_cast<setter>(AudioNodeListener_put_SpeedOfSound), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(AudioNodeListener_get_Position), reinterpret_cast<setter>(AudioNodeListener_put_Position), nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(AudioNodeListener_get_Orientation), reinterpret_cast<setter>(AudioNodeListener_put_Orientation), nullptr, nullptr },
        { "doppler_velocity", reinterpret_cast<getter>(AudioNodeListener_get_DopplerVelocity), reinterpret_cast<setter>(AudioNodeListener_put_DopplerVelocity), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioNodeListener[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioNodeListener) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioNodeListener) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioNodeListener) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioNodeListener) },
        { },
    };

    static PyType_Spec type_spec_AudioNodeListener =
    {
        "_winsdk_Windows_Media_Audio.AudioNodeListener",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeListener),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeListener
    };

    // ----- AudioPlaybackConnection class --------------------
    static constexpr const char* const type_name_AudioPlaybackConnection = "AudioPlaybackConnection";

    static PyObject* _new_AudioPlaybackConnection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioPlaybackConnection);
        return nullptr;
    }

    static void _dealloc_AudioPlaybackConnection(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioPlaybackConnection_Close(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::Audio::AudioPlaybackConnection::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_Open(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"Open", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Open());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_OpenAsync(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"OpenAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.OpenAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_Start(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_StartAsync(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"StartAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_TryCreateFromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"TryCreateFromId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Audio::AudioPlaybackConnection::TryCreateFromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_get_DeviceId(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_get_State(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_add_StateChanged(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioPlaybackConnection, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_remove_StateChanged(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioPlaybackConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioPlaybackConnection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioPlaybackConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioPlaybackConnection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioPlaybackConnection(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_AudioPlaybackConnection(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioPlaybackConnection[] = {
        { "close", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_Close), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "open", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_Open), METH_VARARGS, nullptr },
        { "open_async", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_OpenAsync), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_Start), METH_VARARGS, nullptr },
        { "start_async", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_StartAsync), METH_VARARGS, nullptr },
        { "try_create_from_id", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_TryCreateFromId), METH_VARARGS | METH_STATIC, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_remove_StateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AudioPlaybackConnection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioPlaybackConnection), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioPlaybackConnection), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioPlaybackConnection), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioPlaybackConnection[] = {
        { "device_id", reinterpret_cast<getter>(AudioPlaybackConnection_get_DeviceId), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(AudioPlaybackConnection_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioPlaybackConnection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioPlaybackConnection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioPlaybackConnection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioPlaybackConnection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioPlaybackConnection) },
        { },
    };

    static PyType_Spec type_spec_AudioPlaybackConnection =
    {
        "_winsdk_Windows_Media_Audio.AudioPlaybackConnection",
        sizeof(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioPlaybackConnection
    };

    // ----- AudioPlaybackConnectionOpenResult class --------------------
    static constexpr const char* const type_name_AudioPlaybackConnectionOpenResult = "AudioPlaybackConnectionOpenResult";

    static PyObject* _new_AudioPlaybackConnectionOpenResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioPlaybackConnectionOpenResult);
        return nullptr;
    }

    static void _dealloc_AudioPlaybackConnectionOpenResult(py::wrapper::Windows::Media::Audio::AudioPlaybackConnectionOpenResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioPlaybackConnectionOpenResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::AudioPlaybackConnectionOpenResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioPlaybackConnectionOpenResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnectionOpenResult_get_Status(py::wrapper::Windows::Media::Audio::AudioPlaybackConnectionOpenResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioPlaybackConnectionOpenResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioPlaybackConnectionOpenResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioPlaybackConnectionOpenResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioPlaybackConnectionOpenResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioPlaybackConnectionOpenResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioPlaybackConnectionOpenResult[] = {
        { "_assign_array_", _assign_array_AudioPlaybackConnectionOpenResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioPlaybackConnectionOpenResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioPlaybackConnectionOpenResult[] = {
        { "extended_error", reinterpret_cast<getter>(AudioPlaybackConnectionOpenResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(AudioPlaybackConnectionOpenResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioPlaybackConnectionOpenResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioPlaybackConnectionOpenResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioPlaybackConnectionOpenResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioPlaybackConnectionOpenResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioPlaybackConnectionOpenResult) },
        { },
    };

    static PyType_Spec type_spec_AudioPlaybackConnectionOpenResult =
    {
        "_winsdk_Windows_Media_Audio.AudioPlaybackConnectionOpenResult",
        sizeof(py::wrapper::Windows::Media::Audio::AudioPlaybackConnectionOpenResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioPlaybackConnectionOpenResult
    };

    // ----- AudioStateMonitor class --------------------
    static constexpr const char* const type_name_AudioStateMonitor = "AudioStateMonitor";

    static PyObject* _new_AudioStateMonitor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioStateMonitor);
        return nullptr;
    }

    static void _dealloc_AudioStateMonitor(py::wrapper::Windows::Media::Audio::AudioStateMonitor* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioStateMonitor_CreateForCaptureMonitoring(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioStateMonitor", L"CreateForCaptureMonitoring", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForCaptureMonitoring());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioStateMonitor", L"CreateForCaptureMonitoring", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);

                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForCaptureMonitoring(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioStateMonitor", L"CreateForCaptureMonitoring", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Devices::AudioDeviceRole>(args, 1);

                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForCaptureMonitoring(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_CreateForCaptureMonitoringWithCategoryAndDeviceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioStateMonitor", L"CreateForCaptureMonitoringWithCategoryAndDeviceId", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForCaptureMonitoringWithCategoryAndDeviceId(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_CreateForRenderMonitoring(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioStateMonitor", L"CreateForRenderMonitoring", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForRenderMonitoring());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioStateMonitor", L"CreateForRenderMonitoring", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(args, 0);

                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForRenderMonitoring(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioStateMonitor", L"CreateForRenderMonitoring", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Devices::AudioDeviceRole>(args, 1);

                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForRenderMonitoring(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_CreateForRenderMonitoringWithCategoryAndDeviceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioStateMonitor", L"CreateForRenderMonitoringWithCategoryAndDeviceId", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForRenderMonitoringWithCategoryAndDeviceId(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_get_SoundLevel(py::wrapper::Windows::Media::Audio::AudioStateMonitor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioStateMonitor", L"SoundLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SoundLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_add_SoundLevelChanged(py::wrapper::Windows::Media::Audio::AudioStateMonitor* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioStateMonitor", L"SoundLevelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioStateMonitor, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SoundLevelChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_remove_SoundLevelChanged(py::wrapper::Windows::Media::Audio::AudioStateMonitor* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioStateMonitor", L"SoundLevelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SoundLevelChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioStateMonitor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioStateMonitor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioStateMonitor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioStateMonitor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioStateMonitor[] = {
        { "create_for_capture_monitoring", reinterpret_cast<PyCFunction>(AudioStateMonitor_CreateForCaptureMonitoring), METH_VARARGS | METH_STATIC, nullptr },
        { "create_for_capture_monitoring_with_category_and_device_id", reinterpret_cast<PyCFunction>(AudioStateMonitor_CreateForCaptureMonitoringWithCategoryAndDeviceId), METH_VARARGS | METH_STATIC, nullptr },
        { "create_for_render_monitoring", reinterpret_cast<PyCFunction>(AudioStateMonitor_CreateForRenderMonitoring), METH_VARARGS | METH_STATIC, nullptr },
        { "create_for_render_monitoring_with_category_and_device_id", reinterpret_cast<PyCFunction>(AudioStateMonitor_CreateForRenderMonitoringWithCategoryAndDeviceId), METH_VARARGS | METH_STATIC, nullptr },
        { "add_sound_level_changed", reinterpret_cast<PyCFunction>(AudioStateMonitor_add_SoundLevelChanged), METH_O, nullptr },
        { "remove_sound_level_changed", reinterpret_cast<PyCFunction>(AudioStateMonitor_remove_SoundLevelChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AudioStateMonitor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioStateMonitor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioStateMonitor[] = {
        { "sound_level", reinterpret_cast<getter>(AudioStateMonitor_get_SoundLevel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioStateMonitor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioStateMonitor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioStateMonitor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioStateMonitor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioStateMonitor) },
        { },
    };

    static PyType_Spec type_spec_AudioStateMonitor =
    {
        "_winsdk_Windows_Media_Audio.AudioStateMonitor",
        sizeof(py::wrapper::Windows::Media::Audio::AudioStateMonitor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioStateMonitor
    };

    // ----- AudioSubmixNode class --------------------
    static constexpr const char* const type_name_AudioSubmixNode = "AudioSubmixNode";

    static PyObject* _new_AudioSubmixNode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioSubmixNode);
        return nullptr;
    }

    static void _dealloc_AudioSubmixNode(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioSubmixNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioSubmixNode", L"AddOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioSubmixNode", L"AddOutgoingConnection", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_Close(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioSubmixNode", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioSubmixNode", L"DisableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioSubmixNode", L"EnableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioSubmixNode", L"RemoveOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_Reset(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioSubmixNode", L"Reset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_Start(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioSubmixNode", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_Stop(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioSubmixNode", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioSubmixNode", L"OutgoingConnections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_get_Emitter(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioSubmixNode", L"Emitter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Emitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioSubmixNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioSubmixNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioSubmixNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioSubmixNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioSubmixNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioSubmixNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioSubmixNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioSubmixNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioSubmixNode", L"EffectDefinitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioSubmixNode", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioSubmixNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioSubmixNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioSubmixNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioSubmixNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioSubmixNode(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_AudioSubmixNode(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioSubmixNode[] = {
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(AudioSubmixNode_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(AudioSubmixNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioSubmixNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioSubmixNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(AudioSubmixNode_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioSubmixNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioSubmixNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioSubmixNode_Stop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AudioSubmixNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioSubmixNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioSubmixNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioSubmixNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioSubmixNode[] = {
        { "outgoing_connections", reinterpret_cast<getter>(AudioSubmixNode_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { "emitter", reinterpret_cast<getter>(AudioSubmixNode_get_Emitter), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(AudioSubmixNode_get_OutgoingGain), reinterpret_cast<setter>(AudioSubmixNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioSubmixNode_get_ConsumeInput), reinterpret_cast<setter>(AudioSubmixNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioSubmixNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioSubmixNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioSubmixNode[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioSubmixNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioSubmixNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioSubmixNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioSubmixNode) },
        { },
    };

    static PyType_Spec type_spec_AudioSubmixNode =
    {
        "_winsdk_Windows_Media_Audio.AudioSubmixNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioSubmixNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioSubmixNode
    };

    // ----- CreateAudioDeviceInputNodeResult class --------------------
    static constexpr const char* const type_name_CreateAudioDeviceInputNodeResult = "CreateAudioDeviceInputNodeResult";

    static PyObject* _new_CreateAudioDeviceInputNodeResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CreateAudioDeviceInputNodeResult);
        return nullptr;
    }

    static void _dealloc_CreateAudioDeviceInputNodeResult(py::wrapper::Windows::Media::Audio::CreateAudioDeviceInputNodeResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CreateAudioDeviceInputNodeResult_get_DeviceInputNode(py::wrapper::Windows::Media::Audio::CreateAudioDeviceInputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioDeviceInputNodeResult", L"DeviceInputNode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceInputNode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioDeviceInputNodeResult_get_Status(py::wrapper::Windows::Media::Audio::CreateAudioDeviceInputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioDeviceInputNodeResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioDeviceInputNodeResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateAudioDeviceInputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioDeviceInputNodeResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CreateAudioDeviceInputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::CreateAudioDeviceInputNodeResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CreateAudioDeviceInputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateAudioDeviceInputNodeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateAudioDeviceInputNodeResult[] = {
        { "_assign_array_", _assign_array_CreateAudioDeviceInputNodeResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CreateAudioDeviceInputNodeResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CreateAudioDeviceInputNodeResult[] = {
        { "device_input_node", reinterpret_cast<getter>(CreateAudioDeviceInputNodeResult_get_DeviceInputNode), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CreateAudioDeviceInputNodeResult_get_Status), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(CreateAudioDeviceInputNodeResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CreateAudioDeviceInputNodeResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CreateAudioDeviceInputNodeResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CreateAudioDeviceInputNodeResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CreateAudioDeviceInputNodeResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CreateAudioDeviceInputNodeResult) },
        { },
    };

    static PyType_Spec type_spec_CreateAudioDeviceInputNodeResult =
    {
        "_winsdk_Windows_Media_Audio.CreateAudioDeviceInputNodeResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateAudioDeviceInputNodeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateAudioDeviceInputNodeResult
    };

    // ----- CreateAudioDeviceOutputNodeResult class --------------------
    static constexpr const char* const type_name_CreateAudioDeviceOutputNodeResult = "CreateAudioDeviceOutputNodeResult";

    static PyObject* _new_CreateAudioDeviceOutputNodeResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CreateAudioDeviceOutputNodeResult);
        return nullptr;
    }

    static void _dealloc_CreateAudioDeviceOutputNodeResult(py::wrapper::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CreateAudioDeviceOutputNodeResult_get_DeviceOutputNode(py::wrapper::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioDeviceOutputNodeResult", L"DeviceOutputNode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceOutputNode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioDeviceOutputNodeResult_get_Status(py::wrapper::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioDeviceOutputNodeResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioDeviceOutputNodeResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioDeviceOutputNodeResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CreateAudioDeviceOutputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CreateAudioDeviceOutputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateAudioDeviceOutputNodeResult[] = {
        { "_assign_array_", _assign_array_CreateAudioDeviceOutputNodeResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CreateAudioDeviceOutputNodeResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CreateAudioDeviceOutputNodeResult[] = {
        { "device_output_node", reinterpret_cast<getter>(CreateAudioDeviceOutputNodeResult_get_DeviceOutputNode), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CreateAudioDeviceOutputNodeResult_get_Status), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(CreateAudioDeviceOutputNodeResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CreateAudioDeviceOutputNodeResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CreateAudioDeviceOutputNodeResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CreateAudioDeviceOutputNodeResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CreateAudioDeviceOutputNodeResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CreateAudioDeviceOutputNodeResult) },
        { },
    };

    static PyType_Spec type_spec_CreateAudioDeviceOutputNodeResult =
    {
        "_winsdk_Windows_Media_Audio.CreateAudioDeviceOutputNodeResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateAudioDeviceOutputNodeResult
    };

    // ----- CreateAudioFileInputNodeResult class --------------------
    static constexpr const char* const type_name_CreateAudioFileInputNodeResult = "CreateAudioFileInputNodeResult";

    static PyObject* _new_CreateAudioFileInputNodeResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CreateAudioFileInputNodeResult);
        return nullptr;
    }

    static void _dealloc_CreateAudioFileInputNodeResult(py::wrapper::Windows::Media::Audio::CreateAudioFileInputNodeResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CreateAudioFileInputNodeResult_get_FileInputNode(py::wrapper::Windows::Media::Audio::CreateAudioFileInputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioFileInputNodeResult", L"FileInputNode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FileInputNode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioFileInputNodeResult_get_Status(py::wrapper::Windows::Media::Audio::CreateAudioFileInputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioFileInputNodeResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioFileInputNodeResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateAudioFileInputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioFileInputNodeResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CreateAudioFileInputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::CreateAudioFileInputNodeResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CreateAudioFileInputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateAudioFileInputNodeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateAudioFileInputNodeResult[] = {
        { "_assign_array_", _assign_array_CreateAudioFileInputNodeResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CreateAudioFileInputNodeResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CreateAudioFileInputNodeResult[] = {
        { "file_input_node", reinterpret_cast<getter>(CreateAudioFileInputNodeResult_get_FileInputNode), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CreateAudioFileInputNodeResult_get_Status), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(CreateAudioFileInputNodeResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CreateAudioFileInputNodeResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CreateAudioFileInputNodeResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CreateAudioFileInputNodeResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CreateAudioFileInputNodeResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CreateAudioFileInputNodeResult) },
        { },
    };

    static PyType_Spec type_spec_CreateAudioFileInputNodeResult =
    {
        "_winsdk_Windows_Media_Audio.CreateAudioFileInputNodeResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateAudioFileInputNodeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateAudioFileInputNodeResult
    };

    // ----- CreateAudioFileOutputNodeResult class --------------------
    static constexpr const char* const type_name_CreateAudioFileOutputNodeResult = "CreateAudioFileOutputNodeResult";

    static PyObject* _new_CreateAudioFileOutputNodeResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CreateAudioFileOutputNodeResult);
        return nullptr;
    }

    static void _dealloc_CreateAudioFileOutputNodeResult(py::wrapper::Windows::Media::Audio::CreateAudioFileOutputNodeResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CreateAudioFileOutputNodeResult_get_FileOutputNode(py::wrapper::Windows::Media::Audio::CreateAudioFileOutputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioFileOutputNodeResult", L"FileOutputNode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FileOutputNode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioFileOutputNodeResult_get_Status(py::wrapper::Windows::Media::Audio::CreateAudioFileOutputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioFileOutputNodeResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioFileOutputNodeResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateAudioFileOutputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioFileOutputNodeResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CreateAudioFileOutputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::CreateAudioFileOutputNodeResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CreateAudioFileOutputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateAudioFileOutputNodeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateAudioFileOutputNodeResult[] = {
        { "_assign_array_", _assign_array_CreateAudioFileOutputNodeResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CreateAudioFileOutputNodeResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CreateAudioFileOutputNodeResult[] = {
        { "file_output_node", reinterpret_cast<getter>(CreateAudioFileOutputNodeResult_get_FileOutputNode), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CreateAudioFileOutputNodeResult_get_Status), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(CreateAudioFileOutputNodeResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CreateAudioFileOutputNodeResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CreateAudioFileOutputNodeResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CreateAudioFileOutputNodeResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CreateAudioFileOutputNodeResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CreateAudioFileOutputNodeResult) },
        { },
    };

    static PyType_Spec type_spec_CreateAudioFileOutputNodeResult =
    {
        "_winsdk_Windows_Media_Audio.CreateAudioFileOutputNodeResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateAudioFileOutputNodeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateAudioFileOutputNodeResult
    };

    // ----- CreateAudioGraphResult class --------------------
    static constexpr const char* const type_name_CreateAudioGraphResult = "CreateAudioGraphResult";

    static PyObject* _new_CreateAudioGraphResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CreateAudioGraphResult);
        return nullptr;
    }

    static void _dealloc_CreateAudioGraphResult(py::wrapper::Windows::Media::Audio::CreateAudioGraphResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CreateAudioGraphResult_get_Graph(py::wrapper::Windows::Media::Audio::CreateAudioGraphResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioGraphResult", L"Graph"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Graph());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioGraphResult_get_Status(py::wrapper::Windows::Media::Audio::CreateAudioGraphResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioGraphResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioGraphResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateAudioGraphResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioGraphResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CreateAudioGraphResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::CreateAudioGraphResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CreateAudioGraphResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateAudioGraphResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateAudioGraphResult[] = {
        { "_assign_array_", _assign_array_CreateAudioGraphResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CreateAudioGraphResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CreateAudioGraphResult[] = {
        { "graph", reinterpret_cast<getter>(CreateAudioGraphResult_get_Graph), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CreateAudioGraphResult_get_Status), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(CreateAudioGraphResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CreateAudioGraphResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CreateAudioGraphResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CreateAudioGraphResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CreateAudioGraphResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CreateAudioGraphResult) },
        { },
    };

    static PyType_Spec type_spec_CreateAudioGraphResult =
    {
        "_winsdk_Windows_Media_Audio.CreateAudioGraphResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateAudioGraphResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateAudioGraphResult
    };

    // ----- CreateMediaSourceAudioInputNodeResult class --------------------
    static constexpr const char* const type_name_CreateMediaSourceAudioInputNodeResult = "CreateMediaSourceAudioInputNodeResult";

    static PyObject* _new_CreateMediaSourceAudioInputNodeResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CreateMediaSourceAudioInputNodeResult);
        return nullptr;
    }

    static void _dealloc_CreateMediaSourceAudioInputNodeResult(py::wrapper::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CreateMediaSourceAudioInputNodeResult_get_Node(py::wrapper::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateMediaSourceAudioInputNodeResult", L"Node"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Node());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateMediaSourceAudioInputNodeResult_get_Status(py::wrapper::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateMediaSourceAudioInputNodeResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateMediaSourceAudioInputNodeResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateMediaSourceAudioInputNodeResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CreateMediaSourceAudioInputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CreateMediaSourceAudioInputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateMediaSourceAudioInputNodeResult[] = {
        { "_assign_array_", _assign_array_CreateMediaSourceAudioInputNodeResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CreateMediaSourceAudioInputNodeResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CreateMediaSourceAudioInputNodeResult[] = {
        { "node", reinterpret_cast<getter>(CreateMediaSourceAudioInputNodeResult_get_Node), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CreateMediaSourceAudioInputNodeResult_get_Status), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(CreateMediaSourceAudioInputNodeResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CreateMediaSourceAudioInputNodeResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CreateMediaSourceAudioInputNodeResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CreateMediaSourceAudioInputNodeResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CreateMediaSourceAudioInputNodeResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CreateMediaSourceAudioInputNodeResult) },
        { },
    };

    static PyType_Spec type_spec_CreateMediaSourceAudioInputNodeResult =
    {
        "_winsdk_Windows_Media_Audio.CreateMediaSourceAudioInputNodeResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateMediaSourceAudioInputNodeResult
    };

    // ----- EchoEffectDefinition class --------------------
    static constexpr const char* const type_name_EchoEffectDefinition = "EchoEffectDefinition";

    static PyObject* _new_EchoEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                winrt::Windows::Media::Audio::EchoEffectDefinition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EchoEffectDefinition(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EchoEffectDefinition_get_WetDryMix(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EchoEffectDefinition", L"WetDryMix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WetDryMix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EchoEffectDefinition_put_WetDryMix(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EchoEffectDefinition", L"WetDryMix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.WetDryMix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EchoEffectDefinition_get_Feedback(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EchoEffectDefinition", L"Feedback"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Feedback());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EchoEffectDefinition_put_Feedback(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EchoEffectDefinition", L"Feedback"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Feedback(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EchoEffectDefinition_get_Delay(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EchoEffectDefinition", L"Delay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Delay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EchoEffectDefinition_put_Delay(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EchoEffectDefinition", L"Delay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Delay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EchoEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EchoEffectDefinition", L"ActivatableClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EchoEffectDefinition_get_Properties(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EchoEffectDefinition", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EchoEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::EchoEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EchoEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::EchoEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EchoEffectDefinition[] = {
        { "_assign_array_", _assign_array_EchoEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EchoEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EchoEffectDefinition[] = {
        { "wet_dry_mix", reinterpret_cast<getter>(EchoEffectDefinition_get_WetDryMix), reinterpret_cast<setter>(EchoEffectDefinition_put_WetDryMix), nullptr, nullptr },
        { "feedback", reinterpret_cast<getter>(EchoEffectDefinition_get_Feedback), reinterpret_cast<setter>(EchoEffectDefinition_put_Feedback), nullptr, nullptr },
        { "delay", reinterpret_cast<getter>(EchoEffectDefinition_get_Delay), reinterpret_cast<setter>(EchoEffectDefinition_put_Delay), nullptr, nullptr },
        { "activatable_class_id", reinterpret_cast<getter>(EchoEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(EchoEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EchoEffectDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EchoEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EchoEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EchoEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EchoEffectDefinition) },
        { },
    };

    static PyType_Spec type_spec_EchoEffectDefinition =
    {
        "_winsdk_Windows_Media_Audio.EchoEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Audio::EchoEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EchoEffectDefinition
    };

    // ----- EqualizerBand class --------------------
    static constexpr const char* const type_name_EqualizerBand = "EqualizerBand";

    static PyObject* _new_EqualizerBand(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EqualizerBand);
        return nullptr;
    }

    static void _dealloc_EqualizerBand(py::wrapper::Windows::Media::Audio::EqualizerBand* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EqualizerBand_get_Gain(py::wrapper::Windows::Media::Audio::EqualizerBand* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EqualizerBand", L"Gain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Gain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EqualizerBand_put_Gain(py::wrapper::Windows::Media::Audio::EqualizerBand* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EqualizerBand", L"Gain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Gain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EqualizerBand_get_FrequencyCenter(py::wrapper::Windows::Media::Audio::EqualizerBand* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EqualizerBand", L"FrequencyCenter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrequencyCenter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EqualizerBand_put_FrequencyCenter(py::wrapper::Windows::Media::Audio::EqualizerBand* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EqualizerBand", L"FrequencyCenter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.FrequencyCenter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EqualizerBand_get_Bandwidth(py::wrapper::Windows::Media::Audio::EqualizerBand* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EqualizerBand", L"Bandwidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Bandwidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EqualizerBand_put_Bandwidth(py::wrapper::Windows::Media::Audio::EqualizerBand* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EqualizerBand", L"Bandwidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Bandwidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_EqualizerBand(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::EqualizerBand>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EqualizerBand(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::EqualizerBand>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EqualizerBand[] = {
        { "_assign_array_", _assign_array_EqualizerBand, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EqualizerBand), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EqualizerBand[] = {
        { "gain", reinterpret_cast<getter>(EqualizerBand_get_Gain), reinterpret_cast<setter>(EqualizerBand_put_Gain), nullptr, nullptr },
        { "frequency_center", reinterpret_cast<getter>(EqualizerBand_get_FrequencyCenter), reinterpret_cast<setter>(EqualizerBand_put_FrequencyCenter), nullptr, nullptr },
        { "bandwidth", reinterpret_cast<getter>(EqualizerBand_get_Bandwidth), reinterpret_cast<setter>(EqualizerBand_put_Bandwidth), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EqualizerBand[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EqualizerBand) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EqualizerBand) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EqualizerBand) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EqualizerBand) },
        { },
    };

    static PyType_Spec type_spec_EqualizerBand =
    {
        "_winsdk_Windows_Media_Audio.EqualizerBand",
        sizeof(py::wrapper::Windows::Media::Audio::EqualizerBand),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EqualizerBand
    };

    // ----- EqualizerEffectDefinition class --------------------
    static constexpr const char* const type_name_EqualizerEffectDefinition = "EqualizerEffectDefinition";

    static PyObject* _new_EqualizerEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                winrt::Windows::Media::Audio::EqualizerEffectDefinition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EqualizerEffectDefinition(py::wrapper::Windows::Media::Audio::EqualizerEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EqualizerEffectDefinition_get_Bands(py::wrapper::Windows::Media::Audio::EqualizerEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EqualizerEffectDefinition", L"Bands"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Bands());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EqualizerEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Audio::EqualizerEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EqualizerEffectDefinition", L"ActivatableClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EqualizerEffectDefinition_get_Properties(py::wrapper::Windows::Media::Audio::EqualizerEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EqualizerEffectDefinition", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EqualizerEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::EqualizerEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EqualizerEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::EqualizerEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EqualizerEffectDefinition[] = {
        { "_assign_array_", _assign_array_EqualizerEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EqualizerEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EqualizerEffectDefinition[] = {
        { "bands", reinterpret_cast<getter>(EqualizerEffectDefinition_get_Bands), nullptr, nullptr, nullptr },
        { "activatable_class_id", reinterpret_cast<getter>(EqualizerEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(EqualizerEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EqualizerEffectDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EqualizerEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EqualizerEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EqualizerEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EqualizerEffectDefinition) },
        { },
    };

    static PyType_Spec type_spec_EqualizerEffectDefinition =
    {
        "_winsdk_Windows_Media_Audio.EqualizerEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Audio::EqualizerEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EqualizerEffectDefinition
    };

    // ----- FrameInputNodeQuantumStartedEventArgs class --------------------
    static constexpr const char* const type_name_FrameInputNodeQuantumStartedEventArgs = "FrameInputNodeQuantumStartedEventArgs";

    static PyObject* _new_FrameInputNodeQuantumStartedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FrameInputNodeQuantumStartedEventArgs);
        return nullptr;
    }

    static void _dealloc_FrameInputNodeQuantumStartedEventArgs(py::wrapper::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameInputNodeQuantumStartedEventArgs_get_RequiredSamples(py::wrapper::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.FrameInputNodeQuantumStartedEventArgs", L"RequiredSamples"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequiredSamples());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FrameInputNodeQuantumStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameInputNodeQuantumStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameInputNodeQuantumStartedEventArgs[] = {
        { "_assign_array_", _assign_array_FrameInputNodeQuantumStartedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameInputNodeQuantumStartedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameInputNodeQuantumStartedEventArgs[] = {
        { "required_samples", reinterpret_cast<getter>(FrameInputNodeQuantumStartedEventArgs_get_RequiredSamples), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameInputNodeQuantumStartedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameInputNodeQuantumStartedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameInputNodeQuantumStartedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameInputNodeQuantumStartedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameInputNodeQuantumStartedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_FrameInputNodeQuantumStartedEventArgs =
    {
        "_winsdk_Windows_Media_Audio.FrameInputNodeQuantumStartedEventArgs",
        sizeof(py::wrapper::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameInputNodeQuantumStartedEventArgs
    };

    // ----- LimiterEffectDefinition class --------------------
    static constexpr const char* const type_name_LimiterEffectDefinition = "LimiterEffectDefinition";

    static PyObject* _new_LimiterEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                winrt::Windows::Media::Audio::LimiterEffectDefinition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LimiterEffectDefinition(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LimiterEffectDefinition_get_Release(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.LimiterEffectDefinition", L"Release"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LimiterEffectDefinition_put_Release(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.LimiterEffectDefinition", L"Release"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Release(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LimiterEffectDefinition_get_Loudness(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.LimiterEffectDefinition", L"Loudness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Loudness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LimiterEffectDefinition_put_Loudness(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.LimiterEffectDefinition", L"Loudness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Loudness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LimiterEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.LimiterEffectDefinition", L"ActivatableClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LimiterEffectDefinition_get_Properties(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.LimiterEffectDefinition", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LimiterEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::LimiterEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LimiterEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::LimiterEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LimiterEffectDefinition[] = {
        { "_assign_array_", _assign_array_LimiterEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LimiterEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LimiterEffectDefinition[] = {
        { "release", reinterpret_cast<getter>(LimiterEffectDefinition_get_Release), reinterpret_cast<setter>(LimiterEffectDefinition_put_Release), nullptr, nullptr },
        { "loudness", reinterpret_cast<getter>(LimiterEffectDefinition_get_Loudness), reinterpret_cast<setter>(LimiterEffectDefinition_put_Loudness), nullptr, nullptr },
        { "activatable_class_id", reinterpret_cast<getter>(LimiterEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(LimiterEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LimiterEffectDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LimiterEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LimiterEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LimiterEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LimiterEffectDefinition) },
        { },
    };

    static PyType_Spec type_spec_LimiterEffectDefinition =
    {
        "_winsdk_Windows_Media_Audio.LimiterEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LimiterEffectDefinition
    };

    // ----- MediaSourceAudioInputNode class --------------------
    static constexpr const char* const type_name_MediaSourceAudioInputNode = "MediaSourceAudioInputNode";

    static PyObject* _new_MediaSourceAudioInputNode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaSourceAudioInputNode);
        return nullptr;
    }

    static void _dealloc_MediaSourceAudioInputNode(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaSourceAudioInputNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"AddOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"AddOutgoingConnection", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_Close(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"DisableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"EnableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"RemoveOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_Reset(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"Reset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_Seek(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"Seek", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_Start(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_Stop(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"OutgoingConnections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_Emitter(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"Emitter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Emitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"EffectDefinitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_StartTime(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_StartTime(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"PlaybackSpeedFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackSpeedFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"PlaybackSpeedFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.PlaybackSpeedFactor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_LoopCount(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"LoopCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LoopCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_LoopCount(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"LoopCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.LoopCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_EndTime(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"EndTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_EndTime(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"EndTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.EndTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_Duration(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_MediaSource(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"MediaSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MediaSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_Position(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_add_MediaSourceCompleted(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"MediaSourceCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::MediaSourceAudioInputNode, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.MediaSourceCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_remove_MediaSourceCompleted(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"MediaSourceCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MediaSourceCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaSourceAudioInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::MediaSourceAudioInputNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaSourceAudioInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::MediaSourceAudioInputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaSourceAudioInputNode(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_MediaSourceAudioInputNode(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSourceAudioInputNode[] = {
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_Reset), METH_VARARGS, nullptr },
        { "seek", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_Seek), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_Stop), METH_VARARGS, nullptr },
        { "add_media_source_completed", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_add_MediaSourceCompleted), METH_O, nullptr },
        { "remove_media_source_completed", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_remove_MediaSourceCompleted), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaSourceAudioInputNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaSourceAudioInputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MediaSourceAudioInputNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MediaSourceAudioInputNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaSourceAudioInputNode[] = {
        { "outgoing_connections", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { "emitter", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_Emitter), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_OutgoingGain), reinterpret_cast<setter>(MediaSourceAudioInputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_ConsumeInput), reinterpret_cast<setter>(MediaSourceAudioInputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_StartTime), reinterpret_cast<setter>(MediaSourceAudioInputNode_put_StartTime), nullptr, nullptr },
        { "playback_speed_factor", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_PlaybackSpeedFactor), reinterpret_cast<setter>(MediaSourceAudioInputNode_put_PlaybackSpeedFactor), nullptr, nullptr },
        { "loop_count", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_LoopCount), reinterpret_cast<setter>(MediaSourceAudioInputNode_put_LoopCount), nullptr, nullptr },
        { "end_time", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_EndTime), reinterpret_cast<setter>(MediaSourceAudioInputNode_put_EndTime), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_Duration), nullptr, nullptr, nullptr },
        { "media_source", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_MediaSource), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaSourceAudioInputNode[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaSourceAudioInputNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaSourceAudioInputNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaSourceAudioInputNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaSourceAudioInputNode) },
        { },
    };

    static PyType_Spec type_spec_MediaSourceAudioInputNode =
    {
        "_winsdk_Windows_Media_Audio.MediaSourceAudioInputNode",
        sizeof(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSourceAudioInputNode
    };

    // ----- ReverbEffectDefinition class --------------------
    static constexpr const char* const type_name_ReverbEffectDefinition = "ReverbEffectDefinition";

    static PyObject* _new_ReverbEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                winrt::Windows::Media::Audio::ReverbEffectDefinition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ReverbEffectDefinition(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ReverbEffectDefinition_get_HighEQGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"HighEQGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HighEQGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_HighEQGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"HighEQGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.HighEQGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_HighEQCutoff(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"HighEQCutoff"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HighEQCutoff());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_HighEQCutoff(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"HighEQCutoff"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.HighEQCutoff(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_DisableLateField(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"DisableLateField"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisableLateField());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_DisableLateField(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"DisableLateField"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DisableLateField(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_Density(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"Density"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Density());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_Density(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"Density"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Density(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_PositionRight(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"PositionRight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PositionRight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_PositionRight(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"PositionRight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.PositionRight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_DecayTime(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"DecayTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DecayTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_DecayTime(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"DecayTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DecayTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_LateDiffusion(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"LateDiffusion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LateDiffusion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_LateDiffusion(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"LateDiffusion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.LateDiffusion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_PositionMatrixRight(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"PositionMatrixRight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PositionMatrixRight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_PositionMatrixRight(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"PositionMatrixRight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.PositionMatrixRight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_PositionMatrixLeft(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"PositionMatrixLeft"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PositionMatrixLeft());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_PositionMatrixLeft(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"PositionMatrixLeft"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.PositionMatrixLeft(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_PositionLeft(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"PositionLeft"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PositionLeft());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_PositionLeft(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"PositionLeft"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.PositionLeft(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_LowEQGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"LowEQGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LowEQGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_LowEQGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"LowEQGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.LowEQGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_LowEQCutoff(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"LowEQCutoff"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LowEQCutoff());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_LowEQCutoff(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"LowEQCutoff"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.LowEQCutoff(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_RoomFilterFreq(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RoomFilterFreq"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RoomFilterFreq());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_RoomFilterFreq(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RoomFilterFreq"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RoomFilterFreq(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_ReverbGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"ReverbGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReverbGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_ReverbGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"ReverbGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ReverbGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_ReverbDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"ReverbDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReverbDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_ReverbDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"ReverbDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.ReverbDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_ReflectionsGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"ReflectionsGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReflectionsGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_ReflectionsGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"ReflectionsGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ReflectionsGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_ReflectionsDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"ReflectionsDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReflectionsDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_ReflectionsDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"ReflectionsDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReflectionsDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_RearDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RearDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RearDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_RearDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RearDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.RearDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_WetDryMix(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"WetDryMix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WetDryMix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_WetDryMix(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"WetDryMix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.WetDryMix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_EarlyDiffusion(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"EarlyDiffusion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EarlyDiffusion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_EarlyDiffusion(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"EarlyDiffusion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.EarlyDiffusion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_RoomSize(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RoomSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RoomSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_RoomSize(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RoomSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RoomSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_RoomFilterMain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RoomFilterMain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RoomFilterMain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_RoomFilterMain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RoomFilterMain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RoomFilterMain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_RoomFilterHF(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RoomFilterHF"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RoomFilterHF());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_RoomFilterHF(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RoomFilterHF"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RoomFilterHF(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"ActivatableClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReverbEffectDefinition_get_Properties(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ReverbEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::ReverbEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ReverbEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::ReverbEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ReverbEffectDefinition[] = {
        { "_assign_array_", _assign_array_ReverbEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ReverbEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ReverbEffectDefinition[] = {
        { "high_e_q_gain", reinterpret_cast<getter>(ReverbEffectDefinition_get_HighEQGain), reinterpret_cast<setter>(ReverbEffectDefinition_put_HighEQGain), nullptr, nullptr },
        { "high_e_q_cutoff", reinterpret_cast<getter>(ReverbEffectDefinition_get_HighEQCutoff), reinterpret_cast<setter>(ReverbEffectDefinition_put_HighEQCutoff), nullptr, nullptr },
        { "disable_late_field", reinterpret_cast<getter>(ReverbEffectDefinition_get_DisableLateField), reinterpret_cast<setter>(ReverbEffectDefinition_put_DisableLateField), nullptr, nullptr },
        { "density", reinterpret_cast<getter>(ReverbEffectDefinition_get_Density), reinterpret_cast<setter>(ReverbEffectDefinition_put_Density), nullptr, nullptr },
        { "position_right", reinterpret_cast<getter>(ReverbEffectDefinition_get_PositionRight), reinterpret_cast<setter>(ReverbEffectDefinition_put_PositionRight), nullptr, nullptr },
        { "decay_time", reinterpret_cast<getter>(ReverbEffectDefinition_get_DecayTime), reinterpret_cast<setter>(ReverbEffectDefinition_put_DecayTime), nullptr, nullptr },
        { "late_diffusion", reinterpret_cast<getter>(ReverbEffectDefinition_get_LateDiffusion), reinterpret_cast<setter>(ReverbEffectDefinition_put_LateDiffusion), nullptr, nullptr },
        { "position_matrix_right", reinterpret_cast<getter>(ReverbEffectDefinition_get_PositionMatrixRight), reinterpret_cast<setter>(ReverbEffectDefinition_put_PositionMatrixRight), nullptr, nullptr },
        { "position_matrix_left", reinterpret_cast<getter>(ReverbEffectDefinition_get_PositionMatrixLeft), reinterpret_cast<setter>(ReverbEffectDefinition_put_PositionMatrixLeft), nullptr, nullptr },
        { "position_left", reinterpret_cast<getter>(ReverbEffectDefinition_get_PositionLeft), reinterpret_cast<setter>(ReverbEffectDefinition_put_PositionLeft), nullptr, nullptr },
        { "low_e_q_gain", reinterpret_cast<getter>(ReverbEffectDefinition_get_LowEQGain), reinterpret_cast<setter>(ReverbEffectDefinition_put_LowEQGain), nullptr, nullptr },
        { "low_e_q_cutoff", reinterpret_cast<getter>(ReverbEffectDefinition_get_LowEQCutoff), reinterpret_cast<setter>(ReverbEffectDefinition_put_LowEQCutoff), nullptr, nullptr },
        { "room_filter_freq", reinterpret_cast<getter>(ReverbEffectDefinition_get_RoomFilterFreq), reinterpret_cast<setter>(ReverbEffectDefinition_put_RoomFilterFreq), nullptr, nullptr },
        { "reverb_gain", reinterpret_cast<getter>(ReverbEffectDefinition_get_ReverbGain), reinterpret_cast<setter>(ReverbEffectDefinition_put_ReverbGain), nullptr, nullptr },
        { "reverb_delay", reinterpret_cast<getter>(ReverbEffectDefinition_get_ReverbDelay), reinterpret_cast<setter>(ReverbEffectDefinition_put_ReverbDelay), nullptr, nullptr },
        { "reflections_gain", reinterpret_cast<getter>(ReverbEffectDefinition_get_ReflectionsGain), reinterpret_cast<setter>(ReverbEffectDefinition_put_ReflectionsGain), nullptr, nullptr },
        { "reflections_delay", reinterpret_cast<getter>(ReverbEffectDefinition_get_ReflectionsDelay), reinterpret_cast<setter>(ReverbEffectDefinition_put_ReflectionsDelay), nullptr, nullptr },
        { "rear_delay", reinterpret_cast<getter>(ReverbEffectDefinition_get_RearDelay), reinterpret_cast<setter>(ReverbEffectDefinition_put_RearDelay), nullptr, nullptr },
        { "wet_dry_mix", reinterpret_cast<getter>(ReverbEffectDefinition_get_WetDryMix), reinterpret_cast<setter>(ReverbEffectDefinition_put_WetDryMix), nullptr, nullptr },
        { "early_diffusion", reinterpret_cast<getter>(ReverbEffectDefinition_get_EarlyDiffusion), reinterpret_cast<setter>(ReverbEffectDefinition_put_EarlyDiffusion), nullptr, nullptr },
        { "room_size", reinterpret_cast<getter>(ReverbEffectDefinition_get_RoomSize), reinterpret_cast<setter>(ReverbEffectDefinition_put_RoomSize), nullptr, nullptr },
        { "room_filter_main", reinterpret_cast<getter>(ReverbEffectDefinition_get_RoomFilterMain), reinterpret_cast<setter>(ReverbEffectDefinition_put_RoomFilterMain), nullptr, nullptr },
        { "room_filter_h_f", reinterpret_cast<getter>(ReverbEffectDefinition_get_RoomFilterHF), reinterpret_cast<setter>(ReverbEffectDefinition_put_RoomFilterHF), nullptr, nullptr },
        { "activatable_class_id", reinterpret_cast<getter>(ReverbEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(ReverbEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ReverbEffectDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ReverbEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ReverbEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ReverbEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ReverbEffectDefinition) },
        { },
    };

    static PyType_Spec type_spec_ReverbEffectDefinition =
    {
        "_winsdk_Windows_Media_Audio.ReverbEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ReverbEffectDefinition
    };

    // ----- SetDefaultSpatialAudioFormatResult class --------------------
    static constexpr const char* const type_name_SetDefaultSpatialAudioFormatResult = "SetDefaultSpatialAudioFormatResult";

    static PyObject* _new_SetDefaultSpatialAudioFormatResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SetDefaultSpatialAudioFormatResult);
        return nullptr;
    }

    static void _dealloc_SetDefaultSpatialAudioFormatResult(py::wrapper::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SetDefaultSpatialAudioFormatResult_get_Status(py::wrapper::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SetDefaultSpatialAudioFormatResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SetDefaultSpatialAudioFormatResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SetDefaultSpatialAudioFormatResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SetDefaultSpatialAudioFormatResult[] = {
        { "_assign_array_", _assign_array_SetDefaultSpatialAudioFormatResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SetDefaultSpatialAudioFormatResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SetDefaultSpatialAudioFormatResult[] = {
        { "status", reinterpret_cast<getter>(SetDefaultSpatialAudioFormatResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SetDefaultSpatialAudioFormatResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SetDefaultSpatialAudioFormatResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SetDefaultSpatialAudioFormatResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SetDefaultSpatialAudioFormatResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SetDefaultSpatialAudioFormatResult) },
        { },
    };

    static PyType_Spec type_spec_SetDefaultSpatialAudioFormatResult =
    {
        "_winsdk_Windows_Media_Audio.SetDefaultSpatialAudioFormatResult",
        sizeof(py::wrapper::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SetDefaultSpatialAudioFormatResult
    };

    // ----- SpatialAudioDeviceConfiguration class --------------------
    static constexpr const char* const type_name_SpatialAudioDeviceConfiguration = "SpatialAudioDeviceConfiguration";

    static PyObject* _new_SpatialAudioDeviceConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialAudioDeviceConfiguration);
        return nullptr;
    }

    static void _dealloc_SpatialAudioDeviceConfiguration(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialAudioDeviceConfiguration_GetForDeviceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.SpatialAudioDeviceConfiguration", L"GetForDeviceId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration::GetForDeviceId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_IsSpatialAudioFormatSupported(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.SpatialAudioDeviceConfiguration", L"IsSpatialAudioFormatSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsSpatialAudioFormatSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_SetDefaultSpatialAudioFormatAsync(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.SpatialAudioDeviceConfiguration", L"SetDefaultSpatialAudioFormatAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.SetDefaultSpatialAudioFormatAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_get_ActiveSpatialAudioFormat(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioDeviceConfiguration", L"ActiveSpatialAudioFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActiveSpatialAudioFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_get_DefaultSpatialAudioFormat(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioDeviceConfiguration", L"DefaultSpatialAudioFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultSpatialAudioFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_get_DeviceId(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioDeviceConfiguration", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_get_IsSpatialAudioSupported(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioDeviceConfiguration", L"IsSpatialAudioSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSpatialAudioSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_add_ConfigurationChanged(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.SpatialAudioDeviceConfiguration", L"ConfigurationChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ConfigurationChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_remove_ConfigurationChanged(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.SpatialAudioDeviceConfiguration", L"ConfigurationChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ConfigurationChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialAudioDeviceConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialAudioDeviceConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialAudioDeviceConfiguration[] = {
        { "get_for_device_id", reinterpret_cast<PyCFunction>(SpatialAudioDeviceConfiguration_GetForDeviceId), METH_VARARGS | METH_STATIC, nullptr },
        { "is_spatial_audio_format_supported", reinterpret_cast<PyCFunction>(SpatialAudioDeviceConfiguration_IsSpatialAudioFormatSupported), METH_VARARGS, nullptr },
        { "set_default_spatial_audio_format_async", reinterpret_cast<PyCFunction>(SpatialAudioDeviceConfiguration_SetDefaultSpatialAudioFormatAsync), METH_VARARGS, nullptr },
        { "add_configuration_changed", reinterpret_cast<PyCFunction>(SpatialAudioDeviceConfiguration_add_ConfigurationChanged), METH_O, nullptr },
        { "remove_configuration_changed", reinterpret_cast<PyCFunction>(SpatialAudioDeviceConfiguration_remove_ConfigurationChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_SpatialAudioDeviceConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialAudioDeviceConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialAudioDeviceConfiguration[] = {
        { "active_spatial_audio_format", reinterpret_cast<getter>(SpatialAudioDeviceConfiguration_get_ActiveSpatialAudioFormat), nullptr, nullptr, nullptr },
        { "default_spatial_audio_format", reinterpret_cast<getter>(SpatialAudioDeviceConfiguration_get_DefaultSpatialAudioFormat), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(SpatialAudioDeviceConfiguration_get_DeviceId), nullptr, nullptr, nullptr },
        { "is_spatial_audio_supported", reinterpret_cast<getter>(SpatialAudioDeviceConfiguration_get_IsSpatialAudioSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialAudioDeviceConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialAudioDeviceConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialAudioDeviceConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialAudioDeviceConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialAudioDeviceConfiguration) },
        { },
    };

    static PyType_Spec type_spec_SpatialAudioDeviceConfiguration =
    {
        "_winsdk_Windows_Media_Audio.SpatialAudioDeviceConfiguration",
        sizeof(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialAudioDeviceConfiguration
    };

    // ----- SpatialAudioFormatConfiguration class --------------------
    static constexpr const char* const type_name_SpatialAudioFormatConfiguration = "SpatialAudioFormatConfiguration";

    static PyObject* _new_SpatialAudioFormatConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialAudioFormatConfiguration);
        return nullptr;
    }

    static void _dealloc_SpatialAudioFormatConfiguration(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialAudioFormatConfiguration_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.SpatialAudioFormatConfiguration", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatConfiguration::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatConfiguration_ReportConfigurationChangedAsync(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.SpatialAudioFormatConfiguration", L"ReportConfigurationChangedAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ReportConfigurationChangedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatConfiguration_ReportLicenseChangedAsync(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.SpatialAudioFormatConfiguration", L"ReportLicenseChangedAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ReportLicenseChangedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatConfiguration_get_MixedRealityExclusiveModePolicy(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioFormatConfiguration", L"MixedRealityExclusiveModePolicy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MixedRealityExclusiveModePolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpatialAudioFormatConfiguration_put_MixedRealityExclusiveModePolicy(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioFormatConfiguration", L"MixedRealityExclusiveModePolicy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Audio::MixedRealitySpatialAudioFormatPolicy>(arg);

            self->obj.MixedRealityExclusiveModePolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SpatialAudioFormatConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::SpatialAudioFormatConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialAudioFormatConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::SpatialAudioFormatConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialAudioFormatConfiguration[] = {
        { "get_default", reinterpret_cast<PyCFunction>(SpatialAudioFormatConfiguration_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "report_configuration_changed_async", reinterpret_cast<PyCFunction>(SpatialAudioFormatConfiguration_ReportConfigurationChangedAsync), METH_VARARGS, nullptr },
        { "report_license_changed_async", reinterpret_cast<PyCFunction>(SpatialAudioFormatConfiguration_ReportLicenseChangedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialAudioFormatConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialAudioFormatConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialAudioFormatConfiguration[] = {
        { "mixed_reality_exclusive_mode_policy", reinterpret_cast<getter>(SpatialAudioFormatConfiguration_get_MixedRealityExclusiveModePolicy), reinterpret_cast<setter>(SpatialAudioFormatConfiguration_put_MixedRealityExclusiveModePolicy), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialAudioFormatConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialAudioFormatConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialAudioFormatConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialAudioFormatConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialAudioFormatConfiguration) },
        { },
    };

    static PyType_Spec type_spec_SpatialAudioFormatConfiguration =
    {
        "_winsdk_Windows_Media_Audio.SpatialAudioFormatConfiguration",
        sizeof(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialAudioFormatConfiguration
    };

    // ----- SpatialAudioFormatSubtype class --------------------
    static constexpr const char* const type_name_SpatialAudioFormatSubtype = "SpatialAudioFormatSubtype";

    static PyObject* _new_SpatialAudioFormatSubtype(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialAudioFormatSubtype);
        return nullptr;
    }

    static PyObject* SpatialAudioFormatSubtype_get_DTSHeadphoneX(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioFormatSubtype", L"DTSHeadphoneX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DTSHeadphoneX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_DTSXUltra(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioFormatSubtype", L"DTSXUltra"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DTSXUltra());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_DolbyAtmosForHeadphones(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioFormatSubtype", L"DolbyAtmosForHeadphones"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DolbyAtmosForHeadphones());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_DolbyAtmosForHomeTheater(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioFormatSubtype", L"DolbyAtmosForHomeTheater"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DolbyAtmosForHomeTheater());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_DolbyAtmosForSpeakers(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioFormatSubtype", L"DolbyAtmosForSpeakers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DolbyAtmosForSpeakers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_WindowsSonic(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioFormatSubtype", L"WindowsSonic"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::WindowsSonic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_DTSXForHomeTheater(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioFormatSubtype", L"DTSXForHomeTheater"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DTSXForHomeTheater());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialAudioFormatSubtype[] = {
        { }
    };

    static PyGetSetDef _getset_SpatialAudioFormatSubtype[] = {
        { }
    };

    static PyType_Slot _type_slots_SpatialAudioFormatSubtype[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialAudioFormatSubtype) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialAudioFormatSubtype) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialAudioFormatSubtype) },
        { },
    };

    static PyType_Spec type_spec_SpatialAudioFormatSubtype =
    {
        "_winsdk_Windows_Media_Audio.SpatialAudioFormatSubtype",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialAudioFormatSubtype
    };

    static PyGetSetDef getset_SpatialAudioFormatSubtype_Meta[] = {
        { "d_t_s_headphone_x", reinterpret_cast<getter>(SpatialAudioFormatSubtype_get_DTSHeadphoneX), nullptr, nullptr, nullptr },
        { "d_t_s_x_ultra", reinterpret_cast<getter>(SpatialAudioFormatSubtype_get_DTSXUltra), nullptr, nullptr, nullptr },
        { "dolby_atmos_for_headphones", reinterpret_cast<getter>(SpatialAudioFormatSubtype_get_DolbyAtmosForHeadphones), nullptr, nullptr, nullptr },
        { "dolby_atmos_for_home_theater", reinterpret_cast<getter>(SpatialAudioFormatSubtype_get_DolbyAtmosForHomeTheater), nullptr, nullptr, nullptr },
        { "dolby_atmos_for_speakers", reinterpret_cast<getter>(SpatialAudioFormatSubtype_get_DolbyAtmosForSpeakers), nullptr, nullptr, nullptr },
        { "windows_sonic", reinterpret_cast<getter>(SpatialAudioFormatSubtype_get_WindowsSonic), nullptr, nullptr, nullptr },
        { "d_t_s_x_for_home_theater", reinterpret_cast<getter>(SpatialAudioFormatSubtype_get_DTSXForHomeTheater), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_SpatialAudioFormatSubtype_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SpatialAudioFormatSubtype_Meta) },
        { }
    };

    static PyType_Spec type_spec_SpatialAudioFormatSubtype_Meta =
    {
        "_winsdk_Windows_Media_Audio.SpatialAudioFormatSubtype_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SpatialAudioFormatSubtype_Meta
    };

    // ----- IAudioInputNode interface --------------------
    static constexpr const char* const type_name_IAudioInputNode = "IAudioInputNode";

    static PyObject* _new_IAudioInputNode(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IAudioInputNode);
        return nullptr;
    }

    static void _dealloc_IAudioInputNode(py::wrapper::Windows::Media::Audio::IAudioInputNode* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAudioInputNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioInputNode", L"AddOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioInputNode", L"AddOutgoingConnection", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_Close(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"DisableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"EnableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioInputNode", L"RemoveOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_Reset(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Reset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_Start(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_Stop(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioInputNode", L"OutgoingConnections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioInputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioInputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"EffectDefinitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioInputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IAudioInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::IAudioInputNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAudioInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::IAudioInputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IAudioInputNode(py::wrapper::Windows::Media::Audio::IAudioInputNode* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_IAudioInputNode(py::wrapper::Windows::Media::Audio::IAudioInputNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAudioInputNode[] = {
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(IAudioInputNode_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IAudioInputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioInputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioInputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(IAudioInputNode_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(IAudioInputNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(IAudioInputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(IAudioInputNode_Stop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IAudioInputNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAudioInputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IAudioInputNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IAudioInputNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAudioInputNode[] = {
        { "outgoing_connections", reinterpret_cast<getter>(IAudioInputNode_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(IAudioInputNode_get_ConsumeInput), reinterpret_cast<setter>(IAudioInputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(IAudioInputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(IAudioInputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(IAudioInputNode_get_OutgoingGain), reinterpret_cast<setter>(IAudioInputNode_put_OutgoingGain), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAudioInputNode[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAudioInputNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAudioInputNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAudioInputNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAudioInputNode) },
        { },
    };

    static PyType_Spec type_spec_IAudioInputNode =
    {
        "_winsdk_Windows_Media_Audio.IAudioInputNode",
        sizeof(py::wrapper::Windows::Media::Audio::IAudioInputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAudioInputNode
    };

    // ----- IAudioInputNode2 interface --------------------
    static constexpr const char* const type_name_IAudioInputNode2 = "IAudioInputNode2";

    static PyObject* _new_IAudioInputNode2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IAudioInputNode2);
        return nullptr;
    }

    static void _dealloc_IAudioInputNode2(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAudioInputNode2_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioInputNode", L"AddOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioInputNode", L"AddOutgoingConnection", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_Close(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"DisableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"EnableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioInputNode", L"RemoveOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_Reset(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Reset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_Start(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_Stop(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_get_Emitter(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioInputNode2", L"Emitter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Emitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_get_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioInputNode2_put_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioInputNode2_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"EffectDefinitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_get_EncodingProperties(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_get_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioInputNode2_put_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioInputNode2_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioInputNode", L"OutgoingConnections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IAudioInputNode2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::IAudioInputNode2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAudioInputNode2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::IAudioInputNode2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IAudioInputNode2(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_IAudioInputNode2(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAudioInputNode2[] = {
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(IAudioInputNode2_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IAudioInputNode2_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioInputNode2_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioInputNode2_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(IAudioInputNode2_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(IAudioInputNode2_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(IAudioInputNode2_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(IAudioInputNode2_Stop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IAudioInputNode2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAudioInputNode2), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IAudioInputNode2), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IAudioInputNode2), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAudioInputNode2[] = {
        { "emitter", reinterpret_cast<getter>(IAudioInputNode2_get_Emitter), nullptr, nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(IAudioInputNode2_get_ConsumeInput), reinterpret_cast<setter>(IAudioInputNode2_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(IAudioInputNode2_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(IAudioInputNode2_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(IAudioInputNode2_get_OutgoingGain), reinterpret_cast<setter>(IAudioInputNode2_put_OutgoingGain), nullptr, nullptr },
        { "outgoing_connections", reinterpret_cast<getter>(IAudioInputNode2_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAudioInputNode2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAudioInputNode2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAudioInputNode2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAudioInputNode2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAudioInputNode2) },
        { },
    };

    static PyType_Spec type_spec_IAudioInputNode2 =
    {
        "_winsdk_Windows_Media_Audio.IAudioInputNode2",
        sizeof(py::wrapper::Windows::Media::Audio::IAudioInputNode2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAudioInputNode2
    };

    // ----- IAudioNode interface --------------------
    static constexpr const char* const type_name_IAudioNode = "IAudioNode";

    static PyObject* _new_IAudioNode(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IAudioNode);
        return nullptr;
    }

    static void _dealloc_IAudioNode(py::wrapper::Windows::Media::Audio::IAudioNode* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAudioNode_Close(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"DisableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"EnableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_Reset(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Reset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_Start(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_Stop(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::IAudioNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"EffectDefinitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::IAudioNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IAudioNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::IAudioNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAudioNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::IAudioNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IAudioNode(py::wrapper::Windows::Media::Audio::IAudioNode* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_IAudioNode(py::wrapper::Windows::Media::Audio::IAudioNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAudioNode[] = {
        { "close", reinterpret_cast<PyCFunction>(IAudioNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(IAudioNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(IAudioNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(IAudioNode_Stop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IAudioNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAudioNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IAudioNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IAudioNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAudioNode[] = {
        { "consume_input", reinterpret_cast<getter>(IAudioNode_get_ConsumeInput), reinterpret_cast<setter>(IAudioNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(IAudioNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(IAudioNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(IAudioNode_get_OutgoingGain), reinterpret_cast<setter>(IAudioNode_put_OutgoingGain), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAudioNode[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAudioNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAudioNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAudioNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAudioNode) },
        { },
    };

    static PyType_Spec type_spec_IAudioNode =
    {
        "_winsdk_Windows_Media_Audio.IAudioNode",
        sizeof(py::wrapper::Windows::Media::Audio::IAudioNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAudioNode
    };

    // ----- IAudioNodeWithListener interface --------------------
    static constexpr const char* const type_name_IAudioNodeWithListener = "IAudioNodeWithListener";

    static PyObject* _new_IAudioNodeWithListener(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IAudioNodeWithListener);
        return nullptr;
    }

    static void _dealloc_IAudioNodeWithListener(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAudioNodeWithListener_Close(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"DisableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"EnableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_Reset(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Reset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_Start(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_Stop(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_get_Listener(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNodeWithListener", L"Listener"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Listener());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioNodeWithListener_put_Listener(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNodeWithListener", L"Listener"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeListener>(arg);

            self->obj.Listener(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioNodeWithListener_get_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioNodeWithListener_put_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioNodeWithListener_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"EffectDefinitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_get_EncodingProperties(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_get_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioNodeWithListener_put_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IAudioNodeWithListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::IAudioNodeWithListener>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAudioNodeWithListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::IAudioNodeWithListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IAudioNodeWithListener(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_IAudioNodeWithListener(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAudioNodeWithListener[] = {
        { "close", reinterpret_cast<PyCFunction>(IAudioNodeWithListener_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioNodeWithListener_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioNodeWithListener_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(IAudioNodeWithListener_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(IAudioNodeWithListener_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(IAudioNodeWithListener_Stop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IAudioNodeWithListener, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAudioNodeWithListener), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IAudioNodeWithListener), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IAudioNodeWithListener), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAudioNodeWithListener[] = {
        { "listener", reinterpret_cast<getter>(IAudioNodeWithListener_get_Listener), reinterpret_cast<setter>(IAudioNodeWithListener_put_Listener), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(IAudioNodeWithListener_get_ConsumeInput), reinterpret_cast<setter>(IAudioNodeWithListener_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(IAudioNodeWithListener_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(IAudioNodeWithListener_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(IAudioNodeWithListener_get_OutgoingGain), reinterpret_cast<setter>(IAudioNodeWithListener_put_OutgoingGain), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAudioNodeWithListener[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAudioNodeWithListener) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAudioNodeWithListener) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAudioNodeWithListener) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAudioNodeWithListener) },
        { },
    };

    static PyType_Spec type_spec_IAudioNodeWithListener =
    {
        "_winsdk_Windows_Media_Audio.IAudioNodeWithListener",
        sizeof(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAudioNodeWithListener
    };

    // ----- Windows.Media.Audio Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Media::Audio");

    static PyMethodDef module_methods[] = {
        {"_register_AudioDeviceNodeCreationStatus", register_AudioDeviceNodeCreationStatus, METH_O, "registers type"},
        {"_register_AudioFileNodeCreationStatus", register_AudioFileNodeCreationStatus, METH_O, "registers type"},
        {"_register_AudioGraphCreationStatus", register_AudioGraphCreationStatus, METH_O, "registers type"},
        {"_register_AudioGraphUnrecoverableError", register_AudioGraphUnrecoverableError, METH_O, "registers type"},
        {"_register_AudioNodeEmitterDecayKind", register_AudioNodeEmitterDecayKind, METH_O, "registers type"},
        {"_register_AudioNodeEmitterSettings", register_AudioNodeEmitterSettings, METH_O, "registers type"},
        {"_register_AudioNodeEmitterShapeKind", register_AudioNodeEmitterShapeKind, METH_O, "registers type"},
        {"_register_AudioPlaybackConnectionOpenResultStatus", register_AudioPlaybackConnectionOpenResultStatus, METH_O, "registers type"},
        {"_register_AudioPlaybackConnectionState", register_AudioPlaybackConnectionState, METH_O, "registers type"},
        {"_register_MediaSourceAudioInputNodeCreationStatus", register_MediaSourceAudioInputNodeCreationStatus, METH_O, "registers type"},
        {"_register_MixedRealitySpatialAudioFormatPolicy", register_MixedRealitySpatialAudioFormatPolicy, METH_O, "registers type"},
        {"_register_QuantumSizeSelectionMode", register_QuantumSizeSelectionMode, METH_O, "registers type"},
        {"_register_SetDefaultSpatialAudioFormatStatus", register_SetDefaultSpatialAudioFormatStatus, METH_O, "registers type"},
        {"_register_SpatialAudioModel", register_SpatialAudioModel, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_AudioDeviceNodeCreationStatus);
        Py_VISIT(state->type_AudioFileNodeCreationStatus);
        Py_VISIT(state->type_AudioGraphCreationStatus);
        Py_VISIT(state->type_AudioGraphUnrecoverableError);
        Py_VISIT(state->type_AudioNodeEmitterDecayKind);
        Py_VISIT(state->type_AudioNodeEmitterSettings);
        Py_VISIT(state->type_AudioNodeEmitterShapeKind);
        Py_VISIT(state->type_AudioPlaybackConnectionOpenResultStatus);
        Py_VISIT(state->type_AudioPlaybackConnectionState);
        Py_VISIT(state->type_MediaSourceAudioInputNodeCreationStatus);
        Py_VISIT(state->type_MixedRealitySpatialAudioFormatPolicy);
        Py_VISIT(state->type_QuantumSizeSelectionMode);
        Py_VISIT(state->type_SetDefaultSpatialAudioFormatStatus);
        Py_VISIT(state->type_SpatialAudioModel);
        Py_VISIT(state->type_AudioDeviceInputNode);
        Py_VISIT(state->type_AudioDeviceOutputNode);
        Py_VISIT(state->type_AudioFileInputNode);
        Py_VISIT(state->type_AudioFileOutputNode);
        Py_VISIT(state->type_AudioFrameCompletedEventArgs);
        Py_VISIT(state->type_AudioFrameInputNode);
        Py_VISIT(state->type_AudioFrameOutputNode);
        Py_VISIT(state->type_AudioGraph);
        Py_VISIT(state->type_AudioGraphBatchUpdater);
        Py_VISIT(state->type_AudioGraphConnection);
        Py_VISIT(state->type_AudioGraphSettings);
        Py_VISIT(state->type_AudioGraphUnrecoverableErrorOccurredEventArgs);
        Py_VISIT(state->type_AudioNodeEmitter);
        Py_VISIT(state->type_AudioNodeEmitterConeProperties);
        Py_VISIT(state->type_AudioNodeEmitterDecayModel);
        Py_VISIT(state->type_AudioNodeEmitterNaturalDecayModelProperties);
        Py_VISIT(state->type_AudioNodeEmitterShape);
        Py_VISIT(state->type_AudioNodeListener);
        Py_VISIT(state->type_AudioPlaybackConnection);
        Py_VISIT(state->type_AudioPlaybackConnectionOpenResult);
        Py_VISIT(state->type_AudioStateMonitor);
        Py_VISIT(state->type_AudioSubmixNode);
        Py_VISIT(state->type_CreateAudioDeviceInputNodeResult);
        Py_VISIT(state->type_CreateAudioDeviceOutputNodeResult);
        Py_VISIT(state->type_CreateAudioFileInputNodeResult);
        Py_VISIT(state->type_CreateAudioFileOutputNodeResult);
        Py_VISIT(state->type_CreateAudioGraphResult);
        Py_VISIT(state->type_CreateMediaSourceAudioInputNodeResult);
        Py_VISIT(state->type_EchoEffectDefinition);
        Py_VISIT(state->type_EqualizerBand);
        Py_VISIT(state->type_EqualizerEffectDefinition);
        Py_VISIT(state->type_FrameInputNodeQuantumStartedEventArgs);
        Py_VISIT(state->type_LimiterEffectDefinition);
        Py_VISIT(state->type_MediaSourceAudioInputNode);
        Py_VISIT(state->type_ReverbEffectDefinition);
        Py_VISIT(state->type_SetDefaultSpatialAudioFormatResult);
        Py_VISIT(state->type_SpatialAudioDeviceConfiguration);
        Py_VISIT(state->type_SpatialAudioFormatConfiguration);
        Py_VISIT(state->type_SpatialAudioFormatSubtype);
        Py_VISIT(state->type_IAudioInputNode);
        Py_VISIT(state->type_IAudioInputNode2);
        Py_VISIT(state->type_IAudioNode);
        Py_VISIT(state->type_IAudioNodeWithListener);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_AudioDeviceNodeCreationStatus);
        Py_CLEAR(state->type_AudioFileNodeCreationStatus);
        Py_CLEAR(state->type_AudioGraphCreationStatus);
        Py_CLEAR(state->type_AudioGraphUnrecoverableError);
        Py_CLEAR(state->type_AudioNodeEmitterDecayKind);
        Py_CLEAR(state->type_AudioNodeEmitterSettings);
        Py_CLEAR(state->type_AudioNodeEmitterShapeKind);
        Py_CLEAR(state->type_AudioPlaybackConnectionOpenResultStatus);
        Py_CLEAR(state->type_AudioPlaybackConnectionState);
        Py_CLEAR(state->type_MediaSourceAudioInputNodeCreationStatus);
        Py_CLEAR(state->type_MixedRealitySpatialAudioFormatPolicy);
        Py_CLEAR(state->type_QuantumSizeSelectionMode);
        Py_CLEAR(state->type_SetDefaultSpatialAudioFormatStatus);
        Py_CLEAR(state->type_SpatialAudioModel);
        Py_CLEAR(state->type_AudioDeviceInputNode);
        Py_CLEAR(state->type_AudioDeviceOutputNode);
        Py_CLEAR(state->type_AudioFileInputNode);
        Py_CLEAR(state->type_AudioFileOutputNode);
        Py_CLEAR(state->type_AudioFrameCompletedEventArgs);
        Py_CLEAR(state->type_AudioFrameInputNode);
        Py_CLEAR(state->type_AudioFrameOutputNode);
        Py_CLEAR(state->type_AudioGraph);
        Py_CLEAR(state->type_AudioGraphBatchUpdater);
        Py_CLEAR(state->type_AudioGraphConnection);
        Py_CLEAR(state->type_AudioGraphSettings);
        Py_CLEAR(state->type_AudioGraphUnrecoverableErrorOccurredEventArgs);
        Py_CLEAR(state->type_AudioNodeEmitter);
        Py_CLEAR(state->type_AudioNodeEmitterConeProperties);
        Py_CLEAR(state->type_AudioNodeEmitterDecayModel);
        Py_CLEAR(state->type_AudioNodeEmitterNaturalDecayModelProperties);
        Py_CLEAR(state->type_AudioNodeEmitterShape);
        Py_CLEAR(state->type_AudioNodeListener);
        Py_CLEAR(state->type_AudioPlaybackConnection);
        Py_CLEAR(state->type_AudioPlaybackConnectionOpenResult);
        Py_CLEAR(state->type_AudioStateMonitor);
        Py_CLEAR(state->type_AudioSubmixNode);
        Py_CLEAR(state->type_CreateAudioDeviceInputNodeResult);
        Py_CLEAR(state->type_CreateAudioDeviceOutputNodeResult);
        Py_CLEAR(state->type_CreateAudioFileInputNodeResult);
        Py_CLEAR(state->type_CreateAudioFileOutputNodeResult);
        Py_CLEAR(state->type_CreateAudioGraphResult);
        Py_CLEAR(state->type_CreateMediaSourceAudioInputNodeResult);
        Py_CLEAR(state->type_EchoEffectDefinition);
        Py_CLEAR(state->type_EqualizerBand);
        Py_CLEAR(state->type_EqualizerEffectDefinition);
        Py_CLEAR(state->type_FrameInputNodeQuantumStartedEventArgs);
        Py_CLEAR(state->type_LimiterEffectDefinition);
        Py_CLEAR(state->type_MediaSourceAudioInputNode);
        Py_CLEAR(state->type_ReverbEffectDefinition);
        Py_CLEAR(state->type_SetDefaultSpatialAudioFormatResult);
        Py_CLEAR(state->type_SpatialAudioDeviceConfiguration);
        Py_CLEAR(state->type_SpatialAudioFormatConfiguration);
        Py_CLEAR(state->type_SpatialAudioFormatSubtype);
        Py_CLEAR(state->type_IAudioInputNode);
        Py_CLEAR(state->type_IAudioInputNode2);
        Py_CLEAR(state->type_IAudioNode);
        Py_CLEAR(state->type_IAudioNodeWithListener);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Media_Audio",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Media::Audio

PyMODINIT_FUNC PyInit__winsdk_Windows_Media_Audio(void) noexcept
{
    using namespace py::cpp::Windows::Media::Audio;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_AudioDeviceInputNode = py::register_python_type(module.get(), type_name_AudioDeviceInputNode, &type_spec_AudioDeviceInputNode, bases.get(), nullptr);
    if (!state->type_AudioDeviceInputNode)
    {
        return nullptr;
    }

    state->type_AudioDeviceOutputNode = py::register_python_type(module.get(), type_name_AudioDeviceOutputNode, &type_spec_AudioDeviceOutputNode, bases.get(), nullptr);
    if (!state->type_AudioDeviceOutputNode)
    {
        return nullptr;
    }

    state->type_AudioFileInputNode = py::register_python_type(module.get(), type_name_AudioFileInputNode, &type_spec_AudioFileInputNode, bases.get(), nullptr);
    if (!state->type_AudioFileInputNode)
    {
        return nullptr;
    }

    state->type_AudioFileOutputNode = py::register_python_type(module.get(), type_name_AudioFileOutputNode, &type_spec_AudioFileOutputNode, bases.get(), nullptr);
    if (!state->type_AudioFileOutputNode)
    {
        return nullptr;
    }

    state->type_AudioFrameCompletedEventArgs = py::register_python_type(module.get(), type_name_AudioFrameCompletedEventArgs, &type_spec_AudioFrameCompletedEventArgs, bases.get(), nullptr);
    if (!state->type_AudioFrameCompletedEventArgs)
    {
        return nullptr;
    }

    state->type_AudioFrameInputNode = py::register_python_type(module.get(), type_name_AudioFrameInputNode, &type_spec_AudioFrameInputNode, bases.get(), nullptr);
    if (!state->type_AudioFrameInputNode)
    {
        return nullptr;
    }

    state->type_AudioFrameOutputNode = py::register_python_type(module.get(), type_name_AudioFrameOutputNode, &type_spec_AudioFrameOutputNode, bases.get(), nullptr);
    if (!state->type_AudioFrameOutputNode)
    {
        return nullptr;
    }

    state->type_AudioGraph = py::register_python_type(module.get(), type_name_AudioGraph, &type_spec_AudioGraph, bases.get(), nullptr);
    if (!state->type_AudioGraph)
    {
        return nullptr;
    }

    state->type_AudioGraphBatchUpdater = py::register_python_type(module.get(), type_name_AudioGraphBatchUpdater, &type_spec_AudioGraphBatchUpdater, bases.get(), nullptr);
    if (!state->type_AudioGraphBatchUpdater)
    {
        return nullptr;
    }

    state->type_AudioGraphConnection = py::register_python_type(module.get(), type_name_AudioGraphConnection, &type_spec_AudioGraphConnection, bases.get(), nullptr);
    if (!state->type_AudioGraphConnection)
    {
        return nullptr;
    }

    state->type_AudioGraphSettings = py::register_python_type(module.get(), type_name_AudioGraphSettings, &type_spec_AudioGraphSettings, bases.get(), nullptr);
    if (!state->type_AudioGraphSettings)
    {
        return nullptr;
    }

    state->type_AudioGraphUnrecoverableErrorOccurredEventArgs = py::register_python_type(module.get(), type_name_AudioGraphUnrecoverableErrorOccurredEventArgs, &type_spec_AudioGraphUnrecoverableErrorOccurredEventArgs, bases.get(), nullptr);
    if (!state->type_AudioGraphUnrecoverableErrorOccurredEventArgs)
    {
        return nullptr;
    }

    state->type_AudioNodeEmitter = py::register_python_type(module.get(), type_name_AudioNodeEmitter, &type_spec_AudioNodeEmitter, bases.get(), nullptr);
    if (!state->type_AudioNodeEmitter)
    {
        return nullptr;
    }

    state->type_AudioNodeEmitterConeProperties = py::register_python_type(module.get(), type_name_AudioNodeEmitterConeProperties, &type_spec_AudioNodeEmitterConeProperties, bases.get(), nullptr);
    if (!state->type_AudioNodeEmitterConeProperties)
    {
        return nullptr;
    }

    state->type_AudioNodeEmitterDecayModel = py::register_python_type(module.get(), type_name_AudioNodeEmitterDecayModel, &type_spec_AudioNodeEmitterDecayModel, bases.get(), nullptr);
    if (!state->type_AudioNodeEmitterDecayModel)
    {
        return nullptr;
    }

    state->type_AudioNodeEmitterNaturalDecayModelProperties = py::register_python_type(module.get(), type_name_AudioNodeEmitterNaturalDecayModelProperties, &type_spec_AudioNodeEmitterNaturalDecayModelProperties, bases.get(), nullptr);
    if (!state->type_AudioNodeEmitterNaturalDecayModelProperties)
    {
        return nullptr;
    }

    state->type_AudioNodeEmitterShape = py::register_python_type(module.get(), type_name_AudioNodeEmitterShape, &type_spec_AudioNodeEmitterShape, bases.get(), nullptr);
    if (!state->type_AudioNodeEmitterShape)
    {
        return nullptr;
    }

    state->type_AudioNodeListener = py::register_python_type(module.get(), type_name_AudioNodeListener, &type_spec_AudioNodeListener, bases.get(), nullptr);
    if (!state->type_AudioNodeListener)
    {
        return nullptr;
    }

    state->type_AudioPlaybackConnection = py::register_python_type(module.get(), type_name_AudioPlaybackConnection, &type_spec_AudioPlaybackConnection, bases.get(), nullptr);
    if (!state->type_AudioPlaybackConnection)
    {
        return nullptr;
    }

    state->type_AudioPlaybackConnectionOpenResult = py::register_python_type(module.get(), type_name_AudioPlaybackConnectionOpenResult, &type_spec_AudioPlaybackConnectionOpenResult, bases.get(), nullptr);
    if (!state->type_AudioPlaybackConnectionOpenResult)
    {
        return nullptr;
    }

    state->type_AudioStateMonitor = py::register_python_type(module.get(), type_name_AudioStateMonitor, &type_spec_AudioStateMonitor, bases.get(), nullptr);
    if (!state->type_AudioStateMonitor)
    {
        return nullptr;
    }

    state->type_AudioSubmixNode = py::register_python_type(module.get(), type_name_AudioSubmixNode, &type_spec_AudioSubmixNode, bases.get(), nullptr);
    if (!state->type_AudioSubmixNode)
    {
        return nullptr;
    }

    state->type_CreateAudioDeviceInputNodeResult = py::register_python_type(module.get(), type_name_CreateAudioDeviceInputNodeResult, &type_spec_CreateAudioDeviceInputNodeResult, bases.get(), nullptr);
    if (!state->type_CreateAudioDeviceInputNodeResult)
    {
        return nullptr;
    }

    state->type_CreateAudioDeviceOutputNodeResult = py::register_python_type(module.get(), type_name_CreateAudioDeviceOutputNodeResult, &type_spec_CreateAudioDeviceOutputNodeResult, bases.get(), nullptr);
    if (!state->type_CreateAudioDeviceOutputNodeResult)
    {
        return nullptr;
    }

    state->type_CreateAudioFileInputNodeResult = py::register_python_type(module.get(), type_name_CreateAudioFileInputNodeResult, &type_spec_CreateAudioFileInputNodeResult, bases.get(), nullptr);
    if (!state->type_CreateAudioFileInputNodeResult)
    {
        return nullptr;
    }

    state->type_CreateAudioFileOutputNodeResult = py::register_python_type(module.get(), type_name_CreateAudioFileOutputNodeResult, &type_spec_CreateAudioFileOutputNodeResult, bases.get(), nullptr);
    if (!state->type_CreateAudioFileOutputNodeResult)
    {
        return nullptr;
    }

    state->type_CreateAudioGraphResult = py::register_python_type(module.get(), type_name_CreateAudioGraphResult, &type_spec_CreateAudioGraphResult, bases.get(), nullptr);
    if (!state->type_CreateAudioGraphResult)
    {
        return nullptr;
    }

    state->type_CreateMediaSourceAudioInputNodeResult = py::register_python_type(module.get(), type_name_CreateMediaSourceAudioInputNodeResult, &type_spec_CreateMediaSourceAudioInputNodeResult, bases.get(), nullptr);
    if (!state->type_CreateMediaSourceAudioInputNodeResult)
    {
        return nullptr;
    }

    state->type_EchoEffectDefinition = py::register_python_type(module.get(), type_name_EchoEffectDefinition, &type_spec_EchoEffectDefinition, bases.get(), nullptr);
    if (!state->type_EchoEffectDefinition)
    {
        return nullptr;
    }

    state->type_EqualizerBand = py::register_python_type(module.get(), type_name_EqualizerBand, &type_spec_EqualizerBand, bases.get(), nullptr);
    if (!state->type_EqualizerBand)
    {
        return nullptr;
    }

    state->type_EqualizerEffectDefinition = py::register_python_type(module.get(), type_name_EqualizerEffectDefinition, &type_spec_EqualizerEffectDefinition, bases.get(), nullptr);
    if (!state->type_EqualizerEffectDefinition)
    {
        return nullptr;
    }

    state->type_FrameInputNodeQuantumStartedEventArgs = py::register_python_type(module.get(), type_name_FrameInputNodeQuantumStartedEventArgs, &type_spec_FrameInputNodeQuantumStartedEventArgs, bases.get(), nullptr);
    if (!state->type_FrameInputNodeQuantumStartedEventArgs)
    {
        return nullptr;
    }

    state->type_LimiterEffectDefinition = py::register_python_type(module.get(), type_name_LimiterEffectDefinition, &type_spec_LimiterEffectDefinition, bases.get(), nullptr);
    if (!state->type_LimiterEffectDefinition)
    {
        return nullptr;
    }

    state->type_MediaSourceAudioInputNode = py::register_python_type(module.get(), type_name_MediaSourceAudioInputNode, &type_spec_MediaSourceAudioInputNode, bases.get(), nullptr);
    if (!state->type_MediaSourceAudioInputNode)
    {
        return nullptr;
    }

    state->type_ReverbEffectDefinition = py::register_python_type(module.get(), type_name_ReverbEffectDefinition, &type_spec_ReverbEffectDefinition, bases.get(), nullptr);
    if (!state->type_ReverbEffectDefinition)
    {
        return nullptr;
    }

    state->type_SetDefaultSpatialAudioFormatResult = py::register_python_type(module.get(), type_name_SetDefaultSpatialAudioFormatResult, &type_spec_SetDefaultSpatialAudioFormatResult, bases.get(), nullptr);
    if (!state->type_SetDefaultSpatialAudioFormatResult)
    {
        return nullptr;
    }

    state->type_SpatialAudioDeviceConfiguration = py::register_python_type(module.get(), type_name_SpatialAudioDeviceConfiguration, &type_spec_SpatialAudioDeviceConfiguration, bases.get(), nullptr);
    if (!state->type_SpatialAudioDeviceConfiguration)
    {
        return nullptr;
    }

    state->type_SpatialAudioFormatConfiguration = py::register_python_type(module.get(), type_name_SpatialAudioFormatConfiguration, &type_spec_SpatialAudioFormatConfiguration, bases.get(), nullptr);
    if (!state->type_SpatialAudioFormatConfiguration)
    {
        return nullptr;
    }

    py::pyobj_handle type_SpatialAudioFormatSubtype_Meta{PyType_FromSpec(&type_spec_SpatialAudioFormatSubtype_Meta)};
    if (!type_SpatialAudioFormatSubtype_Meta)
    {
        return nullptr;
    }

    state->type_SpatialAudioFormatSubtype = py::register_python_type(module.get(), type_name_SpatialAudioFormatSubtype, &type_spec_SpatialAudioFormatSubtype, nullptr, reinterpret_cast<PyTypeObject*>(type_SpatialAudioFormatSubtype_Meta.get()));
    if (!state->type_SpatialAudioFormatSubtype)
    {
        return nullptr;
    }

    state->type_IAudioInputNode = py::register_python_type(module.get(), type_name_IAudioInputNode, &type_spec_IAudioInputNode, bases.get(), nullptr);
    if (!state->type_IAudioInputNode)
    {
        return nullptr;
    }

    state->type_IAudioInputNode2 = py::register_python_type(module.get(), type_name_IAudioInputNode2, &type_spec_IAudioInputNode2, bases.get(), nullptr);
    if (!state->type_IAudioInputNode2)
    {
        return nullptr;
    }

    state->type_IAudioNode = py::register_python_type(module.get(), type_name_IAudioNode, &type_spec_IAudioNode, bases.get(), nullptr);
    if (!state->type_IAudioNode)
    {
        return nullptr;
    }

    state->type_IAudioNodeWithListener = py::register_python_type(module.get(), type_name_IAudioNodeWithListener, &type_spec_IAudioNodeWithListener, bases.get(), nullptr);
    if (!state->type_IAudioNodeWithListener)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Media::Audio::AudioDeviceNodeCreationStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioDeviceNodeCreationStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioDeviceNodeCreationStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Audio::AudioFileNodeCreationStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioFileNodeCreationStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioFileNodeCreationStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Audio::AudioGraphCreationStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioGraphCreationStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioGraphCreationStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Audio::AudioGraphUnrecoverableError>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioGraphUnrecoverableError;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioGraphUnrecoverableError is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Audio::AudioNodeEmitterDecayKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioNodeEmitterDecayKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioNodeEmitterDecayKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Audio::AudioNodeEmitterSettings>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioNodeEmitterSettings;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioNodeEmitterSettings is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Audio::AudioNodeEmitterShapeKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioNodeEmitterShapeKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioNodeEmitterShapeKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Audio::AudioPlaybackConnectionOpenResultStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioPlaybackConnectionOpenResultStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioPlaybackConnectionOpenResultStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Audio::AudioPlaybackConnectionState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioPlaybackConnectionState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioPlaybackConnectionState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Audio::MediaSourceAudioInputNodeCreationStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaSourceAudioInputNodeCreationStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::MediaSourceAudioInputNodeCreationStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Audio::MixedRealitySpatialAudioFormatPolicy>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MixedRealitySpatialAudioFormatPolicy;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::MixedRealitySpatialAudioFormatPolicy is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Audio::QuantumSizeSelectionMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_QuantumSizeSelectionMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::QuantumSizeSelectionMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Audio::SetDefaultSpatialAudioFormatStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SetDefaultSpatialAudioFormatStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::SetDefaultSpatialAudioFormatStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Audio::SpatialAudioModel>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialAudioModel;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::SpatialAudioModel is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioDeviceInputNode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioDeviceInputNode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioDeviceInputNode is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioDeviceOutputNode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioDeviceOutputNode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioDeviceOutputNode is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioFileInputNode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioFileInputNode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioFileInputNode is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioFileOutputNode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioFileOutputNode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioFileOutputNode is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioFrameCompletedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioFrameCompletedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioFrameCompletedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioFrameInputNode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioFrameInputNode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioFrameInputNode is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioFrameOutputNode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioFrameOutputNode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioFrameOutputNode is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioGraph>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioGraph;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioGraph is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioGraphBatchUpdater>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioGraphBatchUpdater;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioGraphBatchUpdater is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioGraphConnection>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioGraphConnection;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioGraphConnection is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioGraphSettings>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioGraphSettings;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioGraphSettings is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioGraphUnrecoverableErrorOccurredEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioNodeEmitter>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioNodeEmitter;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioNodeEmitter is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioNodeEmitterConeProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioNodeEmitterConeProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioNodeEmitterConeProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioNodeEmitterDecayModel;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioNodeEmitterNaturalDecayModelProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioNodeEmitterShape>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioNodeEmitterShape;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioNodeEmitterShape is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioNodeListener>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioNodeListener;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioNodeListener is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioPlaybackConnection>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioPlaybackConnection;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioPlaybackConnection is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioPlaybackConnectionOpenResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioPlaybackConnectionOpenResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioPlaybackConnectionOpenResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioStateMonitor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioStateMonitor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioStateMonitor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioSubmixNode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioSubmixNode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::AudioSubmixNode is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::CreateAudioDeviceInputNodeResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CreateAudioDeviceInputNodeResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::CreateAudioDeviceInputNodeResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CreateAudioDeviceOutputNodeResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::CreateAudioFileInputNodeResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CreateAudioFileInputNodeResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::CreateAudioFileInputNodeResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::CreateAudioFileOutputNodeResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CreateAudioFileOutputNodeResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::CreateAudioFileOutputNodeResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::CreateAudioGraphResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CreateAudioGraphResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::CreateAudioGraphResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CreateMediaSourceAudioInputNodeResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::EchoEffectDefinition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EchoEffectDefinition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::EchoEffectDefinition is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::EqualizerBand>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EqualizerBand;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::EqualizerBand is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::EqualizerEffectDefinition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EqualizerEffectDefinition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::EqualizerEffectDefinition is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FrameInputNodeQuantumStartedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::LimiterEffectDefinition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LimiterEffectDefinition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::LimiterEffectDefinition is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::MediaSourceAudioInputNode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaSourceAudioInputNode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::MediaSourceAudioInputNode is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::ReverbEffectDefinition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ReverbEffectDefinition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::ReverbEffectDefinition is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SetDefaultSpatialAudioFormatResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialAudioDeviceConfiguration;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::SpatialAudioFormatConfiguration>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialAudioFormatConfiguration;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::SpatialAudioFormatConfiguration is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::SpatialAudioFormatSubtype>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialAudioFormatSubtype;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::SpatialAudioFormatSubtype is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::IAudioInputNode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IAudioInputNode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::IAudioInputNode is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::IAudioInputNode2>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IAudioInputNode2;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::IAudioInputNode2 is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::IAudioNode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IAudioNode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::IAudioNode is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::IAudioNodeWithListener>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Audio;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Audio");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IAudioNodeWithListener;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Audio::IAudioNodeWithListener is not registered");
        return nullptr;
    }

    return python_type;
}
