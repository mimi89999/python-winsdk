// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.Graphics.Printing.OptionDetails.h"


namespace py::cpp::Windows::Graphics::Printing::OptionDetails
{
    struct module_state
    {
        PyObject* type_PrintOptionStates;
        PyObject* type_PrintOptionType;
        PyTypeObject* type_PrintBindingOptionDetails;
        PyTypeObject* type_PrintBorderingOptionDetails;
        PyTypeObject* type_PrintCollationOptionDetails;
        PyTypeObject* type_PrintColorModeOptionDetails;
        PyTypeObject* type_PrintCopiesOptionDetails;
        PyTypeObject* type_PrintCustomItemDetails;
        PyTypeObject* type_PrintCustomItemListOptionDetails;
        PyTypeObject* type_PrintCustomTextOptionDetails;
        PyTypeObject* type_PrintCustomToggleOptionDetails;
        PyTypeObject* type_PrintDuplexOptionDetails;
        PyTypeObject* type_PrintHolePunchOptionDetails;
        PyTypeObject* type_PrintMediaSizeOptionDetails;
        PyTypeObject* type_PrintMediaTypeOptionDetails;
        PyTypeObject* type_PrintOrientationOptionDetails;
        PyTypeObject* type_PrintPageRangeOptionDetails;
        PyTypeObject* type_PrintQualityOptionDetails;
        PyTypeObject* type_PrintStapleOptionDetails;
        PyTypeObject* type_PrintTaskOptionChangedEventArgs;
        PyTypeObject* type_PrintTaskOptionDetails;
        PyTypeObject* type_IPrintCustomOptionDetails;
        PyTypeObject* type_IPrintItemListOptionDetails;
        PyTypeObject* type_IPrintNumberOptionDetails;
        PyTypeObject* type_IPrintOptionDetails;
        PyTypeObject* type_IPrintTextOptionDetails;
    };

    static PyObject* register_PrintOptionStates(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PrintOptionStates)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PrintOptionStates = type;
        Py_INCREF(state->type_PrintOptionStates);


        Py_RETURN_NONE;
    }

    static PyObject* register_PrintOptionType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PrintOptionType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PrintOptionType = type;
        Py_INCREF(state->type_PrintOptionType);


        Py_RETURN_NONE;
    }

    // ----- PrintBindingOptionDetails class --------------------
    static constexpr const char* const type_name_PrintBindingOptionDetails = "PrintBindingOptionDetails";

    static PyObject* _new_PrintBindingOptionDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PrintBindingOptionDetails);
        return nullptr;
    }

    static void _dealloc_PrintBindingOptionDetails(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBindingOptionDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintBindingOptionDetails_TrySetValue(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBindingOptionDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.PrintBindingOptionDetails", L"TrySetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.TrySetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintBindingOptionDetails_get_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBindingOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintBindingOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WarningText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintBindingOptionDetails_put_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBindingOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintBindingOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.WarningText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintBindingOptionDetails_get_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBindingOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintBindingOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintBindingOptionDetails_put_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBindingOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintBindingOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintBindingOptionDetails_get_Items(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBindingOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintBindingOptionDetails", L"Items"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Items());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintBindingOptionDetails_get_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBindingOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintBindingOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintBindingOptionDetails_put_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBindingOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintBindingOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::OptionDetails::PrintOptionStates>(arg);

            self->obj.State(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintBindingOptionDetails_get_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBindingOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintBindingOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintBindingOptionDetails_put_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBindingOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintBindingOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ErrorText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintBindingOptionDetails_get_OptionId(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBindingOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintBindingOptionDetails", L"OptionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintBindingOptionDetails_get_OptionType(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBindingOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintBindingOptionDetails", L"OptionType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintBindingOptionDetails_get_Value(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBindingOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintBindingOptionDetails", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintBindingOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::OptionDetails::PrintBindingOptionDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintBindingOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::OptionDetails::PrintBindingOptionDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintBindingOptionDetails[] = {
        { "try_set_value", reinterpret_cast<PyCFunction>(PrintBindingOptionDetails_TrySetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintBindingOptionDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintBindingOptionDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintBindingOptionDetails[] = {
        { "warning_text", reinterpret_cast<getter>(PrintBindingOptionDetails_get_WarningText), reinterpret_cast<setter>(PrintBindingOptionDetails_put_WarningText), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(PrintBindingOptionDetails_get_Description), reinterpret_cast<setter>(PrintBindingOptionDetails_put_Description), nullptr, nullptr },
        { "items", reinterpret_cast<getter>(PrintBindingOptionDetails_get_Items), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(PrintBindingOptionDetails_get_State), reinterpret_cast<setter>(PrintBindingOptionDetails_put_State), nullptr, nullptr },
        { "error_text", reinterpret_cast<getter>(PrintBindingOptionDetails_get_ErrorText), reinterpret_cast<setter>(PrintBindingOptionDetails_put_ErrorText), nullptr, nullptr },
        { "option_id", reinterpret_cast<getter>(PrintBindingOptionDetails_get_OptionId), nullptr, nullptr, nullptr },
        { "option_type", reinterpret_cast<getter>(PrintBindingOptionDetails_get_OptionType), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(PrintBindingOptionDetails_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintBindingOptionDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintBindingOptionDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintBindingOptionDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintBindingOptionDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintBindingOptionDetails) },
        { },
    };

    static PyType_Spec type_spec_PrintBindingOptionDetails =
    {
        "_winsdk_Windows_Graphics_Printing_OptionDetails.PrintBindingOptionDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBindingOptionDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintBindingOptionDetails
    };

    // ----- PrintBorderingOptionDetails class --------------------
    static constexpr const char* const type_name_PrintBorderingOptionDetails = "PrintBorderingOptionDetails";

    static PyObject* _new_PrintBorderingOptionDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PrintBorderingOptionDetails);
        return nullptr;
    }

    static void _dealloc_PrintBorderingOptionDetails(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBorderingOptionDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintBorderingOptionDetails_TrySetValue(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBorderingOptionDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.PrintBorderingOptionDetails", L"TrySetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.TrySetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintBorderingOptionDetails_get_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBorderingOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintBorderingOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WarningText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintBorderingOptionDetails_put_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBorderingOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintBorderingOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.WarningText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintBorderingOptionDetails_get_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBorderingOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintBorderingOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintBorderingOptionDetails_put_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBorderingOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintBorderingOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintBorderingOptionDetails_get_Items(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBorderingOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintBorderingOptionDetails", L"Items"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Items());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintBorderingOptionDetails_get_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBorderingOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintBorderingOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintBorderingOptionDetails_put_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBorderingOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintBorderingOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::OptionDetails::PrintOptionStates>(arg);

            self->obj.State(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintBorderingOptionDetails_get_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBorderingOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintBorderingOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintBorderingOptionDetails_put_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBorderingOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintBorderingOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ErrorText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintBorderingOptionDetails_get_OptionId(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBorderingOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintBorderingOptionDetails", L"OptionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintBorderingOptionDetails_get_OptionType(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBorderingOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintBorderingOptionDetails", L"OptionType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintBorderingOptionDetails_get_Value(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBorderingOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintBorderingOptionDetails", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintBorderingOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::OptionDetails::PrintBorderingOptionDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintBorderingOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::OptionDetails::PrintBorderingOptionDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintBorderingOptionDetails[] = {
        { "try_set_value", reinterpret_cast<PyCFunction>(PrintBorderingOptionDetails_TrySetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintBorderingOptionDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintBorderingOptionDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintBorderingOptionDetails[] = {
        { "warning_text", reinterpret_cast<getter>(PrintBorderingOptionDetails_get_WarningText), reinterpret_cast<setter>(PrintBorderingOptionDetails_put_WarningText), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(PrintBorderingOptionDetails_get_Description), reinterpret_cast<setter>(PrintBorderingOptionDetails_put_Description), nullptr, nullptr },
        { "items", reinterpret_cast<getter>(PrintBorderingOptionDetails_get_Items), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(PrintBorderingOptionDetails_get_State), reinterpret_cast<setter>(PrintBorderingOptionDetails_put_State), nullptr, nullptr },
        { "error_text", reinterpret_cast<getter>(PrintBorderingOptionDetails_get_ErrorText), reinterpret_cast<setter>(PrintBorderingOptionDetails_put_ErrorText), nullptr, nullptr },
        { "option_id", reinterpret_cast<getter>(PrintBorderingOptionDetails_get_OptionId), nullptr, nullptr, nullptr },
        { "option_type", reinterpret_cast<getter>(PrintBorderingOptionDetails_get_OptionType), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(PrintBorderingOptionDetails_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintBorderingOptionDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintBorderingOptionDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintBorderingOptionDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintBorderingOptionDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintBorderingOptionDetails) },
        { },
    };

    static PyType_Spec type_spec_PrintBorderingOptionDetails =
    {
        "_winsdk_Windows_Graphics_Printing_OptionDetails.PrintBorderingOptionDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintBorderingOptionDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintBorderingOptionDetails
    };

    // ----- PrintCollationOptionDetails class --------------------
    static constexpr const char* const type_name_PrintCollationOptionDetails = "PrintCollationOptionDetails";

    static PyObject* _new_PrintCollationOptionDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PrintCollationOptionDetails);
        return nullptr;
    }

    static void _dealloc_PrintCollationOptionDetails(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCollationOptionDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintCollationOptionDetails_TrySetValue(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCollationOptionDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCollationOptionDetails", L"TrySetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.TrySetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintCollationOptionDetails_get_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCollationOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCollationOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WarningText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintCollationOptionDetails_put_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCollationOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCollationOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.WarningText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintCollationOptionDetails_get_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCollationOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCollationOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintCollationOptionDetails_put_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCollationOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCollationOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintCollationOptionDetails_get_Items(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCollationOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCollationOptionDetails", L"Items"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Items());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintCollationOptionDetails_get_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCollationOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCollationOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintCollationOptionDetails_put_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCollationOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCollationOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::OptionDetails::PrintOptionStates>(arg);

            self->obj.State(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintCollationOptionDetails_get_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCollationOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCollationOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintCollationOptionDetails_put_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCollationOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCollationOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ErrorText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintCollationOptionDetails_get_OptionId(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCollationOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCollationOptionDetails", L"OptionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintCollationOptionDetails_get_OptionType(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCollationOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCollationOptionDetails", L"OptionType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintCollationOptionDetails_get_Value(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCollationOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCollationOptionDetails", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintCollationOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::OptionDetails::PrintCollationOptionDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintCollationOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::OptionDetails::PrintCollationOptionDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintCollationOptionDetails[] = {
        { "try_set_value", reinterpret_cast<PyCFunction>(PrintCollationOptionDetails_TrySetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintCollationOptionDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintCollationOptionDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintCollationOptionDetails[] = {
        { "warning_text", reinterpret_cast<getter>(PrintCollationOptionDetails_get_WarningText), reinterpret_cast<setter>(PrintCollationOptionDetails_put_WarningText), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(PrintCollationOptionDetails_get_Description), reinterpret_cast<setter>(PrintCollationOptionDetails_put_Description), nullptr, nullptr },
        { "items", reinterpret_cast<getter>(PrintCollationOptionDetails_get_Items), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(PrintCollationOptionDetails_get_State), reinterpret_cast<setter>(PrintCollationOptionDetails_put_State), nullptr, nullptr },
        { "error_text", reinterpret_cast<getter>(PrintCollationOptionDetails_get_ErrorText), reinterpret_cast<setter>(PrintCollationOptionDetails_put_ErrorText), nullptr, nullptr },
        { "option_id", reinterpret_cast<getter>(PrintCollationOptionDetails_get_OptionId), nullptr, nullptr, nullptr },
        { "option_type", reinterpret_cast<getter>(PrintCollationOptionDetails_get_OptionType), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(PrintCollationOptionDetails_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintCollationOptionDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintCollationOptionDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintCollationOptionDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintCollationOptionDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintCollationOptionDetails) },
        { },
    };

    static PyType_Spec type_spec_PrintCollationOptionDetails =
    {
        "_winsdk_Windows_Graphics_Printing_OptionDetails.PrintCollationOptionDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCollationOptionDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintCollationOptionDetails
    };

    // ----- PrintColorModeOptionDetails class --------------------
    static constexpr const char* const type_name_PrintColorModeOptionDetails = "PrintColorModeOptionDetails";

    static PyObject* _new_PrintColorModeOptionDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PrintColorModeOptionDetails);
        return nullptr;
    }

    static void _dealloc_PrintColorModeOptionDetails(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintColorModeOptionDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintColorModeOptionDetails_TrySetValue(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintColorModeOptionDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.PrintColorModeOptionDetails", L"TrySetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.TrySetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintColorModeOptionDetails_get_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintColorModeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintColorModeOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WarningText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintColorModeOptionDetails_put_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintColorModeOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintColorModeOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.WarningText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintColorModeOptionDetails_get_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintColorModeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintColorModeOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintColorModeOptionDetails_put_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintColorModeOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintColorModeOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintColorModeOptionDetails_get_Items(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintColorModeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintColorModeOptionDetails", L"Items"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Items());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintColorModeOptionDetails_get_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintColorModeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintColorModeOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintColorModeOptionDetails_put_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintColorModeOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintColorModeOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::OptionDetails::PrintOptionStates>(arg);

            self->obj.State(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintColorModeOptionDetails_get_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintColorModeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintColorModeOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintColorModeOptionDetails_put_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintColorModeOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintColorModeOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ErrorText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintColorModeOptionDetails_get_OptionId(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintColorModeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintColorModeOptionDetails", L"OptionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintColorModeOptionDetails_get_OptionType(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintColorModeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintColorModeOptionDetails", L"OptionType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintColorModeOptionDetails_get_Value(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintColorModeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintColorModeOptionDetails", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintColorModeOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::OptionDetails::PrintColorModeOptionDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintColorModeOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::OptionDetails::PrintColorModeOptionDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintColorModeOptionDetails[] = {
        { "try_set_value", reinterpret_cast<PyCFunction>(PrintColorModeOptionDetails_TrySetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintColorModeOptionDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintColorModeOptionDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintColorModeOptionDetails[] = {
        { "warning_text", reinterpret_cast<getter>(PrintColorModeOptionDetails_get_WarningText), reinterpret_cast<setter>(PrintColorModeOptionDetails_put_WarningText), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(PrintColorModeOptionDetails_get_Description), reinterpret_cast<setter>(PrintColorModeOptionDetails_put_Description), nullptr, nullptr },
        { "items", reinterpret_cast<getter>(PrintColorModeOptionDetails_get_Items), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(PrintColorModeOptionDetails_get_State), reinterpret_cast<setter>(PrintColorModeOptionDetails_put_State), nullptr, nullptr },
        { "error_text", reinterpret_cast<getter>(PrintColorModeOptionDetails_get_ErrorText), reinterpret_cast<setter>(PrintColorModeOptionDetails_put_ErrorText), nullptr, nullptr },
        { "option_id", reinterpret_cast<getter>(PrintColorModeOptionDetails_get_OptionId), nullptr, nullptr, nullptr },
        { "option_type", reinterpret_cast<getter>(PrintColorModeOptionDetails_get_OptionType), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(PrintColorModeOptionDetails_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintColorModeOptionDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintColorModeOptionDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintColorModeOptionDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintColorModeOptionDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintColorModeOptionDetails) },
        { },
    };

    static PyType_Spec type_spec_PrintColorModeOptionDetails =
    {
        "_winsdk_Windows_Graphics_Printing_OptionDetails.PrintColorModeOptionDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintColorModeOptionDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintColorModeOptionDetails
    };

    // ----- PrintCopiesOptionDetails class --------------------
    static constexpr const char* const type_name_PrintCopiesOptionDetails = "PrintCopiesOptionDetails";

    static PyObject* _new_PrintCopiesOptionDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PrintCopiesOptionDetails);
        return nullptr;
    }

    static void _dealloc_PrintCopiesOptionDetails(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCopiesOptionDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintCopiesOptionDetails_TrySetValue(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCopiesOptionDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCopiesOptionDetails", L"TrySetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.TrySetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintCopiesOptionDetails_get_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCopiesOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCopiesOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WarningText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintCopiesOptionDetails_put_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCopiesOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCopiesOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.WarningText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintCopiesOptionDetails_get_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCopiesOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCopiesOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintCopiesOptionDetails_put_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCopiesOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCopiesOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintCopiesOptionDetails_get_MaxValue(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCopiesOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCopiesOptionDetails", L"MaxValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintCopiesOptionDetails_get_MinValue(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCopiesOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCopiesOptionDetails", L"MinValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintCopiesOptionDetails_get_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCopiesOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCopiesOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintCopiesOptionDetails_put_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCopiesOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCopiesOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::OptionDetails::PrintOptionStates>(arg);

            self->obj.State(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintCopiesOptionDetails_get_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCopiesOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCopiesOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintCopiesOptionDetails_put_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCopiesOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCopiesOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ErrorText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintCopiesOptionDetails_get_OptionId(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCopiesOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCopiesOptionDetails", L"OptionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintCopiesOptionDetails_get_OptionType(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCopiesOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCopiesOptionDetails", L"OptionType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintCopiesOptionDetails_get_Value(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCopiesOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCopiesOptionDetails", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintCopiesOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::OptionDetails::PrintCopiesOptionDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintCopiesOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::OptionDetails::PrintCopiesOptionDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintCopiesOptionDetails[] = {
        { "try_set_value", reinterpret_cast<PyCFunction>(PrintCopiesOptionDetails_TrySetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintCopiesOptionDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintCopiesOptionDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintCopiesOptionDetails[] = {
        { "warning_text", reinterpret_cast<getter>(PrintCopiesOptionDetails_get_WarningText), reinterpret_cast<setter>(PrintCopiesOptionDetails_put_WarningText), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(PrintCopiesOptionDetails_get_Description), reinterpret_cast<setter>(PrintCopiesOptionDetails_put_Description), nullptr, nullptr },
        { "max_value", reinterpret_cast<getter>(PrintCopiesOptionDetails_get_MaxValue), nullptr, nullptr, nullptr },
        { "min_value", reinterpret_cast<getter>(PrintCopiesOptionDetails_get_MinValue), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(PrintCopiesOptionDetails_get_State), reinterpret_cast<setter>(PrintCopiesOptionDetails_put_State), nullptr, nullptr },
        { "error_text", reinterpret_cast<getter>(PrintCopiesOptionDetails_get_ErrorText), reinterpret_cast<setter>(PrintCopiesOptionDetails_put_ErrorText), nullptr, nullptr },
        { "option_id", reinterpret_cast<getter>(PrintCopiesOptionDetails_get_OptionId), nullptr, nullptr, nullptr },
        { "option_type", reinterpret_cast<getter>(PrintCopiesOptionDetails_get_OptionType), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(PrintCopiesOptionDetails_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintCopiesOptionDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintCopiesOptionDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintCopiesOptionDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintCopiesOptionDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintCopiesOptionDetails) },
        { },
    };

    static PyType_Spec type_spec_PrintCopiesOptionDetails =
    {
        "_winsdk_Windows_Graphics_Printing_OptionDetails.PrintCopiesOptionDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCopiesOptionDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintCopiesOptionDetails
    };

    // ----- PrintCustomItemDetails class --------------------
    static constexpr const char* const type_name_PrintCustomItemDetails = "PrintCustomItemDetails";

    static PyObject* _new_PrintCustomItemDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PrintCustomItemDetails);
        return nullptr;
    }

    static void _dealloc_PrintCustomItemDetails(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomItemDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintCustomItemDetails_get_ItemDisplayName(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomItemDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomItemDetails", L"ItemDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ItemDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintCustomItemDetails_put_ItemDisplayName(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomItemDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomItemDetails", L"ItemDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ItemDisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintCustomItemDetails_get_ItemId(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomItemDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomItemDetails", L"ItemId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ItemId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintCustomItemDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::OptionDetails::PrintCustomItemDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintCustomItemDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::OptionDetails::PrintCustomItemDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintCustomItemDetails[] = {
        { "_assign_array_", _assign_array_PrintCustomItemDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintCustomItemDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintCustomItemDetails[] = {
        { "item_display_name", reinterpret_cast<getter>(PrintCustomItemDetails_get_ItemDisplayName), reinterpret_cast<setter>(PrintCustomItemDetails_put_ItemDisplayName), nullptr, nullptr },
        { "item_id", reinterpret_cast<getter>(PrintCustomItemDetails_get_ItemId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintCustomItemDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintCustomItemDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintCustomItemDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintCustomItemDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintCustomItemDetails) },
        { },
    };

    static PyType_Spec type_spec_PrintCustomItemDetails =
    {
        "_winsdk_Windows_Graphics_Printing_OptionDetails.PrintCustomItemDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomItemDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintCustomItemDetails
    };

    // ----- PrintCustomItemListOptionDetails class --------------------
    static constexpr const char* const type_name_PrintCustomItemListOptionDetails = "PrintCustomItemListOptionDetails";

    static PyObject* _new_PrintCustomItemListOptionDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PrintCustomItemListOptionDetails);
        return nullptr;
    }

    static void _dealloc_PrintCustomItemListOptionDetails(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomItemListOptionDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintCustomItemListOptionDetails_AddItem(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomItemListOptionDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails", L"AddItem", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.AddItem(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails", L"AddItem", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>(args, 3);

                self->obj.AddItem(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintCustomItemListOptionDetails_TrySetValue(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomItemListOptionDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails", L"TrySetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.TrySetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintCustomItemListOptionDetails_get_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomItemListOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WarningText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintCustomItemListOptionDetails_put_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomItemListOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.WarningText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintCustomItemListOptionDetails_get_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomItemListOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintCustomItemListOptionDetails_put_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomItemListOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintCustomItemListOptionDetails_get_DisplayName(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomItemListOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintCustomItemListOptionDetails_put_DisplayName(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomItemListOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintCustomItemListOptionDetails_get_Items(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomItemListOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails", L"Items"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Items());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintCustomItemListOptionDetails_get_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomItemListOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintCustomItemListOptionDetails_put_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomItemListOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::OptionDetails::PrintOptionStates>(arg);

            self->obj.State(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintCustomItemListOptionDetails_get_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomItemListOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintCustomItemListOptionDetails_put_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomItemListOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ErrorText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintCustomItemListOptionDetails_get_OptionId(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomItemListOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails", L"OptionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintCustomItemListOptionDetails_get_OptionType(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomItemListOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails", L"OptionType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintCustomItemListOptionDetails_get_Value(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomItemListOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintCustomItemListOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::OptionDetails::PrintCustomItemListOptionDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintCustomItemListOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::OptionDetails::PrintCustomItemListOptionDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintCustomItemListOptionDetails[] = {
        { "add_item", reinterpret_cast<PyCFunction>(PrintCustomItemListOptionDetails_AddItem), METH_VARARGS, nullptr },
        { "try_set_value", reinterpret_cast<PyCFunction>(PrintCustomItemListOptionDetails_TrySetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintCustomItemListOptionDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintCustomItemListOptionDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintCustomItemListOptionDetails[] = {
        { "warning_text", reinterpret_cast<getter>(PrintCustomItemListOptionDetails_get_WarningText), reinterpret_cast<setter>(PrintCustomItemListOptionDetails_put_WarningText), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(PrintCustomItemListOptionDetails_get_Description), reinterpret_cast<setter>(PrintCustomItemListOptionDetails_put_Description), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PrintCustomItemListOptionDetails_get_DisplayName), reinterpret_cast<setter>(PrintCustomItemListOptionDetails_put_DisplayName), nullptr, nullptr },
        { "items", reinterpret_cast<getter>(PrintCustomItemListOptionDetails_get_Items), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(PrintCustomItemListOptionDetails_get_State), reinterpret_cast<setter>(PrintCustomItemListOptionDetails_put_State), nullptr, nullptr },
        { "error_text", reinterpret_cast<getter>(PrintCustomItemListOptionDetails_get_ErrorText), reinterpret_cast<setter>(PrintCustomItemListOptionDetails_put_ErrorText), nullptr, nullptr },
        { "option_id", reinterpret_cast<getter>(PrintCustomItemListOptionDetails_get_OptionId), nullptr, nullptr, nullptr },
        { "option_type", reinterpret_cast<getter>(PrintCustomItemListOptionDetails_get_OptionType), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(PrintCustomItemListOptionDetails_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintCustomItemListOptionDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintCustomItemListOptionDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintCustomItemListOptionDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintCustomItemListOptionDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintCustomItemListOptionDetails) },
        { },
    };

    static PyType_Spec type_spec_PrintCustomItemListOptionDetails =
    {
        "_winsdk_Windows_Graphics_Printing_OptionDetails.PrintCustomItemListOptionDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomItemListOptionDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintCustomItemListOptionDetails
    };

    // ----- PrintCustomTextOptionDetails class --------------------
    static constexpr const char* const type_name_PrintCustomTextOptionDetails = "PrintCustomTextOptionDetails";

    static PyObject* _new_PrintCustomTextOptionDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PrintCustomTextOptionDetails);
        return nullptr;
    }

    static void _dealloc_PrintCustomTextOptionDetails(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomTextOptionDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintCustomTextOptionDetails_TrySetValue(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomTextOptionDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails", L"TrySetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.TrySetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintCustomTextOptionDetails_get_DisplayName(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomTextOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintCustomTextOptionDetails_put_DisplayName(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomTextOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintCustomTextOptionDetails_get_MaxCharacters(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomTextOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails", L"MaxCharacters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxCharacters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintCustomTextOptionDetails_put_MaxCharacters(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomTextOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails", L"MaxCharacters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.MaxCharacters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintCustomTextOptionDetails_get_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomTextOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WarningText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintCustomTextOptionDetails_put_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomTextOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.WarningText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintCustomTextOptionDetails_get_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomTextOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintCustomTextOptionDetails_put_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomTextOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintCustomTextOptionDetails_get_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomTextOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintCustomTextOptionDetails_put_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomTextOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::OptionDetails::PrintOptionStates>(arg);

            self->obj.State(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintCustomTextOptionDetails_get_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomTextOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintCustomTextOptionDetails_put_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomTextOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ErrorText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintCustomTextOptionDetails_get_OptionId(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomTextOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails", L"OptionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintCustomTextOptionDetails_get_OptionType(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomTextOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails", L"OptionType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintCustomTextOptionDetails_get_Value(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomTextOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintCustomTextOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::OptionDetails::PrintCustomTextOptionDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintCustomTextOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::OptionDetails::PrintCustomTextOptionDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintCustomTextOptionDetails[] = {
        { "try_set_value", reinterpret_cast<PyCFunction>(PrintCustomTextOptionDetails_TrySetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintCustomTextOptionDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintCustomTextOptionDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintCustomTextOptionDetails[] = {
        { "display_name", reinterpret_cast<getter>(PrintCustomTextOptionDetails_get_DisplayName), reinterpret_cast<setter>(PrintCustomTextOptionDetails_put_DisplayName), nullptr, nullptr },
        { "max_characters", reinterpret_cast<getter>(PrintCustomTextOptionDetails_get_MaxCharacters), reinterpret_cast<setter>(PrintCustomTextOptionDetails_put_MaxCharacters), nullptr, nullptr },
        { "warning_text", reinterpret_cast<getter>(PrintCustomTextOptionDetails_get_WarningText), reinterpret_cast<setter>(PrintCustomTextOptionDetails_put_WarningText), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(PrintCustomTextOptionDetails_get_Description), reinterpret_cast<setter>(PrintCustomTextOptionDetails_put_Description), nullptr, nullptr },
        { "state", reinterpret_cast<getter>(PrintCustomTextOptionDetails_get_State), reinterpret_cast<setter>(PrintCustomTextOptionDetails_put_State), nullptr, nullptr },
        { "error_text", reinterpret_cast<getter>(PrintCustomTextOptionDetails_get_ErrorText), reinterpret_cast<setter>(PrintCustomTextOptionDetails_put_ErrorText), nullptr, nullptr },
        { "option_id", reinterpret_cast<getter>(PrintCustomTextOptionDetails_get_OptionId), nullptr, nullptr, nullptr },
        { "option_type", reinterpret_cast<getter>(PrintCustomTextOptionDetails_get_OptionType), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(PrintCustomTextOptionDetails_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintCustomTextOptionDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintCustomTextOptionDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintCustomTextOptionDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintCustomTextOptionDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintCustomTextOptionDetails) },
        { },
    };

    static PyType_Spec type_spec_PrintCustomTextOptionDetails =
    {
        "_winsdk_Windows_Graphics_Printing_OptionDetails.PrintCustomTextOptionDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomTextOptionDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintCustomTextOptionDetails
    };

    // ----- PrintCustomToggleOptionDetails class --------------------
    static constexpr const char* const type_name_PrintCustomToggleOptionDetails = "PrintCustomToggleOptionDetails";

    static PyObject* _new_PrintCustomToggleOptionDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PrintCustomToggleOptionDetails);
        return nullptr;
    }

    static void _dealloc_PrintCustomToggleOptionDetails(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomToggleOptionDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintCustomToggleOptionDetails_TrySetValue(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomToggleOptionDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomToggleOptionDetails", L"TrySetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.TrySetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintCustomToggleOptionDetails_get_DisplayName(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomToggleOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomToggleOptionDetails", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintCustomToggleOptionDetails_put_DisplayName(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomToggleOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomToggleOptionDetails", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintCustomToggleOptionDetails_get_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomToggleOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomToggleOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WarningText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintCustomToggleOptionDetails_put_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomToggleOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomToggleOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.WarningText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintCustomToggleOptionDetails_get_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomToggleOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomToggleOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintCustomToggleOptionDetails_put_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomToggleOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomToggleOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintCustomToggleOptionDetails_get_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomToggleOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomToggleOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintCustomToggleOptionDetails_put_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomToggleOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomToggleOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::OptionDetails::PrintOptionStates>(arg);

            self->obj.State(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintCustomToggleOptionDetails_get_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomToggleOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomToggleOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintCustomToggleOptionDetails_put_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomToggleOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomToggleOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ErrorText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintCustomToggleOptionDetails_get_OptionId(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomToggleOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomToggleOptionDetails", L"OptionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintCustomToggleOptionDetails_get_OptionType(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomToggleOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomToggleOptionDetails", L"OptionType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintCustomToggleOptionDetails_get_Value(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomToggleOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintCustomToggleOptionDetails", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintCustomToggleOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::OptionDetails::PrintCustomToggleOptionDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintCustomToggleOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::OptionDetails::PrintCustomToggleOptionDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintCustomToggleOptionDetails[] = {
        { "try_set_value", reinterpret_cast<PyCFunction>(PrintCustomToggleOptionDetails_TrySetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintCustomToggleOptionDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintCustomToggleOptionDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintCustomToggleOptionDetails[] = {
        { "display_name", reinterpret_cast<getter>(PrintCustomToggleOptionDetails_get_DisplayName), reinterpret_cast<setter>(PrintCustomToggleOptionDetails_put_DisplayName), nullptr, nullptr },
        { "warning_text", reinterpret_cast<getter>(PrintCustomToggleOptionDetails_get_WarningText), reinterpret_cast<setter>(PrintCustomToggleOptionDetails_put_WarningText), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(PrintCustomToggleOptionDetails_get_Description), reinterpret_cast<setter>(PrintCustomToggleOptionDetails_put_Description), nullptr, nullptr },
        { "state", reinterpret_cast<getter>(PrintCustomToggleOptionDetails_get_State), reinterpret_cast<setter>(PrintCustomToggleOptionDetails_put_State), nullptr, nullptr },
        { "error_text", reinterpret_cast<getter>(PrintCustomToggleOptionDetails_get_ErrorText), reinterpret_cast<setter>(PrintCustomToggleOptionDetails_put_ErrorText), nullptr, nullptr },
        { "option_id", reinterpret_cast<getter>(PrintCustomToggleOptionDetails_get_OptionId), nullptr, nullptr, nullptr },
        { "option_type", reinterpret_cast<getter>(PrintCustomToggleOptionDetails_get_OptionType), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(PrintCustomToggleOptionDetails_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintCustomToggleOptionDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintCustomToggleOptionDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintCustomToggleOptionDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintCustomToggleOptionDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintCustomToggleOptionDetails) },
        { },
    };

    static PyType_Spec type_spec_PrintCustomToggleOptionDetails =
    {
        "_winsdk_Windows_Graphics_Printing_OptionDetails.PrintCustomToggleOptionDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintCustomToggleOptionDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintCustomToggleOptionDetails
    };

    // ----- PrintDuplexOptionDetails class --------------------
    static constexpr const char* const type_name_PrintDuplexOptionDetails = "PrintDuplexOptionDetails";

    static PyObject* _new_PrintDuplexOptionDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PrintDuplexOptionDetails);
        return nullptr;
    }

    static void _dealloc_PrintDuplexOptionDetails(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintDuplexOptionDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintDuplexOptionDetails_TrySetValue(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintDuplexOptionDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.PrintDuplexOptionDetails", L"TrySetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.TrySetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintDuplexOptionDetails_get_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintDuplexOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintDuplexOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WarningText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintDuplexOptionDetails_put_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintDuplexOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintDuplexOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.WarningText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintDuplexOptionDetails_get_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintDuplexOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintDuplexOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintDuplexOptionDetails_put_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintDuplexOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintDuplexOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintDuplexOptionDetails_get_Items(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintDuplexOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintDuplexOptionDetails", L"Items"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Items());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintDuplexOptionDetails_get_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintDuplexOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintDuplexOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintDuplexOptionDetails_put_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintDuplexOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintDuplexOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::OptionDetails::PrintOptionStates>(arg);

            self->obj.State(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintDuplexOptionDetails_get_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintDuplexOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintDuplexOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintDuplexOptionDetails_put_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintDuplexOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintDuplexOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ErrorText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintDuplexOptionDetails_get_OptionId(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintDuplexOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintDuplexOptionDetails", L"OptionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintDuplexOptionDetails_get_OptionType(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintDuplexOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintDuplexOptionDetails", L"OptionType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintDuplexOptionDetails_get_Value(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintDuplexOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintDuplexOptionDetails", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintDuplexOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::OptionDetails::PrintDuplexOptionDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintDuplexOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::OptionDetails::PrintDuplexOptionDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintDuplexOptionDetails[] = {
        { "try_set_value", reinterpret_cast<PyCFunction>(PrintDuplexOptionDetails_TrySetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintDuplexOptionDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintDuplexOptionDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintDuplexOptionDetails[] = {
        { "warning_text", reinterpret_cast<getter>(PrintDuplexOptionDetails_get_WarningText), reinterpret_cast<setter>(PrintDuplexOptionDetails_put_WarningText), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(PrintDuplexOptionDetails_get_Description), reinterpret_cast<setter>(PrintDuplexOptionDetails_put_Description), nullptr, nullptr },
        { "items", reinterpret_cast<getter>(PrintDuplexOptionDetails_get_Items), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(PrintDuplexOptionDetails_get_State), reinterpret_cast<setter>(PrintDuplexOptionDetails_put_State), nullptr, nullptr },
        { "error_text", reinterpret_cast<getter>(PrintDuplexOptionDetails_get_ErrorText), reinterpret_cast<setter>(PrintDuplexOptionDetails_put_ErrorText), nullptr, nullptr },
        { "option_id", reinterpret_cast<getter>(PrintDuplexOptionDetails_get_OptionId), nullptr, nullptr, nullptr },
        { "option_type", reinterpret_cast<getter>(PrintDuplexOptionDetails_get_OptionType), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(PrintDuplexOptionDetails_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintDuplexOptionDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintDuplexOptionDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintDuplexOptionDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintDuplexOptionDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintDuplexOptionDetails) },
        { },
    };

    static PyType_Spec type_spec_PrintDuplexOptionDetails =
    {
        "_winsdk_Windows_Graphics_Printing_OptionDetails.PrintDuplexOptionDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintDuplexOptionDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintDuplexOptionDetails
    };

    // ----- PrintHolePunchOptionDetails class --------------------
    static constexpr const char* const type_name_PrintHolePunchOptionDetails = "PrintHolePunchOptionDetails";

    static PyObject* _new_PrintHolePunchOptionDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PrintHolePunchOptionDetails);
        return nullptr;
    }

    static void _dealloc_PrintHolePunchOptionDetails(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintHolePunchOptionDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintHolePunchOptionDetails_TrySetValue(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintHolePunchOptionDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.PrintHolePunchOptionDetails", L"TrySetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.TrySetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintHolePunchOptionDetails_get_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintHolePunchOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintHolePunchOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WarningText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintHolePunchOptionDetails_put_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintHolePunchOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintHolePunchOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.WarningText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintHolePunchOptionDetails_get_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintHolePunchOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintHolePunchOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintHolePunchOptionDetails_put_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintHolePunchOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintHolePunchOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintHolePunchOptionDetails_get_Items(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintHolePunchOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintHolePunchOptionDetails", L"Items"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Items());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintHolePunchOptionDetails_get_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintHolePunchOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintHolePunchOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintHolePunchOptionDetails_put_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintHolePunchOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintHolePunchOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::OptionDetails::PrintOptionStates>(arg);

            self->obj.State(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintHolePunchOptionDetails_get_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintHolePunchOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintHolePunchOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintHolePunchOptionDetails_put_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintHolePunchOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintHolePunchOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ErrorText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintHolePunchOptionDetails_get_OptionId(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintHolePunchOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintHolePunchOptionDetails", L"OptionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintHolePunchOptionDetails_get_OptionType(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintHolePunchOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintHolePunchOptionDetails", L"OptionType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintHolePunchOptionDetails_get_Value(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintHolePunchOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintHolePunchOptionDetails", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintHolePunchOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::OptionDetails::PrintHolePunchOptionDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintHolePunchOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::OptionDetails::PrintHolePunchOptionDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintHolePunchOptionDetails[] = {
        { "try_set_value", reinterpret_cast<PyCFunction>(PrintHolePunchOptionDetails_TrySetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintHolePunchOptionDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintHolePunchOptionDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintHolePunchOptionDetails[] = {
        { "warning_text", reinterpret_cast<getter>(PrintHolePunchOptionDetails_get_WarningText), reinterpret_cast<setter>(PrintHolePunchOptionDetails_put_WarningText), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(PrintHolePunchOptionDetails_get_Description), reinterpret_cast<setter>(PrintHolePunchOptionDetails_put_Description), nullptr, nullptr },
        { "items", reinterpret_cast<getter>(PrintHolePunchOptionDetails_get_Items), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(PrintHolePunchOptionDetails_get_State), reinterpret_cast<setter>(PrintHolePunchOptionDetails_put_State), nullptr, nullptr },
        { "error_text", reinterpret_cast<getter>(PrintHolePunchOptionDetails_get_ErrorText), reinterpret_cast<setter>(PrintHolePunchOptionDetails_put_ErrorText), nullptr, nullptr },
        { "option_id", reinterpret_cast<getter>(PrintHolePunchOptionDetails_get_OptionId), nullptr, nullptr, nullptr },
        { "option_type", reinterpret_cast<getter>(PrintHolePunchOptionDetails_get_OptionType), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(PrintHolePunchOptionDetails_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintHolePunchOptionDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintHolePunchOptionDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintHolePunchOptionDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintHolePunchOptionDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintHolePunchOptionDetails) },
        { },
    };

    static PyType_Spec type_spec_PrintHolePunchOptionDetails =
    {
        "_winsdk_Windows_Graphics_Printing_OptionDetails.PrintHolePunchOptionDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintHolePunchOptionDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintHolePunchOptionDetails
    };

    // ----- PrintMediaSizeOptionDetails class --------------------
    static constexpr const char* const type_name_PrintMediaSizeOptionDetails = "PrintMediaSizeOptionDetails";

    static PyObject* _new_PrintMediaSizeOptionDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PrintMediaSizeOptionDetails);
        return nullptr;
    }

    static void _dealloc_PrintMediaSizeOptionDetails(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaSizeOptionDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintMediaSizeOptionDetails_TrySetValue(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaSizeOptionDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.PrintMediaSizeOptionDetails", L"TrySetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.TrySetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintMediaSizeOptionDetails_get_Items(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaSizeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintMediaSizeOptionDetails", L"Items"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Items());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintMediaSizeOptionDetails_get_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaSizeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintMediaSizeOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WarningText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintMediaSizeOptionDetails_put_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaSizeOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintMediaSizeOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.WarningText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintMediaSizeOptionDetails_get_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaSizeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintMediaSizeOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintMediaSizeOptionDetails_put_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaSizeOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintMediaSizeOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintMediaSizeOptionDetails_get_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaSizeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintMediaSizeOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintMediaSizeOptionDetails_put_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaSizeOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintMediaSizeOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::OptionDetails::PrintOptionStates>(arg);

            self->obj.State(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintMediaSizeOptionDetails_get_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaSizeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintMediaSizeOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintMediaSizeOptionDetails_put_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaSizeOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintMediaSizeOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ErrorText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintMediaSizeOptionDetails_get_OptionId(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaSizeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintMediaSizeOptionDetails", L"OptionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintMediaSizeOptionDetails_get_OptionType(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaSizeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintMediaSizeOptionDetails", L"OptionType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintMediaSizeOptionDetails_get_Value(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaSizeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintMediaSizeOptionDetails", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintMediaSizeOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::OptionDetails::PrintMediaSizeOptionDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintMediaSizeOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::OptionDetails::PrintMediaSizeOptionDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintMediaSizeOptionDetails[] = {
        { "try_set_value", reinterpret_cast<PyCFunction>(PrintMediaSizeOptionDetails_TrySetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintMediaSizeOptionDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintMediaSizeOptionDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintMediaSizeOptionDetails[] = {
        { "items", reinterpret_cast<getter>(PrintMediaSizeOptionDetails_get_Items), nullptr, nullptr, nullptr },
        { "warning_text", reinterpret_cast<getter>(PrintMediaSizeOptionDetails_get_WarningText), reinterpret_cast<setter>(PrintMediaSizeOptionDetails_put_WarningText), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(PrintMediaSizeOptionDetails_get_Description), reinterpret_cast<setter>(PrintMediaSizeOptionDetails_put_Description), nullptr, nullptr },
        { "state", reinterpret_cast<getter>(PrintMediaSizeOptionDetails_get_State), reinterpret_cast<setter>(PrintMediaSizeOptionDetails_put_State), nullptr, nullptr },
        { "error_text", reinterpret_cast<getter>(PrintMediaSizeOptionDetails_get_ErrorText), reinterpret_cast<setter>(PrintMediaSizeOptionDetails_put_ErrorText), nullptr, nullptr },
        { "option_id", reinterpret_cast<getter>(PrintMediaSizeOptionDetails_get_OptionId), nullptr, nullptr, nullptr },
        { "option_type", reinterpret_cast<getter>(PrintMediaSizeOptionDetails_get_OptionType), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(PrintMediaSizeOptionDetails_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintMediaSizeOptionDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintMediaSizeOptionDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintMediaSizeOptionDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintMediaSizeOptionDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintMediaSizeOptionDetails) },
        { },
    };

    static PyType_Spec type_spec_PrintMediaSizeOptionDetails =
    {
        "_winsdk_Windows_Graphics_Printing_OptionDetails.PrintMediaSizeOptionDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaSizeOptionDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintMediaSizeOptionDetails
    };

    // ----- PrintMediaTypeOptionDetails class --------------------
    static constexpr const char* const type_name_PrintMediaTypeOptionDetails = "PrintMediaTypeOptionDetails";

    static PyObject* _new_PrintMediaTypeOptionDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PrintMediaTypeOptionDetails);
        return nullptr;
    }

    static void _dealloc_PrintMediaTypeOptionDetails(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaTypeOptionDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintMediaTypeOptionDetails_TrySetValue(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaTypeOptionDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.PrintMediaTypeOptionDetails", L"TrySetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.TrySetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintMediaTypeOptionDetails_get_Items(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaTypeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintMediaTypeOptionDetails", L"Items"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Items());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintMediaTypeOptionDetails_get_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaTypeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintMediaTypeOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WarningText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintMediaTypeOptionDetails_put_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaTypeOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintMediaTypeOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.WarningText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintMediaTypeOptionDetails_get_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaTypeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintMediaTypeOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintMediaTypeOptionDetails_put_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaTypeOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintMediaTypeOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintMediaTypeOptionDetails_get_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaTypeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintMediaTypeOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintMediaTypeOptionDetails_put_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaTypeOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintMediaTypeOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::OptionDetails::PrintOptionStates>(arg);

            self->obj.State(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintMediaTypeOptionDetails_get_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaTypeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintMediaTypeOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintMediaTypeOptionDetails_put_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaTypeOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintMediaTypeOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ErrorText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintMediaTypeOptionDetails_get_OptionId(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaTypeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintMediaTypeOptionDetails", L"OptionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintMediaTypeOptionDetails_get_OptionType(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaTypeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintMediaTypeOptionDetails", L"OptionType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintMediaTypeOptionDetails_get_Value(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaTypeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintMediaTypeOptionDetails", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintMediaTypeOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::OptionDetails::PrintMediaTypeOptionDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintMediaTypeOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::OptionDetails::PrintMediaTypeOptionDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintMediaTypeOptionDetails[] = {
        { "try_set_value", reinterpret_cast<PyCFunction>(PrintMediaTypeOptionDetails_TrySetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintMediaTypeOptionDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintMediaTypeOptionDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintMediaTypeOptionDetails[] = {
        { "items", reinterpret_cast<getter>(PrintMediaTypeOptionDetails_get_Items), nullptr, nullptr, nullptr },
        { "warning_text", reinterpret_cast<getter>(PrintMediaTypeOptionDetails_get_WarningText), reinterpret_cast<setter>(PrintMediaTypeOptionDetails_put_WarningText), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(PrintMediaTypeOptionDetails_get_Description), reinterpret_cast<setter>(PrintMediaTypeOptionDetails_put_Description), nullptr, nullptr },
        { "state", reinterpret_cast<getter>(PrintMediaTypeOptionDetails_get_State), reinterpret_cast<setter>(PrintMediaTypeOptionDetails_put_State), nullptr, nullptr },
        { "error_text", reinterpret_cast<getter>(PrintMediaTypeOptionDetails_get_ErrorText), reinterpret_cast<setter>(PrintMediaTypeOptionDetails_put_ErrorText), nullptr, nullptr },
        { "option_id", reinterpret_cast<getter>(PrintMediaTypeOptionDetails_get_OptionId), nullptr, nullptr, nullptr },
        { "option_type", reinterpret_cast<getter>(PrintMediaTypeOptionDetails_get_OptionType), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(PrintMediaTypeOptionDetails_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintMediaTypeOptionDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintMediaTypeOptionDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintMediaTypeOptionDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintMediaTypeOptionDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintMediaTypeOptionDetails) },
        { },
    };

    static PyType_Spec type_spec_PrintMediaTypeOptionDetails =
    {
        "_winsdk_Windows_Graphics_Printing_OptionDetails.PrintMediaTypeOptionDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintMediaTypeOptionDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintMediaTypeOptionDetails
    };

    // ----- PrintOrientationOptionDetails class --------------------
    static constexpr const char* const type_name_PrintOrientationOptionDetails = "PrintOrientationOptionDetails";

    static PyObject* _new_PrintOrientationOptionDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PrintOrientationOptionDetails);
        return nullptr;
    }

    static void _dealloc_PrintOrientationOptionDetails(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintOrientationOptionDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintOrientationOptionDetails_TrySetValue(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintOrientationOptionDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.PrintOrientationOptionDetails", L"TrySetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.TrySetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintOrientationOptionDetails_get_Items(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintOrientationOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintOrientationOptionDetails", L"Items"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Items());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintOrientationOptionDetails_get_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintOrientationOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintOrientationOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintOrientationOptionDetails_put_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintOrientationOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintOrientationOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::OptionDetails::PrintOptionStates>(arg);

            self->obj.State(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintOrientationOptionDetails_get_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintOrientationOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintOrientationOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintOrientationOptionDetails_put_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintOrientationOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintOrientationOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ErrorText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintOrientationOptionDetails_get_OptionId(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintOrientationOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintOrientationOptionDetails", L"OptionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintOrientationOptionDetails_get_OptionType(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintOrientationOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintOrientationOptionDetails", L"OptionType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintOrientationOptionDetails_get_Value(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintOrientationOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintOrientationOptionDetails", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintOrientationOptionDetails_get_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintOrientationOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintOrientationOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WarningText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintOrientationOptionDetails_put_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintOrientationOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintOrientationOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.WarningText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintOrientationOptionDetails_get_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintOrientationOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintOrientationOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintOrientationOptionDetails_put_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintOrientationOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintOrientationOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PrintOrientationOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::OptionDetails::PrintOrientationOptionDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintOrientationOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::OptionDetails::PrintOrientationOptionDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintOrientationOptionDetails[] = {
        { "try_set_value", reinterpret_cast<PyCFunction>(PrintOrientationOptionDetails_TrySetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintOrientationOptionDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintOrientationOptionDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintOrientationOptionDetails[] = {
        { "items", reinterpret_cast<getter>(PrintOrientationOptionDetails_get_Items), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(PrintOrientationOptionDetails_get_State), reinterpret_cast<setter>(PrintOrientationOptionDetails_put_State), nullptr, nullptr },
        { "error_text", reinterpret_cast<getter>(PrintOrientationOptionDetails_get_ErrorText), reinterpret_cast<setter>(PrintOrientationOptionDetails_put_ErrorText), nullptr, nullptr },
        { "option_id", reinterpret_cast<getter>(PrintOrientationOptionDetails_get_OptionId), nullptr, nullptr, nullptr },
        { "option_type", reinterpret_cast<getter>(PrintOrientationOptionDetails_get_OptionType), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(PrintOrientationOptionDetails_get_Value), nullptr, nullptr, nullptr },
        { "warning_text", reinterpret_cast<getter>(PrintOrientationOptionDetails_get_WarningText), reinterpret_cast<setter>(PrintOrientationOptionDetails_put_WarningText), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(PrintOrientationOptionDetails_get_Description), reinterpret_cast<setter>(PrintOrientationOptionDetails_put_Description), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintOrientationOptionDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintOrientationOptionDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintOrientationOptionDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintOrientationOptionDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintOrientationOptionDetails) },
        { },
    };

    static PyType_Spec type_spec_PrintOrientationOptionDetails =
    {
        "_winsdk_Windows_Graphics_Printing_OptionDetails.PrintOrientationOptionDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintOrientationOptionDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintOrientationOptionDetails
    };

    // ----- PrintPageRangeOptionDetails class --------------------
    static constexpr const char* const type_name_PrintPageRangeOptionDetails = "PrintPageRangeOptionDetails";

    static PyObject* _new_PrintPageRangeOptionDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PrintPageRangeOptionDetails);
        return nullptr;
    }

    static void _dealloc_PrintPageRangeOptionDetails(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintPageRangeOptionDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintPageRangeOptionDetails_TrySetValue(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintPageRangeOptionDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.PrintPageRangeOptionDetails", L"TrySetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.TrySetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintPageRangeOptionDetails_get_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintPageRangeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintPageRangeOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintPageRangeOptionDetails_put_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintPageRangeOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintPageRangeOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::OptionDetails::PrintOptionStates>(arg);

            self->obj.State(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintPageRangeOptionDetails_get_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintPageRangeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintPageRangeOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintPageRangeOptionDetails_put_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintPageRangeOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintPageRangeOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ErrorText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintPageRangeOptionDetails_get_OptionId(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintPageRangeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintPageRangeOptionDetails", L"OptionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintPageRangeOptionDetails_get_OptionType(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintPageRangeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintPageRangeOptionDetails", L"OptionType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintPageRangeOptionDetails_get_Value(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintPageRangeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintPageRangeOptionDetails", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintPageRangeOptionDetails_get_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintPageRangeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintPageRangeOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WarningText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintPageRangeOptionDetails_put_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintPageRangeOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintPageRangeOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.WarningText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintPageRangeOptionDetails_get_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintPageRangeOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintPageRangeOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintPageRangeOptionDetails_put_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintPageRangeOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintPageRangeOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PrintPageRangeOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::OptionDetails::PrintPageRangeOptionDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintPageRangeOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::OptionDetails::PrintPageRangeOptionDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintPageRangeOptionDetails[] = {
        { "try_set_value", reinterpret_cast<PyCFunction>(PrintPageRangeOptionDetails_TrySetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintPageRangeOptionDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintPageRangeOptionDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintPageRangeOptionDetails[] = {
        { "state", reinterpret_cast<getter>(PrintPageRangeOptionDetails_get_State), reinterpret_cast<setter>(PrintPageRangeOptionDetails_put_State), nullptr, nullptr },
        { "error_text", reinterpret_cast<getter>(PrintPageRangeOptionDetails_get_ErrorText), reinterpret_cast<setter>(PrintPageRangeOptionDetails_put_ErrorText), nullptr, nullptr },
        { "option_id", reinterpret_cast<getter>(PrintPageRangeOptionDetails_get_OptionId), nullptr, nullptr, nullptr },
        { "option_type", reinterpret_cast<getter>(PrintPageRangeOptionDetails_get_OptionType), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(PrintPageRangeOptionDetails_get_Value), nullptr, nullptr, nullptr },
        { "warning_text", reinterpret_cast<getter>(PrintPageRangeOptionDetails_get_WarningText), reinterpret_cast<setter>(PrintPageRangeOptionDetails_put_WarningText), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(PrintPageRangeOptionDetails_get_Description), reinterpret_cast<setter>(PrintPageRangeOptionDetails_put_Description), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintPageRangeOptionDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintPageRangeOptionDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintPageRangeOptionDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintPageRangeOptionDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintPageRangeOptionDetails) },
        { },
    };

    static PyType_Spec type_spec_PrintPageRangeOptionDetails =
    {
        "_winsdk_Windows_Graphics_Printing_OptionDetails.PrintPageRangeOptionDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintPageRangeOptionDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintPageRangeOptionDetails
    };

    // ----- PrintQualityOptionDetails class --------------------
    static constexpr const char* const type_name_PrintQualityOptionDetails = "PrintQualityOptionDetails";

    static PyObject* _new_PrintQualityOptionDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PrintQualityOptionDetails);
        return nullptr;
    }

    static void _dealloc_PrintQualityOptionDetails(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintQualityOptionDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintQualityOptionDetails_TrySetValue(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintQualityOptionDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.PrintQualityOptionDetails", L"TrySetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.TrySetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintQualityOptionDetails_get_Items(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintQualityOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintQualityOptionDetails", L"Items"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Items());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintQualityOptionDetails_get_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintQualityOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintQualityOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintQualityOptionDetails_put_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintQualityOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintQualityOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::OptionDetails::PrintOptionStates>(arg);

            self->obj.State(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintQualityOptionDetails_get_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintQualityOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintQualityOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintQualityOptionDetails_put_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintQualityOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintQualityOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ErrorText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintQualityOptionDetails_get_OptionId(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintQualityOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintQualityOptionDetails", L"OptionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintQualityOptionDetails_get_OptionType(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintQualityOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintQualityOptionDetails", L"OptionType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintQualityOptionDetails_get_Value(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintQualityOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintQualityOptionDetails", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintQualityOptionDetails_get_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintQualityOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintQualityOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WarningText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintQualityOptionDetails_put_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintQualityOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintQualityOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.WarningText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintQualityOptionDetails_get_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintQualityOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintQualityOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintQualityOptionDetails_put_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintQualityOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintQualityOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PrintQualityOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::OptionDetails::PrintQualityOptionDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintQualityOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::OptionDetails::PrintQualityOptionDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintQualityOptionDetails[] = {
        { "try_set_value", reinterpret_cast<PyCFunction>(PrintQualityOptionDetails_TrySetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintQualityOptionDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintQualityOptionDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintQualityOptionDetails[] = {
        { "items", reinterpret_cast<getter>(PrintQualityOptionDetails_get_Items), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(PrintQualityOptionDetails_get_State), reinterpret_cast<setter>(PrintQualityOptionDetails_put_State), nullptr, nullptr },
        { "error_text", reinterpret_cast<getter>(PrintQualityOptionDetails_get_ErrorText), reinterpret_cast<setter>(PrintQualityOptionDetails_put_ErrorText), nullptr, nullptr },
        { "option_id", reinterpret_cast<getter>(PrintQualityOptionDetails_get_OptionId), nullptr, nullptr, nullptr },
        { "option_type", reinterpret_cast<getter>(PrintQualityOptionDetails_get_OptionType), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(PrintQualityOptionDetails_get_Value), nullptr, nullptr, nullptr },
        { "warning_text", reinterpret_cast<getter>(PrintQualityOptionDetails_get_WarningText), reinterpret_cast<setter>(PrintQualityOptionDetails_put_WarningText), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(PrintQualityOptionDetails_get_Description), reinterpret_cast<setter>(PrintQualityOptionDetails_put_Description), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintQualityOptionDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintQualityOptionDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintQualityOptionDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintQualityOptionDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintQualityOptionDetails) },
        { },
    };

    static PyType_Spec type_spec_PrintQualityOptionDetails =
    {
        "_winsdk_Windows_Graphics_Printing_OptionDetails.PrintQualityOptionDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintQualityOptionDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintQualityOptionDetails
    };

    // ----- PrintStapleOptionDetails class --------------------
    static constexpr const char* const type_name_PrintStapleOptionDetails = "PrintStapleOptionDetails";

    static PyObject* _new_PrintStapleOptionDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PrintStapleOptionDetails);
        return nullptr;
    }

    static void _dealloc_PrintStapleOptionDetails(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintStapleOptionDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintStapleOptionDetails_TrySetValue(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintStapleOptionDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.PrintStapleOptionDetails", L"TrySetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.TrySetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintStapleOptionDetails_get_Items(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintStapleOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintStapleOptionDetails", L"Items"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Items());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintStapleOptionDetails_get_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintStapleOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintStapleOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintStapleOptionDetails_put_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintStapleOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintStapleOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::OptionDetails::PrintOptionStates>(arg);

            self->obj.State(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintStapleOptionDetails_get_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintStapleOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintStapleOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintStapleOptionDetails_put_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintStapleOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintStapleOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ErrorText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintStapleOptionDetails_get_OptionId(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintStapleOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintStapleOptionDetails", L"OptionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintStapleOptionDetails_get_OptionType(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintStapleOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintStapleOptionDetails", L"OptionType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintStapleOptionDetails_get_Value(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintStapleOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintStapleOptionDetails", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintStapleOptionDetails_get_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintStapleOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintStapleOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WarningText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintStapleOptionDetails_put_WarningText(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintStapleOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintStapleOptionDetails", L"WarningText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.WarningText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintStapleOptionDetails_get_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintStapleOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintStapleOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintStapleOptionDetails_put_Description(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintStapleOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintStapleOptionDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PrintStapleOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::OptionDetails::PrintStapleOptionDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintStapleOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::OptionDetails::PrintStapleOptionDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintStapleOptionDetails[] = {
        { "try_set_value", reinterpret_cast<PyCFunction>(PrintStapleOptionDetails_TrySetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintStapleOptionDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintStapleOptionDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintStapleOptionDetails[] = {
        { "items", reinterpret_cast<getter>(PrintStapleOptionDetails_get_Items), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(PrintStapleOptionDetails_get_State), reinterpret_cast<setter>(PrintStapleOptionDetails_put_State), nullptr, nullptr },
        { "error_text", reinterpret_cast<getter>(PrintStapleOptionDetails_get_ErrorText), reinterpret_cast<setter>(PrintStapleOptionDetails_put_ErrorText), nullptr, nullptr },
        { "option_id", reinterpret_cast<getter>(PrintStapleOptionDetails_get_OptionId), nullptr, nullptr, nullptr },
        { "option_type", reinterpret_cast<getter>(PrintStapleOptionDetails_get_OptionType), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(PrintStapleOptionDetails_get_Value), nullptr, nullptr, nullptr },
        { "warning_text", reinterpret_cast<getter>(PrintStapleOptionDetails_get_WarningText), reinterpret_cast<setter>(PrintStapleOptionDetails_put_WarningText), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(PrintStapleOptionDetails_get_Description), reinterpret_cast<setter>(PrintStapleOptionDetails_put_Description), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintStapleOptionDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintStapleOptionDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintStapleOptionDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintStapleOptionDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintStapleOptionDetails) },
        { },
    };

    static PyType_Spec type_spec_PrintStapleOptionDetails =
    {
        "_winsdk_Windows_Graphics_Printing_OptionDetails.PrintStapleOptionDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintStapleOptionDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintStapleOptionDetails
    };

    // ----- PrintTaskOptionChangedEventArgs class --------------------
    static constexpr const char* const type_name_PrintTaskOptionChangedEventArgs = "PrintTaskOptionChangedEventArgs";

    static PyObject* _new_PrintTaskOptionChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PrintTaskOptionChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_PrintTaskOptionChangedEventArgs(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintTaskOptionChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintTaskOptionChangedEventArgs_get_OptionId(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintTaskOptionChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintTaskOptionChangedEventArgs", L"OptionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintTaskOptionChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::OptionDetails::PrintTaskOptionChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintTaskOptionChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::OptionDetails::PrintTaskOptionChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintTaskOptionChangedEventArgs[] = {
        { "_assign_array_", _assign_array_PrintTaskOptionChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintTaskOptionChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintTaskOptionChangedEventArgs[] = {
        { "option_id", reinterpret_cast<getter>(PrintTaskOptionChangedEventArgs_get_OptionId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintTaskOptionChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintTaskOptionChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintTaskOptionChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintTaskOptionChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintTaskOptionChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PrintTaskOptionChangedEventArgs =
    {
        "_winsdk_Windows_Graphics_Printing_OptionDetails.PrintTaskOptionChangedEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintTaskOptionChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintTaskOptionChangedEventArgs
    };

    // ----- PrintTaskOptionDetails class --------------------
    static constexpr const char* const type_name_PrintTaskOptionDetails = "PrintTaskOptionDetails";

    static PyObject* _new_PrintTaskOptionDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PrintTaskOptionDetails);
        return nullptr;
    }

    static void _dealloc_PrintTaskOptionDetails(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintTaskOptionDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintTaskOptionDetails_CreateItemListOption(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintTaskOptionDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails", L"CreateItemListOption", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CreateItemListOption(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintTaskOptionDetails_CreateTextOption(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintTaskOptionDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails", L"CreateTextOption", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CreateTextOption(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintTaskOptionDetails_CreateToggleOption(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintTaskOptionDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails", L"CreateToggleOption", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CreateToggleOption(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintTaskOptionDetails_GetFromPrintTaskOptions(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails", L"GetFromPrintTaskOptions", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::PrintTaskOptions>(args, 0);

                return py::convert(winrt::Windows::Graphics::Printing::OptionDetails::PrintTaskOptionDetails::GetFromPrintTaskOptions(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintTaskOptionDetails_GetPageDescription(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintTaskOptionDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails", L"GetPageDescription", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetPageDescription(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintTaskOptionDetails_get_DisplayedOptions(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintTaskOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails", L"DisplayedOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayedOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintTaskOptionDetails_get_Options(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintTaskOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails", L"Options"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Options());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintTaskOptionDetails_add_BeginValidation(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintTaskOptionDetails* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails", L"BeginValidation"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing::OptionDetails::PrintTaskOptionDetails, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.BeginValidation(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintTaskOptionDetails_remove_BeginValidation(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintTaskOptionDetails* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails", L"BeginValidation"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BeginValidation(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintTaskOptionDetails_add_OptionChanged(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintTaskOptionDetails* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails", L"OptionChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing::OptionDetails::PrintTaskOptionDetails, winrt::Windows::Graphics::Printing::OptionDetails::PrintTaskOptionChangedEventArgs>>(arg);

            return py::convert(self->obj.OptionChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintTaskOptionDetails_remove_OptionChanged(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintTaskOptionDetails* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails", L"OptionChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OptionChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintTaskOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::OptionDetails::PrintTaskOptionDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintTaskOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::OptionDetails::PrintTaskOptionDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintTaskOptionDetails[] = {
        { "create_item_list_option", reinterpret_cast<PyCFunction>(PrintTaskOptionDetails_CreateItemListOption), METH_VARARGS, nullptr },
        { "create_text_option", reinterpret_cast<PyCFunction>(PrintTaskOptionDetails_CreateTextOption), METH_VARARGS, nullptr },
        { "create_toggle_option", reinterpret_cast<PyCFunction>(PrintTaskOptionDetails_CreateToggleOption), METH_VARARGS, nullptr },
        { "get_from_print_task_options", reinterpret_cast<PyCFunction>(PrintTaskOptionDetails_GetFromPrintTaskOptions), METH_VARARGS | METH_STATIC, nullptr },
        { "get_page_description", reinterpret_cast<PyCFunction>(PrintTaskOptionDetails_GetPageDescription), METH_VARARGS, nullptr },
        { "add_begin_validation", reinterpret_cast<PyCFunction>(PrintTaskOptionDetails_add_BeginValidation), METH_O, nullptr },
        { "remove_begin_validation", reinterpret_cast<PyCFunction>(PrintTaskOptionDetails_remove_BeginValidation), METH_O, nullptr },
        { "add_option_changed", reinterpret_cast<PyCFunction>(PrintTaskOptionDetails_add_OptionChanged), METH_O, nullptr },
        { "remove_option_changed", reinterpret_cast<PyCFunction>(PrintTaskOptionDetails_remove_OptionChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_PrintTaskOptionDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintTaskOptionDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintTaskOptionDetails[] = {
        { "displayed_options", reinterpret_cast<getter>(PrintTaskOptionDetails_get_DisplayedOptions), nullptr, nullptr, nullptr },
        { "options", reinterpret_cast<getter>(PrintTaskOptionDetails_get_Options), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintTaskOptionDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintTaskOptionDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintTaskOptionDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintTaskOptionDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintTaskOptionDetails) },
        { },
    };

    static PyType_Spec type_spec_PrintTaskOptionDetails =
    {
        "_winsdk_Windows_Graphics_Printing_OptionDetails.PrintTaskOptionDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::OptionDetails::PrintTaskOptionDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintTaskOptionDetails
    };

    // ----- IPrintCustomOptionDetails interface --------------------
    static constexpr const char* const type_name_IPrintCustomOptionDetails = "IPrintCustomOptionDetails";

    static PyObject* _new_IPrintCustomOptionDetails(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IPrintCustomOptionDetails);
        return nullptr;
    }

    static void _dealloc_IPrintCustomOptionDetails(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintCustomOptionDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPrintCustomOptionDetails_TrySetValue(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintCustomOptionDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"TrySetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.TrySetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPrintCustomOptionDetails_get_DisplayName(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintCustomOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintCustomOptionDetails", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPrintCustomOptionDetails_put_DisplayName(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintCustomOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintCustomOptionDetails", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPrintCustomOptionDetails_get_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintCustomOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPrintCustomOptionDetails_put_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintCustomOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ErrorText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPrintCustomOptionDetails_get_OptionId(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintCustomOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"OptionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrintCustomOptionDetails_get_OptionType(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintCustomOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"OptionType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrintCustomOptionDetails_get_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintCustomOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPrintCustomOptionDetails_put_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintCustomOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::OptionDetails::PrintOptionStates>(arg);

            self->obj.State(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPrintCustomOptionDetails_get_Value(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintCustomOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IPrintCustomOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::OptionDetails::IPrintCustomOptionDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPrintCustomOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::OptionDetails::IPrintCustomOptionDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPrintCustomOptionDetails[] = {
        { "try_set_value", reinterpret_cast<PyCFunction>(IPrintCustomOptionDetails_TrySetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IPrintCustomOptionDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPrintCustomOptionDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPrintCustomOptionDetails[] = {
        { "display_name", reinterpret_cast<getter>(IPrintCustomOptionDetails_get_DisplayName), reinterpret_cast<setter>(IPrintCustomOptionDetails_put_DisplayName), nullptr, nullptr },
        { "error_text", reinterpret_cast<getter>(IPrintCustomOptionDetails_get_ErrorText), reinterpret_cast<setter>(IPrintCustomOptionDetails_put_ErrorText), nullptr, nullptr },
        { "option_id", reinterpret_cast<getter>(IPrintCustomOptionDetails_get_OptionId), nullptr, nullptr, nullptr },
        { "option_type", reinterpret_cast<getter>(IPrintCustomOptionDetails_get_OptionType), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(IPrintCustomOptionDetails_get_State), reinterpret_cast<setter>(IPrintCustomOptionDetails_put_State), nullptr, nullptr },
        { "value", reinterpret_cast<getter>(IPrintCustomOptionDetails_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IPrintCustomOptionDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPrintCustomOptionDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPrintCustomOptionDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPrintCustomOptionDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPrintCustomOptionDetails) },
        { },
    };

    static PyType_Spec type_spec_IPrintCustomOptionDetails =
    {
        "_winsdk_Windows_Graphics_Printing_OptionDetails.IPrintCustomOptionDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintCustomOptionDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPrintCustomOptionDetails
    };

    // ----- IPrintItemListOptionDetails interface --------------------
    static constexpr const char* const type_name_IPrintItemListOptionDetails = "IPrintItemListOptionDetails";

    static PyObject* _new_IPrintItemListOptionDetails(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IPrintItemListOptionDetails);
        return nullptr;
    }

    static void _dealloc_IPrintItemListOptionDetails(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintItemListOptionDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPrintItemListOptionDetails_TrySetValue(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintItemListOptionDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"TrySetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.TrySetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPrintItemListOptionDetails_get_Items(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintItemListOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintItemListOptionDetails", L"Items"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Items());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrintItemListOptionDetails_get_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintItemListOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPrintItemListOptionDetails_put_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintItemListOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ErrorText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPrintItemListOptionDetails_get_OptionId(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintItemListOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"OptionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrintItemListOptionDetails_get_OptionType(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintItemListOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"OptionType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrintItemListOptionDetails_get_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintItemListOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPrintItemListOptionDetails_put_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintItemListOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::OptionDetails::PrintOptionStates>(arg);

            self->obj.State(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPrintItemListOptionDetails_get_Value(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintItemListOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IPrintItemListOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::OptionDetails::IPrintItemListOptionDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPrintItemListOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::OptionDetails::IPrintItemListOptionDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPrintItemListOptionDetails[] = {
        { "try_set_value", reinterpret_cast<PyCFunction>(IPrintItemListOptionDetails_TrySetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IPrintItemListOptionDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPrintItemListOptionDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPrintItemListOptionDetails[] = {
        { "items", reinterpret_cast<getter>(IPrintItemListOptionDetails_get_Items), nullptr, nullptr, nullptr },
        { "error_text", reinterpret_cast<getter>(IPrintItemListOptionDetails_get_ErrorText), reinterpret_cast<setter>(IPrintItemListOptionDetails_put_ErrorText), nullptr, nullptr },
        { "option_id", reinterpret_cast<getter>(IPrintItemListOptionDetails_get_OptionId), nullptr, nullptr, nullptr },
        { "option_type", reinterpret_cast<getter>(IPrintItemListOptionDetails_get_OptionType), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(IPrintItemListOptionDetails_get_State), reinterpret_cast<setter>(IPrintItemListOptionDetails_put_State), nullptr, nullptr },
        { "value", reinterpret_cast<getter>(IPrintItemListOptionDetails_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IPrintItemListOptionDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPrintItemListOptionDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPrintItemListOptionDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPrintItemListOptionDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPrintItemListOptionDetails) },
        { },
    };

    static PyType_Spec type_spec_IPrintItemListOptionDetails =
    {
        "_winsdk_Windows_Graphics_Printing_OptionDetails.IPrintItemListOptionDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintItemListOptionDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPrintItemListOptionDetails
    };

    // ----- IPrintNumberOptionDetails interface --------------------
    static constexpr const char* const type_name_IPrintNumberOptionDetails = "IPrintNumberOptionDetails";

    static PyObject* _new_IPrintNumberOptionDetails(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IPrintNumberOptionDetails);
        return nullptr;
    }

    static void _dealloc_IPrintNumberOptionDetails(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintNumberOptionDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPrintNumberOptionDetails_TrySetValue(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintNumberOptionDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"TrySetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.TrySetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPrintNumberOptionDetails_get_MaxValue(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintNumberOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintNumberOptionDetails", L"MaxValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrintNumberOptionDetails_get_MinValue(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintNumberOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintNumberOptionDetails", L"MinValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrintNumberOptionDetails_get_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintNumberOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPrintNumberOptionDetails_put_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintNumberOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ErrorText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPrintNumberOptionDetails_get_OptionId(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintNumberOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"OptionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrintNumberOptionDetails_get_OptionType(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintNumberOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"OptionType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrintNumberOptionDetails_get_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintNumberOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPrintNumberOptionDetails_put_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintNumberOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::OptionDetails::PrintOptionStates>(arg);

            self->obj.State(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPrintNumberOptionDetails_get_Value(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintNumberOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IPrintNumberOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::OptionDetails::IPrintNumberOptionDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPrintNumberOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::OptionDetails::IPrintNumberOptionDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPrintNumberOptionDetails[] = {
        { "try_set_value", reinterpret_cast<PyCFunction>(IPrintNumberOptionDetails_TrySetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IPrintNumberOptionDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPrintNumberOptionDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPrintNumberOptionDetails[] = {
        { "max_value", reinterpret_cast<getter>(IPrintNumberOptionDetails_get_MaxValue), nullptr, nullptr, nullptr },
        { "min_value", reinterpret_cast<getter>(IPrintNumberOptionDetails_get_MinValue), nullptr, nullptr, nullptr },
        { "error_text", reinterpret_cast<getter>(IPrintNumberOptionDetails_get_ErrorText), reinterpret_cast<setter>(IPrintNumberOptionDetails_put_ErrorText), nullptr, nullptr },
        { "option_id", reinterpret_cast<getter>(IPrintNumberOptionDetails_get_OptionId), nullptr, nullptr, nullptr },
        { "option_type", reinterpret_cast<getter>(IPrintNumberOptionDetails_get_OptionType), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(IPrintNumberOptionDetails_get_State), reinterpret_cast<setter>(IPrintNumberOptionDetails_put_State), nullptr, nullptr },
        { "value", reinterpret_cast<getter>(IPrintNumberOptionDetails_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IPrintNumberOptionDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPrintNumberOptionDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPrintNumberOptionDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPrintNumberOptionDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPrintNumberOptionDetails) },
        { },
    };

    static PyType_Spec type_spec_IPrintNumberOptionDetails =
    {
        "_winsdk_Windows_Graphics_Printing_OptionDetails.IPrintNumberOptionDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintNumberOptionDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPrintNumberOptionDetails
    };

    // ----- IPrintOptionDetails interface --------------------
    static constexpr const char* const type_name_IPrintOptionDetails = "IPrintOptionDetails";

    static PyObject* _new_IPrintOptionDetails(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IPrintOptionDetails);
        return nullptr;
    }

    static void _dealloc_IPrintOptionDetails(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintOptionDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPrintOptionDetails_TrySetValue(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintOptionDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"TrySetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.TrySetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPrintOptionDetails_get_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPrintOptionDetails_put_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ErrorText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPrintOptionDetails_get_OptionId(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"OptionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrintOptionDetails_get_OptionType(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"OptionType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrintOptionDetails_get_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPrintOptionDetails_put_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::OptionDetails::PrintOptionStates>(arg);

            self->obj.State(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPrintOptionDetails_get_Value(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IPrintOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::OptionDetails::IPrintOptionDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPrintOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::OptionDetails::IPrintOptionDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPrintOptionDetails[] = {
        { "try_set_value", reinterpret_cast<PyCFunction>(IPrintOptionDetails_TrySetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IPrintOptionDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPrintOptionDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPrintOptionDetails[] = {
        { "error_text", reinterpret_cast<getter>(IPrintOptionDetails_get_ErrorText), reinterpret_cast<setter>(IPrintOptionDetails_put_ErrorText), nullptr, nullptr },
        { "option_id", reinterpret_cast<getter>(IPrintOptionDetails_get_OptionId), nullptr, nullptr, nullptr },
        { "option_type", reinterpret_cast<getter>(IPrintOptionDetails_get_OptionType), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(IPrintOptionDetails_get_State), reinterpret_cast<setter>(IPrintOptionDetails_put_State), nullptr, nullptr },
        { "value", reinterpret_cast<getter>(IPrintOptionDetails_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IPrintOptionDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPrintOptionDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPrintOptionDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPrintOptionDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPrintOptionDetails) },
        { },
    };

    static PyType_Spec type_spec_IPrintOptionDetails =
    {
        "_winsdk_Windows_Graphics_Printing_OptionDetails.IPrintOptionDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintOptionDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPrintOptionDetails
    };

    // ----- IPrintTextOptionDetails interface --------------------
    static constexpr const char* const type_name_IPrintTextOptionDetails = "IPrintTextOptionDetails";

    static PyObject* _new_IPrintTextOptionDetails(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IPrintTextOptionDetails);
        return nullptr;
    }

    static void _dealloc_IPrintTextOptionDetails(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintTextOptionDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPrintTextOptionDetails_TrySetValue(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintTextOptionDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"TrySetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.TrySetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPrintTextOptionDetails_get_MaxCharacters(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintTextOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintTextOptionDetails", L"MaxCharacters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxCharacters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrintTextOptionDetails_get_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintTextOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPrintTextOptionDetails_put_ErrorText(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintTextOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ErrorText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPrintTextOptionDetails_get_OptionId(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintTextOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"OptionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrintTextOptionDetails_get_OptionType(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintTextOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"OptionType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrintTextOptionDetails_get_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintTextOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPrintTextOptionDetails_put_State(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintTextOptionDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::OptionDetails::PrintOptionStates>(arg);

            self->obj.State(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPrintTextOptionDetails_get_Value(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintTextOptionDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IPrintTextOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::OptionDetails::IPrintTextOptionDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPrintTextOptionDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::OptionDetails::IPrintTextOptionDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPrintTextOptionDetails[] = {
        { "try_set_value", reinterpret_cast<PyCFunction>(IPrintTextOptionDetails_TrySetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IPrintTextOptionDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPrintTextOptionDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPrintTextOptionDetails[] = {
        { "max_characters", reinterpret_cast<getter>(IPrintTextOptionDetails_get_MaxCharacters), nullptr, nullptr, nullptr },
        { "error_text", reinterpret_cast<getter>(IPrintTextOptionDetails_get_ErrorText), reinterpret_cast<setter>(IPrintTextOptionDetails_put_ErrorText), nullptr, nullptr },
        { "option_id", reinterpret_cast<getter>(IPrintTextOptionDetails_get_OptionId), nullptr, nullptr, nullptr },
        { "option_type", reinterpret_cast<getter>(IPrintTextOptionDetails_get_OptionType), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(IPrintTextOptionDetails_get_State), reinterpret_cast<setter>(IPrintTextOptionDetails_put_State), nullptr, nullptr },
        { "value", reinterpret_cast<getter>(IPrintTextOptionDetails_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IPrintTextOptionDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPrintTextOptionDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPrintTextOptionDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPrintTextOptionDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPrintTextOptionDetails) },
        { },
    };

    static PyType_Spec type_spec_IPrintTextOptionDetails =
    {
        "_winsdk_Windows_Graphics_Printing_OptionDetails.IPrintTextOptionDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::OptionDetails::IPrintTextOptionDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPrintTextOptionDetails
    };

    // ----- Windows.Graphics.Printing.OptionDetails Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Graphics::Printing::OptionDetails");

    static PyMethodDef module_methods[] = {
        {"_register_PrintOptionStates", register_PrintOptionStates, METH_O, "registers type"},
        {"_register_PrintOptionType", register_PrintOptionType, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_PrintOptionStates);
        Py_VISIT(state->type_PrintOptionType);
        Py_VISIT(state->type_PrintBindingOptionDetails);
        Py_VISIT(state->type_PrintBorderingOptionDetails);
        Py_VISIT(state->type_PrintCollationOptionDetails);
        Py_VISIT(state->type_PrintColorModeOptionDetails);
        Py_VISIT(state->type_PrintCopiesOptionDetails);
        Py_VISIT(state->type_PrintCustomItemDetails);
        Py_VISIT(state->type_PrintCustomItemListOptionDetails);
        Py_VISIT(state->type_PrintCustomTextOptionDetails);
        Py_VISIT(state->type_PrintCustomToggleOptionDetails);
        Py_VISIT(state->type_PrintDuplexOptionDetails);
        Py_VISIT(state->type_PrintHolePunchOptionDetails);
        Py_VISIT(state->type_PrintMediaSizeOptionDetails);
        Py_VISIT(state->type_PrintMediaTypeOptionDetails);
        Py_VISIT(state->type_PrintOrientationOptionDetails);
        Py_VISIT(state->type_PrintPageRangeOptionDetails);
        Py_VISIT(state->type_PrintQualityOptionDetails);
        Py_VISIT(state->type_PrintStapleOptionDetails);
        Py_VISIT(state->type_PrintTaskOptionChangedEventArgs);
        Py_VISIT(state->type_PrintTaskOptionDetails);
        Py_VISIT(state->type_IPrintCustomOptionDetails);
        Py_VISIT(state->type_IPrintItemListOptionDetails);
        Py_VISIT(state->type_IPrintNumberOptionDetails);
        Py_VISIT(state->type_IPrintOptionDetails);
        Py_VISIT(state->type_IPrintTextOptionDetails);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_PrintOptionStates);
        Py_CLEAR(state->type_PrintOptionType);
        Py_CLEAR(state->type_PrintBindingOptionDetails);
        Py_CLEAR(state->type_PrintBorderingOptionDetails);
        Py_CLEAR(state->type_PrintCollationOptionDetails);
        Py_CLEAR(state->type_PrintColorModeOptionDetails);
        Py_CLEAR(state->type_PrintCopiesOptionDetails);
        Py_CLEAR(state->type_PrintCustomItemDetails);
        Py_CLEAR(state->type_PrintCustomItemListOptionDetails);
        Py_CLEAR(state->type_PrintCustomTextOptionDetails);
        Py_CLEAR(state->type_PrintCustomToggleOptionDetails);
        Py_CLEAR(state->type_PrintDuplexOptionDetails);
        Py_CLEAR(state->type_PrintHolePunchOptionDetails);
        Py_CLEAR(state->type_PrintMediaSizeOptionDetails);
        Py_CLEAR(state->type_PrintMediaTypeOptionDetails);
        Py_CLEAR(state->type_PrintOrientationOptionDetails);
        Py_CLEAR(state->type_PrintPageRangeOptionDetails);
        Py_CLEAR(state->type_PrintQualityOptionDetails);
        Py_CLEAR(state->type_PrintStapleOptionDetails);
        Py_CLEAR(state->type_PrintTaskOptionChangedEventArgs);
        Py_CLEAR(state->type_PrintTaskOptionDetails);
        Py_CLEAR(state->type_IPrintCustomOptionDetails);
        Py_CLEAR(state->type_IPrintItemListOptionDetails);
        Py_CLEAR(state->type_IPrintNumberOptionDetails);
        Py_CLEAR(state->type_IPrintOptionDetails);
        Py_CLEAR(state->type_IPrintTextOptionDetails);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Graphics_Printing_OptionDetails",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Graphics::Printing::OptionDetails

PyMODINIT_FUNC PyInit__winsdk_Windows_Graphics_Printing_OptionDetails(void) noexcept
{
    using namespace py::cpp::Windows::Graphics::Printing::OptionDetails;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_PrintBindingOptionDetails = py::register_python_type(module.get(), type_name_PrintBindingOptionDetails, &type_spec_PrintBindingOptionDetails, bases.get(), nullptr);
    if (!state->type_PrintBindingOptionDetails)
    {
        return nullptr;
    }

    state->type_PrintBorderingOptionDetails = py::register_python_type(module.get(), type_name_PrintBorderingOptionDetails, &type_spec_PrintBorderingOptionDetails, bases.get(), nullptr);
    if (!state->type_PrintBorderingOptionDetails)
    {
        return nullptr;
    }

    state->type_PrintCollationOptionDetails = py::register_python_type(module.get(), type_name_PrintCollationOptionDetails, &type_spec_PrintCollationOptionDetails, bases.get(), nullptr);
    if (!state->type_PrintCollationOptionDetails)
    {
        return nullptr;
    }

    state->type_PrintColorModeOptionDetails = py::register_python_type(module.get(), type_name_PrintColorModeOptionDetails, &type_spec_PrintColorModeOptionDetails, bases.get(), nullptr);
    if (!state->type_PrintColorModeOptionDetails)
    {
        return nullptr;
    }

    state->type_PrintCopiesOptionDetails = py::register_python_type(module.get(), type_name_PrintCopiesOptionDetails, &type_spec_PrintCopiesOptionDetails, bases.get(), nullptr);
    if (!state->type_PrintCopiesOptionDetails)
    {
        return nullptr;
    }

    state->type_PrintCustomItemDetails = py::register_python_type(module.get(), type_name_PrintCustomItemDetails, &type_spec_PrintCustomItemDetails, bases.get(), nullptr);
    if (!state->type_PrintCustomItemDetails)
    {
        return nullptr;
    }

    state->type_PrintCustomItemListOptionDetails = py::register_python_type(module.get(), type_name_PrintCustomItemListOptionDetails, &type_spec_PrintCustomItemListOptionDetails, bases.get(), nullptr);
    if (!state->type_PrintCustomItemListOptionDetails)
    {
        return nullptr;
    }

    state->type_PrintCustomTextOptionDetails = py::register_python_type(module.get(), type_name_PrintCustomTextOptionDetails, &type_spec_PrintCustomTextOptionDetails, bases.get(), nullptr);
    if (!state->type_PrintCustomTextOptionDetails)
    {
        return nullptr;
    }

    state->type_PrintCustomToggleOptionDetails = py::register_python_type(module.get(), type_name_PrintCustomToggleOptionDetails, &type_spec_PrintCustomToggleOptionDetails, bases.get(), nullptr);
    if (!state->type_PrintCustomToggleOptionDetails)
    {
        return nullptr;
    }

    state->type_PrintDuplexOptionDetails = py::register_python_type(module.get(), type_name_PrintDuplexOptionDetails, &type_spec_PrintDuplexOptionDetails, bases.get(), nullptr);
    if (!state->type_PrintDuplexOptionDetails)
    {
        return nullptr;
    }

    state->type_PrintHolePunchOptionDetails = py::register_python_type(module.get(), type_name_PrintHolePunchOptionDetails, &type_spec_PrintHolePunchOptionDetails, bases.get(), nullptr);
    if (!state->type_PrintHolePunchOptionDetails)
    {
        return nullptr;
    }

    state->type_PrintMediaSizeOptionDetails = py::register_python_type(module.get(), type_name_PrintMediaSizeOptionDetails, &type_spec_PrintMediaSizeOptionDetails, bases.get(), nullptr);
    if (!state->type_PrintMediaSizeOptionDetails)
    {
        return nullptr;
    }

    state->type_PrintMediaTypeOptionDetails = py::register_python_type(module.get(), type_name_PrintMediaTypeOptionDetails, &type_spec_PrintMediaTypeOptionDetails, bases.get(), nullptr);
    if (!state->type_PrintMediaTypeOptionDetails)
    {
        return nullptr;
    }

    state->type_PrintOrientationOptionDetails = py::register_python_type(module.get(), type_name_PrintOrientationOptionDetails, &type_spec_PrintOrientationOptionDetails, bases.get(), nullptr);
    if (!state->type_PrintOrientationOptionDetails)
    {
        return nullptr;
    }

    state->type_PrintPageRangeOptionDetails = py::register_python_type(module.get(), type_name_PrintPageRangeOptionDetails, &type_spec_PrintPageRangeOptionDetails, bases.get(), nullptr);
    if (!state->type_PrintPageRangeOptionDetails)
    {
        return nullptr;
    }

    state->type_PrintQualityOptionDetails = py::register_python_type(module.get(), type_name_PrintQualityOptionDetails, &type_spec_PrintQualityOptionDetails, bases.get(), nullptr);
    if (!state->type_PrintQualityOptionDetails)
    {
        return nullptr;
    }

    state->type_PrintStapleOptionDetails = py::register_python_type(module.get(), type_name_PrintStapleOptionDetails, &type_spec_PrintStapleOptionDetails, bases.get(), nullptr);
    if (!state->type_PrintStapleOptionDetails)
    {
        return nullptr;
    }

    state->type_PrintTaskOptionChangedEventArgs = py::register_python_type(module.get(), type_name_PrintTaskOptionChangedEventArgs, &type_spec_PrintTaskOptionChangedEventArgs, bases.get(), nullptr);
    if (!state->type_PrintTaskOptionChangedEventArgs)
    {
        return nullptr;
    }

    state->type_PrintTaskOptionDetails = py::register_python_type(module.get(), type_name_PrintTaskOptionDetails, &type_spec_PrintTaskOptionDetails, bases.get(), nullptr);
    if (!state->type_PrintTaskOptionDetails)
    {
        return nullptr;
    }

    state->type_IPrintCustomOptionDetails = py::register_python_type(module.get(), type_name_IPrintCustomOptionDetails, &type_spec_IPrintCustomOptionDetails, bases.get(), nullptr);
    if (!state->type_IPrintCustomOptionDetails)
    {
        return nullptr;
    }

    state->type_IPrintItemListOptionDetails = py::register_python_type(module.get(), type_name_IPrintItemListOptionDetails, &type_spec_IPrintItemListOptionDetails, bases.get(), nullptr);
    if (!state->type_IPrintItemListOptionDetails)
    {
        return nullptr;
    }

    state->type_IPrintNumberOptionDetails = py::register_python_type(module.get(), type_name_IPrintNumberOptionDetails, &type_spec_IPrintNumberOptionDetails, bases.get(), nullptr);
    if (!state->type_IPrintNumberOptionDetails)
    {
        return nullptr;
    }

    state->type_IPrintOptionDetails = py::register_python_type(module.get(), type_name_IPrintOptionDetails, &type_spec_IPrintOptionDetails, bases.get(), nullptr);
    if (!state->type_IPrintOptionDetails)
    {
        return nullptr;
    }

    state->type_IPrintTextOptionDetails = py::register_python_type(module.get(), type_name_IPrintTextOptionDetails, &type_spec_IPrintTextOptionDetails, bases.get(), nullptr);
    if (!state->type_IPrintTextOptionDetails)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Graphics::Printing::OptionDetails::PrintOptionStates>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Printing::OptionDetails;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Printing::OptionDetails");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PrintOptionStates;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Printing::OptionDetails::PrintOptionStates is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Graphics::Printing::OptionDetails::PrintOptionType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Printing::OptionDetails;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Printing::OptionDetails");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PrintOptionType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Printing::OptionDetails::PrintOptionType is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Printing::OptionDetails::PrintBindingOptionDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Printing::OptionDetails;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Printing::OptionDetails");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PrintBindingOptionDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Printing::OptionDetails::PrintBindingOptionDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Printing::OptionDetails::PrintBorderingOptionDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Printing::OptionDetails;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Printing::OptionDetails");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PrintBorderingOptionDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Printing::OptionDetails::PrintBorderingOptionDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Printing::OptionDetails::PrintCollationOptionDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Printing::OptionDetails;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Printing::OptionDetails");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PrintCollationOptionDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Printing::OptionDetails::PrintCollationOptionDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Printing::OptionDetails::PrintColorModeOptionDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Printing::OptionDetails;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Printing::OptionDetails");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PrintColorModeOptionDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Printing::OptionDetails::PrintColorModeOptionDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Printing::OptionDetails::PrintCopiesOptionDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Printing::OptionDetails;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Printing::OptionDetails");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PrintCopiesOptionDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Printing::OptionDetails::PrintCopiesOptionDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Printing::OptionDetails::PrintCustomItemDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Printing::OptionDetails;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Printing::OptionDetails");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PrintCustomItemDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Printing::OptionDetails::PrintCustomItemDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Printing::OptionDetails::PrintCustomItemListOptionDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Printing::OptionDetails;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Printing::OptionDetails");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PrintCustomItemListOptionDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Printing::OptionDetails::PrintCustomItemListOptionDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Printing::OptionDetails::PrintCustomTextOptionDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Printing::OptionDetails;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Printing::OptionDetails");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PrintCustomTextOptionDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Printing::OptionDetails::PrintCustomTextOptionDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Printing::OptionDetails::PrintCustomToggleOptionDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Printing::OptionDetails;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Printing::OptionDetails");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PrintCustomToggleOptionDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Printing::OptionDetails::PrintCustomToggleOptionDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Printing::OptionDetails::PrintDuplexOptionDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Printing::OptionDetails;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Printing::OptionDetails");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PrintDuplexOptionDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Printing::OptionDetails::PrintDuplexOptionDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Printing::OptionDetails::PrintHolePunchOptionDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Printing::OptionDetails;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Printing::OptionDetails");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PrintHolePunchOptionDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Printing::OptionDetails::PrintHolePunchOptionDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Printing::OptionDetails::PrintMediaSizeOptionDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Printing::OptionDetails;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Printing::OptionDetails");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PrintMediaSizeOptionDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Printing::OptionDetails::PrintMediaSizeOptionDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Printing::OptionDetails::PrintMediaTypeOptionDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Printing::OptionDetails;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Printing::OptionDetails");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PrintMediaTypeOptionDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Printing::OptionDetails::PrintMediaTypeOptionDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Printing::OptionDetails::PrintOrientationOptionDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Printing::OptionDetails;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Printing::OptionDetails");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PrintOrientationOptionDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Printing::OptionDetails::PrintOrientationOptionDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Printing::OptionDetails::PrintPageRangeOptionDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Printing::OptionDetails;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Printing::OptionDetails");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PrintPageRangeOptionDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Printing::OptionDetails::PrintPageRangeOptionDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Printing::OptionDetails::PrintQualityOptionDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Printing::OptionDetails;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Printing::OptionDetails");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PrintQualityOptionDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Printing::OptionDetails::PrintQualityOptionDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Printing::OptionDetails::PrintStapleOptionDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Printing::OptionDetails;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Printing::OptionDetails");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PrintStapleOptionDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Printing::OptionDetails::PrintStapleOptionDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Printing::OptionDetails::PrintTaskOptionChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Printing::OptionDetails;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Printing::OptionDetails");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PrintTaskOptionChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Printing::OptionDetails::PrintTaskOptionChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Printing::OptionDetails::PrintTaskOptionDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Printing::OptionDetails;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Printing::OptionDetails");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PrintTaskOptionDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Printing::OptionDetails::PrintTaskOptionDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Printing::OptionDetails::IPrintCustomOptionDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Printing::OptionDetails;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Printing::OptionDetails");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IPrintCustomOptionDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Printing::OptionDetails::IPrintCustomOptionDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Printing::OptionDetails::IPrintItemListOptionDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Printing::OptionDetails;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Printing::OptionDetails");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IPrintItemListOptionDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Printing::OptionDetails::IPrintItemListOptionDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Printing::OptionDetails::IPrintNumberOptionDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Printing::OptionDetails;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Printing::OptionDetails");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IPrintNumberOptionDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Printing::OptionDetails::IPrintNumberOptionDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Printing::OptionDetails::IPrintOptionDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Printing::OptionDetails;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Printing::OptionDetails");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IPrintOptionDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Printing::OptionDetails::IPrintOptionDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Printing::OptionDetails::IPrintTextOptionDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Printing::OptionDetails;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Printing::OptionDetails");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IPrintTextOptionDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Printing::OptionDetails::IPrintTextOptionDetails is not registered");
        return nullptr;
    }

    return python_type;
}
