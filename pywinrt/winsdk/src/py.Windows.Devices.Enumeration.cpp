// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.Devices.Enumeration.h"


namespace py::cpp::Windows::Devices::Enumeration
{
    struct module_state
    {
        PyObject* type_DeviceAccessStatus;
        PyObject* type_DeviceClass;
        PyObject* type_DeviceInformationKind;
        PyObject* type_DevicePairingKinds;
        PyObject* type_DevicePairingProtectionLevel;
        PyObject* type_DevicePairingResultStatus;
        PyObject* type_DevicePickerDisplayStatusOptions;
        PyObject* type_DeviceUnpairingResultStatus;
        PyObject* type_DeviceWatcherEventKind;
        PyObject* type_DeviceWatcherStatus;
        PyObject* type_Panel;
        PyTypeObject* type_DeviceAccessChangedEventArgs;
        PyTypeObject* type_DeviceAccessInformation;
        PyTypeObject* type_DeviceConnectionChangeTriggerDetails;
        PyTypeObject* type_DeviceDisconnectButtonClickedEventArgs;
        PyTypeObject* type_DeviceInformation;
        PyTypeObject* type_DeviceInformationCollection;
        PyTypeObject* type_DeviceInformationCustomPairing;
        PyTypeObject* type_DeviceInformationPairing;
        PyTypeObject* type_DeviceInformationUpdate;
        PyTypeObject* type_DevicePairingRequestedEventArgs;
        PyTypeObject* type_DevicePairingResult;
        PyTypeObject* type_DevicePicker;
        PyTypeObject* type_DevicePickerAppearance;
        PyTypeObject* type_DevicePickerFilter;
        PyTypeObject* type_DeviceSelectedEventArgs;
        PyTypeObject* type_DeviceThumbnail;
        PyTypeObject* type_DeviceUnpairingResult;
        PyTypeObject* type_DeviceWatcher;
        PyTypeObject* type_DeviceWatcherEvent;
        PyTypeObject* type_DeviceWatcherTriggerDetails;
        PyTypeObject* type_EnclosureLocation;
        PyTypeObject* type_IDevicePairingSettings;
    };

    static PyObject* register_DeviceAccessStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DeviceAccessStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DeviceAccessStatus = type;
        Py_INCREF(state->type_DeviceAccessStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_DeviceClass(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DeviceClass)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DeviceClass = type;
        Py_INCREF(state->type_DeviceClass);


        Py_RETURN_NONE;
    }

    static PyObject* register_DeviceInformationKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DeviceInformationKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DeviceInformationKind = type;
        Py_INCREF(state->type_DeviceInformationKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_DevicePairingKinds(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DevicePairingKinds)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DevicePairingKinds = type;
        Py_INCREF(state->type_DevicePairingKinds);


        Py_RETURN_NONE;
    }

    static PyObject* register_DevicePairingProtectionLevel(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DevicePairingProtectionLevel)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DevicePairingProtectionLevel = type;
        Py_INCREF(state->type_DevicePairingProtectionLevel);


        Py_RETURN_NONE;
    }

    static PyObject* register_DevicePairingResultStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DevicePairingResultStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DevicePairingResultStatus = type;
        Py_INCREF(state->type_DevicePairingResultStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_DevicePickerDisplayStatusOptions(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DevicePickerDisplayStatusOptions)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DevicePickerDisplayStatusOptions = type;
        Py_INCREF(state->type_DevicePickerDisplayStatusOptions);


        Py_RETURN_NONE;
    }

    static PyObject* register_DeviceUnpairingResultStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DeviceUnpairingResultStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DeviceUnpairingResultStatus = type;
        Py_INCREF(state->type_DeviceUnpairingResultStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_DeviceWatcherEventKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DeviceWatcherEventKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DeviceWatcherEventKind = type;
        Py_INCREF(state->type_DeviceWatcherEventKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_DeviceWatcherStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DeviceWatcherStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DeviceWatcherStatus = type;
        Py_INCREF(state->type_DeviceWatcherStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_Panel(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_Panel)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_Panel = type;
        Py_INCREF(state->type_Panel);


        Py_RETURN_NONE;
    }

    // ----- DeviceAccessChangedEventArgs class --------------------
    static constexpr const char* const type_name_DeviceAccessChangedEventArgs = "DeviceAccessChangedEventArgs";

    static PyObject* _new_DeviceAccessChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DeviceAccessChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_DeviceAccessChangedEventArgs(py::wrapper::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceAccessChangedEventArgs_get_Status(py::wrapper::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceAccessChangedEventArgs", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceAccessChangedEventArgs_get_Id(py::wrapper::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceAccessChangedEventArgs", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceAccessChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceAccessChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceAccessChangedEventArgs[] = {
        { "_assign_array_", _assign_array_DeviceAccessChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceAccessChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceAccessChangedEventArgs[] = {
        { "status", reinterpret_cast<getter>(DeviceAccessChangedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(DeviceAccessChangedEventArgs_get_Id), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceAccessChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceAccessChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceAccessChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceAccessChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceAccessChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DeviceAccessChangedEventArgs =
    {
        "_winsdk_Windows_Devices_Enumeration.DeviceAccessChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceAccessChangedEventArgs
    };

    // ----- DeviceAccessInformation class --------------------
    static constexpr const char* const type_name_DeviceAccessInformation = "DeviceAccessInformation";

    static PyObject* _new_DeviceAccessInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DeviceAccessInformation);
        return nullptr;
    }

    static void _dealloc_DeviceAccessInformation(py::wrapper::Windows::Devices::Enumeration::DeviceAccessInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceAccessInformation_CreateFromDeviceClass(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceAccessInformation", L"CreateFromDeviceClass", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceClass>(args, 0);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceAccessInformation::CreateFromDeviceClass(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceAccessInformation_CreateFromDeviceClassId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceAccessInformation", L"CreateFromDeviceClassId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceAccessInformation::CreateFromDeviceClassId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceAccessInformation_CreateFromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceAccessInformation", L"CreateFromId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceAccessInformation::CreateFromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceAccessInformation_get_CurrentStatus(py::wrapper::Windows::Devices::Enumeration::DeviceAccessInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceAccessInformation", L"CurrentStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceAccessInformation_add_AccessChanged(py::wrapper::Windows::Devices::Enumeration::DeviceAccessInformation* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceAccessInformation", L"AccessChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DeviceAccessInformation, winrt::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs>>(arg);

            return py::convert(self->obj.AccessChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceAccessInformation_remove_AccessChanged(py::wrapper::Windows::Devices::Enumeration::DeviceAccessInformation* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceAccessInformation", L"AccessChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AccessChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceAccessInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceAccessInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceAccessInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceAccessInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceAccessInformation[] = {
        { "create_from_device_class", reinterpret_cast<PyCFunction>(DeviceAccessInformation_CreateFromDeviceClass), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_device_class_id", reinterpret_cast<PyCFunction>(DeviceAccessInformation_CreateFromDeviceClassId), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_id", reinterpret_cast<PyCFunction>(DeviceAccessInformation_CreateFromId), METH_VARARGS | METH_STATIC, nullptr },
        { "add_access_changed", reinterpret_cast<PyCFunction>(DeviceAccessInformation_add_AccessChanged), METH_O, nullptr },
        { "remove_access_changed", reinterpret_cast<PyCFunction>(DeviceAccessInformation_remove_AccessChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_DeviceAccessInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceAccessInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceAccessInformation[] = {
        { "current_status", reinterpret_cast<getter>(DeviceAccessInformation_get_CurrentStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceAccessInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceAccessInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceAccessInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceAccessInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceAccessInformation) },
        { },
    };

    static PyType_Spec type_spec_DeviceAccessInformation =
    {
        "_winsdk_Windows_Devices_Enumeration.DeviceAccessInformation",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceAccessInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceAccessInformation
    };

    // ----- DeviceConnectionChangeTriggerDetails class --------------------
    static constexpr const char* const type_name_DeviceConnectionChangeTriggerDetails = "DeviceConnectionChangeTriggerDetails";

    static PyObject* _new_DeviceConnectionChangeTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DeviceConnectionChangeTriggerDetails);
        return nullptr;
    }

    static void _dealloc_DeviceConnectionChangeTriggerDetails(py::wrapper::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceConnectionChangeTriggerDetails_get_DeviceId(py::wrapper::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceConnectionChangeTriggerDetails", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceConnectionChangeTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceConnectionChangeTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceConnectionChangeTriggerDetails[] = {
        { "_assign_array_", _assign_array_DeviceConnectionChangeTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceConnectionChangeTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceConnectionChangeTriggerDetails[] = {
        { "device_id", reinterpret_cast<getter>(DeviceConnectionChangeTriggerDetails_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceConnectionChangeTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceConnectionChangeTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceConnectionChangeTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceConnectionChangeTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceConnectionChangeTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_DeviceConnectionChangeTriggerDetails =
    {
        "_winsdk_Windows_Devices_Enumeration.DeviceConnectionChangeTriggerDetails",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceConnectionChangeTriggerDetails
    };

    // ----- DeviceDisconnectButtonClickedEventArgs class --------------------
    static constexpr const char* const type_name_DeviceDisconnectButtonClickedEventArgs = "DeviceDisconnectButtonClickedEventArgs";

    static PyObject* _new_DeviceDisconnectButtonClickedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DeviceDisconnectButtonClickedEventArgs);
        return nullptr;
    }

    static void _dealloc_DeviceDisconnectButtonClickedEventArgs(py::wrapper::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceDisconnectButtonClickedEventArgs_get_Device(py::wrapper::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceDisconnectButtonClickedEventArgs", L"Device"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Device());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceDisconnectButtonClickedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceDisconnectButtonClickedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceDisconnectButtonClickedEventArgs[] = {
        { "_assign_array_", _assign_array_DeviceDisconnectButtonClickedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceDisconnectButtonClickedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceDisconnectButtonClickedEventArgs[] = {
        { "device", reinterpret_cast<getter>(DeviceDisconnectButtonClickedEventArgs_get_Device), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceDisconnectButtonClickedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceDisconnectButtonClickedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceDisconnectButtonClickedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceDisconnectButtonClickedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceDisconnectButtonClickedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DeviceDisconnectButtonClickedEventArgs =
    {
        "_winsdk_Windows_Devices_Enumeration.DeviceDisconnectButtonClickedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceDisconnectButtonClickedEventArgs
    };

    // ----- DeviceInformation class --------------------
    static constexpr const char* const type_name_DeviceInformation = "DeviceInformation";

    static PyObject* _new_DeviceInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DeviceInformation);
        return nullptr;
    }

    static void _dealloc_DeviceInformation(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceInformation_CreateFromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"CreateFromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::CreateFromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"CreateFromIdAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::CreateFromIdAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"CreateFromIdAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformationKind>(args, 2);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::CreateFromIdAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_CreateWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"CreateWatcher", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::CreateWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"CreateWatcher", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceClass>(args, 0);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::CreateWatcher(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"CreateWatcher", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::CreateWatcher(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"CreateWatcher", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformationKind>(args, 2);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::CreateWatcher(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_FindAllAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"FindAllAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::FindAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"FindAllAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceClass>(args, 0);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::FindAllAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"FindAllAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::FindAllAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"FindAllAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformationKind>(args, 2);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::FindAllAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_GetAqsFilterFromDeviceClass(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"GetAqsFilterFromDeviceClass", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceClass>(args, 0);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::GetAqsFilterFromDeviceClass(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_GetGlyphThumbnailAsync(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"GetGlyphThumbnailAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetGlyphThumbnailAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_GetThumbnailAsync(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"GetThumbnailAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetThumbnailAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_Update(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"Update", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformationUpdate>(args, 0);

                self->obj.Update(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_get_EnclosureLocation(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"EnclosureLocation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EnclosureLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_get_Id(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_get_IsDefault(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"IsDefault"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDefault());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_get_IsEnabled(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_get_Name(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_get_Properties(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_get_Kind(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_get_Pairing(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"Pairing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pairing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceInformation[] = {
        { "create_from_id_async", reinterpret_cast<PyCFunction>(DeviceInformation_CreateFromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "create_watcher", reinterpret_cast<PyCFunction>(DeviceInformation_CreateWatcher), METH_VARARGS | METH_STATIC, nullptr },
        { "find_all_async", reinterpret_cast<PyCFunction>(DeviceInformation_FindAllAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_aqs_filter_from_device_class", reinterpret_cast<PyCFunction>(DeviceInformation_GetAqsFilterFromDeviceClass), METH_VARARGS | METH_STATIC, nullptr },
        { "get_glyph_thumbnail_async", reinterpret_cast<PyCFunction>(DeviceInformation_GetGlyphThumbnailAsync), METH_VARARGS, nullptr },
        { "get_thumbnail_async", reinterpret_cast<PyCFunction>(DeviceInformation_GetThumbnailAsync), METH_VARARGS, nullptr },
        { "update", reinterpret_cast<PyCFunction>(DeviceInformation_Update), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DeviceInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceInformation[] = {
        { "enclosure_location", reinterpret_cast<getter>(DeviceInformation_get_EnclosureLocation), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(DeviceInformation_get_Id), nullptr, nullptr, nullptr },
        { "is_default", reinterpret_cast<getter>(DeviceInformation_get_IsDefault), nullptr, nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(DeviceInformation_get_IsEnabled), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(DeviceInformation_get_Name), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DeviceInformation_get_Properties), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(DeviceInformation_get_Kind), nullptr, nullptr, nullptr },
        { "pairing", reinterpret_cast<getter>(DeviceInformation_get_Pairing), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceInformation) },
        { },
    };

    static PyType_Spec type_spec_DeviceInformation =
    {
        "_winsdk_Windows_Devices_Enumeration.DeviceInformation",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceInformation
    };

    // ----- DeviceInformationCollection class --------------------
    static constexpr const char* const type_name_DeviceInformationCollection = "DeviceInformationCollection";

    static PyObject* _new_DeviceInformationCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DeviceInformationCollection);
        return nullptr;
    }

    static void _dealloc_DeviceInformationCollection(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceInformationCollection_First(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformationCollection", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformationCollection_GetAt(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformationCollection", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformationCollection_GetMany(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformationCollection", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Devices::Enumeration::DeviceInformation, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformationCollection_IndexOf(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformationCollection", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformationCollection_get_Size(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformationCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceInformationCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceInformationCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceInformationCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceInformationCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_DeviceInformationCollection(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_DeviceInformationCollection(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_DeviceInformationCollection(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_DeviceInformationCollection(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_DeviceInformationCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::Devices::Enumeration::DeviceInformation> items(length, empty_instance<winrt::Windows::Devices::Enumeration::DeviceInformation>::get());

            auto count = self->obj.GetMany(start, items);

            if (count != length)
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformationCollection_get_insert(PyObject* self) noexcept
    {
        return PyObject_GetAttrString(self, "insert_at");
    }

    static PyMethodDef _methods_DeviceInformationCollection[] = {
        { "first", reinterpret_cast<PyCFunction>(DeviceInformationCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(DeviceInformationCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(DeviceInformationCollection_GetMany), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(DeviceInformationCollection_IndexOf), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DeviceInformationCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceInformationCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceInformationCollection[] = {
        { "size", reinterpret_cast<getter>(DeviceInformationCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceInformationCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceInformationCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceInformationCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceInformationCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceInformationCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_DeviceInformationCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_DeviceInformationCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_DeviceInformationCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_DeviceInformationCollection) },
        { },
    };

    static PyType_Spec type_spec_DeviceInformationCollection =
    {
        "_winsdk_Windows_Devices_Enumeration.DeviceInformationCollection",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceInformationCollection
    };

    // ----- DeviceInformationCustomPairing class --------------------
    static constexpr const char* const type_name_DeviceInformationCustomPairing = "DeviceInformationCustomPairing";

    static PyObject* _new_DeviceInformationCustomPairing(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DeviceInformationCustomPairing);
        return nullptr;
    }

    static void _dealloc_DeviceInformationCustomPairing(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCustomPairing* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceInformationCustomPairing_PairAsync(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCustomPairing* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformationCustomPairing", L"PairAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingKinds>(args, 0);

                return py::convert(self->obj.PairAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformationCustomPairing", L"PairAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingKinds>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingProtectionLevel>(args, 1);

                return py::convert(self->obj.PairAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformationCustomPairing", L"PairAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingKinds>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingProtectionLevel>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Enumeration::IDevicePairingSettings>(args, 2);

                return py::convert(self->obj.PairAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformationCustomPairing_add_PairingRequested(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCustomPairing* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceInformationCustomPairing", L"PairingRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DeviceInformationCustomPairing, winrt::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs>>(arg);

            return py::convert(self->obj.PairingRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformationCustomPairing_remove_PairingRequested(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCustomPairing* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceInformationCustomPairing", L"PairingRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PairingRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceInformationCustomPairing(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceInformationCustomPairing>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceInformationCustomPairing(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceInformationCustomPairing>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceInformationCustomPairing[] = {
        { "pair_async", reinterpret_cast<PyCFunction>(DeviceInformationCustomPairing_PairAsync), METH_VARARGS, nullptr },
        { "add_pairing_requested", reinterpret_cast<PyCFunction>(DeviceInformationCustomPairing_add_PairingRequested), METH_O, nullptr },
        { "remove_pairing_requested", reinterpret_cast<PyCFunction>(DeviceInformationCustomPairing_remove_PairingRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_DeviceInformationCustomPairing, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceInformationCustomPairing), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceInformationCustomPairing[] = {
        { }
    };

    static PyType_Slot _type_slots_DeviceInformationCustomPairing[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceInformationCustomPairing) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceInformationCustomPairing) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceInformationCustomPairing) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceInformationCustomPairing) },
        { },
    };

    static PyType_Spec type_spec_DeviceInformationCustomPairing =
    {
        "_winsdk_Windows_Devices_Enumeration.DeviceInformationCustomPairing",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCustomPairing),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceInformationCustomPairing
    };

    // ----- DeviceInformationPairing class --------------------
    static constexpr const char* const type_name_DeviceInformationPairing = "DeviceInformationPairing";

    static PyObject* _new_DeviceInformationPairing(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DeviceInformationPairing);
        return nullptr;
    }

    static void _dealloc_DeviceInformationPairing(py::wrapper::Windows::Devices::Enumeration::DeviceInformationPairing* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceInformationPairing_PairAsync(py::wrapper::Windows::Devices::Enumeration::DeviceInformationPairing* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformationPairing", L"PairAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.PairAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformationPairing", L"PairAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingProtectionLevel>(args, 0);

                return py::convert(self->obj.PairAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformationPairing", L"PairAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingProtectionLevel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Enumeration::IDevicePairingSettings>(args, 1);

                return py::convert(self->obj.PairAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformationPairing_TryRegisterForAllInboundPairingRequests(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformationPairing", L"TryRegisterForAllInboundPairingRequests", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingKinds>(args, 0);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformationPairing::TryRegisterForAllInboundPairingRequests(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformationPairing_TryRegisterForAllInboundPairingRequestsWithProtectionLevel(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformationPairing", L"TryRegisterForAllInboundPairingRequestsWithProtectionLevel", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingKinds>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingProtectionLevel>(args, 1);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformationPairing::TryRegisterForAllInboundPairingRequestsWithProtectionLevel(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformationPairing_UnpairAsync(py::wrapper::Windows::Devices::Enumeration::DeviceInformationPairing* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformationPairing", L"UnpairAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.UnpairAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformationPairing_get_CanPair(py::wrapper::Windows::Devices::Enumeration::DeviceInformationPairing* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformationPairing", L"CanPair"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanPair());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformationPairing_get_IsPaired(py::wrapper::Windows::Devices::Enumeration::DeviceInformationPairing* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformationPairing", L"IsPaired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPaired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformationPairing_get_Custom(py::wrapper::Windows::Devices::Enumeration::DeviceInformationPairing* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformationPairing", L"Custom"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Custom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformationPairing_get_ProtectionLevel(py::wrapper::Windows::Devices::Enumeration::DeviceInformationPairing* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformationPairing", L"ProtectionLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceInformationPairing(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceInformationPairing>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceInformationPairing(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceInformationPairing>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceInformationPairing[] = {
        { "pair_async", reinterpret_cast<PyCFunction>(DeviceInformationPairing_PairAsync), METH_VARARGS, nullptr },
        { "try_register_for_all_inbound_pairing_requests", reinterpret_cast<PyCFunction>(DeviceInformationPairing_TryRegisterForAllInboundPairingRequests), METH_VARARGS | METH_STATIC, nullptr },
        { "try_register_for_all_inbound_pairing_requests_with_protection_level", reinterpret_cast<PyCFunction>(DeviceInformationPairing_TryRegisterForAllInboundPairingRequestsWithProtectionLevel), METH_VARARGS | METH_STATIC, nullptr },
        { "unpair_async", reinterpret_cast<PyCFunction>(DeviceInformationPairing_UnpairAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DeviceInformationPairing, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceInformationPairing), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceInformationPairing[] = {
        { "can_pair", reinterpret_cast<getter>(DeviceInformationPairing_get_CanPair), nullptr, nullptr, nullptr },
        { "is_paired", reinterpret_cast<getter>(DeviceInformationPairing_get_IsPaired), nullptr, nullptr, nullptr },
        { "custom", reinterpret_cast<getter>(DeviceInformationPairing_get_Custom), nullptr, nullptr, nullptr },
        { "protection_level", reinterpret_cast<getter>(DeviceInformationPairing_get_ProtectionLevel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceInformationPairing[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceInformationPairing) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceInformationPairing) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceInformationPairing) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceInformationPairing) },
        { },
    };

    static PyType_Spec type_spec_DeviceInformationPairing =
    {
        "_winsdk_Windows_Devices_Enumeration.DeviceInformationPairing",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceInformationPairing),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceInformationPairing
    };

    // ----- DeviceInformationUpdate class --------------------
    static constexpr const char* const type_name_DeviceInformationUpdate = "DeviceInformationUpdate";

    static PyObject* _new_DeviceInformationUpdate(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DeviceInformationUpdate);
        return nullptr;
    }

    static void _dealloc_DeviceInformationUpdate(py::wrapper::Windows::Devices::Enumeration::DeviceInformationUpdate* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceInformationUpdate_get_Id(py::wrapper::Windows::Devices::Enumeration::DeviceInformationUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformationUpdate", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformationUpdate_get_Properties(py::wrapper::Windows::Devices::Enumeration::DeviceInformationUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformationUpdate", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformationUpdate_get_Kind(py::wrapper::Windows::Devices::Enumeration::DeviceInformationUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformationUpdate", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceInformationUpdate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceInformationUpdate>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceInformationUpdate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceInformationUpdate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceInformationUpdate[] = {
        { "_assign_array_", _assign_array_DeviceInformationUpdate, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceInformationUpdate), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceInformationUpdate[] = {
        { "id", reinterpret_cast<getter>(DeviceInformationUpdate_get_Id), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DeviceInformationUpdate_get_Properties), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(DeviceInformationUpdate_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceInformationUpdate[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceInformationUpdate) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceInformationUpdate) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceInformationUpdate) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceInformationUpdate) },
        { },
    };

    static PyType_Spec type_spec_DeviceInformationUpdate =
    {
        "_winsdk_Windows_Devices_Enumeration.DeviceInformationUpdate",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceInformationUpdate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceInformationUpdate
    };

    // ----- DevicePairingRequestedEventArgs class --------------------
    static constexpr const char* const type_name_DevicePairingRequestedEventArgs = "DevicePairingRequestedEventArgs";

    static PyObject* _new_DevicePairingRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DevicePairingRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_DevicePairingRequestedEventArgs(py::wrapper::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DevicePairingRequestedEventArgs_Accept(py::wrapper::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DevicePairingRequestedEventArgs", L"Accept", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Accept();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DevicePairingRequestedEventArgs", L"Accept", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Accept(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DevicePairingRequestedEventArgs_AcceptWithPasswordCredential(py::wrapper::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DevicePairingRequestedEventArgs", L"AcceptWithPasswordCredential", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(args, 0);

                self->obj.AcceptWithPasswordCredential(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DevicePairingRequestedEventArgs_GetDeferral(py::wrapper::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DevicePairingRequestedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DevicePairingRequestedEventArgs_get_DeviceInformation(py::wrapper::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePairingRequestedEventArgs", L"DeviceInformation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePairingRequestedEventArgs_get_PairingKind(py::wrapper::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePairingRequestedEventArgs", L"PairingKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PairingKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePairingRequestedEventArgs_get_Pin(py::wrapper::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePairingRequestedEventArgs", L"Pin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DevicePairingRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DevicePairingRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DevicePairingRequestedEventArgs[] = {
        { "accept", reinterpret_cast<PyCFunction>(DevicePairingRequestedEventArgs_Accept), METH_VARARGS, nullptr },
        { "accept_with_password_credential", reinterpret_cast<PyCFunction>(DevicePairingRequestedEventArgs_AcceptWithPasswordCredential), METH_VARARGS, nullptr },
        { "get_deferral", reinterpret_cast<PyCFunction>(DevicePairingRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DevicePairingRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DevicePairingRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DevicePairingRequestedEventArgs[] = {
        { "device_information", reinterpret_cast<getter>(DevicePairingRequestedEventArgs_get_DeviceInformation), nullptr, nullptr, nullptr },
        { "pairing_kind", reinterpret_cast<getter>(DevicePairingRequestedEventArgs_get_PairingKind), nullptr, nullptr, nullptr },
        { "pin", reinterpret_cast<getter>(DevicePairingRequestedEventArgs_get_Pin), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DevicePairingRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DevicePairingRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DevicePairingRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DevicePairingRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DevicePairingRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DevicePairingRequestedEventArgs =
    {
        "_winsdk_Windows_Devices_Enumeration.DevicePairingRequestedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DevicePairingRequestedEventArgs
    };

    // ----- DevicePairingResult class --------------------
    static constexpr const char* const type_name_DevicePairingResult = "DevicePairingResult";

    static PyObject* _new_DevicePairingResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DevicePairingResult);
        return nullptr;
    }

    static void _dealloc_DevicePairingResult(py::wrapper::Windows::Devices::Enumeration::DevicePairingResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DevicePairingResult_get_ProtectionLevelUsed(py::wrapper::Windows::Devices::Enumeration::DevicePairingResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePairingResult", L"ProtectionLevelUsed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProtectionLevelUsed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePairingResult_get_Status(py::wrapper::Windows::Devices::Enumeration::DevicePairingResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePairingResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DevicePairingResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DevicePairingResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DevicePairingResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DevicePairingResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DevicePairingResult[] = {
        { "_assign_array_", _assign_array_DevicePairingResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DevicePairingResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DevicePairingResult[] = {
        { "protection_level_used", reinterpret_cast<getter>(DevicePairingResult_get_ProtectionLevelUsed), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(DevicePairingResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DevicePairingResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DevicePairingResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DevicePairingResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DevicePairingResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DevicePairingResult) },
        { },
    };

    static PyType_Spec type_spec_DevicePairingResult =
    {
        "_winsdk_Windows_Devices_Enumeration.DevicePairingResult",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DevicePairingResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DevicePairingResult
    };

    // ----- DevicePicker class --------------------
    static constexpr const char* const type_name_DevicePicker = "DevicePicker";

    static PyObject* _new_DevicePicker(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Enumeration::DevicePicker instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DevicePicker(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DevicePicker_Hide(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DevicePicker", L"Hide", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Hide();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DevicePicker_PickSingleDeviceAsync(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DevicePicker", L"PickSingleDeviceAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                return py::convert(self->obj.PickSingleDeviceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DevicePicker", L"PickSingleDeviceAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 1);

                return py::convert(self->obj.PickSingleDeviceAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DevicePicker_SetDisplayStatus(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DevicePicker", L"SetDisplayStatus", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePickerDisplayStatusOptions>(args, 2);

                self->obj.SetDisplayStatus(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DevicePicker_Show(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DevicePicker", L"Show", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                self->obj.Show(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DevicePicker", L"Show", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 1);

                self->obj.Show(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DevicePicker_get_Appearance(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePicker", L"Appearance"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Appearance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePicker_get_Filter(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePicker", L"Filter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Filter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePicker_get_RequestedProperties(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePicker", L"RequestedProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePicker_add_DevicePickerDismissed(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DevicePicker", L"DevicePickerDismissed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DevicePicker, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.DevicePickerDismissed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePicker_remove_DevicePickerDismissed(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DevicePicker", L"DevicePickerDismissed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DevicePickerDismissed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePicker_add_DeviceSelected(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DevicePicker", L"DeviceSelected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DevicePicker, winrt::Windows::Devices::Enumeration::DeviceSelectedEventArgs>>(arg);

            return py::convert(self->obj.DeviceSelected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePicker_remove_DeviceSelected(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DevicePicker", L"DeviceSelected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DeviceSelected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePicker_add_DisconnectButtonClicked(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DevicePicker", L"DisconnectButtonClicked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DevicePicker, winrt::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs>>(arg);

            return py::convert(self->obj.DisconnectButtonClicked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePicker_remove_DisconnectButtonClicked(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DevicePicker", L"DisconnectButtonClicked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DisconnectButtonClicked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DevicePicker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DevicePicker>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DevicePicker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DevicePicker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DevicePicker[] = {
        { "hide", reinterpret_cast<PyCFunction>(DevicePicker_Hide), METH_VARARGS, nullptr },
        { "pick_single_device_async", reinterpret_cast<PyCFunction>(DevicePicker_PickSingleDeviceAsync), METH_VARARGS, nullptr },
        { "set_display_status", reinterpret_cast<PyCFunction>(DevicePicker_SetDisplayStatus), METH_VARARGS, nullptr },
        { "show", reinterpret_cast<PyCFunction>(DevicePicker_Show), METH_VARARGS, nullptr },
        { "add_device_picker_dismissed", reinterpret_cast<PyCFunction>(DevicePicker_add_DevicePickerDismissed), METH_O, nullptr },
        { "remove_device_picker_dismissed", reinterpret_cast<PyCFunction>(DevicePicker_remove_DevicePickerDismissed), METH_O, nullptr },
        { "add_device_selected", reinterpret_cast<PyCFunction>(DevicePicker_add_DeviceSelected), METH_O, nullptr },
        { "remove_device_selected", reinterpret_cast<PyCFunction>(DevicePicker_remove_DeviceSelected), METH_O, nullptr },
        { "add_disconnect_button_clicked", reinterpret_cast<PyCFunction>(DevicePicker_add_DisconnectButtonClicked), METH_O, nullptr },
        { "remove_disconnect_button_clicked", reinterpret_cast<PyCFunction>(DevicePicker_remove_DisconnectButtonClicked), METH_O, nullptr },
        { "_assign_array_", _assign_array_DevicePicker, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DevicePicker), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DevicePicker[] = {
        { "appearance", reinterpret_cast<getter>(DevicePicker_get_Appearance), nullptr, nullptr, nullptr },
        { "filter", reinterpret_cast<getter>(DevicePicker_get_Filter), nullptr, nullptr, nullptr },
        { "requested_properties", reinterpret_cast<getter>(DevicePicker_get_RequestedProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DevicePicker[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DevicePicker) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DevicePicker) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DevicePicker) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DevicePicker) },
        { },
    };

    static PyType_Spec type_spec_DevicePicker =
    {
        "_winsdk_Windows_Devices_Enumeration.DevicePicker",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DevicePicker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DevicePicker
    };

    // ----- DevicePickerAppearance class --------------------
    static constexpr const char* const type_name_DevicePickerAppearance = "DevicePickerAppearance";

    static PyObject* _new_DevicePickerAppearance(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DevicePickerAppearance);
        return nullptr;
    }

    static void _dealloc_DevicePickerAppearance(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DevicePickerAppearance_get_Title(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DevicePickerAppearance_put_Title(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DevicePickerAppearance_get_SelectedForegroundColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"SelectedForegroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DevicePickerAppearance_put_SelectedForegroundColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"SelectedForegroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.SelectedForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DevicePickerAppearance_get_SelectedBackgroundColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"SelectedBackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedBackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DevicePickerAppearance_put_SelectedBackgroundColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"SelectedBackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.SelectedBackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DevicePickerAppearance_get_SelectedAccentColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"SelectedAccentColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedAccentColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DevicePickerAppearance_put_SelectedAccentColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"SelectedAccentColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.SelectedAccentColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DevicePickerAppearance_get_ForegroundColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"ForegroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DevicePickerAppearance_put_ForegroundColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"ForegroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.ForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DevicePickerAppearance_get_BackgroundColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"BackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DevicePickerAppearance_put_BackgroundColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"BackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.BackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DevicePickerAppearance_get_AccentColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"AccentColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccentColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DevicePickerAppearance_put_AccentColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"AccentColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.AccentColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DevicePickerAppearance(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DevicePickerAppearance>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DevicePickerAppearance(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DevicePickerAppearance>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DevicePickerAppearance[] = {
        { "_assign_array_", _assign_array_DevicePickerAppearance, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DevicePickerAppearance), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DevicePickerAppearance[] = {
        { "title", reinterpret_cast<getter>(DevicePickerAppearance_get_Title), reinterpret_cast<setter>(DevicePickerAppearance_put_Title), nullptr, nullptr },
        { "selected_foreground_color", reinterpret_cast<getter>(DevicePickerAppearance_get_SelectedForegroundColor), reinterpret_cast<setter>(DevicePickerAppearance_put_SelectedForegroundColor), nullptr, nullptr },
        { "selected_background_color", reinterpret_cast<getter>(DevicePickerAppearance_get_SelectedBackgroundColor), reinterpret_cast<setter>(DevicePickerAppearance_put_SelectedBackgroundColor), nullptr, nullptr },
        { "selected_accent_color", reinterpret_cast<getter>(DevicePickerAppearance_get_SelectedAccentColor), reinterpret_cast<setter>(DevicePickerAppearance_put_SelectedAccentColor), nullptr, nullptr },
        { "foreground_color", reinterpret_cast<getter>(DevicePickerAppearance_get_ForegroundColor), reinterpret_cast<setter>(DevicePickerAppearance_put_ForegroundColor), nullptr, nullptr },
        { "background_color", reinterpret_cast<getter>(DevicePickerAppearance_get_BackgroundColor), reinterpret_cast<setter>(DevicePickerAppearance_put_BackgroundColor), nullptr, nullptr },
        { "accent_color", reinterpret_cast<getter>(DevicePickerAppearance_get_AccentColor), reinterpret_cast<setter>(DevicePickerAppearance_put_AccentColor), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DevicePickerAppearance[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DevicePickerAppearance) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DevicePickerAppearance) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DevicePickerAppearance) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DevicePickerAppearance) },
        { },
    };

    static PyType_Spec type_spec_DevicePickerAppearance =
    {
        "_winsdk_Windows_Devices_Enumeration.DevicePickerAppearance",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DevicePickerAppearance
    };

    // ----- DevicePickerFilter class --------------------
    static constexpr const char* const type_name_DevicePickerFilter = "DevicePickerFilter";

    static PyObject* _new_DevicePickerFilter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DevicePickerFilter);
        return nullptr;
    }

    static void _dealloc_DevicePickerFilter(py::wrapper::Windows::Devices::Enumeration::DevicePickerFilter* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DevicePickerFilter_get_SupportedDeviceClasses(py::wrapper::Windows::Devices::Enumeration::DevicePickerFilter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerFilter", L"SupportedDeviceClasses"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedDeviceClasses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePickerFilter_get_SupportedDeviceSelectors(py::wrapper::Windows::Devices::Enumeration::DevicePickerFilter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerFilter", L"SupportedDeviceSelectors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedDeviceSelectors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DevicePickerFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DevicePickerFilter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DevicePickerFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DevicePickerFilter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DevicePickerFilter[] = {
        { "_assign_array_", _assign_array_DevicePickerFilter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DevicePickerFilter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DevicePickerFilter[] = {
        { "supported_device_classes", reinterpret_cast<getter>(DevicePickerFilter_get_SupportedDeviceClasses), nullptr, nullptr, nullptr },
        { "supported_device_selectors", reinterpret_cast<getter>(DevicePickerFilter_get_SupportedDeviceSelectors), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DevicePickerFilter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DevicePickerFilter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DevicePickerFilter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DevicePickerFilter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DevicePickerFilter) },
        { },
    };

    static PyType_Spec type_spec_DevicePickerFilter =
    {
        "_winsdk_Windows_Devices_Enumeration.DevicePickerFilter",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DevicePickerFilter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DevicePickerFilter
    };

    // ----- DeviceSelectedEventArgs class --------------------
    static constexpr const char* const type_name_DeviceSelectedEventArgs = "DeviceSelectedEventArgs";

    static PyObject* _new_DeviceSelectedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DeviceSelectedEventArgs);
        return nullptr;
    }

    static void _dealloc_DeviceSelectedEventArgs(py::wrapper::Windows::Devices::Enumeration::DeviceSelectedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceSelectedEventArgs_get_SelectedDevice(py::wrapper::Windows::Devices::Enumeration::DeviceSelectedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceSelectedEventArgs", L"SelectedDevice"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceSelectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceSelectedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceSelectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceSelectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceSelectedEventArgs[] = {
        { "_assign_array_", _assign_array_DeviceSelectedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceSelectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceSelectedEventArgs[] = {
        { "selected_device", reinterpret_cast<getter>(DeviceSelectedEventArgs_get_SelectedDevice), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceSelectedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceSelectedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceSelectedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceSelectedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceSelectedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DeviceSelectedEventArgs =
    {
        "_winsdk_Windows_Devices_Enumeration.DeviceSelectedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceSelectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceSelectedEventArgs
    };

    // ----- DeviceThumbnail class --------------------
    static constexpr const char* const type_name_DeviceThumbnail = "DeviceThumbnail";

    static PyObject* _new_DeviceThumbnail(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DeviceThumbnail);
        return nullptr;
    }

    static void _dealloc_DeviceThumbnail(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceThumbnail_CloneStream(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"CloneStream", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CloneStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_Close(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_FlushAsync(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"FlushAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_GetInputStreamAt(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"GetInputStreamAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetInputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_GetOutputStreamAt(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"GetOutputStreamAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetOutputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_ReadAsync(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"ReadAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

                return py::convert(self->obj.ReadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_Seek(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"Seek", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_WriteAsync(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"WriteAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_get_ContentType(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"ContentType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_get_Size(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceThumbnail_put_Size(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceThumbnail_get_CanRead(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"CanRead"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_get_CanWrite(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"CanWrite"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanWrite());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_get_Position(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceThumbnail(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceThumbnail>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceThumbnail(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceThumbnail>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_DeviceThumbnail(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_DeviceThumbnail(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceThumbnail[] = {
        { "clone_stream", reinterpret_cast<PyCFunction>(DeviceThumbnail_CloneStream), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(DeviceThumbnail_Close), METH_VARARGS, nullptr },
        { "flush_async", reinterpret_cast<PyCFunction>(DeviceThumbnail_FlushAsync), METH_VARARGS, nullptr },
        { "get_input_stream_at", reinterpret_cast<PyCFunction>(DeviceThumbnail_GetInputStreamAt), METH_VARARGS, nullptr },
        { "get_output_stream_at", reinterpret_cast<PyCFunction>(DeviceThumbnail_GetOutputStreamAt), METH_VARARGS, nullptr },
        { "read_async", reinterpret_cast<PyCFunction>(DeviceThumbnail_ReadAsync), METH_VARARGS, nullptr },
        { "seek", reinterpret_cast<PyCFunction>(DeviceThumbnail_Seek), METH_VARARGS, nullptr },
        { "write_async", reinterpret_cast<PyCFunction>(DeviceThumbnail_WriteAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DeviceThumbnail, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceThumbnail), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_DeviceThumbnail), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_DeviceThumbnail), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceThumbnail[] = {
        { "content_type", reinterpret_cast<getter>(DeviceThumbnail_get_ContentType), nullptr, nullptr, nullptr },
        { "size", reinterpret_cast<getter>(DeviceThumbnail_get_Size), reinterpret_cast<setter>(DeviceThumbnail_put_Size), nullptr, nullptr },
        { "can_read", reinterpret_cast<getter>(DeviceThumbnail_get_CanRead), nullptr, nullptr, nullptr },
        { "can_write", reinterpret_cast<getter>(DeviceThumbnail_get_CanWrite), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(DeviceThumbnail_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceThumbnail[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceThumbnail) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceThumbnail) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceThumbnail) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceThumbnail) },
        { },
    };

    static PyType_Spec type_spec_DeviceThumbnail =
    {
        "_winsdk_Windows_Devices_Enumeration.DeviceThumbnail",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceThumbnail
    };

    // ----- DeviceUnpairingResult class --------------------
    static constexpr const char* const type_name_DeviceUnpairingResult = "DeviceUnpairingResult";

    static PyObject* _new_DeviceUnpairingResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DeviceUnpairingResult);
        return nullptr;
    }

    static void _dealloc_DeviceUnpairingResult(py::wrapper::Windows::Devices::Enumeration::DeviceUnpairingResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceUnpairingResult_get_Status(py::wrapper::Windows::Devices::Enumeration::DeviceUnpairingResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceUnpairingResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceUnpairingResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceUnpairingResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceUnpairingResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceUnpairingResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceUnpairingResult[] = {
        { "_assign_array_", _assign_array_DeviceUnpairingResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceUnpairingResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceUnpairingResult[] = {
        { "status", reinterpret_cast<getter>(DeviceUnpairingResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceUnpairingResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceUnpairingResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceUnpairingResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceUnpairingResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceUnpairingResult) },
        { },
    };

    static PyType_Spec type_spec_DeviceUnpairingResult =
    {
        "_winsdk_Windows_Devices_Enumeration.DeviceUnpairingResult",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceUnpairingResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceUnpairingResult
    };

    // ----- DeviceWatcher class --------------------
    static constexpr const char* const type_name_DeviceWatcher = "DeviceWatcher";

    static PyObject* _new_DeviceWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DeviceWatcher);
        return nullptr;
    }

    static void _dealloc_DeviceWatcher(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceWatcher_GetBackgroundTrigger(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"GetBackgroundTrigger", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Enumeration::DeviceWatcherEventKind>>(args, 0);

                return py::convert(self->obj.GetBackgroundTrigger(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_Start(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_Stop(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_get_Status(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_add_Added(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"Added"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DeviceWatcher, winrt::Windows::Devices::Enumeration::DeviceInformation>>(arg);

            return py::convert(self->obj.Added(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_remove_Added(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"Added"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Added(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_add_EnumerationCompleted(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DeviceWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_remove_EnumerationCompleted(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_add_Removed(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"Removed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DeviceWatcher, winrt::Windows::Devices::Enumeration::DeviceInformationUpdate>>(arg);

            return py::convert(self->obj.Removed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_remove_Removed(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"Removed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Removed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_add_Stopped(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DeviceWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_remove_Stopped(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_add_Updated(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"Updated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DeviceWatcher, winrt::Windows::Devices::Enumeration::DeviceInformationUpdate>>(arg);

            return py::convert(self->obj.Updated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_remove_Updated(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"Updated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Updated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceWatcher[] = {
        { "get_background_trigger", reinterpret_cast<PyCFunction>(DeviceWatcher_GetBackgroundTrigger), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(DeviceWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(DeviceWatcher_Stop), METH_VARARGS, nullptr },
        { "add_added", reinterpret_cast<PyCFunction>(DeviceWatcher_add_Added), METH_O, nullptr },
        { "remove_added", reinterpret_cast<PyCFunction>(DeviceWatcher_remove_Added), METH_O, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(DeviceWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(DeviceWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_removed", reinterpret_cast<PyCFunction>(DeviceWatcher_add_Removed), METH_O, nullptr },
        { "remove_removed", reinterpret_cast<PyCFunction>(DeviceWatcher_remove_Removed), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(DeviceWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(DeviceWatcher_remove_Stopped), METH_O, nullptr },
        { "add_updated", reinterpret_cast<PyCFunction>(DeviceWatcher_add_Updated), METH_O, nullptr },
        { "remove_updated", reinterpret_cast<PyCFunction>(DeviceWatcher_remove_Updated), METH_O, nullptr },
        { "_assign_array_", _assign_array_DeviceWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceWatcher[] = {
        { "status", reinterpret_cast<getter>(DeviceWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceWatcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceWatcher) },
        { },
    };

    static PyType_Spec type_spec_DeviceWatcher =
    {
        "_winsdk_Windows_Devices_Enumeration.DeviceWatcher",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceWatcher
    };

    // ----- DeviceWatcherEvent class --------------------
    static constexpr const char* const type_name_DeviceWatcherEvent = "DeviceWatcherEvent";

    static PyObject* _new_DeviceWatcherEvent(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DeviceWatcherEvent);
        return nullptr;
    }

    static void _dealloc_DeviceWatcherEvent(py::wrapper::Windows::Devices::Enumeration::DeviceWatcherEvent* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceWatcherEvent_get_DeviceInformation(py::wrapper::Windows::Devices::Enumeration::DeviceWatcherEvent* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceWatcherEvent", L"DeviceInformation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcherEvent_get_DeviceInformationUpdate(py::wrapper::Windows::Devices::Enumeration::DeviceWatcherEvent* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceWatcherEvent", L"DeviceInformationUpdate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceInformationUpdate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcherEvent_get_Kind(py::wrapper::Windows::Devices::Enumeration::DeviceWatcherEvent* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceWatcherEvent", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceWatcherEvent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceWatcherEvent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceWatcherEvent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceWatcherEvent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceWatcherEvent[] = {
        { "_assign_array_", _assign_array_DeviceWatcherEvent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceWatcherEvent), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceWatcherEvent[] = {
        { "device_information", reinterpret_cast<getter>(DeviceWatcherEvent_get_DeviceInformation), nullptr, nullptr, nullptr },
        { "device_information_update", reinterpret_cast<getter>(DeviceWatcherEvent_get_DeviceInformationUpdate), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(DeviceWatcherEvent_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceWatcherEvent[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceWatcherEvent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceWatcherEvent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceWatcherEvent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceWatcherEvent) },
        { },
    };

    static PyType_Spec type_spec_DeviceWatcherEvent =
    {
        "_winsdk_Windows_Devices_Enumeration.DeviceWatcherEvent",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceWatcherEvent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceWatcherEvent
    };

    // ----- DeviceWatcherTriggerDetails class --------------------
    static constexpr const char* const type_name_DeviceWatcherTriggerDetails = "DeviceWatcherTriggerDetails";

    static PyObject* _new_DeviceWatcherTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DeviceWatcherTriggerDetails);
        return nullptr;
    }

    static void _dealloc_DeviceWatcherTriggerDetails(py::wrapper::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceWatcherTriggerDetails_get_DeviceWatcherEvents(py::wrapper::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceWatcherTriggerDetails", L"DeviceWatcherEvents"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceWatcherEvents());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceWatcherTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceWatcherTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceWatcherTriggerDetails[] = {
        { "_assign_array_", _assign_array_DeviceWatcherTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceWatcherTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceWatcherTriggerDetails[] = {
        { "device_watcher_events", reinterpret_cast<getter>(DeviceWatcherTriggerDetails_get_DeviceWatcherEvents), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceWatcherTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceWatcherTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceWatcherTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceWatcherTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceWatcherTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_DeviceWatcherTriggerDetails =
    {
        "_winsdk_Windows_Devices_Enumeration.DeviceWatcherTriggerDetails",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceWatcherTriggerDetails
    };

    // ----- EnclosureLocation class --------------------
    static constexpr const char* const type_name_EnclosureLocation = "EnclosureLocation";

    static PyObject* _new_EnclosureLocation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EnclosureLocation);
        return nullptr;
    }

    static void _dealloc_EnclosureLocation(py::wrapper::Windows::Devices::Enumeration::EnclosureLocation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EnclosureLocation_get_InDock(py::wrapper::Windows::Devices::Enumeration::EnclosureLocation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.EnclosureLocation", L"InDock"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InDock());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EnclosureLocation_get_InLid(py::wrapper::Windows::Devices::Enumeration::EnclosureLocation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.EnclosureLocation", L"InLid"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InLid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EnclosureLocation_get_Panel(py::wrapper::Windows::Devices::Enumeration::EnclosureLocation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.EnclosureLocation", L"Panel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Panel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EnclosureLocation_get_RotationAngleInDegreesClockwise(py::wrapper::Windows::Devices::Enumeration::EnclosureLocation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.EnclosureLocation", L"RotationAngleInDegreesClockwise"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RotationAngleInDegreesClockwise());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EnclosureLocation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::EnclosureLocation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EnclosureLocation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::EnclosureLocation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EnclosureLocation[] = {
        { "_assign_array_", _assign_array_EnclosureLocation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EnclosureLocation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EnclosureLocation[] = {
        { "in_dock", reinterpret_cast<getter>(EnclosureLocation_get_InDock), nullptr, nullptr, nullptr },
        { "in_lid", reinterpret_cast<getter>(EnclosureLocation_get_InLid), nullptr, nullptr, nullptr },
        { "panel", reinterpret_cast<getter>(EnclosureLocation_get_Panel), nullptr, nullptr, nullptr },
        { "rotation_angle_in_degrees_clockwise", reinterpret_cast<getter>(EnclosureLocation_get_RotationAngleInDegreesClockwise), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EnclosureLocation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EnclosureLocation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EnclosureLocation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EnclosureLocation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EnclosureLocation) },
        { },
    };

    static PyType_Spec type_spec_EnclosureLocation =
    {
        "_winsdk_Windows_Devices_Enumeration.EnclosureLocation",
        sizeof(py::wrapper::Windows::Devices::Enumeration::EnclosureLocation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EnclosureLocation
    };

    // ----- IDevicePairingSettings interface --------------------
    static constexpr const char* const type_name_IDevicePairingSettings = "IDevicePairingSettings";

    static PyObject* _new_IDevicePairingSettings(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IDevicePairingSettings);
        return nullptr;
    }

    static void _dealloc_IDevicePairingSettings(py::wrapper::Windows::Devices::Enumeration::IDevicePairingSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_IDevicePairingSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::IDevicePairingSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IDevicePairingSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::IDevicePairingSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDevicePairingSettings[] = {
        { "_assign_array_", _assign_array_IDevicePairingSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IDevicePairingSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IDevicePairingSettings[] = {
        { }
    };

    static PyType_Slot _type_slots_IDevicePairingSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IDevicePairingSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IDevicePairingSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IDevicePairingSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IDevicePairingSettings) },
        { },
    };

    static PyType_Spec type_spec_IDevicePairingSettings =
    {
        "_winsdk_Windows_Devices_Enumeration.IDevicePairingSettings",
        sizeof(py::wrapper::Windows::Devices::Enumeration::IDevicePairingSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IDevicePairingSettings
    };

    // ----- Windows.Devices.Enumeration Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Devices::Enumeration");

    static PyMethodDef module_methods[] = {
        {"_register_DeviceAccessStatus", register_DeviceAccessStatus, METH_O, "registers type"},
        {"_register_DeviceClass", register_DeviceClass, METH_O, "registers type"},
        {"_register_DeviceInformationKind", register_DeviceInformationKind, METH_O, "registers type"},
        {"_register_DevicePairingKinds", register_DevicePairingKinds, METH_O, "registers type"},
        {"_register_DevicePairingProtectionLevel", register_DevicePairingProtectionLevel, METH_O, "registers type"},
        {"_register_DevicePairingResultStatus", register_DevicePairingResultStatus, METH_O, "registers type"},
        {"_register_DevicePickerDisplayStatusOptions", register_DevicePickerDisplayStatusOptions, METH_O, "registers type"},
        {"_register_DeviceUnpairingResultStatus", register_DeviceUnpairingResultStatus, METH_O, "registers type"},
        {"_register_DeviceWatcherEventKind", register_DeviceWatcherEventKind, METH_O, "registers type"},
        {"_register_DeviceWatcherStatus", register_DeviceWatcherStatus, METH_O, "registers type"},
        {"_register_Panel", register_Panel, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_DeviceAccessStatus);
        Py_VISIT(state->type_DeviceClass);
        Py_VISIT(state->type_DeviceInformationKind);
        Py_VISIT(state->type_DevicePairingKinds);
        Py_VISIT(state->type_DevicePairingProtectionLevel);
        Py_VISIT(state->type_DevicePairingResultStatus);
        Py_VISIT(state->type_DevicePickerDisplayStatusOptions);
        Py_VISIT(state->type_DeviceUnpairingResultStatus);
        Py_VISIT(state->type_DeviceWatcherEventKind);
        Py_VISIT(state->type_DeviceWatcherStatus);
        Py_VISIT(state->type_Panel);
        Py_VISIT(state->type_DeviceAccessChangedEventArgs);
        Py_VISIT(state->type_DeviceAccessInformation);
        Py_VISIT(state->type_DeviceConnectionChangeTriggerDetails);
        Py_VISIT(state->type_DeviceDisconnectButtonClickedEventArgs);
        Py_VISIT(state->type_DeviceInformation);
        Py_VISIT(state->type_DeviceInformationCollection);
        Py_VISIT(state->type_DeviceInformationCustomPairing);
        Py_VISIT(state->type_DeviceInformationPairing);
        Py_VISIT(state->type_DeviceInformationUpdate);
        Py_VISIT(state->type_DevicePairingRequestedEventArgs);
        Py_VISIT(state->type_DevicePairingResult);
        Py_VISIT(state->type_DevicePicker);
        Py_VISIT(state->type_DevicePickerAppearance);
        Py_VISIT(state->type_DevicePickerFilter);
        Py_VISIT(state->type_DeviceSelectedEventArgs);
        Py_VISIT(state->type_DeviceThumbnail);
        Py_VISIT(state->type_DeviceUnpairingResult);
        Py_VISIT(state->type_DeviceWatcher);
        Py_VISIT(state->type_DeviceWatcherEvent);
        Py_VISIT(state->type_DeviceWatcherTriggerDetails);
        Py_VISIT(state->type_EnclosureLocation);
        Py_VISIT(state->type_IDevicePairingSettings);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_DeviceAccessStatus);
        Py_CLEAR(state->type_DeviceClass);
        Py_CLEAR(state->type_DeviceInformationKind);
        Py_CLEAR(state->type_DevicePairingKinds);
        Py_CLEAR(state->type_DevicePairingProtectionLevel);
        Py_CLEAR(state->type_DevicePairingResultStatus);
        Py_CLEAR(state->type_DevicePickerDisplayStatusOptions);
        Py_CLEAR(state->type_DeviceUnpairingResultStatus);
        Py_CLEAR(state->type_DeviceWatcherEventKind);
        Py_CLEAR(state->type_DeviceWatcherStatus);
        Py_CLEAR(state->type_Panel);
        Py_CLEAR(state->type_DeviceAccessChangedEventArgs);
        Py_CLEAR(state->type_DeviceAccessInformation);
        Py_CLEAR(state->type_DeviceConnectionChangeTriggerDetails);
        Py_CLEAR(state->type_DeviceDisconnectButtonClickedEventArgs);
        Py_CLEAR(state->type_DeviceInformation);
        Py_CLEAR(state->type_DeviceInformationCollection);
        Py_CLEAR(state->type_DeviceInformationCustomPairing);
        Py_CLEAR(state->type_DeviceInformationPairing);
        Py_CLEAR(state->type_DeviceInformationUpdate);
        Py_CLEAR(state->type_DevicePairingRequestedEventArgs);
        Py_CLEAR(state->type_DevicePairingResult);
        Py_CLEAR(state->type_DevicePicker);
        Py_CLEAR(state->type_DevicePickerAppearance);
        Py_CLEAR(state->type_DevicePickerFilter);
        Py_CLEAR(state->type_DeviceSelectedEventArgs);
        Py_CLEAR(state->type_DeviceThumbnail);
        Py_CLEAR(state->type_DeviceUnpairingResult);
        Py_CLEAR(state->type_DeviceWatcher);
        Py_CLEAR(state->type_DeviceWatcherEvent);
        Py_CLEAR(state->type_DeviceWatcherTriggerDetails);
        Py_CLEAR(state->type_EnclosureLocation);
        Py_CLEAR(state->type_IDevicePairingSettings);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Devices_Enumeration",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Devices::Enumeration

PyMODINIT_FUNC PyInit__winsdk_Windows_Devices_Enumeration(void) noexcept
{
    using namespace py::cpp::Windows::Devices::Enumeration;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_DeviceAccessChangedEventArgs = py::register_python_type(module.get(), type_name_DeviceAccessChangedEventArgs, &type_spec_DeviceAccessChangedEventArgs, bases.get(), nullptr);
    if (!state->type_DeviceAccessChangedEventArgs)
    {
        return nullptr;
    }

    state->type_DeviceAccessInformation = py::register_python_type(module.get(), type_name_DeviceAccessInformation, &type_spec_DeviceAccessInformation, bases.get(), nullptr);
    if (!state->type_DeviceAccessInformation)
    {
        return nullptr;
    }

    state->type_DeviceConnectionChangeTriggerDetails = py::register_python_type(module.get(), type_name_DeviceConnectionChangeTriggerDetails, &type_spec_DeviceConnectionChangeTriggerDetails, bases.get(), nullptr);
    if (!state->type_DeviceConnectionChangeTriggerDetails)
    {
        return nullptr;
    }

    state->type_DeviceDisconnectButtonClickedEventArgs = py::register_python_type(module.get(), type_name_DeviceDisconnectButtonClickedEventArgs, &type_spec_DeviceDisconnectButtonClickedEventArgs, bases.get(), nullptr);
    if (!state->type_DeviceDisconnectButtonClickedEventArgs)
    {
        return nullptr;
    }

    state->type_DeviceInformation = py::register_python_type(module.get(), type_name_DeviceInformation, &type_spec_DeviceInformation, bases.get(), nullptr);
    if (!state->type_DeviceInformation)
    {
        return nullptr;
    }

    state->type_DeviceInformationCollection = py::register_python_type(module.get(), type_name_DeviceInformationCollection, &type_spec_DeviceInformationCollection, sequence_bases.get(), nullptr);
    if (!state->type_DeviceInformationCollection)
    {
        return nullptr;
    }

    state->type_DeviceInformationCustomPairing = py::register_python_type(module.get(), type_name_DeviceInformationCustomPairing, &type_spec_DeviceInformationCustomPairing, bases.get(), nullptr);
    if (!state->type_DeviceInformationCustomPairing)
    {
        return nullptr;
    }

    state->type_DeviceInformationPairing = py::register_python_type(module.get(), type_name_DeviceInformationPairing, &type_spec_DeviceInformationPairing, bases.get(), nullptr);
    if (!state->type_DeviceInformationPairing)
    {
        return nullptr;
    }

    state->type_DeviceInformationUpdate = py::register_python_type(module.get(), type_name_DeviceInformationUpdate, &type_spec_DeviceInformationUpdate, bases.get(), nullptr);
    if (!state->type_DeviceInformationUpdate)
    {
        return nullptr;
    }

    state->type_DevicePairingRequestedEventArgs = py::register_python_type(module.get(), type_name_DevicePairingRequestedEventArgs, &type_spec_DevicePairingRequestedEventArgs, bases.get(), nullptr);
    if (!state->type_DevicePairingRequestedEventArgs)
    {
        return nullptr;
    }

    state->type_DevicePairingResult = py::register_python_type(module.get(), type_name_DevicePairingResult, &type_spec_DevicePairingResult, bases.get(), nullptr);
    if (!state->type_DevicePairingResult)
    {
        return nullptr;
    }

    state->type_DevicePicker = py::register_python_type(module.get(), type_name_DevicePicker, &type_spec_DevicePicker, bases.get(), nullptr);
    if (!state->type_DevicePicker)
    {
        return nullptr;
    }

    state->type_DevicePickerAppearance = py::register_python_type(module.get(), type_name_DevicePickerAppearance, &type_spec_DevicePickerAppearance, bases.get(), nullptr);
    if (!state->type_DevicePickerAppearance)
    {
        return nullptr;
    }

    state->type_DevicePickerFilter = py::register_python_type(module.get(), type_name_DevicePickerFilter, &type_spec_DevicePickerFilter, bases.get(), nullptr);
    if (!state->type_DevicePickerFilter)
    {
        return nullptr;
    }

    state->type_DeviceSelectedEventArgs = py::register_python_type(module.get(), type_name_DeviceSelectedEventArgs, &type_spec_DeviceSelectedEventArgs, bases.get(), nullptr);
    if (!state->type_DeviceSelectedEventArgs)
    {
        return nullptr;
    }

    state->type_DeviceThumbnail = py::register_python_type(module.get(), type_name_DeviceThumbnail, &type_spec_DeviceThumbnail, bases.get(), nullptr);
    if (!state->type_DeviceThumbnail)
    {
        return nullptr;
    }

    state->type_DeviceUnpairingResult = py::register_python_type(module.get(), type_name_DeviceUnpairingResult, &type_spec_DeviceUnpairingResult, bases.get(), nullptr);
    if (!state->type_DeviceUnpairingResult)
    {
        return nullptr;
    }

    state->type_DeviceWatcher = py::register_python_type(module.get(), type_name_DeviceWatcher, &type_spec_DeviceWatcher, bases.get(), nullptr);
    if (!state->type_DeviceWatcher)
    {
        return nullptr;
    }

    state->type_DeviceWatcherEvent = py::register_python_type(module.get(), type_name_DeviceWatcherEvent, &type_spec_DeviceWatcherEvent, bases.get(), nullptr);
    if (!state->type_DeviceWatcherEvent)
    {
        return nullptr;
    }

    state->type_DeviceWatcherTriggerDetails = py::register_python_type(module.get(), type_name_DeviceWatcherTriggerDetails, &type_spec_DeviceWatcherTriggerDetails, bases.get(), nullptr);
    if (!state->type_DeviceWatcherTriggerDetails)
    {
        return nullptr;
    }

    state->type_EnclosureLocation = py::register_python_type(module.get(), type_name_EnclosureLocation, &type_spec_EnclosureLocation, bases.get(), nullptr);
    if (!state->type_EnclosureLocation)
    {
        return nullptr;
    }

    state->type_IDevicePairingSettings = py::register_python_type(module.get(), type_name_IDevicePairingSettings, &type_spec_IDevicePairingSettings, bases.get(), nullptr);
    if (!state->type_IDevicePairingSettings)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Devices::Enumeration::DeviceAccessStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceAccessStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DeviceAccessStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Enumeration::DeviceClass>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceClass;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DeviceClass is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Enumeration::DeviceInformationKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceInformationKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DeviceInformationKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Enumeration::DevicePairingKinds>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DevicePairingKinds;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DevicePairingKinds is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Enumeration::DevicePairingProtectionLevel>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DevicePairingProtectionLevel;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DevicePairingProtectionLevel is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Enumeration::DevicePairingResultStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DevicePairingResultStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DevicePairingResultStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Enumeration::DevicePickerDisplayStatusOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DevicePickerDisplayStatusOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DevicePickerDisplayStatusOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Enumeration::DeviceUnpairingResultStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceUnpairingResultStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DeviceUnpairingResultStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Enumeration::DeviceWatcherEventKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceWatcherEventKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DeviceWatcherEventKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Enumeration::DeviceWatcherStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceWatcherStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DeviceWatcherStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Enumeration::Panel>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Panel;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::Panel is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceAccessChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceAccessInformation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceAccessInformation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DeviceAccessInformation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceConnectionChangeTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceDisconnectButtonClickedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceInformation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceInformation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DeviceInformation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceInformationCollection>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceInformationCollection;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DeviceInformationCollection is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceInformationCustomPairing>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceInformationCustomPairing;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DeviceInformationCustomPairing is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceInformationPairing>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceInformationPairing;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DeviceInformationPairing is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceInformationUpdate>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceInformationUpdate;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DeviceInformationUpdate is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DevicePairingRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DevicePairingResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DevicePairingResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DevicePairingResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DevicePicker>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DevicePicker;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DevicePicker is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DevicePickerAppearance>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DevicePickerAppearance;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DevicePickerAppearance is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DevicePickerFilter>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DevicePickerFilter;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DevicePickerFilter is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceSelectedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceSelectedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DeviceSelectedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceThumbnail>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceThumbnail;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DeviceThumbnail is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceUnpairingResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceUnpairingResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DeviceUnpairingResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceWatcher>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceWatcher;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DeviceWatcher is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceWatcherEvent>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceWatcherEvent;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DeviceWatcherEvent is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceWatcherTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::EnclosureLocation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EnclosureLocation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::EnclosureLocation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::IDevicePairingSettings>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Enumeration;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Enumeration");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IDevicePairingSettings;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Enumeration::IDevicePairingSettings is not registered");
        return nullptr;
    }

    return python_type;
}
