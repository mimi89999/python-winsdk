// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.Networking.NetworkOperators.h"


PyObject* py::converter<winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress>::convert(winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress py::converter<winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress");
    throw python_exception();
}

PyObject* py::converter<winrt::Windows::Networking::NetworkOperators::ProfileUsage>::convert(winrt::Windows::Networking::NetworkOperators::ProfileUsage instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Networking::NetworkOperators::ProfileUsage>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Networking::NetworkOperators::ProfileUsage py::converter<winrt::Windows::Networking::NetworkOperators::ProfileUsage>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Networking::NetworkOperators::ProfileUsage>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Networking::NetworkOperators::ProfileUsage>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Networking::NetworkOperators::ProfileUsage");
    throw python_exception();
}

namespace py::cpp::Windows::Networking::NetworkOperators
{
    struct module_state
    {
        PyObject* type_DataClasses;
        PyObject* type_ESimAuthenticationPreference;
        PyObject* type_ESimDiscoverResultKind;
        PyObject* type_ESimOperationStatus;
        PyObject* type_ESimProfileClass;
        PyObject* type_ESimProfileMetadataState;
        PyObject* type_ESimProfileState;
        PyObject* type_ESimState;
        PyObject* type_ESimWatcherStatus;
        PyObject* type_HotspotAuthenticationResponseCode;
        PyObject* type_MobileBroadbandAccountWatcherStatus;
        PyObject* type_MobileBroadbandDeviceType;
        PyObject* type_MobileBroadbandModemStatus;
        PyObject* type_MobileBroadbandPinFormat;
        PyObject* type_MobileBroadbandPinLockState;
        PyObject* type_MobileBroadbandPinType;
        PyObject* type_MobileBroadbandRadioState;
        PyObject* type_MobileBroadbandSlotState;
        PyObject* type_MobileBroadbandUiccAppOperationStatus;
        PyObject* type_NetworkDeviceStatus;
        PyObject* type_NetworkOperatorDataUsageNotificationKind;
        PyObject* type_NetworkOperatorEventMessageType;
        PyObject* type_NetworkRegistrationState;
        PyObject* type_ProfileMediaType;
        PyObject* type_TetheringCapability;
        PyObject* type_TetheringOperationStatus;
        PyObject* type_TetheringOperationalState;
        PyObject* type_TetheringWiFiBand;
        PyObject* type_UiccAccessCondition;
        PyObject* type_UiccAppKind;
        PyObject* type_UiccAppRecordKind;
        PyObject* type_UssdResultCode;
        PyTypeObject* type_ESim;
        PyTypeObject* type_ESimAddedEventArgs;
        PyTypeObject* type_ESimDiscoverEvent;
        PyTypeObject* type_ESimDiscoverResult;
        PyTypeObject* type_ESimDownloadProfileMetadataResult;
        PyTypeObject* type_ESimManager;
        PyTypeObject* type_ESimOperationResult;
        PyTypeObject* type_ESimPolicy;
        PyTypeObject* type_ESimProfile;
        PyTypeObject* type_ESimProfileMetadata;
        PyTypeObject* type_ESimProfilePolicy;
        PyTypeObject* type_ESimRemovedEventArgs;
        PyTypeObject* type_ESimServiceInfo;
        PyTypeObject* type_ESimUpdatedEventArgs;
        PyTypeObject* type_ESimWatcher;
        PyTypeObject* type_FdnAccessManager;
        PyTypeObject* type_HotspotAuthenticationContext;
        PyTypeObject* type_HotspotAuthenticationEventDetails;
        PyTypeObject* type_HotspotCredentialsAuthenticationResult;
        PyTypeObject* type_KnownCSimFilePaths;
        PyTypeObject* type_KnownRuimFilePaths;
        PyTypeObject* type_KnownSimFilePaths;
        PyTypeObject* type_KnownUSimFilePaths;
        PyTypeObject* type_MobileBroadbandAccount;
        PyTypeObject* type_MobileBroadbandAccountEventArgs;
        PyTypeObject* type_MobileBroadbandAccountUpdatedEventArgs;
        PyTypeObject* type_MobileBroadbandAccountWatcher;
        PyTypeObject* type_MobileBroadbandAntennaSar;
        PyTypeObject* type_MobileBroadbandCellCdma;
        PyTypeObject* type_MobileBroadbandCellGsm;
        PyTypeObject* type_MobileBroadbandCellLte;
        PyTypeObject* type_MobileBroadbandCellNR;
        PyTypeObject* type_MobileBroadbandCellTdscdma;
        PyTypeObject* type_MobileBroadbandCellUmts;
        PyTypeObject* type_MobileBroadbandCellsInfo;
        PyTypeObject* type_MobileBroadbandCurrentSlotIndexChangedEventArgs;
        PyTypeObject* type_MobileBroadbandDeviceInformation;
        PyTypeObject* type_MobileBroadbandDeviceService;
        PyTypeObject* type_MobileBroadbandDeviceServiceCommandResult;
        PyTypeObject* type_MobileBroadbandDeviceServiceCommandSession;
        PyTypeObject* type_MobileBroadbandDeviceServiceDataReceivedEventArgs;
        PyTypeObject* type_MobileBroadbandDeviceServiceDataSession;
        PyTypeObject* type_MobileBroadbandDeviceServiceInformation;
        PyTypeObject* type_MobileBroadbandDeviceServiceTriggerDetails;
        PyTypeObject* type_MobileBroadbandModem;
        PyTypeObject* type_MobileBroadbandModemConfiguration;
        PyTypeObject* type_MobileBroadbandModemIsolation;
        PyTypeObject* type_MobileBroadbandNetwork;
        PyTypeObject* type_MobileBroadbandNetworkRegistrationStateChange;
        PyTypeObject* type_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails;
        PyTypeObject* type_MobileBroadbandPco;
        PyTypeObject* type_MobileBroadbandPcoDataChangeTriggerDetails;
        PyTypeObject* type_MobileBroadbandPin;
        PyTypeObject* type_MobileBroadbandPinLockStateChange;
        PyTypeObject* type_MobileBroadbandPinLockStateChangeTriggerDetails;
        PyTypeObject* type_MobileBroadbandPinManager;
        PyTypeObject* type_MobileBroadbandPinOperationResult;
        PyTypeObject* type_MobileBroadbandRadioStateChange;
        PyTypeObject* type_MobileBroadbandRadioStateChangeTriggerDetails;
        PyTypeObject* type_MobileBroadbandSarManager;
        PyTypeObject* type_MobileBroadbandSlotInfo;
        PyTypeObject* type_MobileBroadbandSlotInfoChangedEventArgs;
        PyTypeObject* type_MobileBroadbandSlotManager;
        PyTypeObject* type_MobileBroadbandTransmissionStateChangedEventArgs;
        PyTypeObject* type_MobileBroadbandUicc;
        PyTypeObject* type_MobileBroadbandUiccApp;
        PyTypeObject* type_MobileBroadbandUiccAppReadRecordResult;
        PyTypeObject* type_MobileBroadbandUiccAppRecordDetailsResult;
        PyTypeObject* type_MobileBroadbandUiccAppsResult;
        PyTypeObject* type_NetworkOperatorDataUsageTriggerDetails;
        PyTypeObject* type_NetworkOperatorNotificationEventDetails;
        PyTypeObject* type_NetworkOperatorTetheringAccessPointConfiguration;
        PyTypeObject* type_NetworkOperatorTetheringClient;
        PyTypeObject* type_NetworkOperatorTetheringManager;
        PyTypeObject* type_NetworkOperatorTetheringOperationResult;
        PyTypeObject* type_ProvisionFromXmlDocumentResults;
        PyTypeObject* type_ProvisionedProfile;
        PyTypeObject* type_ProvisioningAgent;
        PyTypeObject* type_TetheringEntitlementCheckTriggerDetails;
        PyTypeObject* type_UssdMessage;
        PyTypeObject* type_UssdReply;
        PyTypeObject* type_UssdSession;
        PyTypeObject* type_ESimProfileInstallProgress;
        PyTypeObject* type_ProfileUsage;
    };

    static PyObject* register_DataClasses(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DataClasses)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DataClasses = type;
        Py_INCREF(state->type_DataClasses);


        Py_RETURN_NONE;
    }

    static PyObject* register_ESimAuthenticationPreference(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ESimAuthenticationPreference)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ESimAuthenticationPreference = type;
        Py_INCREF(state->type_ESimAuthenticationPreference);


        Py_RETURN_NONE;
    }

    static PyObject* register_ESimDiscoverResultKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ESimDiscoverResultKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ESimDiscoverResultKind = type;
        Py_INCREF(state->type_ESimDiscoverResultKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_ESimOperationStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ESimOperationStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ESimOperationStatus = type;
        Py_INCREF(state->type_ESimOperationStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_ESimProfileClass(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ESimProfileClass)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ESimProfileClass = type;
        Py_INCREF(state->type_ESimProfileClass);


        Py_RETURN_NONE;
    }

    static PyObject* register_ESimProfileMetadataState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ESimProfileMetadataState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ESimProfileMetadataState = type;
        Py_INCREF(state->type_ESimProfileMetadataState);


        Py_RETURN_NONE;
    }

    static PyObject* register_ESimProfileState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ESimProfileState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ESimProfileState = type;
        Py_INCREF(state->type_ESimProfileState);


        Py_RETURN_NONE;
    }

    static PyObject* register_ESimState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ESimState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ESimState = type;
        Py_INCREF(state->type_ESimState);


        Py_RETURN_NONE;
    }

    static PyObject* register_ESimWatcherStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ESimWatcherStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ESimWatcherStatus = type;
        Py_INCREF(state->type_ESimWatcherStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_HotspotAuthenticationResponseCode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_HotspotAuthenticationResponseCode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_HotspotAuthenticationResponseCode = type;
        Py_INCREF(state->type_HotspotAuthenticationResponseCode);


        Py_RETURN_NONE;
    }

    static PyObject* register_MobileBroadbandAccountWatcherStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MobileBroadbandAccountWatcherStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MobileBroadbandAccountWatcherStatus = type;
        Py_INCREF(state->type_MobileBroadbandAccountWatcherStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_MobileBroadbandDeviceType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MobileBroadbandDeviceType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MobileBroadbandDeviceType = type;
        Py_INCREF(state->type_MobileBroadbandDeviceType);


        Py_RETURN_NONE;
    }

    static PyObject* register_MobileBroadbandModemStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MobileBroadbandModemStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MobileBroadbandModemStatus = type;
        Py_INCREF(state->type_MobileBroadbandModemStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_MobileBroadbandPinFormat(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MobileBroadbandPinFormat)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MobileBroadbandPinFormat = type;
        Py_INCREF(state->type_MobileBroadbandPinFormat);


        Py_RETURN_NONE;
    }

    static PyObject* register_MobileBroadbandPinLockState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MobileBroadbandPinLockState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MobileBroadbandPinLockState = type;
        Py_INCREF(state->type_MobileBroadbandPinLockState);


        Py_RETURN_NONE;
    }

    static PyObject* register_MobileBroadbandPinType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MobileBroadbandPinType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MobileBroadbandPinType = type;
        Py_INCREF(state->type_MobileBroadbandPinType);


        Py_RETURN_NONE;
    }

    static PyObject* register_MobileBroadbandRadioState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MobileBroadbandRadioState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MobileBroadbandRadioState = type;
        Py_INCREF(state->type_MobileBroadbandRadioState);


        Py_RETURN_NONE;
    }

    static PyObject* register_MobileBroadbandSlotState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MobileBroadbandSlotState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MobileBroadbandSlotState = type;
        Py_INCREF(state->type_MobileBroadbandSlotState);


        Py_RETURN_NONE;
    }

    static PyObject* register_MobileBroadbandUiccAppOperationStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MobileBroadbandUiccAppOperationStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MobileBroadbandUiccAppOperationStatus = type;
        Py_INCREF(state->type_MobileBroadbandUiccAppOperationStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_NetworkDeviceStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_NetworkDeviceStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_NetworkDeviceStatus = type;
        Py_INCREF(state->type_NetworkDeviceStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_NetworkOperatorDataUsageNotificationKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_NetworkOperatorDataUsageNotificationKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_NetworkOperatorDataUsageNotificationKind = type;
        Py_INCREF(state->type_NetworkOperatorDataUsageNotificationKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_NetworkOperatorEventMessageType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_NetworkOperatorEventMessageType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_NetworkOperatorEventMessageType = type;
        Py_INCREF(state->type_NetworkOperatorEventMessageType);


        Py_RETURN_NONE;
    }

    static PyObject* register_NetworkRegistrationState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_NetworkRegistrationState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_NetworkRegistrationState = type;
        Py_INCREF(state->type_NetworkRegistrationState);


        Py_RETURN_NONE;
    }

    static PyObject* register_ProfileMediaType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ProfileMediaType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ProfileMediaType = type;
        Py_INCREF(state->type_ProfileMediaType);


        Py_RETURN_NONE;
    }

    static PyObject* register_TetheringCapability(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TetheringCapability)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TetheringCapability = type;
        Py_INCREF(state->type_TetheringCapability);


        Py_RETURN_NONE;
    }

    static PyObject* register_TetheringOperationStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TetheringOperationStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TetheringOperationStatus = type;
        Py_INCREF(state->type_TetheringOperationStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_TetheringOperationalState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TetheringOperationalState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TetheringOperationalState = type;
        Py_INCREF(state->type_TetheringOperationalState);


        Py_RETURN_NONE;
    }

    static PyObject* register_TetheringWiFiBand(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TetheringWiFiBand)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TetheringWiFiBand = type;
        Py_INCREF(state->type_TetheringWiFiBand);


        Py_RETURN_NONE;
    }

    static PyObject* register_UiccAccessCondition(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_UiccAccessCondition)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_UiccAccessCondition = type;
        Py_INCREF(state->type_UiccAccessCondition);


        Py_RETURN_NONE;
    }

    static PyObject* register_UiccAppKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_UiccAppKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_UiccAppKind = type;
        Py_INCREF(state->type_UiccAppKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_UiccAppRecordKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_UiccAppRecordKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_UiccAppRecordKind = type;
        Py_INCREF(state->type_UiccAppRecordKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_UssdResultCode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_UssdResultCode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_UssdResultCode = type;
        Py_INCREF(state->type_UssdResultCode);


        Py_RETURN_NONE;
    }

    // ----- ESim class --------------------
    static constexpr const char* const type_name_ESim = "ESim";

    static PyObject* _new_ESim(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESim);
        return nullptr;
    }

    static void _dealloc_ESim(py::wrapper::Windows::Networking::NetworkOperators::ESim* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESim_DeleteProfileAsync(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESim", L"DeleteProfileAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DeleteProfileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESim_Discover(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESim", L"Discover", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Discover());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESim", L"Discover", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.Discover(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESim_DiscoverAsync(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESim", L"DiscoverAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DiscoverAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESim", L"DiscoverAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.DiscoverAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESim_DownloadProfileMetadataAsync(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESim", L"DownloadProfileMetadataAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DownloadProfileMetadataAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESim_GetProfiles(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESim", L"GetProfiles", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetProfiles());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESim_ResetAsync(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESim", L"ResetAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ResetAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESim_get_AvailableMemoryInBytes(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESim", L"AvailableMemoryInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AvailableMemoryInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESim_get_Eid(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESim", L"Eid"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Eid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESim_get_FirmwareVersion(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESim", L"FirmwareVersion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FirmwareVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESim_get_MobileBroadbandModemDeviceId(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESim", L"MobileBroadbandModemDeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MobileBroadbandModemDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESim_get_Policy(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESim", L"Policy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Policy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESim_get_State(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESim", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESim_get_SlotIndex(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESim", L"SlotIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SlotIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESim_add_ProfileChanged(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESim", L"ProfileChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::ESim, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ProfileChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESim_remove_ProfileChanged(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESim", L"ProfileChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ProfileChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESim(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESim>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESim(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESim>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESim[] = {
        { "delete_profile_async", reinterpret_cast<PyCFunction>(ESim_DeleteProfileAsync), METH_VARARGS, nullptr },
        { "discover", reinterpret_cast<PyCFunction>(ESim_Discover), METH_VARARGS, nullptr },
        { "discover_async", reinterpret_cast<PyCFunction>(ESim_DiscoverAsync), METH_VARARGS, nullptr },
        { "download_profile_metadata_async", reinterpret_cast<PyCFunction>(ESim_DownloadProfileMetadataAsync), METH_VARARGS, nullptr },
        { "get_profiles", reinterpret_cast<PyCFunction>(ESim_GetProfiles), METH_VARARGS, nullptr },
        { "reset_async", reinterpret_cast<PyCFunction>(ESim_ResetAsync), METH_VARARGS, nullptr },
        { "add_profile_changed", reinterpret_cast<PyCFunction>(ESim_add_ProfileChanged), METH_O, nullptr },
        { "remove_profile_changed", reinterpret_cast<PyCFunction>(ESim_remove_ProfileChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ESim, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESim), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESim[] = {
        { "available_memory_in_bytes", reinterpret_cast<getter>(ESim_get_AvailableMemoryInBytes), nullptr, nullptr, nullptr },
        { "eid", reinterpret_cast<getter>(ESim_get_Eid), nullptr, nullptr, nullptr },
        { "firmware_version", reinterpret_cast<getter>(ESim_get_FirmwareVersion), nullptr, nullptr, nullptr },
        { "mobile_broadband_modem_device_id", reinterpret_cast<getter>(ESim_get_MobileBroadbandModemDeviceId), nullptr, nullptr, nullptr },
        { "policy", reinterpret_cast<getter>(ESim_get_Policy), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(ESim_get_State), nullptr, nullptr, nullptr },
        { "slot_index", reinterpret_cast<getter>(ESim_get_SlotIndex), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESim[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESim) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESim) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESim) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESim) },
        { },
    };

    static PyType_Spec type_spec_ESim =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESim",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESim),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESim
    };

    // ----- ESimAddedEventArgs class --------------------
    static constexpr const char* const type_name_ESimAddedEventArgs = "ESimAddedEventArgs";

    static PyObject* _new_ESimAddedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimAddedEventArgs);
        return nullptr;
    }

    static void _dealloc_ESimAddedEventArgs(py::wrapper::Windows::Networking::NetworkOperators::ESimAddedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimAddedEventArgs_get_ESim(py::wrapper::Windows::Networking::NetworkOperators::ESimAddedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimAddedEventArgs", L"ESim"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ESim());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESimAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESimAddedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESimAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimAddedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimAddedEventArgs[] = {
        { "_assign_array_", _assign_array_ESimAddedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimAddedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimAddedEventArgs[] = {
        { "e_sim", reinterpret_cast<getter>(ESimAddedEventArgs_get_ESim), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimAddedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimAddedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimAddedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimAddedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimAddedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ESimAddedEventArgs =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimAddedEventArgs",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimAddedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimAddedEventArgs
    };

    // ----- ESimDiscoverEvent class --------------------
    static constexpr const char* const type_name_ESimDiscoverEvent = "ESimDiscoverEvent";

    static PyObject* _new_ESimDiscoverEvent(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimDiscoverEvent);
        return nullptr;
    }

    static void _dealloc_ESimDiscoverEvent(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverEvent* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimDiscoverEvent_get_MatchingId(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverEvent* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimDiscoverEvent", L"MatchingId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MatchingId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimDiscoverEvent_get_RspServerAddress(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverEvent* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimDiscoverEvent", L"RspServerAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RspServerAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESimDiscoverEvent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESimDiscoverEvent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESimDiscoverEvent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimDiscoverEvent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimDiscoverEvent[] = {
        { "_assign_array_", _assign_array_ESimDiscoverEvent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimDiscoverEvent), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimDiscoverEvent[] = {
        { "matching_id", reinterpret_cast<getter>(ESimDiscoverEvent_get_MatchingId), nullptr, nullptr, nullptr },
        { "rsp_server_address", reinterpret_cast<getter>(ESimDiscoverEvent_get_RspServerAddress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimDiscoverEvent[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimDiscoverEvent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimDiscoverEvent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimDiscoverEvent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimDiscoverEvent) },
        { },
    };

    static PyType_Spec type_spec_ESimDiscoverEvent =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimDiscoverEvent",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverEvent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimDiscoverEvent
    };

    // ----- ESimDiscoverResult class --------------------
    static constexpr const char* const type_name_ESimDiscoverResult = "ESimDiscoverResult";

    static PyObject* _new_ESimDiscoverResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimDiscoverResult);
        return nullptr;
    }

    static void _dealloc_ESimDiscoverResult(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimDiscoverResult_get_Events(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimDiscoverResult", L"Events"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Events());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimDiscoverResult_get_Kind(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimDiscoverResult", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimDiscoverResult_get_ProfileMetadata(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimDiscoverResult", L"ProfileMetadata"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProfileMetadata());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimDiscoverResult_get_Result(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimDiscoverResult", L"Result"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESimDiscoverResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESimDiscoverResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESimDiscoverResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimDiscoverResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimDiscoverResult[] = {
        { "_assign_array_", _assign_array_ESimDiscoverResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimDiscoverResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimDiscoverResult[] = {
        { "events", reinterpret_cast<getter>(ESimDiscoverResult_get_Events), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ESimDiscoverResult_get_Kind), nullptr, nullptr, nullptr },
        { "profile_metadata", reinterpret_cast<getter>(ESimDiscoverResult_get_ProfileMetadata), nullptr, nullptr, nullptr },
        { "result", reinterpret_cast<getter>(ESimDiscoverResult_get_Result), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimDiscoverResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimDiscoverResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimDiscoverResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimDiscoverResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimDiscoverResult) },
        { },
    };

    static PyType_Spec type_spec_ESimDiscoverResult =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimDiscoverResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimDiscoverResult
    };

    // ----- ESimDownloadProfileMetadataResult class --------------------
    static constexpr const char* const type_name_ESimDownloadProfileMetadataResult = "ESimDownloadProfileMetadataResult";

    static PyObject* _new_ESimDownloadProfileMetadataResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimDownloadProfileMetadataResult);
        return nullptr;
    }

    static void _dealloc_ESimDownloadProfileMetadataResult(py::wrapper::Windows::Networking::NetworkOperators::ESimDownloadProfileMetadataResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimDownloadProfileMetadataResult_get_ProfileMetadata(py::wrapper::Windows::Networking::NetworkOperators::ESimDownloadProfileMetadataResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimDownloadProfileMetadataResult", L"ProfileMetadata"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProfileMetadata());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimDownloadProfileMetadataResult_get_Result(py::wrapper::Windows::Networking::NetworkOperators::ESimDownloadProfileMetadataResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimDownloadProfileMetadataResult", L"Result"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESimDownloadProfileMetadataResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESimDownloadProfileMetadataResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESimDownloadProfileMetadataResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimDownloadProfileMetadataResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimDownloadProfileMetadataResult[] = {
        { "_assign_array_", _assign_array_ESimDownloadProfileMetadataResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimDownloadProfileMetadataResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimDownloadProfileMetadataResult[] = {
        { "profile_metadata", reinterpret_cast<getter>(ESimDownloadProfileMetadataResult_get_ProfileMetadata), nullptr, nullptr, nullptr },
        { "result", reinterpret_cast<getter>(ESimDownloadProfileMetadataResult_get_Result), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimDownloadProfileMetadataResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimDownloadProfileMetadataResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimDownloadProfileMetadataResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimDownloadProfileMetadataResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimDownloadProfileMetadataResult) },
        { },
    };

    static PyType_Spec type_spec_ESimDownloadProfileMetadataResult =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimDownloadProfileMetadataResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimDownloadProfileMetadataResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimDownloadProfileMetadataResult
    };

    // ----- ESimManager class --------------------
    static constexpr const char* const type_name_ESimManager = "ESimManager";

    static PyObject* _new_ESimManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimManager);
        return nullptr;
    }

    static PyObject* ESimManager_TryCreateESimWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESimManager", L"TryCreateESimWatcher", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Networking::NetworkOperators::ESimManager::TryCreateESimWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESimManager_get_ServiceInfo(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimManager", L"ServiceInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::ESimManager::ServiceInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimManager_add_ServiceInfoChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimManager", L"ServiceInfoChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::Networking::NetworkOperators::ESimManager::ServiceInfoChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimManager_remove_ServiceInfoChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimManager", L"ServiceInfoChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Networking::NetworkOperators::ESimManager::ServiceInfoChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimManager[] = {
        { "try_create_e_sim_watcher", reinterpret_cast<PyCFunction>(ESimManager_TryCreateESimWatcher), METH_VARARGS | METH_STATIC, nullptr },
        { "add_service_info_changed", reinterpret_cast<PyCFunction>(ESimManager_add_ServiceInfoChanged), METH_O | METH_STATIC, nullptr },
        { "remove_service_info_changed", reinterpret_cast<PyCFunction>(ESimManager_remove_ServiceInfoChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimManager[] = {
        { }
    };

    static PyType_Slot _type_slots_ESimManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimManager) },
        { },
    };

    static PyType_Spec type_spec_ESimManager =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimManager
    };

    static PyGetSetDef getset_ESimManager_Meta[] = {
        { "service_info", reinterpret_cast<getter>(ESimManager_get_ServiceInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_ESimManager_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ESimManager_Meta) },
        { }
    };

    static PyType_Spec type_spec_ESimManager_Meta =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimManager_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ESimManager_Meta
    };

    // ----- ESimOperationResult class --------------------
    static constexpr const char* const type_name_ESimOperationResult = "ESimOperationResult";

    static PyObject* _new_ESimOperationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimOperationResult);
        return nullptr;
    }

    static void _dealloc_ESimOperationResult(py::wrapper::Windows::Networking::NetworkOperators::ESimOperationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimOperationResult_get_Status(py::wrapper::Windows::Networking::NetworkOperators::ESimOperationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimOperationResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESimOperationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESimOperationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESimOperationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimOperationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimOperationResult[] = {
        { "_assign_array_", _assign_array_ESimOperationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimOperationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimOperationResult[] = {
        { "status", reinterpret_cast<getter>(ESimOperationResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimOperationResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimOperationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimOperationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimOperationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimOperationResult) },
        { },
    };

    static PyType_Spec type_spec_ESimOperationResult =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimOperationResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimOperationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimOperationResult
    };

    // ----- ESimPolicy class --------------------
    static constexpr const char* const type_name_ESimPolicy = "ESimPolicy";

    static PyObject* _new_ESimPolicy(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimPolicy);
        return nullptr;
    }

    static void _dealloc_ESimPolicy(py::wrapper::Windows::Networking::NetworkOperators::ESimPolicy* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimPolicy_get_ShouldEnableManagingUi(py::wrapper::Windows::Networking::NetworkOperators::ESimPolicy* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimPolicy", L"ShouldEnableManagingUi"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShouldEnableManagingUi());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESimPolicy(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESimPolicy>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESimPolicy(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimPolicy>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimPolicy[] = {
        { "_assign_array_", _assign_array_ESimPolicy, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimPolicy), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimPolicy[] = {
        { "should_enable_managing_ui", reinterpret_cast<getter>(ESimPolicy_get_ShouldEnableManagingUi), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimPolicy[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimPolicy) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimPolicy) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimPolicy) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimPolicy) },
        { },
    };

    static PyType_Spec type_spec_ESimPolicy =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimPolicy",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimPolicy),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimPolicy
    };

    // ----- ESimProfile class --------------------
    static constexpr const char* const type_name_ESimProfile = "ESimProfile";

    static PyObject* _new_ESimProfile(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimProfile);
        return nullptr;
    }

    static void _dealloc_ESimProfile(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimProfile_DisableAsync(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESimProfile", L"DisableAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DisableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESimProfile_EnableAsync(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESimProfile", L"EnableAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.EnableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESimProfile_SetNicknameAsync(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESimProfile", L"SetNicknameAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.SetNicknameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESimProfile_get_Class(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfile", L"Class"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Class());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfile_get_Id(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfile", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfile_get_Nickname(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfile", L"Nickname"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Nickname());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfile_get_Policy(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfile", L"Policy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Policy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfile_get_ProviderIcon(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfile", L"ProviderIcon"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderIcon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfile_get_ProviderId(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfile", L"ProviderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfile_get_ProviderName(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfile", L"ProviderName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfile_get_State(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfile", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESimProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESimProfile>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESimProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimProfile[] = {
        { "disable_async", reinterpret_cast<PyCFunction>(ESimProfile_DisableAsync), METH_VARARGS, nullptr },
        { "enable_async", reinterpret_cast<PyCFunction>(ESimProfile_EnableAsync), METH_VARARGS, nullptr },
        { "set_nickname_async", reinterpret_cast<PyCFunction>(ESimProfile_SetNicknameAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ESimProfile, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimProfile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimProfile[] = {
        { "class_", reinterpret_cast<getter>(ESimProfile_get_Class), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ESimProfile_get_Id), nullptr, nullptr, nullptr },
        { "nickname", reinterpret_cast<getter>(ESimProfile_get_Nickname), nullptr, nullptr, nullptr },
        { "policy", reinterpret_cast<getter>(ESimProfile_get_Policy), nullptr, nullptr, nullptr },
        { "provider_icon", reinterpret_cast<getter>(ESimProfile_get_ProviderIcon), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(ESimProfile_get_ProviderId), nullptr, nullptr, nullptr },
        { "provider_name", reinterpret_cast<getter>(ESimProfile_get_ProviderName), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(ESimProfile_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimProfile[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimProfile) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimProfile) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimProfile) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimProfile) },
        { },
    };

    static PyType_Spec type_spec_ESimProfile =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimProfile",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimProfile
    };

    // ----- ESimProfileMetadata class --------------------
    static constexpr const char* const type_name_ESimProfileMetadata = "ESimProfileMetadata";

    static PyObject* _new_ESimProfileMetadata(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimProfileMetadata);
        return nullptr;
    }

    static void _dealloc_ESimProfileMetadata(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimProfileMetadata_ConfirmInstallAsync(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESimProfileMetadata", L"ConfirmInstallAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ConfirmInstallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESimProfileMetadata", L"ConfirmInstallAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ConfirmInstallAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_DenyInstallAsync(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESimProfileMetadata", L"DenyInstallAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DenyInstallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_PostponeInstallAsync(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESimProfileMetadata", L"PostponeInstallAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.PostponeInstallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_get_Id(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfileMetadata", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_get_IsConfirmationCodeRequired(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfileMetadata", L"IsConfirmationCodeRequired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsConfirmationCodeRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_get_Policy(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfileMetadata", L"Policy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Policy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_get_ProviderIcon(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfileMetadata", L"ProviderIcon"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderIcon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_get_ProviderId(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfileMetadata", L"ProviderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_get_ProviderName(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfileMetadata", L"ProviderName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_get_State(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfileMetadata", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_add_StateChanged(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimProfileMetadata", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::ESimProfileMetadata, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_remove_StateChanged(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimProfileMetadata", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESimProfileMetadata(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESimProfileMetadata>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESimProfileMetadata(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimProfileMetadata>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimProfileMetadata[] = {
        { "confirm_install_async", reinterpret_cast<PyCFunction>(ESimProfileMetadata_ConfirmInstallAsync), METH_VARARGS, nullptr },
        { "deny_install_async", reinterpret_cast<PyCFunction>(ESimProfileMetadata_DenyInstallAsync), METH_VARARGS, nullptr },
        { "postpone_install_async", reinterpret_cast<PyCFunction>(ESimProfileMetadata_PostponeInstallAsync), METH_VARARGS, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(ESimProfileMetadata_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(ESimProfileMetadata_remove_StateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ESimProfileMetadata, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimProfileMetadata), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimProfileMetadata[] = {
        { "id", reinterpret_cast<getter>(ESimProfileMetadata_get_Id), nullptr, nullptr, nullptr },
        { "is_confirmation_code_required", reinterpret_cast<getter>(ESimProfileMetadata_get_IsConfirmationCodeRequired), nullptr, nullptr, nullptr },
        { "policy", reinterpret_cast<getter>(ESimProfileMetadata_get_Policy), nullptr, nullptr, nullptr },
        { "provider_icon", reinterpret_cast<getter>(ESimProfileMetadata_get_ProviderIcon), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(ESimProfileMetadata_get_ProviderId), nullptr, nullptr, nullptr },
        { "provider_name", reinterpret_cast<getter>(ESimProfileMetadata_get_ProviderName), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(ESimProfileMetadata_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimProfileMetadata[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimProfileMetadata) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimProfileMetadata) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimProfileMetadata) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimProfileMetadata) },
        { },
    };

    static PyType_Spec type_spec_ESimProfileMetadata =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimProfileMetadata",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimProfileMetadata
    };

    // ----- ESimProfilePolicy class --------------------
    static constexpr const char* const type_name_ESimProfilePolicy = "ESimProfilePolicy";

    static PyObject* _new_ESimProfilePolicy(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimProfilePolicy);
        return nullptr;
    }

    static void _dealloc_ESimProfilePolicy(py::wrapper::Windows::Networking::NetworkOperators::ESimProfilePolicy* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimProfilePolicy_get_CanDelete(py::wrapper::Windows::Networking::NetworkOperators::ESimProfilePolicy* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfilePolicy", L"CanDelete"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanDelete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfilePolicy_get_CanDisable(py::wrapper::Windows::Networking::NetworkOperators::ESimProfilePolicy* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfilePolicy", L"CanDisable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanDisable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfilePolicy_get_IsManagedByEnterprise(py::wrapper::Windows::Networking::NetworkOperators::ESimProfilePolicy* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfilePolicy", L"IsManagedByEnterprise"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsManagedByEnterprise());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESimProfilePolicy(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESimProfilePolicy>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESimProfilePolicy(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimProfilePolicy>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimProfilePolicy[] = {
        { "_assign_array_", _assign_array_ESimProfilePolicy, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimProfilePolicy), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimProfilePolicy[] = {
        { "can_delete", reinterpret_cast<getter>(ESimProfilePolicy_get_CanDelete), nullptr, nullptr, nullptr },
        { "can_disable", reinterpret_cast<getter>(ESimProfilePolicy_get_CanDisable), nullptr, nullptr, nullptr },
        { "is_managed_by_enterprise", reinterpret_cast<getter>(ESimProfilePolicy_get_IsManagedByEnterprise), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimProfilePolicy[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimProfilePolicy) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimProfilePolicy) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimProfilePolicy) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimProfilePolicy) },
        { },
    };

    static PyType_Spec type_spec_ESimProfilePolicy =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimProfilePolicy",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimProfilePolicy),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimProfilePolicy
    };

    // ----- ESimRemovedEventArgs class --------------------
    static constexpr const char* const type_name_ESimRemovedEventArgs = "ESimRemovedEventArgs";

    static PyObject* _new_ESimRemovedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimRemovedEventArgs);
        return nullptr;
    }

    static void _dealloc_ESimRemovedEventArgs(py::wrapper::Windows::Networking::NetworkOperators::ESimRemovedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimRemovedEventArgs_get_ESim(py::wrapper::Windows::Networking::NetworkOperators::ESimRemovedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimRemovedEventArgs", L"ESim"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ESim());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESimRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESimRemovedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESimRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimRemovedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimRemovedEventArgs[] = {
        { "_assign_array_", _assign_array_ESimRemovedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimRemovedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimRemovedEventArgs[] = {
        { "e_sim", reinterpret_cast<getter>(ESimRemovedEventArgs_get_ESim), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimRemovedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimRemovedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimRemovedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimRemovedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimRemovedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ESimRemovedEventArgs =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimRemovedEventArgs",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimRemovedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimRemovedEventArgs
    };

    // ----- ESimServiceInfo class --------------------
    static constexpr const char* const type_name_ESimServiceInfo = "ESimServiceInfo";

    static PyObject* _new_ESimServiceInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimServiceInfo);
        return nullptr;
    }

    static void _dealloc_ESimServiceInfo(py::wrapper::Windows::Networking::NetworkOperators::ESimServiceInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimServiceInfo_get_AuthenticationPreference(py::wrapper::Windows::Networking::NetworkOperators::ESimServiceInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimServiceInfo", L"AuthenticationPreference"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AuthenticationPreference());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimServiceInfo_get_IsESimUiEnabled(py::wrapper::Windows::Networking::NetworkOperators::ESimServiceInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimServiceInfo", L"IsESimUiEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsESimUiEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESimServiceInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESimServiceInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESimServiceInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimServiceInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimServiceInfo[] = {
        { "_assign_array_", _assign_array_ESimServiceInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimServiceInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimServiceInfo[] = {
        { "authentication_preference", reinterpret_cast<getter>(ESimServiceInfo_get_AuthenticationPreference), nullptr, nullptr, nullptr },
        { "is_e_sim_ui_enabled", reinterpret_cast<getter>(ESimServiceInfo_get_IsESimUiEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimServiceInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimServiceInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimServiceInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimServiceInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimServiceInfo) },
        { },
    };

    static PyType_Spec type_spec_ESimServiceInfo =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimServiceInfo",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimServiceInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimServiceInfo
    };

    // ----- ESimUpdatedEventArgs class --------------------
    static constexpr const char* const type_name_ESimUpdatedEventArgs = "ESimUpdatedEventArgs";

    static PyObject* _new_ESimUpdatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimUpdatedEventArgs);
        return nullptr;
    }

    static void _dealloc_ESimUpdatedEventArgs(py::wrapper::Windows::Networking::NetworkOperators::ESimUpdatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimUpdatedEventArgs_get_ESim(py::wrapper::Windows::Networking::NetworkOperators::ESimUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimUpdatedEventArgs", L"ESim"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ESim());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESimUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESimUpdatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESimUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimUpdatedEventArgs[] = {
        { "_assign_array_", _assign_array_ESimUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimUpdatedEventArgs[] = {
        { "e_sim", reinterpret_cast<getter>(ESimUpdatedEventArgs_get_ESim), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimUpdatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimUpdatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimUpdatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimUpdatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimUpdatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ESimUpdatedEventArgs =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimUpdatedEventArgs",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimUpdatedEventArgs
    };

    // ----- ESimWatcher class --------------------
    static constexpr const char* const type_name_ESimWatcher = "ESimWatcher";

    static PyObject* _new_ESimWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimWatcher);
        return nullptr;
    }

    static void _dealloc_ESimWatcher(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimWatcher_Start(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESimWatcher", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_Stop(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESimWatcher", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_get_Status(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimWatcher", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_add_Added(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimWatcher", L"Added"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::ESimWatcher, winrt::Windows::Networking::NetworkOperators::ESimAddedEventArgs>>(arg);

            return py::convert(self->obj.Added(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_remove_Added(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimWatcher", L"Added"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Added(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_add_EnumerationCompleted(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::ESimWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_remove_EnumerationCompleted(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_add_Removed(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimWatcher", L"Removed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::ESimWatcher, winrt::Windows::Networking::NetworkOperators::ESimRemovedEventArgs>>(arg);

            return py::convert(self->obj.Removed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_remove_Removed(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimWatcher", L"Removed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Removed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_add_Stopped(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::ESimWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_remove_Stopped(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_add_Updated(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimWatcher", L"Updated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::ESimWatcher, winrt::Windows::Networking::NetworkOperators::ESimUpdatedEventArgs>>(arg);

            return py::convert(self->obj.Updated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_remove_Updated(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimWatcher", L"Updated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Updated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESimWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESimWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESimWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(ESimWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(ESimWatcher_Stop), METH_VARARGS, nullptr },
        { "add_added", reinterpret_cast<PyCFunction>(ESimWatcher_add_Added), METH_O, nullptr },
        { "remove_added", reinterpret_cast<PyCFunction>(ESimWatcher_remove_Added), METH_O, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(ESimWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(ESimWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_removed", reinterpret_cast<PyCFunction>(ESimWatcher_add_Removed), METH_O, nullptr },
        { "remove_removed", reinterpret_cast<PyCFunction>(ESimWatcher_remove_Removed), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(ESimWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(ESimWatcher_remove_Stopped), METH_O, nullptr },
        { "add_updated", reinterpret_cast<PyCFunction>(ESimWatcher_add_Updated), METH_O, nullptr },
        { "remove_updated", reinterpret_cast<PyCFunction>(ESimWatcher_remove_Updated), METH_O, nullptr },
        { "_assign_array_", _assign_array_ESimWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimWatcher[] = {
        { "status", reinterpret_cast<getter>(ESimWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimWatcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimWatcher) },
        { },
    };

    static PyType_Spec type_spec_ESimWatcher =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimWatcher",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimWatcher
    };

    // ----- FdnAccessManager class --------------------
    static constexpr const char* const type_name_FdnAccessManager = "FdnAccessManager";

    static PyObject* _new_FdnAccessManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FdnAccessManager);
        return nullptr;
    }

    static PyObject* FdnAccessManager_RequestUnlockAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.FdnAccessManager", L"RequestUnlockAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::FdnAccessManager::RequestUnlockAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_FdnAccessManager[] = {
        { "request_unlock_async", reinterpret_cast<PyCFunction>(FdnAccessManager_RequestUnlockAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FdnAccessManager[] = {
        { }
    };

    static PyType_Slot _type_slots_FdnAccessManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FdnAccessManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FdnAccessManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FdnAccessManager) },
        { },
    };

    static PyType_Spec type_spec_FdnAccessManager =
    {
        "_winsdk_Windows_Networking_NetworkOperators.FdnAccessManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FdnAccessManager
    };

    // ----- HotspotAuthenticationContext class --------------------
    static constexpr const char* const type_name_HotspotAuthenticationContext = "HotspotAuthenticationContext";

    static PyObject* _new_HotspotAuthenticationContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HotspotAuthenticationContext);
        return nullptr;
    }

    static void _dealloc_HotspotAuthenticationContext(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HotspotAuthenticationContext_AbortAuthentication(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.HotspotAuthenticationContext", L"AbortAuthentication", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.AbortAuthentication(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_IssueCredentials(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.HotspotAuthenticationContext", L"IssueCredentials", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<bool>(args, 3);

                self->obj.IssueCredentials(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_IssueCredentialsAsync(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.HotspotAuthenticationContext", L"IssueCredentialsAsync", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<bool>(args, 3);

                return py::convert(self->obj.IssueCredentialsAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_SkipAuthentication(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.HotspotAuthenticationContext", L"SkipAuthentication", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.SkipAuthentication();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_TriggerAttentionRequired(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.HotspotAuthenticationContext", L"TriggerAttentionRequired", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.TriggerAttentionRequired(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_TryGetAuthenticationContext(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.HotspotAuthenticationContext", L"TryGetAuthenticationContext", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationContext param1 { nullptr };

                auto return_value = winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationContext::TryGetAuthenticationContext(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_get_AuthenticationUrl(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.HotspotAuthenticationContext", L"AuthenticationUrl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AuthenticationUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_get_NetworkAdapter(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.HotspotAuthenticationContext", L"NetworkAdapter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkAdapter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_get_RedirectMessageUrl(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.HotspotAuthenticationContext", L"RedirectMessageUrl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RedirectMessageUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_get_RedirectMessageXml(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.HotspotAuthenticationContext", L"RedirectMessageXml"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RedirectMessageXml());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_get_WirelessNetworkId(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.HotspotAuthenticationContext", L"WirelessNetworkId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WirelessNetworkId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HotspotAuthenticationContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HotspotAuthenticationContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HotspotAuthenticationContext[] = {
        { "abort_authentication", reinterpret_cast<PyCFunction>(HotspotAuthenticationContext_AbortAuthentication), METH_VARARGS, nullptr },
        { "issue_credentials", reinterpret_cast<PyCFunction>(HotspotAuthenticationContext_IssueCredentials), METH_VARARGS, nullptr },
        { "issue_credentials_async", reinterpret_cast<PyCFunction>(HotspotAuthenticationContext_IssueCredentialsAsync), METH_VARARGS, nullptr },
        { "skip_authentication", reinterpret_cast<PyCFunction>(HotspotAuthenticationContext_SkipAuthentication), METH_VARARGS, nullptr },
        { "trigger_attention_required", reinterpret_cast<PyCFunction>(HotspotAuthenticationContext_TriggerAttentionRequired), METH_VARARGS, nullptr },
        { "try_get_authentication_context", reinterpret_cast<PyCFunction>(HotspotAuthenticationContext_TryGetAuthenticationContext), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_HotspotAuthenticationContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HotspotAuthenticationContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HotspotAuthenticationContext[] = {
        { "authentication_url", reinterpret_cast<getter>(HotspotAuthenticationContext_get_AuthenticationUrl), nullptr, nullptr, nullptr },
        { "network_adapter", reinterpret_cast<getter>(HotspotAuthenticationContext_get_NetworkAdapter), nullptr, nullptr, nullptr },
        { "redirect_message_url", reinterpret_cast<getter>(HotspotAuthenticationContext_get_RedirectMessageUrl), nullptr, nullptr, nullptr },
        { "redirect_message_xml", reinterpret_cast<getter>(HotspotAuthenticationContext_get_RedirectMessageXml), nullptr, nullptr, nullptr },
        { "wireless_network_id", reinterpret_cast<getter>(HotspotAuthenticationContext_get_WirelessNetworkId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HotspotAuthenticationContext[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HotspotAuthenticationContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HotspotAuthenticationContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HotspotAuthenticationContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HotspotAuthenticationContext) },
        { },
    };

    static PyType_Spec type_spec_HotspotAuthenticationContext =
    {
        "_winsdk_Windows_Networking_NetworkOperators.HotspotAuthenticationContext",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HotspotAuthenticationContext
    };

    // ----- HotspotAuthenticationEventDetails class --------------------
    static constexpr const char* const type_name_HotspotAuthenticationEventDetails = "HotspotAuthenticationEventDetails";

    static PyObject* _new_HotspotAuthenticationEventDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HotspotAuthenticationEventDetails);
        return nullptr;
    }

    static void _dealloc_HotspotAuthenticationEventDetails(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationEventDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HotspotAuthenticationEventDetails_get_EventToken(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationEventDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.HotspotAuthenticationEventDetails", L"EventToken"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EventToken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HotspotAuthenticationEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationEventDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HotspotAuthenticationEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationEventDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HotspotAuthenticationEventDetails[] = {
        { "_assign_array_", _assign_array_HotspotAuthenticationEventDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HotspotAuthenticationEventDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HotspotAuthenticationEventDetails[] = {
        { "event_token", reinterpret_cast<getter>(HotspotAuthenticationEventDetails_get_EventToken), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HotspotAuthenticationEventDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HotspotAuthenticationEventDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HotspotAuthenticationEventDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HotspotAuthenticationEventDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HotspotAuthenticationEventDetails) },
        { },
    };

    static PyType_Spec type_spec_HotspotAuthenticationEventDetails =
    {
        "_winsdk_Windows_Networking_NetworkOperators.HotspotAuthenticationEventDetails",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationEventDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HotspotAuthenticationEventDetails
    };

    // ----- HotspotCredentialsAuthenticationResult class --------------------
    static constexpr const char* const type_name_HotspotCredentialsAuthenticationResult = "HotspotCredentialsAuthenticationResult";

    static PyObject* _new_HotspotCredentialsAuthenticationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HotspotCredentialsAuthenticationResult);
        return nullptr;
    }

    static void _dealloc_HotspotCredentialsAuthenticationResult(py::wrapper::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HotspotCredentialsAuthenticationResult_get_AuthenticationReplyXml(py::wrapper::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.HotspotCredentialsAuthenticationResult", L"AuthenticationReplyXml"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AuthenticationReplyXml());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HotspotCredentialsAuthenticationResult_get_HasNetworkErrorOccurred(py::wrapper::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.HotspotCredentialsAuthenticationResult", L"HasNetworkErrorOccurred"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasNetworkErrorOccurred());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HotspotCredentialsAuthenticationResult_get_LogoffUrl(py::wrapper::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.HotspotCredentialsAuthenticationResult", L"LogoffUrl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LogoffUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HotspotCredentialsAuthenticationResult_get_ResponseCode(py::wrapper::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.HotspotCredentialsAuthenticationResult", L"ResponseCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ResponseCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HotspotCredentialsAuthenticationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HotspotCredentialsAuthenticationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HotspotCredentialsAuthenticationResult[] = {
        { "_assign_array_", _assign_array_HotspotCredentialsAuthenticationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HotspotCredentialsAuthenticationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HotspotCredentialsAuthenticationResult[] = {
        { "authentication_reply_xml", reinterpret_cast<getter>(HotspotCredentialsAuthenticationResult_get_AuthenticationReplyXml), nullptr, nullptr, nullptr },
        { "has_network_error_occurred", reinterpret_cast<getter>(HotspotCredentialsAuthenticationResult_get_HasNetworkErrorOccurred), nullptr, nullptr, nullptr },
        { "logoff_url", reinterpret_cast<getter>(HotspotCredentialsAuthenticationResult_get_LogoffUrl), nullptr, nullptr, nullptr },
        { "response_code", reinterpret_cast<getter>(HotspotCredentialsAuthenticationResult_get_ResponseCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HotspotCredentialsAuthenticationResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HotspotCredentialsAuthenticationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HotspotCredentialsAuthenticationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HotspotCredentialsAuthenticationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HotspotCredentialsAuthenticationResult) },
        { },
    };

    static PyType_Spec type_spec_HotspotCredentialsAuthenticationResult =
    {
        "_winsdk_Windows_Networking_NetworkOperators.HotspotCredentialsAuthenticationResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HotspotCredentialsAuthenticationResult
    };

    // ----- KnownCSimFilePaths class --------------------
    static constexpr const char* const type_name_KnownCSimFilePaths = "KnownCSimFilePaths";

    static PyObject* _new_KnownCSimFilePaths(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownCSimFilePaths);
        return nullptr;
    }

    static PyObject* KnownCSimFilePaths_get_EFSpn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownCSimFilePaths", L"EFSpn"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownCSimFilePaths::EFSpn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownCSimFilePaths_get_Gid1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownCSimFilePaths", L"Gid1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownCSimFilePaths::Gid1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownCSimFilePaths_get_Gid2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownCSimFilePaths", L"Gid2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownCSimFilePaths::Gid2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownCSimFilePaths[] = {
        { }
    };

    static PyGetSetDef _getset_KnownCSimFilePaths[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownCSimFilePaths[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownCSimFilePaths) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownCSimFilePaths) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownCSimFilePaths) },
        { },
    };

    static PyType_Spec type_spec_KnownCSimFilePaths =
    {
        "_winsdk_Windows_Networking_NetworkOperators.KnownCSimFilePaths",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownCSimFilePaths
    };

    static PyGetSetDef getset_KnownCSimFilePaths_Meta[] = {
        { "e_f_spn", reinterpret_cast<getter>(KnownCSimFilePaths_get_EFSpn), nullptr, nullptr, nullptr },
        { "gid1", reinterpret_cast<getter>(KnownCSimFilePaths_get_Gid1), nullptr, nullptr, nullptr },
        { "gid2", reinterpret_cast<getter>(KnownCSimFilePaths_get_Gid2), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_KnownCSimFilePaths_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownCSimFilePaths_Meta) },
        { }
    };

    static PyType_Spec type_spec_KnownCSimFilePaths_Meta =
    {
        "_winsdk_Windows_Networking_NetworkOperators.KnownCSimFilePaths_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownCSimFilePaths_Meta
    };

    // ----- KnownRuimFilePaths class --------------------
    static constexpr const char* const type_name_KnownRuimFilePaths = "KnownRuimFilePaths";

    static PyObject* _new_KnownRuimFilePaths(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownRuimFilePaths);
        return nullptr;
    }

    static PyObject* KnownRuimFilePaths_get_EFSpn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownRuimFilePaths", L"EFSpn"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownRuimFilePaths::EFSpn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRuimFilePaths_get_Gid1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownRuimFilePaths", L"Gid1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownRuimFilePaths::Gid1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRuimFilePaths_get_Gid2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownRuimFilePaths", L"Gid2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownRuimFilePaths::Gid2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownRuimFilePaths[] = {
        { }
    };

    static PyGetSetDef _getset_KnownRuimFilePaths[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownRuimFilePaths[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownRuimFilePaths) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownRuimFilePaths) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownRuimFilePaths) },
        { },
    };

    static PyType_Spec type_spec_KnownRuimFilePaths =
    {
        "_winsdk_Windows_Networking_NetworkOperators.KnownRuimFilePaths",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownRuimFilePaths
    };

    static PyGetSetDef getset_KnownRuimFilePaths_Meta[] = {
        { "e_f_spn", reinterpret_cast<getter>(KnownRuimFilePaths_get_EFSpn), nullptr, nullptr, nullptr },
        { "gid1", reinterpret_cast<getter>(KnownRuimFilePaths_get_Gid1), nullptr, nullptr, nullptr },
        { "gid2", reinterpret_cast<getter>(KnownRuimFilePaths_get_Gid2), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_KnownRuimFilePaths_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownRuimFilePaths_Meta) },
        { }
    };

    static PyType_Spec type_spec_KnownRuimFilePaths_Meta =
    {
        "_winsdk_Windows_Networking_NetworkOperators.KnownRuimFilePaths_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownRuimFilePaths_Meta
    };

    // ----- KnownSimFilePaths class --------------------
    static constexpr const char* const type_name_KnownSimFilePaths = "KnownSimFilePaths";

    static PyObject* _new_KnownSimFilePaths(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownSimFilePaths);
        return nullptr;
    }

    static PyObject* KnownSimFilePaths_get_EFOns(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownSimFilePaths", L"EFOns"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownSimFilePaths::EFOns());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownSimFilePaths_get_EFSpn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownSimFilePaths", L"EFSpn"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownSimFilePaths::EFSpn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownSimFilePaths_get_Gid1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownSimFilePaths", L"Gid1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownSimFilePaths::Gid1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownSimFilePaths_get_Gid2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownSimFilePaths", L"Gid2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownSimFilePaths::Gid2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownSimFilePaths[] = {
        { }
    };

    static PyGetSetDef _getset_KnownSimFilePaths[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownSimFilePaths[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownSimFilePaths) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownSimFilePaths) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownSimFilePaths) },
        { },
    };

    static PyType_Spec type_spec_KnownSimFilePaths =
    {
        "_winsdk_Windows_Networking_NetworkOperators.KnownSimFilePaths",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownSimFilePaths
    };

    static PyGetSetDef getset_KnownSimFilePaths_Meta[] = {
        { "e_f_ons", reinterpret_cast<getter>(KnownSimFilePaths_get_EFOns), nullptr, nullptr, nullptr },
        { "e_f_spn", reinterpret_cast<getter>(KnownSimFilePaths_get_EFSpn), nullptr, nullptr, nullptr },
        { "gid1", reinterpret_cast<getter>(KnownSimFilePaths_get_Gid1), nullptr, nullptr, nullptr },
        { "gid2", reinterpret_cast<getter>(KnownSimFilePaths_get_Gid2), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_KnownSimFilePaths_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownSimFilePaths_Meta) },
        { }
    };

    static PyType_Spec type_spec_KnownSimFilePaths_Meta =
    {
        "_winsdk_Windows_Networking_NetworkOperators.KnownSimFilePaths_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownSimFilePaths_Meta
    };

    // ----- KnownUSimFilePaths class --------------------
    static constexpr const char* const type_name_KnownUSimFilePaths = "KnownUSimFilePaths";

    static PyObject* _new_KnownUSimFilePaths(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownUSimFilePaths);
        return nullptr;
    }

    static PyObject* KnownUSimFilePaths_get_EFOpl(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownUSimFilePaths", L"EFOpl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownUSimFilePaths::EFOpl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUSimFilePaths_get_EFPnn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownUSimFilePaths", L"EFPnn"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownUSimFilePaths::EFPnn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUSimFilePaths_get_EFSpn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownUSimFilePaths", L"EFSpn"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownUSimFilePaths::EFSpn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUSimFilePaths_get_Gid1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownUSimFilePaths", L"Gid1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownUSimFilePaths::Gid1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUSimFilePaths_get_Gid2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownUSimFilePaths", L"Gid2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownUSimFilePaths::Gid2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownUSimFilePaths[] = {
        { }
    };

    static PyGetSetDef _getset_KnownUSimFilePaths[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownUSimFilePaths[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownUSimFilePaths) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownUSimFilePaths) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownUSimFilePaths) },
        { },
    };

    static PyType_Spec type_spec_KnownUSimFilePaths =
    {
        "_winsdk_Windows_Networking_NetworkOperators.KnownUSimFilePaths",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownUSimFilePaths
    };

    static PyGetSetDef getset_KnownUSimFilePaths_Meta[] = {
        { "e_f_opl", reinterpret_cast<getter>(KnownUSimFilePaths_get_EFOpl), nullptr, nullptr, nullptr },
        { "e_f_pnn", reinterpret_cast<getter>(KnownUSimFilePaths_get_EFPnn), nullptr, nullptr, nullptr },
        { "e_f_spn", reinterpret_cast<getter>(KnownUSimFilePaths_get_EFSpn), nullptr, nullptr, nullptr },
        { "gid1", reinterpret_cast<getter>(KnownUSimFilePaths_get_Gid1), nullptr, nullptr, nullptr },
        { "gid2", reinterpret_cast<getter>(KnownUSimFilePaths_get_Gid2), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_KnownUSimFilePaths_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownUSimFilePaths_Meta) },
        { }
    };

    static PyType_Spec type_spec_KnownUSimFilePaths_Meta =
    {
        "_winsdk_Windows_Networking_NetworkOperators.KnownUSimFilePaths_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownUSimFilePaths_Meta
    };

    // ----- MobileBroadbandAccount class --------------------
    static constexpr const char* const type_name_MobileBroadbandAccount = "MobileBroadbandAccount";

    static PyObject* _new_MobileBroadbandAccount(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandAccount);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandAccount(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccount* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandAccount_CreateFromNetworkAccountId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccount", L"CreateFromNetworkAccountId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccount::CreateFromNetworkAccountId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccount_GetConnectionProfiles(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccount* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccount", L"GetConnectionProfiles", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetConnectionProfiles());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccount_get_CurrentDeviceInformation(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccount* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccount", L"CurrentDeviceInformation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentDeviceInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccount_get_CurrentNetwork(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccount* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccount", L"CurrentNetwork"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentNetwork());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccount_get_NetworkAccountId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccount* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccount", L"NetworkAccountId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccount_get_ServiceProviderGuid(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccount* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccount", L"ServiceProviderGuid"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServiceProviderGuid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccount_get_ServiceProviderName(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccount* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccount", L"ServiceProviderName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServiceProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccount_get_AccountExperienceUrl(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccount* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccount", L"AccountExperienceUrl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccountExperienceUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccount_get_AvailableNetworkAccountIds(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccount", L"AvailableNetworkAccountIds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccount::AvailableNetworkAccountIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandAccount(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccount>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandAccount(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccount>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandAccount[] = {
        { "create_from_network_account_id", reinterpret_cast<PyCFunction>(MobileBroadbandAccount_CreateFromNetworkAccountId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_connection_profiles", reinterpret_cast<PyCFunction>(MobileBroadbandAccount_GetConnectionProfiles), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandAccount, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandAccount), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandAccount[] = {
        { "current_device_information", reinterpret_cast<getter>(MobileBroadbandAccount_get_CurrentDeviceInformation), nullptr, nullptr, nullptr },
        { "current_network", reinterpret_cast<getter>(MobileBroadbandAccount_get_CurrentNetwork), nullptr, nullptr, nullptr },
        { "network_account_id", reinterpret_cast<getter>(MobileBroadbandAccount_get_NetworkAccountId), nullptr, nullptr, nullptr },
        { "service_provider_guid", reinterpret_cast<getter>(MobileBroadbandAccount_get_ServiceProviderGuid), nullptr, nullptr, nullptr },
        { "service_provider_name", reinterpret_cast<getter>(MobileBroadbandAccount_get_ServiceProviderName), nullptr, nullptr, nullptr },
        { "account_experience_url", reinterpret_cast<getter>(MobileBroadbandAccount_get_AccountExperienceUrl), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandAccount[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandAccount) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandAccount) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandAccount) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandAccount) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandAccount =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandAccount",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccount),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandAccount
    };

    static PyGetSetDef getset_MobileBroadbandAccount_Meta[] = {
        { "available_network_account_ids", reinterpret_cast<getter>(MobileBroadbandAccount_get_AvailableNetworkAccountIds), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_MobileBroadbandAccount_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MobileBroadbandAccount_Meta) },
        { }
    };

    static PyType_Spec type_spec_MobileBroadbandAccount_Meta =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandAccount_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MobileBroadbandAccount_Meta
    };

    // ----- MobileBroadbandAccountEventArgs class --------------------
    static constexpr const char* const type_name_MobileBroadbandAccountEventArgs = "MobileBroadbandAccountEventArgs";

    static PyObject* _new_MobileBroadbandAccountEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandAccountEventArgs);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandAccountEventArgs(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandAccountEventArgs_get_NetworkAccountId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs", L"NetworkAccountId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandAccountEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandAccountEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandAccountEventArgs[] = {
        { "_assign_array_", _assign_array_MobileBroadbandAccountEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandAccountEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandAccountEventArgs[] = {
        { "network_account_id", reinterpret_cast<getter>(MobileBroadbandAccountEventArgs_get_NetworkAccountId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandAccountEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandAccountEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandAccountEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandAccountEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandAccountEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandAccountEventArgs =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandAccountEventArgs",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandAccountEventArgs
    };

    // ----- MobileBroadbandAccountUpdatedEventArgs class --------------------
    static constexpr const char* const type_name_MobileBroadbandAccountUpdatedEventArgs = "MobileBroadbandAccountUpdatedEventArgs";

    static PyObject* _new_MobileBroadbandAccountUpdatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandAccountUpdatedEventArgs);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandAccountUpdatedEventArgs(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandAccountUpdatedEventArgs_get_HasDeviceInformationChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountUpdatedEventArgs", L"HasDeviceInformationChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasDeviceInformationChanged());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountUpdatedEventArgs_get_HasNetworkChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountUpdatedEventArgs", L"HasNetworkChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasNetworkChanged());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountUpdatedEventArgs_get_NetworkAccountId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountUpdatedEventArgs", L"NetworkAccountId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandAccountUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandAccountUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandAccountUpdatedEventArgs[] = {
        { "_assign_array_", _assign_array_MobileBroadbandAccountUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandAccountUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandAccountUpdatedEventArgs[] = {
        { "has_device_information_changed", reinterpret_cast<getter>(MobileBroadbandAccountUpdatedEventArgs_get_HasDeviceInformationChanged), nullptr, nullptr, nullptr },
        { "has_network_changed", reinterpret_cast<getter>(MobileBroadbandAccountUpdatedEventArgs_get_HasNetworkChanged), nullptr, nullptr, nullptr },
        { "network_account_id", reinterpret_cast<getter>(MobileBroadbandAccountUpdatedEventArgs_get_NetworkAccountId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandAccountUpdatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandAccountUpdatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandAccountUpdatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandAccountUpdatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandAccountUpdatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandAccountUpdatedEventArgs =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandAccountUpdatedEventArgs",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandAccountUpdatedEventArgs
    };

    // ----- MobileBroadbandAccountWatcher class --------------------
    static constexpr const char* const type_name_MobileBroadbandAccountWatcher = "MobileBroadbandAccountWatcher";

    static PyObject* _new_MobileBroadbandAccountWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MobileBroadbandAccountWatcher(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandAccountWatcher_Start(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_Stop(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_get_Status(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_add_AccountAdded(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher", L"AccountAdded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher, winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountEventArgs>>(arg);

            return py::convert(self->obj.AccountAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_remove_AccountAdded(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher", L"AccountAdded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AccountAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_add_AccountRemoved(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher", L"AccountRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher, winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountEventArgs>>(arg);

            return py::convert(self->obj.AccountRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_remove_AccountRemoved(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher", L"AccountRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AccountRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_add_AccountUpdated(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher", L"AccountUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher, winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs>>(arg);

            return py::convert(self->obj.AccountUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_remove_AccountUpdated(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher", L"AccountUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AccountUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_add_EnumerationCompleted(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_remove_EnumerationCompleted(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_add_Stopped(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_remove_Stopped(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandAccountWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandAccountWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandAccountWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_Stop), METH_VARARGS, nullptr },
        { "add_account_added", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_add_AccountAdded), METH_O, nullptr },
        { "remove_account_added", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_remove_AccountAdded), METH_O, nullptr },
        { "add_account_removed", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_add_AccountRemoved), METH_O, nullptr },
        { "remove_account_removed", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_remove_AccountRemoved), METH_O, nullptr },
        { "add_account_updated", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_add_AccountUpdated), METH_O, nullptr },
        { "remove_account_updated", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_remove_AccountUpdated), METH_O, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_remove_Stopped), METH_O, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandAccountWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandAccountWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandAccountWatcher[] = {
        { "status", reinterpret_cast<getter>(MobileBroadbandAccountWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandAccountWatcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandAccountWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandAccountWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandAccountWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandAccountWatcher) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandAccountWatcher =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandAccountWatcher",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandAccountWatcher
    };

    // ----- MobileBroadbandAntennaSar class --------------------
    static constexpr const char* const type_name_MobileBroadbandAntennaSar = "MobileBroadbandAntennaSar";

    static PyObject* _new_MobileBroadbandAntennaSar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                winrt::Windows::Networking::NetworkOperators::MobileBroadbandAntennaSar instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MobileBroadbandAntennaSar(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAntennaSar* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandAntennaSar_get_AntennaIndex(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAntennaSar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAntennaSar", L"AntennaIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AntennaIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAntennaSar_get_SarBackoffIndex(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAntennaSar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAntennaSar", L"SarBackoffIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SarBackoffIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandAntennaSar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAntennaSar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandAntennaSar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAntennaSar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandAntennaSar[] = {
        { "_assign_array_", _assign_array_MobileBroadbandAntennaSar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandAntennaSar), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandAntennaSar[] = {
        { "antenna_index", reinterpret_cast<getter>(MobileBroadbandAntennaSar_get_AntennaIndex), nullptr, nullptr, nullptr },
        { "sar_backoff_index", reinterpret_cast<getter>(MobileBroadbandAntennaSar_get_SarBackoffIndex), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandAntennaSar[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandAntennaSar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandAntennaSar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandAntennaSar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandAntennaSar) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandAntennaSar =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandAntennaSar",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAntennaSar),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandAntennaSar
    };

    // ----- MobileBroadbandCellCdma class --------------------
    static constexpr const char* const type_name_MobileBroadbandCellCdma = "MobileBroadbandCellCdma";

    static PyObject* _new_MobileBroadbandCellCdma(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandCellCdma);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandCellCdma(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandCellCdma_get_BaseStationId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellCdma", L"BaseStationId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BaseStationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellCdma_get_BaseStationLastBroadcastGpsTime(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellCdma", L"BaseStationLastBroadcastGpsTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BaseStationLastBroadcastGpsTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellCdma_get_BaseStationLatitude(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellCdma", L"BaseStationLatitude"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BaseStationLatitude());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellCdma_get_BaseStationLongitude(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellCdma", L"BaseStationLongitude"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BaseStationLongitude());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellCdma_get_BaseStationPNCode(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellCdma", L"BaseStationPNCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BaseStationPNCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellCdma_get_NetworkId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellCdma", L"NetworkId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellCdma_get_PilotSignalStrengthInDB(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellCdma", L"PilotSignalStrengthInDB"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PilotSignalStrengthInDB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellCdma_get_SystemId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellCdma", L"SystemId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SystemId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandCellCdma(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandCellCdma(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandCellCdma[] = {
        { "_assign_array_", _assign_array_MobileBroadbandCellCdma, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandCellCdma), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandCellCdma[] = {
        { "base_station_id", reinterpret_cast<getter>(MobileBroadbandCellCdma_get_BaseStationId), nullptr, nullptr, nullptr },
        { "base_station_last_broadcast_gps_time", reinterpret_cast<getter>(MobileBroadbandCellCdma_get_BaseStationLastBroadcastGpsTime), nullptr, nullptr, nullptr },
        { "base_station_latitude", reinterpret_cast<getter>(MobileBroadbandCellCdma_get_BaseStationLatitude), nullptr, nullptr, nullptr },
        { "base_station_longitude", reinterpret_cast<getter>(MobileBroadbandCellCdma_get_BaseStationLongitude), nullptr, nullptr, nullptr },
        { "base_station_p_n_code", reinterpret_cast<getter>(MobileBroadbandCellCdma_get_BaseStationPNCode), nullptr, nullptr, nullptr },
        { "network_id", reinterpret_cast<getter>(MobileBroadbandCellCdma_get_NetworkId), nullptr, nullptr, nullptr },
        { "pilot_signal_strength_in_d_b", reinterpret_cast<getter>(MobileBroadbandCellCdma_get_PilotSignalStrengthInDB), nullptr, nullptr, nullptr },
        { "system_id", reinterpret_cast<getter>(MobileBroadbandCellCdma_get_SystemId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandCellCdma[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandCellCdma) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandCellCdma) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandCellCdma) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandCellCdma) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandCellCdma =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandCellCdma",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandCellCdma
    };

    // ----- MobileBroadbandCellGsm class --------------------
    static constexpr const char* const type_name_MobileBroadbandCellGsm = "MobileBroadbandCellGsm";

    static PyObject* _new_MobileBroadbandCellGsm(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandCellGsm);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandCellGsm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandCellGsm_get_BaseStationId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellGsm", L"BaseStationId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BaseStationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellGsm_get_CellId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellGsm", L"CellId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CellId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellGsm_get_ChannelNumber(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellGsm", L"ChannelNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChannelNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellGsm_get_LocationAreaCode(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellGsm", L"LocationAreaCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocationAreaCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellGsm_get_ProviderId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellGsm", L"ProviderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellGsm_get_ReceivedSignalStrengthInDBm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellGsm", L"ReceivedSignalStrengthInDBm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReceivedSignalStrengthInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellGsm_get_TimingAdvanceInBitPeriods(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellGsm", L"TimingAdvanceInBitPeriods"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimingAdvanceInBitPeriods());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandCellGsm(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandCellGsm(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandCellGsm[] = {
        { "_assign_array_", _assign_array_MobileBroadbandCellGsm, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandCellGsm), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandCellGsm[] = {
        { "base_station_id", reinterpret_cast<getter>(MobileBroadbandCellGsm_get_BaseStationId), nullptr, nullptr, nullptr },
        { "cell_id", reinterpret_cast<getter>(MobileBroadbandCellGsm_get_CellId), nullptr, nullptr, nullptr },
        { "channel_number", reinterpret_cast<getter>(MobileBroadbandCellGsm_get_ChannelNumber), nullptr, nullptr, nullptr },
        { "location_area_code", reinterpret_cast<getter>(MobileBroadbandCellGsm_get_LocationAreaCode), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(MobileBroadbandCellGsm_get_ProviderId), nullptr, nullptr, nullptr },
        { "received_signal_strength_in_d_bm", reinterpret_cast<getter>(MobileBroadbandCellGsm_get_ReceivedSignalStrengthInDBm), nullptr, nullptr, nullptr },
        { "timing_advance_in_bit_periods", reinterpret_cast<getter>(MobileBroadbandCellGsm_get_TimingAdvanceInBitPeriods), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandCellGsm[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandCellGsm) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandCellGsm) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandCellGsm) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandCellGsm) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandCellGsm =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandCellGsm",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandCellGsm
    };

    // ----- MobileBroadbandCellLte class --------------------
    static constexpr const char* const type_name_MobileBroadbandCellLte = "MobileBroadbandCellLte";

    static PyObject* _new_MobileBroadbandCellLte(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandCellLte);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandCellLte(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandCellLte_get_CellId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellLte", L"CellId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CellId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellLte_get_ChannelNumber(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellLte", L"ChannelNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChannelNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellLte_get_PhysicalCellId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellLte", L"PhysicalCellId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhysicalCellId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellLte_get_ProviderId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellLte", L"ProviderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellLte_get_ReferenceSignalReceivedPowerInDBm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellLte", L"ReferenceSignalReceivedPowerInDBm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReferenceSignalReceivedPowerInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellLte_get_ReferenceSignalReceivedQualityInDBm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellLte", L"ReferenceSignalReceivedQualityInDBm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReferenceSignalReceivedQualityInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellLte_get_TimingAdvanceInBitPeriods(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellLte", L"TimingAdvanceInBitPeriods"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimingAdvanceInBitPeriods());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellLte_get_TrackingAreaCode(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellLte", L"TrackingAreaCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrackingAreaCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandCellLte(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellLte>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandCellLte(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellLte>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandCellLte[] = {
        { "_assign_array_", _assign_array_MobileBroadbandCellLte, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandCellLte), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandCellLte[] = {
        { "cell_id", reinterpret_cast<getter>(MobileBroadbandCellLte_get_CellId), nullptr, nullptr, nullptr },
        { "channel_number", reinterpret_cast<getter>(MobileBroadbandCellLte_get_ChannelNumber), nullptr, nullptr, nullptr },
        { "physical_cell_id", reinterpret_cast<getter>(MobileBroadbandCellLte_get_PhysicalCellId), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(MobileBroadbandCellLte_get_ProviderId), nullptr, nullptr, nullptr },
        { "reference_signal_received_power_in_d_bm", reinterpret_cast<getter>(MobileBroadbandCellLte_get_ReferenceSignalReceivedPowerInDBm), nullptr, nullptr, nullptr },
        { "reference_signal_received_quality_in_d_bm", reinterpret_cast<getter>(MobileBroadbandCellLte_get_ReferenceSignalReceivedQualityInDBm), nullptr, nullptr, nullptr },
        { "timing_advance_in_bit_periods", reinterpret_cast<getter>(MobileBroadbandCellLte_get_TimingAdvanceInBitPeriods), nullptr, nullptr, nullptr },
        { "tracking_area_code", reinterpret_cast<getter>(MobileBroadbandCellLte_get_TrackingAreaCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandCellLte[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandCellLte) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandCellLte) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandCellLte) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandCellLte) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandCellLte =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandCellLte",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandCellLte
    };

    // ----- MobileBroadbandCellNR class --------------------
    static constexpr const char* const type_name_MobileBroadbandCellNR = "MobileBroadbandCellNR";

    static PyObject* _new_MobileBroadbandCellNR(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandCellNR);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandCellNR(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandCellNR_get_CellId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellNR", L"CellId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CellId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellNR_get_ChannelNumber(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellNR", L"ChannelNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChannelNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellNR_get_PhysicalCellId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellNR", L"PhysicalCellId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhysicalCellId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellNR_get_ProviderId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellNR", L"ProviderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellNR_get_ReferenceSignalReceivedPowerInDBm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellNR", L"ReferenceSignalReceivedPowerInDBm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReferenceSignalReceivedPowerInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellNR_get_ReferenceSignalReceivedQualityInDBm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellNR", L"ReferenceSignalReceivedQualityInDBm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReferenceSignalReceivedQualityInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellNR_get_SignalToNoiseRatioInDB(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellNR", L"SignalToNoiseRatioInDB"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SignalToNoiseRatioInDB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellNR_get_TimingAdvanceInNanoseconds(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellNR", L"TimingAdvanceInNanoseconds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimingAdvanceInNanoseconds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellNR_get_TrackingAreaCode(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellNR", L"TrackingAreaCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrackingAreaCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandCellNR(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellNR>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandCellNR(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellNR>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandCellNR[] = {
        { "_assign_array_", _assign_array_MobileBroadbandCellNR, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandCellNR), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandCellNR[] = {
        { "cell_id", reinterpret_cast<getter>(MobileBroadbandCellNR_get_CellId), nullptr, nullptr, nullptr },
        { "channel_number", reinterpret_cast<getter>(MobileBroadbandCellNR_get_ChannelNumber), nullptr, nullptr, nullptr },
        { "physical_cell_id", reinterpret_cast<getter>(MobileBroadbandCellNR_get_PhysicalCellId), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(MobileBroadbandCellNR_get_ProviderId), nullptr, nullptr, nullptr },
        { "reference_signal_received_power_in_d_bm", reinterpret_cast<getter>(MobileBroadbandCellNR_get_ReferenceSignalReceivedPowerInDBm), nullptr, nullptr, nullptr },
        { "reference_signal_received_quality_in_d_bm", reinterpret_cast<getter>(MobileBroadbandCellNR_get_ReferenceSignalReceivedQualityInDBm), nullptr, nullptr, nullptr },
        { "signal_to_noise_ratio_in_d_b", reinterpret_cast<getter>(MobileBroadbandCellNR_get_SignalToNoiseRatioInDB), nullptr, nullptr, nullptr },
        { "timing_advance_in_nanoseconds", reinterpret_cast<getter>(MobileBroadbandCellNR_get_TimingAdvanceInNanoseconds), nullptr, nullptr, nullptr },
        { "tracking_area_code", reinterpret_cast<getter>(MobileBroadbandCellNR_get_TrackingAreaCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandCellNR[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandCellNR) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandCellNR) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandCellNR) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandCellNR) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandCellNR =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandCellNR",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandCellNR
    };

    // ----- MobileBroadbandCellTdscdma class --------------------
    static constexpr const char* const type_name_MobileBroadbandCellTdscdma = "MobileBroadbandCellTdscdma";

    static PyObject* _new_MobileBroadbandCellTdscdma(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandCellTdscdma);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandCellTdscdma(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandCellTdscdma_get_CellId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellTdscdma", L"CellId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CellId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellTdscdma_get_CellParameterId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellTdscdma", L"CellParameterId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CellParameterId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellTdscdma_get_ChannelNumber(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellTdscdma", L"ChannelNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChannelNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellTdscdma_get_LocationAreaCode(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellTdscdma", L"LocationAreaCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocationAreaCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellTdscdma_get_PathLossInDB(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellTdscdma", L"PathLossInDB"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PathLossInDB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellTdscdma_get_ProviderId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellTdscdma", L"ProviderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellTdscdma_get_ReceivedSignalCodePowerInDBm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellTdscdma", L"ReceivedSignalCodePowerInDBm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReceivedSignalCodePowerInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellTdscdma_get_TimingAdvanceInBitPeriods(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellTdscdma", L"TimingAdvanceInBitPeriods"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimingAdvanceInBitPeriods());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandCellTdscdma(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandCellTdscdma(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandCellTdscdma[] = {
        { "_assign_array_", _assign_array_MobileBroadbandCellTdscdma, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandCellTdscdma), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandCellTdscdma[] = {
        { "cell_id", reinterpret_cast<getter>(MobileBroadbandCellTdscdma_get_CellId), nullptr, nullptr, nullptr },
        { "cell_parameter_id", reinterpret_cast<getter>(MobileBroadbandCellTdscdma_get_CellParameterId), nullptr, nullptr, nullptr },
        { "channel_number", reinterpret_cast<getter>(MobileBroadbandCellTdscdma_get_ChannelNumber), nullptr, nullptr, nullptr },
        { "location_area_code", reinterpret_cast<getter>(MobileBroadbandCellTdscdma_get_LocationAreaCode), nullptr, nullptr, nullptr },
        { "path_loss_in_d_b", reinterpret_cast<getter>(MobileBroadbandCellTdscdma_get_PathLossInDB), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(MobileBroadbandCellTdscdma_get_ProviderId), nullptr, nullptr, nullptr },
        { "received_signal_code_power_in_d_bm", reinterpret_cast<getter>(MobileBroadbandCellTdscdma_get_ReceivedSignalCodePowerInDBm), nullptr, nullptr, nullptr },
        { "timing_advance_in_bit_periods", reinterpret_cast<getter>(MobileBroadbandCellTdscdma_get_TimingAdvanceInBitPeriods), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandCellTdscdma[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandCellTdscdma) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandCellTdscdma) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandCellTdscdma) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandCellTdscdma) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandCellTdscdma =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandCellTdscdma",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandCellTdscdma
    };

    // ----- MobileBroadbandCellUmts class --------------------
    static constexpr const char* const type_name_MobileBroadbandCellUmts = "MobileBroadbandCellUmts";

    static PyObject* _new_MobileBroadbandCellUmts(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandCellUmts);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandCellUmts(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandCellUmts_get_CellId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellUmts", L"CellId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CellId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellUmts_get_ChannelNumber(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellUmts", L"ChannelNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChannelNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellUmts_get_LocationAreaCode(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellUmts", L"LocationAreaCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocationAreaCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellUmts_get_PathLossInDB(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellUmts", L"PathLossInDB"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PathLossInDB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellUmts_get_PrimaryScramblingCode(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellUmts", L"PrimaryScramblingCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PrimaryScramblingCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellUmts_get_ProviderId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellUmts", L"ProviderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellUmts_get_ReceivedSignalCodePowerInDBm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellUmts", L"ReceivedSignalCodePowerInDBm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReceivedSignalCodePowerInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellUmts_get_SignalToNoiseRatioInDB(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellUmts", L"SignalToNoiseRatioInDB"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SignalToNoiseRatioInDB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandCellUmts(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandCellUmts(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandCellUmts[] = {
        { "_assign_array_", _assign_array_MobileBroadbandCellUmts, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandCellUmts), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandCellUmts[] = {
        { "cell_id", reinterpret_cast<getter>(MobileBroadbandCellUmts_get_CellId), nullptr, nullptr, nullptr },
        { "channel_number", reinterpret_cast<getter>(MobileBroadbandCellUmts_get_ChannelNumber), nullptr, nullptr, nullptr },
        { "location_area_code", reinterpret_cast<getter>(MobileBroadbandCellUmts_get_LocationAreaCode), nullptr, nullptr, nullptr },
        { "path_loss_in_d_b", reinterpret_cast<getter>(MobileBroadbandCellUmts_get_PathLossInDB), nullptr, nullptr, nullptr },
        { "primary_scrambling_code", reinterpret_cast<getter>(MobileBroadbandCellUmts_get_PrimaryScramblingCode), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(MobileBroadbandCellUmts_get_ProviderId), nullptr, nullptr, nullptr },
        { "received_signal_code_power_in_d_bm", reinterpret_cast<getter>(MobileBroadbandCellUmts_get_ReceivedSignalCodePowerInDBm), nullptr, nullptr, nullptr },
        { "signal_to_noise_ratio_in_d_b", reinterpret_cast<getter>(MobileBroadbandCellUmts_get_SignalToNoiseRatioInDB), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandCellUmts[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandCellUmts) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandCellUmts) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandCellUmts) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandCellUmts) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandCellUmts =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandCellUmts",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandCellUmts
    };

    // ----- MobileBroadbandCellsInfo class --------------------
    static constexpr const char* const type_name_MobileBroadbandCellsInfo = "MobileBroadbandCellsInfo";

    static PyObject* _new_MobileBroadbandCellsInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandCellsInfo);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandCellsInfo(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandCellsInfo_get_NeighboringCellsCdma(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellsInfo", L"NeighboringCellsCdma"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NeighboringCellsCdma());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_NeighboringCellsGsm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellsInfo", L"NeighboringCellsGsm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NeighboringCellsGsm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_NeighboringCellsLte(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellsInfo", L"NeighboringCellsLte"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NeighboringCellsLte());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_NeighboringCellsTdscdma(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellsInfo", L"NeighboringCellsTdscdma"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NeighboringCellsTdscdma());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_NeighboringCellsUmts(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellsInfo", L"NeighboringCellsUmts"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NeighboringCellsUmts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_ServingCellsCdma(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellsInfo", L"ServingCellsCdma"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServingCellsCdma());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_ServingCellsGsm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellsInfo", L"ServingCellsGsm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServingCellsGsm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_ServingCellsLte(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellsInfo", L"ServingCellsLte"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServingCellsLte());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_ServingCellsTdscdma(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellsInfo", L"ServingCellsTdscdma"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServingCellsTdscdma());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_ServingCellsUmts(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellsInfo", L"ServingCellsUmts"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServingCellsUmts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_NeighboringCellsNR(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellsInfo", L"NeighboringCellsNR"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NeighboringCellsNR());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_ServingCellsNR(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellsInfo", L"ServingCellsNR"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServingCellsNR());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandCellsInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandCellsInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandCellsInfo[] = {
        { "_assign_array_", _assign_array_MobileBroadbandCellsInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandCellsInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandCellsInfo[] = {
        { "neighboring_cells_cdma", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_NeighboringCellsCdma), nullptr, nullptr, nullptr },
        { "neighboring_cells_gsm", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_NeighboringCellsGsm), nullptr, nullptr, nullptr },
        { "neighboring_cells_lte", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_NeighboringCellsLte), nullptr, nullptr, nullptr },
        { "neighboring_cells_tdscdma", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_NeighboringCellsTdscdma), nullptr, nullptr, nullptr },
        { "neighboring_cells_umts", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_NeighboringCellsUmts), nullptr, nullptr, nullptr },
        { "serving_cells_cdma", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_ServingCellsCdma), nullptr, nullptr, nullptr },
        { "serving_cells_gsm", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_ServingCellsGsm), nullptr, nullptr, nullptr },
        { "serving_cells_lte", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_ServingCellsLte), nullptr, nullptr, nullptr },
        { "serving_cells_tdscdma", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_ServingCellsTdscdma), nullptr, nullptr, nullptr },
        { "serving_cells_umts", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_ServingCellsUmts), nullptr, nullptr, nullptr },
        { "neighboring_cells_n_r", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_NeighboringCellsNR), nullptr, nullptr, nullptr },
        { "serving_cells_n_r", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_ServingCellsNR), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandCellsInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandCellsInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandCellsInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandCellsInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandCellsInfo) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandCellsInfo =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandCellsInfo",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandCellsInfo
    };

    // ----- MobileBroadbandCurrentSlotIndexChangedEventArgs class --------------------
    static constexpr const char* const type_name_MobileBroadbandCurrentSlotIndexChangedEventArgs = "MobileBroadbandCurrentSlotIndexChangedEventArgs";

    static PyObject* _new_MobileBroadbandCurrentSlotIndexChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandCurrentSlotIndexChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandCurrentSlotIndexChangedEventArgs(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCurrentSlotIndexChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandCurrentSlotIndexChangedEventArgs_get_CurrentSlotIndex(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCurrentSlotIndexChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCurrentSlotIndexChangedEventArgs", L"CurrentSlotIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentSlotIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandCurrentSlotIndexChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCurrentSlotIndexChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandCurrentSlotIndexChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCurrentSlotIndexChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandCurrentSlotIndexChangedEventArgs[] = {
        { "_assign_array_", _assign_array_MobileBroadbandCurrentSlotIndexChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandCurrentSlotIndexChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandCurrentSlotIndexChangedEventArgs[] = {
        { "current_slot_index", reinterpret_cast<getter>(MobileBroadbandCurrentSlotIndexChangedEventArgs_get_CurrentSlotIndex), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandCurrentSlotIndexChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandCurrentSlotIndexChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandCurrentSlotIndexChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandCurrentSlotIndexChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandCurrentSlotIndexChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandCurrentSlotIndexChangedEventArgs =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandCurrentSlotIndexChangedEventArgs",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCurrentSlotIndexChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandCurrentSlotIndexChangedEventArgs
    };

    // ----- MobileBroadbandDeviceInformation class --------------------
    static constexpr const char* const type_name_MobileBroadbandDeviceInformation = "MobileBroadbandDeviceInformation";

    static PyObject* _new_MobileBroadbandDeviceInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandDeviceInformation);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandDeviceInformation(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandDeviceInformation_get_CellularClass(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"CellularClass"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_CurrentRadioState(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"CurrentRadioState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentRadioState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_CustomDataClass(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"CustomDataClass"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CustomDataClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_DataClasses(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"DataClasses"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DataClasses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_DeviceId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_DeviceType(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"DeviceType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_FirmwareInformation(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"FirmwareInformation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FirmwareInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_Manufacturer(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"Manufacturer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Manufacturer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_MobileEquipmentId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"MobileEquipmentId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MobileEquipmentId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_Model(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"Model"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Model());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_NetworkDeviceStatus(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"NetworkDeviceStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkDeviceStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_SimIccId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"SimIccId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SimIccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_SubscriberId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"SubscriberId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SubscriberId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_TelephoneNumbers(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"TelephoneNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TelephoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_PinManager(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"PinManager"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PinManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_Revision(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"Revision"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Revision());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_SerialNumber(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"SerialNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SerialNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_SimGid1(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"SimGid1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SimGid1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_SimPnn(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"SimPnn"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SimPnn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_SimSpn(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"SimSpn"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SimSpn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_SlotManager(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"SlotManager"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SlotManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandDeviceInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandDeviceInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandDeviceInformation[] = {
        { "_assign_array_", _assign_array_MobileBroadbandDeviceInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandDeviceInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandDeviceInformation[] = {
        { "cellular_class", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_CellularClass), nullptr, nullptr, nullptr },
        { "current_radio_state", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_CurrentRadioState), nullptr, nullptr, nullptr },
        { "custom_data_class", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_CustomDataClass), nullptr, nullptr, nullptr },
        { "data_classes", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_DataClasses), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_DeviceId), nullptr, nullptr, nullptr },
        { "device_type", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_DeviceType), nullptr, nullptr, nullptr },
        { "firmware_information", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_FirmwareInformation), nullptr, nullptr, nullptr },
        { "manufacturer", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_Manufacturer), nullptr, nullptr, nullptr },
        { "mobile_equipment_id", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_MobileEquipmentId), nullptr, nullptr, nullptr },
        { "model", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_Model), nullptr, nullptr, nullptr },
        { "network_device_status", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_NetworkDeviceStatus), nullptr, nullptr, nullptr },
        { "sim_icc_id", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_SimIccId), nullptr, nullptr, nullptr },
        { "subscriber_id", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_SubscriberId), nullptr, nullptr, nullptr },
        { "telephone_numbers", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_TelephoneNumbers), nullptr, nullptr, nullptr },
        { "pin_manager", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_PinManager), nullptr, nullptr, nullptr },
        { "revision", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_Revision), nullptr, nullptr, nullptr },
        { "serial_number", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_SerialNumber), nullptr, nullptr, nullptr },
        { "sim_gid1", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_SimGid1), nullptr, nullptr, nullptr },
        { "sim_pnn", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_SimPnn), nullptr, nullptr, nullptr },
        { "sim_spn", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_SimSpn), nullptr, nullptr, nullptr },
        { "slot_manager", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_SlotManager), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandDeviceInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandDeviceInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandDeviceInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandDeviceInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandDeviceInformation) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandDeviceInformation =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandDeviceInformation",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandDeviceInformation
    };

    // ----- MobileBroadbandDeviceService class --------------------
    static constexpr const char* const type_name_MobileBroadbandDeviceService = "MobileBroadbandDeviceService";

    static PyObject* _new_MobileBroadbandDeviceService(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandDeviceService);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandDeviceService(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandDeviceService_OpenCommandSession(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceService", L"OpenCommandSession", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.OpenCommandSession());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceService_OpenDataSession(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceService", L"OpenDataSession", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.OpenDataSession());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceService_get_DeviceServiceId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceService", L"DeviceServiceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceService_get_SupportedCommands(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceService", L"SupportedCommands"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedCommands());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandDeviceService(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandDeviceService(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandDeviceService[] = {
        { "open_command_session", reinterpret_cast<PyCFunction>(MobileBroadbandDeviceService_OpenCommandSession), METH_VARARGS, nullptr },
        { "open_data_session", reinterpret_cast<PyCFunction>(MobileBroadbandDeviceService_OpenDataSession), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandDeviceService, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandDeviceService), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandDeviceService[] = {
        { "device_service_id", reinterpret_cast<getter>(MobileBroadbandDeviceService_get_DeviceServiceId), nullptr, nullptr, nullptr },
        { "supported_commands", reinterpret_cast<getter>(MobileBroadbandDeviceService_get_SupportedCommands), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandDeviceService[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandDeviceService) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandDeviceService) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandDeviceService) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandDeviceService) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandDeviceService =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandDeviceService",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandDeviceService
    };

    // ----- MobileBroadbandDeviceServiceCommandResult class --------------------
    static constexpr const char* const type_name_MobileBroadbandDeviceServiceCommandResult = "MobileBroadbandDeviceServiceCommandResult";

    static PyObject* _new_MobileBroadbandDeviceServiceCommandResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandDeviceServiceCommandResult);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandDeviceServiceCommandResult(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandDeviceServiceCommandResult_get_ResponseData(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceCommandResult", L"ResponseData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ResponseData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceCommandResult_get_StatusCode(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceCommandResult", L"StatusCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StatusCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandDeviceServiceCommandResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandDeviceServiceCommandResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandDeviceServiceCommandResult[] = {
        { "_assign_array_", _assign_array_MobileBroadbandDeviceServiceCommandResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandDeviceServiceCommandResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandDeviceServiceCommandResult[] = {
        { "response_data", reinterpret_cast<getter>(MobileBroadbandDeviceServiceCommandResult_get_ResponseData), nullptr, nullptr, nullptr },
        { "status_code", reinterpret_cast<getter>(MobileBroadbandDeviceServiceCommandResult_get_StatusCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandDeviceServiceCommandResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandDeviceServiceCommandResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandDeviceServiceCommandResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandDeviceServiceCommandResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandDeviceServiceCommandResult) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandDeviceServiceCommandResult =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandDeviceServiceCommandResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandDeviceServiceCommandResult
    };

    // ----- MobileBroadbandDeviceServiceCommandSession class --------------------
    static constexpr const char* const type_name_MobileBroadbandDeviceServiceCommandSession = "MobileBroadbandDeviceServiceCommandSession";

    static PyObject* _new_MobileBroadbandDeviceServiceCommandSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandDeviceServiceCommandSession);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandDeviceServiceCommandSession(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandSession* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandDeviceServiceCommandSession_CloseSession(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceCommandSession", L"CloseSession", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.CloseSession();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceCommandSession_SendQueryCommandAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceCommandSession", L"SendQueryCommandAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(self->obj.SendQueryCommandAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceCommandSession_SendSetCommandAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceCommandSession", L"SendSetCommandAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(self->obj.SendSetCommandAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandDeviceServiceCommandSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandDeviceServiceCommandSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandDeviceServiceCommandSession[] = {
        { "close_session", reinterpret_cast<PyCFunction>(MobileBroadbandDeviceServiceCommandSession_CloseSession), METH_VARARGS, nullptr },
        { "send_query_command_async", reinterpret_cast<PyCFunction>(MobileBroadbandDeviceServiceCommandSession_SendQueryCommandAsync), METH_VARARGS, nullptr },
        { "send_set_command_async", reinterpret_cast<PyCFunction>(MobileBroadbandDeviceServiceCommandSession_SendSetCommandAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandDeviceServiceCommandSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandDeviceServiceCommandSession), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandDeviceServiceCommandSession[] = {
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandDeviceServiceCommandSession[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandDeviceServiceCommandSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandDeviceServiceCommandSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandDeviceServiceCommandSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandDeviceServiceCommandSession) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandDeviceServiceCommandSession =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandDeviceServiceCommandSession",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandDeviceServiceCommandSession
    };

    // ----- MobileBroadbandDeviceServiceDataReceivedEventArgs class --------------------
    static constexpr const char* const type_name_MobileBroadbandDeviceServiceDataReceivedEventArgs = "MobileBroadbandDeviceServiceDataReceivedEventArgs";

    static PyObject* _new_MobileBroadbandDeviceServiceDataReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandDeviceServiceDataReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandDeviceServiceDataReceivedEventArgs(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandDeviceServiceDataReceivedEventArgs_get_ReceivedData(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceDataReceivedEventArgs", L"ReceivedData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReceivedData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandDeviceServiceDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandDeviceServiceDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandDeviceServiceDataReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_MobileBroadbandDeviceServiceDataReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandDeviceServiceDataReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandDeviceServiceDataReceivedEventArgs[] = {
        { "received_data", reinterpret_cast<getter>(MobileBroadbandDeviceServiceDataReceivedEventArgs_get_ReceivedData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandDeviceServiceDataReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandDeviceServiceDataReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandDeviceServiceDataReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandDeviceServiceDataReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandDeviceServiceDataReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandDeviceServiceDataReceivedEventArgs =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandDeviceServiceDataReceivedEventArgs",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandDeviceServiceDataReceivedEventArgs
    };

    // ----- MobileBroadbandDeviceServiceDataSession class --------------------
    static constexpr const char* const type_name_MobileBroadbandDeviceServiceDataSession = "MobileBroadbandDeviceServiceDataSession";

    static PyObject* _new_MobileBroadbandDeviceServiceDataSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandDeviceServiceDataSession);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandDeviceServiceDataSession(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandDeviceServiceDataSession_CloseSession(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceDataSession", L"CloseSession", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.CloseSession();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceDataSession_WriteDataAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceDataSession", L"WriteDataAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteDataAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceDataSession_add_DataReceived(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceDataSession", L"DataReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession, winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataReceivedEventArgs>>(arg);

            return py::convert(self->obj.DataReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceDataSession_remove_DataReceived(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceDataSession", L"DataReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DataReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandDeviceServiceDataSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandDeviceServiceDataSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandDeviceServiceDataSession[] = {
        { "close_session", reinterpret_cast<PyCFunction>(MobileBroadbandDeviceServiceDataSession_CloseSession), METH_VARARGS, nullptr },
        { "write_data_async", reinterpret_cast<PyCFunction>(MobileBroadbandDeviceServiceDataSession_WriteDataAsync), METH_VARARGS, nullptr },
        { "add_data_received", reinterpret_cast<PyCFunction>(MobileBroadbandDeviceServiceDataSession_add_DataReceived), METH_O, nullptr },
        { "remove_data_received", reinterpret_cast<PyCFunction>(MobileBroadbandDeviceServiceDataSession_remove_DataReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandDeviceServiceDataSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandDeviceServiceDataSession), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandDeviceServiceDataSession[] = {
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandDeviceServiceDataSession[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandDeviceServiceDataSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandDeviceServiceDataSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandDeviceServiceDataSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandDeviceServiceDataSession) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandDeviceServiceDataSession =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandDeviceServiceDataSession",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandDeviceServiceDataSession
    };

    // ----- MobileBroadbandDeviceServiceInformation class --------------------
    static constexpr const char* const type_name_MobileBroadbandDeviceServiceInformation = "MobileBroadbandDeviceServiceInformation";

    static PyObject* _new_MobileBroadbandDeviceServiceInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandDeviceServiceInformation);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandDeviceServiceInformation(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandDeviceServiceInformation_get_DeviceServiceId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceInformation", L"DeviceServiceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceInformation_get_IsDataReadSupported(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceInformation", L"IsDataReadSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDataReadSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceInformation_get_IsDataWriteSupported(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceInformation", L"IsDataWriteSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDataWriteSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandDeviceServiceInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandDeviceServiceInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandDeviceServiceInformation[] = {
        { "_assign_array_", _assign_array_MobileBroadbandDeviceServiceInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandDeviceServiceInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandDeviceServiceInformation[] = {
        { "device_service_id", reinterpret_cast<getter>(MobileBroadbandDeviceServiceInformation_get_DeviceServiceId), nullptr, nullptr, nullptr },
        { "is_data_read_supported", reinterpret_cast<getter>(MobileBroadbandDeviceServiceInformation_get_IsDataReadSupported), nullptr, nullptr, nullptr },
        { "is_data_write_supported", reinterpret_cast<getter>(MobileBroadbandDeviceServiceInformation_get_IsDataWriteSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandDeviceServiceInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandDeviceServiceInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandDeviceServiceInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandDeviceServiceInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandDeviceServiceInformation) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandDeviceServiceInformation =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandDeviceServiceInformation",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandDeviceServiceInformation
    };

    // ----- MobileBroadbandDeviceServiceTriggerDetails class --------------------
    static constexpr const char* const type_name_MobileBroadbandDeviceServiceTriggerDetails = "MobileBroadbandDeviceServiceTriggerDetails";

    static PyObject* _new_MobileBroadbandDeviceServiceTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandDeviceServiceTriggerDetails);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandDeviceServiceTriggerDetails(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandDeviceServiceTriggerDetails_get_DeviceId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceTriggerDetails", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceTriggerDetails_get_DeviceServiceId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceTriggerDetails", L"DeviceServiceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceTriggerDetails_get_ReceivedData(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceTriggerDetails", L"ReceivedData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReceivedData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceTriggerDetails_get_EventId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceTriggerDetails", L"EventId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EventId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandDeviceServiceTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandDeviceServiceTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandDeviceServiceTriggerDetails[] = {
        { "_assign_array_", _assign_array_MobileBroadbandDeviceServiceTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandDeviceServiceTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandDeviceServiceTriggerDetails[] = {
        { "device_id", reinterpret_cast<getter>(MobileBroadbandDeviceServiceTriggerDetails_get_DeviceId), nullptr, nullptr, nullptr },
        { "device_service_id", reinterpret_cast<getter>(MobileBroadbandDeviceServiceTriggerDetails_get_DeviceServiceId), nullptr, nullptr, nullptr },
        { "received_data", reinterpret_cast<getter>(MobileBroadbandDeviceServiceTriggerDetails_get_ReceivedData), nullptr, nullptr, nullptr },
        { "event_id", reinterpret_cast<getter>(MobileBroadbandDeviceServiceTriggerDetails_get_EventId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandDeviceServiceTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandDeviceServiceTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandDeviceServiceTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandDeviceServiceTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandDeviceServiceTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandDeviceServiceTriggerDetails =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandDeviceServiceTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandDeviceServiceTriggerDetails
    };

    // ----- MobileBroadbandModem class --------------------
    static constexpr const char* const type_name_MobileBroadbandModem = "MobileBroadbandModem";

    static PyObject* _new_MobileBroadbandModem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandModem);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandModem(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandModem_FromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"FromId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::MobileBroadbandModem::FromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_GetCurrentConfigurationAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"GetCurrentConfigurationAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentConfigurationAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Networking::NetworkOperators::MobileBroadbandModem::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Networking::NetworkOperators::MobileBroadbandModem::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_GetDeviceService(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"GetDeviceService", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.GetDeviceService(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_GetIsPassthroughEnabled(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"GetIsPassthroughEnabled", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.GetIsPassthroughEnabled(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_GetIsPassthroughEnabledAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"GetIsPassthroughEnabledAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetIsPassthroughEnabledAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"GetIsPassthroughEnabledAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.GetIsPassthroughEnabledAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_ResetAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"ResetAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ResetAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_SetIsPassthroughEnabled(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"SetIsPassthroughEnabled", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.SetIsPassthroughEnabled(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_SetIsPassthroughEnabledAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"SetIsPassthroughEnabledAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.SetIsPassthroughEnabledAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"SetIsPassthroughEnabledAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.SetIsPassthroughEnabledAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_TryGetPcoAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"TryGetPcoAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryGetPcoAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_get_CurrentAccount(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"CurrentAccount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentAccount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_get_CurrentNetwork(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"CurrentNetwork"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentNetwork());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_get_DeviceInformation(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"DeviceInformation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_get_DeviceServices(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"DeviceServices"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceServices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_get_IsResetSupported(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"IsResetSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsResetSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_get_MaxDeviceServiceCommandSizeInBytes(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"MaxDeviceServiceCommandSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxDeviceServiceCommandSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_get_MaxDeviceServiceDataSizeInBytes(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"MaxDeviceServiceDataSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxDeviceServiceDataSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_get_IsInEmergencyCallMode(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"IsInEmergencyCallMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInEmergencyCallMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_add_IsInEmergencyCallModeChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"IsInEmergencyCallModeChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModem, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.IsInEmergencyCallModeChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_remove_IsInEmergencyCallModeChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"IsInEmergencyCallModeChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsInEmergencyCallModeChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandModem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandModem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandModem[] = {
        { "from_id", reinterpret_cast<PyCFunction>(MobileBroadbandModem_FromId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_configuration_async", reinterpret_cast<PyCFunction>(MobileBroadbandModem_GetCurrentConfigurationAsync), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(MobileBroadbandModem_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(MobileBroadbandModem_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_service", reinterpret_cast<PyCFunction>(MobileBroadbandModem_GetDeviceService), METH_VARARGS, nullptr },
        { "get_is_passthrough_enabled", reinterpret_cast<PyCFunction>(MobileBroadbandModem_GetIsPassthroughEnabled), METH_VARARGS, nullptr },
        { "get_is_passthrough_enabled_async", reinterpret_cast<PyCFunction>(MobileBroadbandModem_GetIsPassthroughEnabledAsync), METH_VARARGS, nullptr },
        { "reset_async", reinterpret_cast<PyCFunction>(MobileBroadbandModem_ResetAsync), METH_VARARGS, nullptr },
        { "set_is_passthrough_enabled", reinterpret_cast<PyCFunction>(MobileBroadbandModem_SetIsPassthroughEnabled), METH_VARARGS, nullptr },
        { "set_is_passthrough_enabled_async", reinterpret_cast<PyCFunction>(MobileBroadbandModem_SetIsPassthroughEnabledAsync), METH_VARARGS, nullptr },
        { "try_get_pco_async", reinterpret_cast<PyCFunction>(MobileBroadbandModem_TryGetPcoAsync), METH_VARARGS, nullptr },
        { "add_is_in_emergency_call_mode_changed", reinterpret_cast<PyCFunction>(MobileBroadbandModem_add_IsInEmergencyCallModeChanged), METH_O, nullptr },
        { "remove_is_in_emergency_call_mode_changed", reinterpret_cast<PyCFunction>(MobileBroadbandModem_remove_IsInEmergencyCallModeChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandModem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandModem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandModem[] = {
        { "current_account", reinterpret_cast<getter>(MobileBroadbandModem_get_CurrentAccount), nullptr, nullptr, nullptr },
        { "current_network", reinterpret_cast<getter>(MobileBroadbandModem_get_CurrentNetwork), nullptr, nullptr, nullptr },
        { "device_information", reinterpret_cast<getter>(MobileBroadbandModem_get_DeviceInformation), nullptr, nullptr, nullptr },
        { "device_services", reinterpret_cast<getter>(MobileBroadbandModem_get_DeviceServices), nullptr, nullptr, nullptr },
        { "is_reset_supported", reinterpret_cast<getter>(MobileBroadbandModem_get_IsResetSupported), nullptr, nullptr, nullptr },
        { "max_device_service_command_size_in_bytes", reinterpret_cast<getter>(MobileBroadbandModem_get_MaxDeviceServiceCommandSizeInBytes), nullptr, nullptr, nullptr },
        { "max_device_service_data_size_in_bytes", reinterpret_cast<getter>(MobileBroadbandModem_get_MaxDeviceServiceDataSizeInBytes), nullptr, nullptr, nullptr },
        { "is_in_emergency_call_mode", reinterpret_cast<getter>(MobileBroadbandModem_get_IsInEmergencyCallMode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandModem[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandModem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandModem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandModem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandModem) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandModem =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandModem",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandModem
    };

    // ----- MobileBroadbandModemConfiguration class --------------------
    static constexpr const char* const type_name_MobileBroadbandModemConfiguration = "MobileBroadbandModemConfiguration";

    static PyObject* _new_MobileBroadbandModemConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandModemConfiguration);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandModemConfiguration(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandModemConfiguration_get_HomeProviderId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModemConfiguration", L"HomeProviderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HomeProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModemConfiguration_get_HomeProviderName(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModemConfiguration", L"HomeProviderName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HomeProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModemConfiguration_get_Uicc(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModemConfiguration", L"Uicc"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uicc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModemConfiguration_get_SarManager(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModemConfiguration", L"SarManager"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SarManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandModemConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandModemConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandModemConfiguration[] = {
        { "_assign_array_", _assign_array_MobileBroadbandModemConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandModemConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandModemConfiguration[] = {
        { "home_provider_id", reinterpret_cast<getter>(MobileBroadbandModemConfiguration_get_HomeProviderId), nullptr, nullptr, nullptr },
        { "home_provider_name", reinterpret_cast<getter>(MobileBroadbandModemConfiguration_get_HomeProviderName), nullptr, nullptr, nullptr },
        { "uicc", reinterpret_cast<getter>(MobileBroadbandModemConfiguration_get_Uicc), nullptr, nullptr, nullptr },
        { "sar_manager", reinterpret_cast<getter>(MobileBroadbandModemConfiguration_get_SarManager), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandModemConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandModemConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandModemConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandModemConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandModemConfiguration) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandModemConfiguration =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandModemConfiguration",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandModemConfiguration
    };

    // ----- MobileBroadbandModemIsolation class --------------------
    static constexpr const char* const type_name_MobileBroadbandModemIsolation = "MobileBroadbandModemIsolation";

    static PyObject* _new_MobileBroadbandModemIsolation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MobileBroadbandModemIsolation(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandModemIsolation_AddAllowedHost(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModemIsolation", L"AddAllowedHost", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);

                self->obj.AddAllowedHost(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModemIsolation_AddAllowedHostRange(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModemIsolation", L"AddAllowedHostRange", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::HostName>(args, 1);

                self->obj.AddAllowedHostRange(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModemIsolation_ApplyConfigurationAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModemIsolation", L"ApplyConfigurationAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ApplyConfigurationAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModemIsolation_ClearConfigurationAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModemIsolation", L"ClearConfigurationAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ClearConfigurationAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandModemIsolation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandModemIsolation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandModemIsolation[] = {
        { "add_allowed_host", reinterpret_cast<PyCFunction>(MobileBroadbandModemIsolation_AddAllowedHost), METH_VARARGS, nullptr },
        { "add_allowed_host_range", reinterpret_cast<PyCFunction>(MobileBroadbandModemIsolation_AddAllowedHostRange), METH_VARARGS, nullptr },
        { "apply_configuration_async", reinterpret_cast<PyCFunction>(MobileBroadbandModemIsolation_ApplyConfigurationAsync), METH_VARARGS, nullptr },
        { "clear_configuration_async", reinterpret_cast<PyCFunction>(MobileBroadbandModemIsolation_ClearConfigurationAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandModemIsolation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandModemIsolation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandModemIsolation[] = {
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandModemIsolation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandModemIsolation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandModemIsolation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandModemIsolation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandModemIsolation) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandModemIsolation =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandModemIsolation",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandModemIsolation
    };

    // ----- MobileBroadbandNetwork class --------------------
    static constexpr const char* const type_name_MobileBroadbandNetwork = "MobileBroadbandNetwork";

    static PyObject* _new_MobileBroadbandNetwork(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandNetwork);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandNetwork(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandNetwork_GetCellsInfoAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetwork", L"GetCellsInfoAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCellsInfoAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_GetVoiceCallSupportAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetwork", L"GetVoiceCallSupportAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetVoiceCallSupportAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_ShowConnectionUI(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetwork", L"ShowConnectionUI", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ShowConnectionUI();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_AccessPointName(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetwork", L"AccessPointName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessPointName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_ActivationNetworkError(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetwork", L"ActivationNetworkError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivationNetworkError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_NetworkAdapter(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetwork", L"NetworkAdapter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkAdapter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_NetworkRegistrationState(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetwork", L"NetworkRegistrationState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkRegistrationState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_PacketAttachNetworkError(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetwork", L"PacketAttachNetworkError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PacketAttachNetworkError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_RegisteredDataClass(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetwork", L"RegisteredDataClass"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RegisteredDataClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_RegisteredProviderId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetwork", L"RegisteredProviderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RegisteredProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_RegisteredProviderName(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetwork", L"RegisteredProviderName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RegisteredProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_RegistrationNetworkError(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetwork", L"RegistrationNetworkError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RegistrationNetworkError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_RegistrationUiccApps(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetwork", L"RegistrationUiccApps"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RegistrationUiccApps());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandNetwork(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetwork>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandNetwork(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetwork>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandNetwork[] = {
        { "get_cells_info_async", reinterpret_cast<PyCFunction>(MobileBroadbandNetwork_GetCellsInfoAsync), METH_VARARGS, nullptr },
        { "get_voice_call_support_async", reinterpret_cast<PyCFunction>(MobileBroadbandNetwork_GetVoiceCallSupportAsync), METH_VARARGS, nullptr },
        { "show_connection_u_i", reinterpret_cast<PyCFunction>(MobileBroadbandNetwork_ShowConnectionUI), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandNetwork, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandNetwork), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandNetwork[] = {
        { "access_point_name", reinterpret_cast<getter>(MobileBroadbandNetwork_get_AccessPointName), nullptr, nullptr, nullptr },
        { "activation_network_error", reinterpret_cast<getter>(MobileBroadbandNetwork_get_ActivationNetworkError), nullptr, nullptr, nullptr },
        { "network_adapter", reinterpret_cast<getter>(MobileBroadbandNetwork_get_NetworkAdapter), nullptr, nullptr, nullptr },
        { "network_registration_state", reinterpret_cast<getter>(MobileBroadbandNetwork_get_NetworkRegistrationState), nullptr, nullptr, nullptr },
        { "packet_attach_network_error", reinterpret_cast<getter>(MobileBroadbandNetwork_get_PacketAttachNetworkError), nullptr, nullptr, nullptr },
        { "registered_data_class", reinterpret_cast<getter>(MobileBroadbandNetwork_get_RegisteredDataClass), nullptr, nullptr, nullptr },
        { "registered_provider_id", reinterpret_cast<getter>(MobileBroadbandNetwork_get_RegisteredProviderId), nullptr, nullptr, nullptr },
        { "registered_provider_name", reinterpret_cast<getter>(MobileBroadbandNetwork_get_RegisteredProviderName), nullptr, nullptr, nullptr },
        { "registration_network_error", reinterpret_cast<getter>(MobileBroadbandNetwork_get_RegistrationNetworkError), nullptr, nullptr, nullptr },
        { "registration_uicc_apps", reinterpret_cast<getter>(MobileBroadbandNetwork_get_RegistrationUiccApps), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandNetwork[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandNetwork) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandNetwork) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandNetwork) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandNetwork) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandNetwork =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandNetwork",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandNetwork
    };

    // ----- MobileBroadbandNetworkRegistrationStateChange class --------------------
    static constexpr const char* const type_name_MobileBroadbandNetworkRegistrationStateChange = "MobileBroadbandNetworkRegistrationStateChange";

    static PyObject* _new_MobileBroadbandNetworkRegistrationStateChange(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandNetworkRegistrationStateChange);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandNetworkRegistrationStateChange(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChange* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandNetworkRegistrationStateChange_get_DeviceId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChange* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetworkRegistrationStateChange", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetworkRegistrationStateChange_get_Network(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChange* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetworkRegistrationStateChange", L"Network"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Network());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandNetworkRegistrationStateChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChange>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandNetworkRegistrationStateChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandNetworkRegistrationStateChange[] = {
        { "_assign_array_", _assign_array_MobileBroadbandNetworkRegistrationStateChange, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandNetworkRegistrationStateChange), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandNetworkRegistrationStateChange[] = {
        { "device_id", reinterpret_cast<getter>(MobileBroadbandNetworkRegistrationStateChange_get_DeviceId), nullptr, nullptr, nullptr },
        { "network", reinterpret_cast<getter>(MobileBroadbandNetworkRegistrationStateChange_get_Network), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandNetworkRegistrationStateChange[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandNetworkRegistrationStateChange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandNetworkRegistrationStateChange) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandNetworkRegistrationStateChange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandNetworkRegistrationStateChange) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandNetworkRegistrationStateChange =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandNetworkRegistrationStateChange",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandNetworkRegistrationStateChange
    };

    // ----- MobileBroadbandNetworkRegistrationStateChangeTriggerDetails class --------------------
    static constexpr const char* const type_name_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails = "MobileBroadbandNetworkRegistrationStateChangeTriggerDetails";

    static PyObject* _new_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChangeTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandNetworkRegistrationStateChangeTriggerDetails_get_NetworkRegistrationStateChanges(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChangeTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetworkRegistrationStateChangeTriggerDetails", L"NetworkRegistrationStateChanges"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkRegistrationStateChanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChangeTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChangeTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails[] = {
        { "_assign_array_", _assign_array_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails[] = {
        { "network_registration_state_changes", reinterpret_cast<getter>(MobileBroadbandNetworkRegistrationStateChangeTriggerDetails_get_NetworkRegistrationStateChanges), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandNetworkRegistrationStateChangeTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChangeTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails
    };

    // ----- MobileBroadbandPco class --------------------
    static constexpr const char* const type_name_MobileBroadbandPco = "MobileBroadbandPco";

    static PyObject* _new_MobileBroadbandPco(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandPco);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandPco(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPco* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandPco_get_Data(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPco* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPco", L"Data"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPco_get_DeviceId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPco* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPco", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPco_get_IsComplete(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPco* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPco", L"IsComplete"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandPco(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPco>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandPco(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPco>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandPco[] = {
        { "_assign_array_", _assign_array_MobileBroadbandPco, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandPco), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandPco[] = {
        { "data", reinterpret_cast<getter>(MobileBroadbandPco_get_Data), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(MobileBroadbandPco_get_DeviceId), nullptr, nullptr, nullptr },
        { "is_complete", reinterpret_cast<getter>(MobileBroadbandPco_get_IsComplete), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandPco[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandPco) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandPco) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandPco) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandPco) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandPco =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandPco",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPco),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandPco
    };

    // ----- MobileBroadbandPcoDataChangeTriggerDetails class --------------------
    static constexpr const char* const type_name_MobileBroadbandPcoDataChangeTriggerDetails = "MobileBroadbandPcoDataChangeTriggerDetails";

    static PyObject* _new_MobileBroadbandPcoDataChangeTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandPcoDataChangeTriggerDetails);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandPcoDataChangeTriggerDetails(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPcoDataChangeTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandPcoDataChangeTriggerDetails_get_UpdatedData(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPcoDataChangeTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPcoDataChangeTriggerDetails", L"UpdatedData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UpdatedData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandPcoDataChangeTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPcoDataChangeTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandPcoDataChangeTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPcoDataChangeTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandPcoDataChangeTriggerDetails[] = {
        { "_assign_array_", _assign_array_MobileBroadbandPcoDataChangeTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandPcoDataChangeTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandPcoDataChangeTriggerDetails[] = {
        { "updated_data", reinterpret_cast<getter>(MobileBroadbandPcoDataChangeTriggerDetails_get_UpdatedData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandPcoDataChangeTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandPcoDataChangeTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandPcoDataChangeTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandPcoDataChangeTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandPcoDataChangeTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandPcoDataChangeTriggerDetails =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandPcoDataChangeTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPcoDataChangeTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandPcoDataChangeTriggerDetails
    };

    // ----- MobileBroadbandPin class --------------------
    static constexpr const char* const type_name_MobileBroadbandPin = "MobileBroadbandPin";

    static PyObject* _new_MobileBroadbandPin(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandPin);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandPin(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandPin_ChangeAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPin", L"ChangeAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.ChangeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_DisableAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPin", L"DisableAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DisableAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_EnableAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPin", L"EnableAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.EnableAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_EnterAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPin", L"EnterAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.EnterAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_UnblockAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPin", L"UnblockAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.UnblockAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_get_AttemptsRemaining(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPin", L"AttemptsRemaining"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AttemptsRemaining());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_get_Enabled(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPin", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_get_Format(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPin", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_get_LockState(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPin", L"LockState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LockState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_get_MaxLength(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPin", L"MaxLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_get_MinLength(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPin", L"MinLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_get_Type(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPin", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandPin(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPin>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandPin(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPin>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandPin[] = {
        { "change_async", reinterpret_cast<PyCFunction>(MobileBroadbandPin_ChangeAsync), METH_VARARGS, nullptr },
        { "disable_async", reinterpret_cast<PyCFunction>(MobileBroadbandPin_DisableAsync), METH_VARARGS, nullptr },
        { "enable_async", reinterpret_cast<PyCFunction>(MobileBroadbandPin_EnableAsync), METH_VARARGS, nullptr },
        { "enter_async", reinterpret_cast<PyCFunction>(MobileBroadbandPin_EnterAsync), METH_VARARGS, nullptr },
        { "unblock_async", reinterpret_cast<PyCFunction>(MobileBroadbandPin_UnblockAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandPin, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandPin), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandPin[] = {
        { "attempts_remaining", reinterpret_cast<getter>(MobileBroadbandPin_get_AttemptsRemaining), nullptr, nullptr, nullptr },
        { "enabled", reinterpret_cast<getter>(MobileBroadbandPin_get_Enabled), nullptr, nullptr, nullptr },
        { "format", reinterpret_cast<getter>(MobileBroadbandPin_get_Format), nullptr, nullptr, nullptr },
        { "lock_state", reinterpret_cast<getter>(MobileBroadbandPin_get_LockState), nullptr, nullptr, nullptr },
        { "max_length", reinterpret_cast<getter>(MobileBroadbandPin_get_MaxLength), nullptr, nullptr, nullptr },
        { "min_length", reinterpret_cast<getter>(MobileBroadbandPin_get_MinLength), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MobileBroadbandPin_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandPin[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandPin) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandPin) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandPin) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandPin) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandPin =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandPin",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandPin
    };

    // ----- MobileBroadbandPinLockStateChange class --------------------
    static constexpr const char* const type_name_MobileBroadbandPinLockStateChange = "MobileBroadbandPinLockStateChange";

    static PyObject* _new_MobileBroadbandPinLockStateChange(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandPinLockStateChange);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandPinLockStateChange(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChange* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandPinLockStateChange_get_DeviceId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChange* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPinLockStateChange", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPinLockStateChange_get_PinLockState(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChange* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPinLockStateChange", L"PinLockState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PinLockState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPinLockStateChange_get_PinType(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChange* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPinLockStateChange", L"PinType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PinType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandPinLockStateChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChange>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandPinLockStateChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandPinLockStateChange[] = {
        { "_assign_array_", _assign_array_MobileBroadbandPinLockStateChange, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandPinLockStateChange), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandPinLockStateChange[] = {
        { "device_id", reinterpret_cast<getter>(MobileBroadbandPinLockStateChange_get_DeviceId), nullptr, nullptr, nullptr },
        { "pin_lock_state", reinterpret_cast<getter>(MobileBroadbandPinLockStateChange_get_PinLockState), nullptr, nullptr, nullptr },
        { "pin_type", reinterpret_cast<getter>(MobileBroadbandPinLockStateChange_get_PinType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandPinLockStateChange[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandPinLockStateChange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandPinLockStateChange) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandPinLockStateChange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandPinLockStateChange) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandPinLockStateChange =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandPinLockStateChange",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandPinLockStateChange
    };

    // ----- MobileBroadbandPinLockStateChangeTriggerDetails class --------------------
    static constexpr const char* const type_name_MobileBroadbandPinLockStateChangeTriggerDetails = "MobileBroadbandPinLockStateChangeTriggerDetails";

    static PyObject* _new_MobileBroadbandPinLockStateChangeTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandPinLockStateChangeTriggerDetails);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandPinLockStateChangeTriggerDetails(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChangeTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandPinLockStateChangeTriggerDetails_get_PinLockStateChanges(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChangeTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPinLockStateChangeTriggerDetails", L"PinLockStateChanges"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PinLockStateChanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandPinLockStateChangeTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChangeTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandPinLockStateChangeTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChangeTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandPinLockStateChangeTriggerDetails[] = {
        { "_assign_array_", _assign_array_MobileBroadbandPinLockStateChangeTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandPinLockStateChangeTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandPinLockStateChangeTriggerDetails[] = {
        { "pin_lock_state_changes", reinterpret_cast<getter>(MobileBroadbandPinLockStateChangeTriggerDetails_get_PinLockStateChanges), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandPinLockStateChangeTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandPinLockStateChangeTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandPinLockStateChangeTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandPinLockStateChangeTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandPinLockStateChangeTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandPinLockStateChangeTriggerDetails =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandPinLockStateChangeTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChangeTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandPinLockStateChangeTriggerDetails
    };

    // ----- MobileBroadbandPinManager class --------------------
    static constexpr const char* const type_name_MobileBroadbandPinManager = "MobileBroadbandPinManager";

    static PyObject* _new_MobileBroadbandPinManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandPinManager);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandPinManager(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinManager* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandPinManager_GetPin(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPinManager", L"GetPin", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinType>(args, 0);

                return py::convert(self->obj.GetPin(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPinManager_get_SupportedPins(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPinManager", L"SupportedPins"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedPins());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandPinManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandPinManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandPinManager[] = {
        { "get_pin", reinterpret_cast<PyCFunction>(MobileBroadbandPinManager_GetPin), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandPinManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandPinManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandPinManager[] = {
        { "supported_pins", reinterpret_cast<getter>(MobileBroadbandPinManager_get_SupportedPins), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandPinManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandPinManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandPinManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandPinManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandPinManager) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandPinManager =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandPinManager",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandPinManager
    };

    // ----- MobileBroadbandPinOperationResult class --------------------
    static constexpr const char* const type_name_MobileBroadbandPinOperationResult = "MobileBroadbandPinOperationResult";

    static PyObject* _new_MobileBroadbandPinOperationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandPinOperationResult);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandPinOperationResult(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinOperationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandPinOperationResult_get_AttemptsRemaining(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinOperationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPinOperationResult", L"AttemptsRemaining"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AttemptsRemaining());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPinOperationResult_get_IsSuccessful(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinOperationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPinOperationResult", L"IsSuccessful"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSuccessful());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandPinOperationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinOperationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandPinOperationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinOperationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandPinOperationResult[] = {
        { "_assign_array_", _assign_array_MobileBroadbandPinOperationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandPinOperationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandPinOperationResult[] = {
        { "attempts_remaining", reinterpret_cast<getter>(MobileBroadbandPinOperationResult_get_AttemptsRemaining), nullptr, nullptr, nullptr },
        { "is_successful", reinterpret_cast<getter>(MobileBroadbandPinOperationResult_get_IsSuccessful), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandPinOperationResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandPinOperationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandPinOperationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandPinOperationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandPinOperationResult) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandPinOperationResult =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandPinOperationResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinOperationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandPinOperationResult
    };

    // ----- MobileBroadbandRadioStateChange class --------------------
    static constexpr const char* const type_name_MobileBroadbandRadioStateChange = "MobileBroadbandRadioStateChange";

    static PyObject* _new_MobileBroadbandRadioStateChange(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandRadioStateChange);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandRadioStateChange(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChange* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandRadioStateChange_get_DeviceId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChange* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandRadioStateChange", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandRadioStateChange_get_RadioState(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChange* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandRadioStateChange", L"RadioState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RadioState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandRadioStateChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChange>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandRadioStateChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandRadioStateChange[] = {
        { "_assign_array_", _assign_array_MobileBroadbandRadioStateChange, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandRadioStateChange), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandRadioStateChange[] = {
        { "device_id", reinterpret_cast<getter>(MobileBroadbandRadioStateChange_get_DeviceId), nullptr, nullptr, nullptr },
        { "radio_state", reinterpret_cast<getter>(MobileBroadbandRadioStateChange_get_RadioState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandRadioStateChange[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandRadioStateChange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandRadioStateChange) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandRadioStateChange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandRadioStateChange) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandRadioStateChange =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandRadioStateChange",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandRadioStateChange
    };

    // ----- MobileBroadbandRadioStateChangeTriggerDetails class --------------------
    static constexpr const char* const type_name_MobileBroadbandRadioStateChangeTriggerDetails = "MobileBroadbandRadioStateChangeTriggerDetails";

    static PyObject* _new_MobileBroadbandRadioStateChangeTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandRadioStateChangeTriggerDetails);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandRadioStateChangeTriggerDetails(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChangeTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandRadioStateChangeTriggerDetails_get_RadioStateChanges(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChangeTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandRadioStateChangeTriggerDetails", L"RadioStateChanges"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RadioStateChanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandRadioStateChangeTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChangeTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandRadioStateChangeTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChangeTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandRadioStateChangeTriggerDetails[] = {
        { "_assign_array_", _assign_array_MobileBroadbandRadioStateChangeTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandRadioStateChangeTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandRadioStateChangeTriggerDetails[] = {
        { "radio_state_changes", reinterpret_cast<getter>(MobileBroadbandRadioStateChangeTriggerDetails_get_RadioStateChanges), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandRadioStateChangeTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandRadioStateChangeTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandRadioStateChangeTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandRadioStateChangeTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandRadioStateChangeTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandRadioStateChangeTriggerDetails =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandRadioStateChangeTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChangeTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandRadioStateChangeTriggerDetails
    };

    // ----- MobileBroadbandSarManager class --------------------
    static constexpr const char* const type_name_MobileBroadbandSarManager = "MobileBroadbandSarManager";

    static PyObject* _new_MobileBroadbandSarManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandSarManager);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandSarManager(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandSarManager_DisableBackoffAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"DisableBackoffAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DisableBackoffAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_EnableBackoffAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"EnableBackoffAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.EnableBackoffAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_GetIsTransmittingAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"GetIsTransmittingAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetIsTransmittingAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_RevertSarToHardwareControlAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"RevertSarToHardwareControlAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RevertSarToHardwareControlAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_SetConfigurationAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"SetConfigurationAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAntennaSar>>(args, 0);

                return py::convert(self->obj.SetConfigurationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_SetTransmissionStateChangedHysteresisAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"SetTransmissionStateChangedHysteresisAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(self->obj.SetTransmissionStateChangedHysteresisAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_StartTransmissionStateMonitoring(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"StartTransmissionStateMonitoring", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.StartTransmissionStateMonitoring();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_StopTransmissionStateMonitoring(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"StopTransmissionStateMonitoring", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.StopTransmissionStateMonitoring();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_get_Antennas(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"Antennas"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Antennas());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_get_HysteresisTimerPeriod(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"HysteresisTimerPeriod"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HysteresisTimerPeriod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_get_IsBackoffEnabled(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"IsBackoffEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsBackoffEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_get_IsSarControlledByHardware(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"IsSarControlledByHardware"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSarControlledByHardware());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_get_IsWiFiHardwareIntegrated(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"IsWiFiHardwareIntegrated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsWiFiHardwareIntegrated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_add_TransmissionStateChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"TransmissionStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSarManager, winrt::Windows::Networking::NetworkOperators::MobileBroadbandTransmissionStateChangedEventArgs>>(arg);

            return py::convert(self->obj.TransmissionStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_remove_TransmissionStateChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"TransmissionStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TransmissionStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandSarManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSarManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandSarManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSarManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandSarManager[] = {
        { "disable_backoff_async", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_DisableBackoffAsync), METH_VARARGS, nullptr },
        { "enable_backoff_async", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_EnableBackoffAsync), METH_VARARGS, nullptr },
        { "get_is_transmitting_async", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_GetIsTransmittingAsync), METH_VARARGS, nullptr },
        { "revert_sar_to_hardware_control_async", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_RevertSarToHardwareControlAsync), METH_VARARGS, nullptr },
        { "set_configuration_async", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_SetConfigurationAsync), METH_VARARGS, nullptr },
        { "set_transmission_state_changed_hysteresis_async", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_SetTransmissionStateChangedHysteresisAsync), METH_VARARGS, nullptr },
        { "start_transmission_state_monitoring", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_StartTransmissionStateMonitoring), METH_VARARGS, nullptr },
        { "stop_transmission_state_monitoring", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_StopTransmissionStateMonitoring), METH_VARARGS, nullptr },
        { "add_transmission_state_changed", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_add_TransmissionStateChanged), METH_O, nullptr },
        { "remove_transmission_state_changed", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_remove_TransmissionStateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandSarManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandSarManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandSarManager[] = {
        { "antennas", reinterpret_cast<getter>(MobileBroadbandSarManager_get_Antennas), nullptr, nullptr, nullptr },
        { "hysteresis_timer_period", reinterpret_cast<getter>(MobileBroadbandSarManager_get_HysteresisTimerPeriod), nullptr, nullptr, nullptr },
        { "is_backoff_enabled", reinterpret_cast<getter>(MobileBroadbandSarManager_get_IsBackoffEnabled), nullptr, nullptr, nullptr },
        { "is_sar_controlled_by_hardware", reinterpret_cast<getter>(MobileBroadbandSarManager_get_IsSarControlledByHardware), nullptr, nullptr, nullptr },
        { "is_wi_fi_hardware_integrated", reinterpret_cast<getter>(MobileBroadbandSarManager_get_IsWiFiHardwareIntegrated), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandSarManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandSarManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandSarManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandSarManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandSarManager) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandSarManager =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandSarManager",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandSarManager
    };

    // ----- MobileBroadbandSlotInfo class --------------------
    static constexpr const char* const type_name_MobileBroadbandSlotInfo = "MobileBroadbandSlotInfo";

    static PyObject* _new_MobileBroadbandSlotInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandSlotInfo);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandSlotInfo(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandSlotInfo_get_Index(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSlotInfo", L"Index"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Index());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSlotInfo_get_State(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSlotInfo", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSlotInfo_get_IccId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSlotInfo", L"IccId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandSlotInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandSlotInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandSlotInfo[] = {
        { "_assign_array_", _assign_array_MobileBroadbandSlotInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandSlotInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandSlotInfo[] = {
        { "index", reinterpret_cast<getter>(MobileBroadbandSlotInfo_get_Index), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(MobileBroadbandSlotInfo_get_State), nullptr, nullptr, nullptr },
        { "icc_id", reinterpret_cast<getter>(MobileBroadbandSlotInfo_get_IccId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandSlotInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandSlotInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandSlotInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandSlotInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandSlotInfo) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandSlotInfo =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandSlotInfo",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandSlotInfo
    };

    // ----- MobileBroadbandSlotInfoChangedEventArgs class --------------------
    static constexpr const char* const type_name_MobileBroadbandSlotInfoChangedEventArgs = "MobileBroadbandSlotInfoChangedEventArgs";

    static PyObject* _new_MobileBroadbandSlotInfoChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandSlotInfoChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandSlotInfoChangedEventArgs(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfoChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandSlotInfoChangedEventArgs_get_SlotInfo(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfoChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSlotInfoChangedEventArgs", L"SlotInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SlotInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandSlotInfoChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfoChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandSlotInfoChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfoChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandSlotInfoChangedEventArgs[] = {
        { "_assign_array_", _assign_array_MobileBroadbandSlotInfoChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandSlotInfoChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandSlotInfoChangedEventArgs[] = {
        { "slot_info", reinterpret_cast<getter>(MobileBroadbandSlotInfoChangedEventArgs_get_SlotInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandSlotInfoChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandSlotInfoChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandSlotInfoChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandSlotInfoChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandSlotInfoChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandSlotInfoChangedEventArgs =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandSlotInfoChangedEventArgs",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfoChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandSlotInfoChangedEventArgs
    };

    // ----- MobileBroadbandSlotManager class --------------------
    static constexpr const char* const type_name_MobileBroadbandSlotManager = "MobileBroadbandSlotManager";

    static PyObject* _new_MobileBroadbandSlotManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandSlotManager);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandSlotManager(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandSlotManager_SetCurrentSlot(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSlotManager", L"SetCurrentSlot", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.SetCurrentSlot(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSlotManager_SetCurrentSlotAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSlotManager", L"SetCurrentSlotAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.SetCurrentSlotAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSlotManager_get_CurrentSlotIndex(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSlotManager", L"CurrentSlotIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentSlotIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSlotManager_get_SlotInfos(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSlotManager", L"SlotInfos"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SlotInfos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSlotManager_add_CurrentSlotIndexChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSlotManager", L"CurrentSlotIndexChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager, winrt::Windows::Networking::NetworkOperators::MobileBroadbandCurrentSlotIndexChangedEventArgs>>(arg);

            return py::convert(self->obj.CurrentSlotIndexChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSlotManager_remove_CurrentSlotIndexChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSlotManager", L"CurrentSlotIndexChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CurrentSlotIndexChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSlotManager_add_SlotInfoChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSlotManager", L"SlotInfoChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager, winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfoChangedEventArgs>>(arg);

            return py::convert(self->obj.SlotInfoChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSlotManager_remove_SlotInfoChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSlotManager", L"SlotInfoChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SlotInfoChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandSlotManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandSlotManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandSlotManager[] = {
        { "set_current_slot", reinterpret_cast<PyCFunction>(MobileBroadbandSlotManager_SetCurrentSlot), METH_VARARGS, nullptr },
        { "set_current_slot_async", reinterpret_cast<PyCFunction>(MobileBroadbandSlotManager_SetCurrentSlotAsync), METH_VARARGS, nullptr },
        { "add_current_slot_index_changed", reinterpret_cast<PyCFunction>(MobileBroadbandSlotManager_add_CurrentSlotIndexChanged), METH_O, nullptr },
        { "remove_current_slot_index_changed", reinterpret_cast<PyCFunction>(MobileBroadbandSlotManager_remove_CurrentSlotIndexChanged), METH_O, nullptr },
        { "add_slot_info_changed", reinterpret_cast<PyCFunction>(MobileBroadbandSlotManager_add_SlotInfoChanged), METH_O, nullptr },
        { "remove_slot_info_changed", reinterpret_cast<PyCFunction>(MobileBroadbandSlotManager_remove_SlotInfoChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandSlotManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandSlotManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandSlotManager[] = {
        { "current_slot_index", reinterpret_cast<getter>(MobileBroadbandSlotManager_get_CurrentSlotIndex), nullptr, nullptr, nullptr },
        { "slot_infos", reinterpret_cast<getter>(MobileBroadbandSlotManager_get_SlotInfos), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandSlotManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandSlotManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandSlotManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandSlotManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandSlotManager) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandSlotManager =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandSlotManager",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandSlotManager
    };

    // ----- MobileBroadbandTransmissionStateChangedEventArgs class --------------------
    static constexpr const char* const type_name_MobileBroadbandTransmissionStateChangedEventArgs = "MobileBroadbandTransmissionStateChangedEventArgs";

    static PyObject* _new_MobileBroadbandTransmissionStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandTransmissionStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandTransmissionStateChangedEventArgs(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandTransmissionStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandTransmissionStateChangedEventArgs_get_IsTransmitting(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandTransmissionStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandTransmissionStateChangedEventArgs", L"IsTransmitting"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTransmitting());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandTransmissionStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandTransmissionStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandTransmissionStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandTransmissionStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandTransmissionStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_MobileBroadbandTransmissionStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandTransmissionStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandTransmissionStateChangedEventArgs[] = {
        { "is_transmitting", reinterpret_cast<getter>(MobileBroadbandTransmissionStateChangedEventArgs_get_IsTransmitting), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandTransmissionStateChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandTransmissionStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandTransmissionStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandTransmissionStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandTransmissionStateChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandTransmissionStateChangedEventArgs =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandTransmissionStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandTransmissionStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandTransmissionStateChangedEventArgs
    };

    // ----- MobileBroadbandUicc class --------------------
    static constexpr const char* const type_name_MobileBroadbandUicc = "MobileBroadbandUicc";

    static PyObject* _new_MobileBroadbandUicc(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandUicc);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandUicc(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUicc* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandUicc_GetUiccAppsAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUicc* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUicc", L"GetUiccAppsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetUiccAppsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUicc_get_SimIccId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUicc* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUicc", L"SimIccId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SimIccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandUicc(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUicc>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandUicc(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUicc>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandUicc[] = {
        { "get_uicc_apps_async", reinterpret_cast<PyCFunction>(MobileBroadbandUicc_GetUiccAppsAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandUicc, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandUicc), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandUicc[] = {
        { "sim_icc_id", reinterpret_cast<getter>(MobileBroadbandUicc_get_SimIccId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandUicc[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandUicc) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandUicc) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandUicc) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandUicc) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandUicc =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandUicc",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUicc),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandUicc
    };

    // ----- MobileBroadbandUiccApp class --------------------
    static constexpr const char* const type_name_MobileBroadbandUiccApp = "MobileBroadbandUiccApp";

    static PyObject* _new_MobileBroadbandUiccApp(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandUiccApp);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandUiccApp(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandUiccApp_GetRecordDetailsAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccApp", L"GetRecordDetailsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint32_t>>(args, 0);

                return py::convert(self->obj.GetRecordDetailsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccApp_ReadRecordAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccApp", L"ReadRecordAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint32_t>>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.ReadRecordAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccApp_get_Id(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccApp", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccApp_get_Kind(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccApp", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandUiccApp(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandUiccApp(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandUiccApp[] = {
        { "get_record_details_async", reinterpret_cast<PyCFunction>(MobileBroadbandUiccApp_GetRecordDetailsAsync), METH_VARARGS, nullptr },
        { "read_record_async", reinterpret_cast<PyCFunction>(MobileBroadbandUiccApp_ReadRecordAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandUiccApp, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandUiccApp), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandUiccApp[] = {
        { "id", reinterpret_cast<getter>(MobileBroadbandUiccApp_get_Id), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(MobileBroadbandUiccApp_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandUiccApp[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandUiccApp) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandUiccApp) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandUiccApp) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandUiccApp) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandUiccApp =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandUiccApp",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandUiccApp
    };

    // ----- MobileBroadbandUiccAppReadRecordResult class --------------------
    static constexpr const char* const type_name_MobileBroadbandUiccAppReadRecordResult = "MobileBroadbandUiccAppReadRecordResult";

    static PyObject* _new_MobileBroadbandUiccAppReadRecordResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandUiccAppReadRecordResult);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandUiccAppReadRecordResult(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppReadRecordResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandUiccAppReadRecordResult_get_Data(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppReadRecordResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccAppReadRecordResult", L"Data"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccAppReadRecordResult_get_Status(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppReadRecordResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccAppReadRecordResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandUiccAppReadRecordResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppReadRecordResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandUiccAppReadRecordResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppReadRecordResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandUiccAppReadRecordResult[] = {
        { "_assign_array_", _assign_array_MobileBroadbandUiccAppReadRecordResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandUiccAppReadRecordResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandUiccAppReadRecordResult[] = {
        { "data", reinterpret_cast<getter>(MobileBroadbandUiccAppReadRecordResult_get_Data), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(MobileBroadbandUiccAppReadRecordResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandUiccAppReadRecordResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandUiccAppReadRecordResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandUiccAppReadRecordResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandUiccAppReadRecordResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandUiccAppReadRecordResult) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandUiccAppReadRecordResult =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandUiccAppReadRecordResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppReadRecordResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandUiccAppReadRecordResult
    };

    // ----- MobileBroadbandUiccAppRecordDetailsResult class --------------------
    static constexpr const char* const type_name_MobileBroadbandUiccAppRecordDetailsResult = "MobileBroadbandUiccAppRecordDetailsResult";

    static PyObject* _new_MobileBroadbandUiccAppRecordDetailsResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandUiccAppRecordDetailsResult);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandUiccAppRecordDetailsResult(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandUiccAppRecordDetailsResult_get_Kind(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccAppRecordDetailsResult", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccAppRecordDetailsResult_get_ReadAccessCondition(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccAppRecordDetailsResult", L"ReadAccessCondition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReadAccessCondition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccAppRecordDetailsResult_get_RecordCount(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccAppRecordDetailsResult", L"RecordCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RecordCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccAppRecordDetailsResult_get_RecordSize(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccAppRecordDetailsResult", L"RecordSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RecordSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccAppRecordDetailsResult_get_Status(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccAppRecordDetailsResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccAppRecordDetailsResult_get_WriteAccessCondition(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccAppRecordDetailsResult", L"WriteAccessCondition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WriteAccessCondition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandUiccAppRecordDetailsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandUiccAppRecordDetailsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandUiccAppRecordDetailsResult[] = {
        { "_assign_array_", _assign_array_MobileBroadbandUiccAppRecordDetailsResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandUiccAppRecordDetailsResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandUiccAppRecordDetailsResult[] = {
        { "kind", reinterpret_cast<getter>(MobileBroadbandUiccAppRecordDetailsResult_get_Kind), nullptr, nullptr, nullptr },
        { "read_access_condition", reinterpret_cast<getter>(MobileBroadbandUiccAppRecordDetailsResult_get_ReadAccessCondition), nullptr, nullptr, nullptr },
        { "record_count", reinterpret_cast<getter>(MobileBroadbandUiccAppRecordDetailsResult_get_RecordCount), nullptr, nullptr, nullptr },
        { "record_size", reinterpret_cast<getter>(MobileBroadbandUiccAppRecordDetailsResult_get_RecordSize), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(MobileBroadbandUiccAppRecordDetailsResult_get_Status), nullptr, nullptr, nullptr },
        { "write_access_condition", reinterpret_cast<getter>(MobileBroadbandUiccAppRecordDetailsResult_get_WriteAccessCondition), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandUiccAppRecordDetailsResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandUiccAppRecordDetailsResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandUiccAppRecordDetailsResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandUiccAppRecordDetailsResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandUiccAppRecordDetailsResult) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandUiccAppRecordDetailsResult =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandUiccAppRecordDetailsResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandUiccAppRecordDetailsResult
    };

    // ----- MobileBroadbandUiccAppsResult class --------------------
    static constexpr const char* const type_name_MobileBroadbandUiccAppsResult = "MobileBroadbandUiccAppsResult";

    static PyObject* _new_MobileBroadbandUiccAppsResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandUiccAppsResult);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandUiccAppsResult(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppsResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandUiccAppsResult_get_Status(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccAppsResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccAppsResult_get_UiccApps(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccAppsResult", L"UiccApps"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UiccApps());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandUiccAppsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppsResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandUiccAppsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppsResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandUiccAppsResult[] = {
        { "_assign_array_", _assign_array_MobileBroadbandUiccAppsResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandUiccAppsResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandUiccAppsResult[] = {
        { "status", reinterpret_cast<getter>(MobileBroadbandUiccAppsResult_get_Status), nullptr, nullptr, nullptr },
        { "uicc_apps", reinterpret_cast<getter>(MobileBroadbandUiccAppsResult_get_UiccApps), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandUiccAppsResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandUiccAppsResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandUiccAppsResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandUiccAppsResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandUiccAppsResult) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandUiccAppsResult =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandUiccAppsResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandUiccAppsResult
    };

    // ----- NetworkOperatorDataUsageTriggerDetails class --------------------
    static constexpr const char* const type_name_NetworkOperatorDataUsageTriggerDetails = "NetworkOperatorDataUsageTriggerDetails";

    static PyObject* _new_NetworkOperatorDataUsageTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_NetworkOperatorDataUsageTriggerDetails);
        return nullptr;
    }

    static void _dealloc_NetworkOperatorDataUsageTriggerDetails(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorDataUsageTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkOperatorDataUsageTriggerDetails_get_NotificationKind(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorDataUsageTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorDataUsageTriggerDetails", L"NotificationKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NotificationKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NetworkOperatorDataUsageTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::NetworkOperatorDataUsageTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NetworkOperatorDataUsageTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::NetworkOperatorDataUsageTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkOperatorDataUsageTriggerDetails[] = {
        { "_assign_array_", _assign_array_NetworkOperatorDataUsageTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkOperatorDataUsageTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkOperatorDataUsageTriggerDetails[] = {
        { "notification_kind", reinterpret_cast<getter>(NetworkOperatorDataUsageTriggerDetails_get_NotificationKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkOperatorDataUsageTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NetworkOperatorDataUsageTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NetworkOperatorDataUsageTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NetworkOperatorDataUsageTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NetworkOperatorDataUsageTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_NetworkOperatorDataUsageTriggerDetails =
    {
        "_winsdk_Windows_Networking_NetworkOperators.NetworkOperatorDataUsageTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorDataUsageTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkOperatorDataUsageTriggerDetails
    };

    // ----- NetworkOperatorNotificationEventDetails class --------------------
    static constexpr const char* const type_name_NetworkOperatorNotificationEventDetails = "NetworkOperatorNotificationEventDetails";

    static PyObject* _new_NetworkOperatorNotificationEventDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_NetworkOperatorNotificationEventDetails);
        return nullptr;
    }

    static void _dealloc_NetworkOperatorNotificationEventDetails(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorNotificationEventDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkOperatorNotificationEventDetails_AuthorizeTethering(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorNotificationEventDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorNotificationEventDetails", L"AuthorizeTethering", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.AuthorizeTethering(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorNotificationEventDetails_get_EncodingType(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorNotificationEventDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorNotificationEventDetails", L"EncodingType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorNotificationEventDetails_get_Message(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorNotificationEventDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorNotificationEventDetails", L"Message"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorNotificationEventDetails_get_NetworkAccountId(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorNotificationEventDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorNotificationEventDetails", L"NetworkAccountId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorNotificationEventDetails_get_NotificationType(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorNotificationEventDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorNotificationEventDetails", L"NotificationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NotificationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorNotificationEventDetails_get_RuleId(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorNotificationEventDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorNotificationEventDetails", L"RuleId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RuleId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorNotificationEventDetails_get_SmsMessage(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorNotificationEventDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorNotificationEventDetails", L"SmsMessage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SmsMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NetworkOperatorNotificationEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::NetworkOperatorNotificationEventDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NetworkOperatorNotificationEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::NetworkOperatorNotificationEventDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkOperatorNotificationEventDetails[] = {
        { "authorize_tethering", reinterpret_cast<PyCFunction>(NetworkOperatorNotificationEventDetails_AuthorizeTethering), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NetworkOperatorNotificationEventDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkOperatorNotificationEventDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkOperatorNotificationEventDetails[] = {
        { "encoding_type", reinterpret_cast<getter>(NetworkOperatorNotificationEventDetails_get_EncodingType), nullptr, nullptr, nullptr },
        { "message", reinterpret_cast<getter>(NetworkOperatorNotificationEventDetails_get_Message), nullptr, nullptr, nullptr },
        { "network_account_id", reinterpret_cast<getter>(NetworkOperatorNotificationEventDetails_get_NetworkAccountId), nullptr, nullptr, nullptr },
        { "notification_type", reinterpret_cast<getter>(NetworkOperatorNotificationEventDetails_get_NotificationType), nullptr, nullptr, nullptr },
        { "rule_id", reinterpret_cast<getter>(NetworkOperatorNotificationEventDetails_get_RuleId), nullptr, nullptr, nullptr },
        { "sms_message", reinterpret_cast<getter>(NetworkOperatorNotificationEventDetails_get_SmsMessage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkOperatorNotificationEventDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NetworkOperatorNotificationEventDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NetworkOperatorNotificationEventDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NetworkOperatorNotificationEventDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NetworkOperatorNotificationEventDetails) },
        { },
    };

    static PyType_Spec type_spec_NetworkOperatorNotificationEventDetails =
    {
        "_winsdk_Windows_Networking_NetworkOperators.NetworkOperatorNotificationEventDetails",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorNotificationEventDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkOperatorNotificationEventDetails
    };

    // ----- NetworkOperatorTetheringAccessPointConfiguration class --------------------
    static constexpr const char* const type_name_NetworkOperatorTetheringAccessPointConfiguration = "NetworkOperatorTetheringAccessPointConfiguration";

    static PyObject* _new_NetworkOperatorTetheringAccessPointConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NetworkOperatorTetheringAccessPointConfiguration(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkOperatorTetheringAccessPointConfiguration_IsBandSupported(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringAccessPointConfiguration", L"IsBandSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::NetworkOperators::TetheringWiFiBand>(args, 0);

                return py::convert(self->obj.IsBandSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringAccessPointConfiguration_IsBandSupportedAsync(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringAccessPointConfiguration", L"IsBandSupportedAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::NetworkOperators::TetheringWiFiBand>(args, 0);

                return py::convert(self->obj.IsBandSupportedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringAccessPointConfiguration_get_Ssid(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringAccessPointConfiguration", L"Ssid"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Ssid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NetworkOperatorTetheringAccessPointConfiguration_put_Ssid(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringAccessPointConfiguration", L"Ssid"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Ssid(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NetworkOperatorTetheringAccessPointConfiguration_get_Passphrase(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringAccessPointConfiguration", L"Passphrase"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Passphrase());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NetworkOperatorTetheringAccessPointConfiguration_put_Passphrase(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringAccessPointConfiguration", L"Passphrase"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Passphrase(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NetworkOperatorTetheringAccessPointConfiguration_get_Band(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringAccessPointConfiguration", L"Band"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Band());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NetworkOperatorTetheringAccessPointConfiguration_put_Band(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringAccessPointConfiguration", L"Band"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::NetworkOperators::TetheringWiFiBand>(arg);

            self->obj.Band(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_NetworkOperatorTetheringAccessPointConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NetworkOperatorTetheringAccessPointConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkOperatorTetheringAccessPointConfiguration[] = {
        { "is_band_supported", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringAccessPointConfiguration_IsBandSupported), METH_VARARGS, nullptr },
        { "is_band_supported_async", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringAccessPointConfiguration_IsBandSupportedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NetworkOperatorTetheringAccessPointConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkOperatorTetheringAccessPointConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkOperatorTetheringAccessPointConfiguration[] = {
        { "ssid", reinterpret_cast<getter>(NetworkOperatorTetheringAccessPointConfiguration_get_Ssid), reinterpret_cast<setter>(NetworkOperatorTetheringAccessPointConfiguration_put_Ssid), nullptr, nullptr },
        { "passphrase", reinterpret_cast<getter>(NetworkOperatorTetheringAccessPointConfiguration_get_Passphrase), reinterpret_cast<setter>(NetworkOperatorTetheringAccessPointConfiguration_put_Passphrase), nullptr, nullptr },
        { "band", reinterpret_cast<getter>(NetworkOperatorTetheringAccessPointConfiguration_get_Band), reinterpret_cast<setter>(NetworkOperatorTetheringAccessPointConfiguration_put_Band), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkOperatorTetheringAccessPointConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NetworkOperatorTetheringAccessPointConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NetworkOperatorTetheringAccessPointConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NetworkOperatorTetheringAccessPointConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NetworkOperatorTetheringAccessPointConfiguration) },
        { },
    };

    static PyType_Spec type_spec_NetworkOperatorTetheringAccessPointConfiguration =
    {
        "_winsdk_Windows_Networking_NetworkOperators.NetworkOperatorTetheringAccessPointConfiguration",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkOperatorTetheringAccessPointConfiguration
    };

    // ----- NetworkOperatorTetheringClient class --------------------
    static constexpr const char* const type_name_NetworkOperatorTetheringClient = "NetworkOperatorTetheringClient";

    static PyObject* _new_NetworkOperatorTetheringClient(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_NetworkOperatorTetheringClient);
        return nullptr;
    }

    static void _dealloc_NetworkOperatorTetheringClient(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringClient* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkOperatorTetheringClient_get_HostNames(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringClient* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringClient", L"HostNames"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HostNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringClient_get_MacAddress(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringClient* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringClient", L"MacAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MacAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NetworkOperatorTetheringClient(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringClient>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NetworkOperatorTetheringClient(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringClient>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkOperatorTetheringClient[] = {
        { "_assign_array_", _assign_array_NetworkOperatorTetheringClient, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkOperatorTetheringClient), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkOperatorTetheringClient[] = {
        { "host_names", reinterpret_cast<getter>(NetworkOperatorTetheringClient_get_HostNames), nullptr, nullptr, nullptr },
        { "mac_address", reinterpret_cast<getter>(NetworkOperatorTetheringClient_get_MacAddress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkOperatorTetheringClient[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NetworkOperatorTetheringClient) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NetworkOperatorTetheringClient) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NetworkOperatorTetheringClient) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NetworkOperatorTetheringClient) },
        { },
    };

    static PyType_Spec type_spec_NetworkOperatorTetheringClient =
    {
        "_winsdk_Windows_Networking_NetworkOperators.NetworkOperatorTetheringClient",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringClient),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkOperatorTetheringClient
    };

    // ----- NetworkOperatorTetheringManager class --------------------
    static constexpr const char* const type_name_NetworkOperatorTetheringManager = "NetworkOperatorTetheringManager";

    static PyObject* _new_NetworkOperatorTetheringManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_NetworkOperatorTetheringManager);
        return nullptr;
    }

    static void _dealloc_NetworkOperatorTetheringManager(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkOperatorTetheringManager_ConfigureAccessPointAsync(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"ConfigureAccessPointAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration>(args, 0);

                return py::convert(self->obj.ConfigureAccessPointAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_CreateFromConnectionProfile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"CreateFromConnectionProfile", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::ConnectionProfile>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::CreateFromConnectionProfile(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"CreateFromConnectionProfile", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::ConnectionProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkAdapter>(args, 1);

                return py::convert(winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::CreateFromConnectionProfile(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_CreateFromNetworkAccountId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"CreateFromNetworkAccountId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::CreateFromNetworkAccountId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_DisableNoConnectionsTimeout(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"DisableNoConnectionsTimeout", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::DisableNoConnectionsTimeout();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_DisableNoConnectionsTimeoutAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"DisableNoConnectionsTimeoutAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::DisableNoConnectionsTimeoutAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_EnableNoConnectionsTimeout(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"EnableNoConnectionsTimeout", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::EnableNoConnectionsTimeout();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_EnableNoConnectionsTimeoutAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"EnableNoConnectionsTimeoutAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::EnableNoConnectionsTimeoutAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_GetCurrentAccessPointConfiguration(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"GetCurrentAccessPointConfiguration", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentAccessPointConfiguration());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_GetTetheringCapability(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"GetTetheringCapability", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::GetTetheringCapability(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_GetTetheringCapabilityFromConnectionProfile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"GetTetheringCapabilityFromConnectionProfile", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::ConnectionProfile>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::GetTetheringCapabilityFromConnectionProfile(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_GetTetheringClients(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"GetTetheringClients", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetTetheringClients());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_IsNoConnectionsTimeoutEnabled(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"IsNoConnectionsTimeoutEnabled", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::IsNoConnectionsTimeoutEnabled());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_StartTetheringAsync(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"StartTetheringAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StartTetheringAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_StopTetheringAsync(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"StopTetheringAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StopTetheringAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_get_ClientCount(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"ClientCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ClientCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_get_MaxClientCount(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"MaxClientCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxClientCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_get_TetheringOperationalState(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"TetheringOperationalState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TetheringOperationalState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NetworkOperatorTetheringManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NetworkOperatorTetheringManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkOperatorTetheringManager[] = {
        { "configure_access_point_async", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_ConfigureAccessPointAsync), METH_VARARGS, nullptr },
        { "create_from_connection_profile", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_CreateFromConnectionProfile), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_network_account_id", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_CreateFromNetworkAccountId), METH_VARARGS | METH_STATIC, nullptr },
        { "disable_no_connections_timeout", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_DisableNoConnectionsTimeout), METH_VARARGS | METH_STATIC, nullptr },
        { "disable_no_connections_timeout_async", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_DisableNoConnectionsTimeoutAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "enable_no_connections_timeout", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_EnableNoConnectionsTimeout), METH_VARARGS | METH_STATIC, nullptr },
        { "enable_no_connections_timeout_async", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_EnableNoConnectionsTimeoutAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_access_point_configuration", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_GetCurrentAccessPointConfiguration), METH_VARARGS, nullptr },
        { "get_tethering_capability", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_GetTetheringCapability), METH_VARARGS | METH_STATIC, nullptr },
        { "get_tethering_capability_from_connection_profile", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_GetTetheringCapabilityFromConnectionProfile), METH_VARARGS | METH_STATIC, nullptr },
        { "get_tethering_clients", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_GetTetheringClients), METH_VARARGS, nullptr },
        { "is_no_connections_timeout_enabled", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_IsNoConnectionsTimeoutEnabled), METH_VARARGS | METH_STATIC, nullptr },
        { "start_tethering_async", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_StartTetheringAsync), METH_VARARGS, nullptr },
        { "stop_tethering_async", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_StopTetheringAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NetworkOperatorTetheringManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkOperatorTetheringManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkOperatorTetheringManager[] = {
        { "client_count", reinterpret_cast<getter>(NetworkOperatorTetheringManager_get_ClientCount), nullptr, nullptr, nullptr },
        { "max_client_count", reinterpret_cast<getter>(NetworkOperatorTetheringManager_get_MaxClientCount), nullptr, nullptr, nullptr },
        { "tethering_operational_state", reinterpret_cast<getter>(NetworkOperatorTetheringManager_get_TetheringOperationalState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkOperatorTetheringManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NetworkOperatorTetheringManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NetworkOperatorTetheringManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NetworkOperatorTetheringManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NetworkOperatorTetheringManager) },
        { },
    };

    static PyType_Spec type_spec_NetworkOperatorTetheringManager =
    {
        "_winsdk_Windows_Networking_NetworkOperators.NetworkOperatorTetheringManager",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkOperatorTetheringManager
    };

    // ----- NetworkOperatorTetheringOperationResult class --------------------
    static constexpr const char* const type_name_NetworkOperatorTetheringOperationResult = "NetworkOperatorTetheringOperationResult";

    static PyObject* _new_NetworkOperatorTetheringOperationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_NetworkOperatorTetheringOperationResult);
        return nullptr;
    }

    static void _dealloc_NetworkOperatorTetheringOperationResult(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringOperationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkOperatorTetheringOperationResult_get_AdditionalErrorMessage(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringOperationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringOperationResult", L"AdditionalErrorMessage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AdditionalErrorMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringOperationResult_get_Status(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringOperationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringOperationResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NetworkOperatorTetheringOperationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringOperationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NetworkOperatorTetheringOperationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringOperationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkOperatorTetheringOperationResult[] = {
        { "_assign_array_", _assign_array_NetworkOperatorTetheringOperationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkOperatorTetheringOperationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkOperatorTetheringOperationResult[] = {
        { "additional_error_message", reinterpret_cast<getter>(NetworkOperatorTetheringOperationResult_get_AdditionalErrorMessage), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(NetworkOperatorTetheringOperationResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkOperatorTetheringOperationResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NetworkOperatorTetheringOperationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NetworkOperatorTetheringOperationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NetworkOperatorTetheringOperationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NetworkOperatorTetheringOperationResult) },
        { },
    };

    static PyType_Spec type_spec_NetworkOperatorTetheringOperationResult =
    {
        "_winsdk_Windows_Networking_NetworkOperators.NetworkOperatorTetheringOperationResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringOperationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkOperatorTetheringOperationResult
    };

    // ----- ProvisionFromXmlDocumentResults class --------------------
    static constexpr const char* const type_name_ProvisionFromXmlDocumentResults = "ProvisionFromXmlDocumentResults";

    static PyObject* _new_ProvisionFromXmlDocumentResults(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ProvisionFromXmlDocumentResults);
        return nullptr;
    }

    static void _dealloc_ProvisionFromXmlDocumentResults(py::wrapper::Windows::Networking::NetworkOperators::ProvisionFromXmlDocumentResults* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProvisionFromXmlDocumentResults_get_AllElementsProvisioned(py::wrapper::Windows::Networking::NetworkOperators::ProvisionFromXmlDocumentResults* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ProvisionFromXmlDocumentResults", L"AllElementsProvisioned"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllElementsProvisioned());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProvisionFromXmlDocumentResults_get_ProvisionResultsXml(py::wrapper::Windows::Networking::NetworkOperators::ProvisionFromXmlDocumentResults* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ProvisionFromXmlDocumentResults", L"ProvisionResultsXml"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProvisionResultsXml());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProvisionFromXmlDocumentResults(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ProvisionFromXmlDocumentResults>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProvisionFromXmlDocumentResults(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ProvisionFromXmlDocumentResults>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProvisionFromXmlDocumentResults[] = {
        { "_assign_array_", _assign_array_ProvisionFromXmlDocumentResults, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProvisionFromXmlDocumentResults), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProvisionFromXmlDocumentResults[] = {
        { "all_elements_provisioned", reinterpret_cast<getter>(ProvisionFromXmlDocumentResults_get_AllElementsProvisioned), nullptr, nullptr, nullptr },
        { "provision_results_xml", reinterpret_cast<getter>(ProvisionFromXmlDocumentResults_get_ProvisionResultsXml), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProvisionFromXmlDocumentResults[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProvisionFromXmlDocumentResults) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProvisionFromXmlDocumentResults) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProvisionFromXmlDocumentResults) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProvisionFromXmlDocumentResults) },
        { },
    };

    static PyType_Spec type_spec_ProvisionFromXmlDocumentResults =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ProvisionFromXmlDocumentResults",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ProvisionFromXmlDocumentResults),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProvisionFromXmlDocumentResults
    };

    // ----- ProvisionedProfile class --------------------
    static constexpr const char* const type_name_ProvisionedProfile = "ProvisionedProfile";

    static PyObject* _new_ProvisionedProfile(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ProvisionedProfile);
        return nullptr;
    }

    static void _dealloc_ProvisionedProfile(py::wrapper::Windows::Networking::NetworkOperators::ProvisionedProfile* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProvisionedProfile_UpdateCost(py::wrapper::Windows::Networking::NetworkOperators::ProvisionedProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ProvisionedProfile", L"UpdateCost", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkCostType>(args, 0);

                self->obj.UpdateCost(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProvisionedProfile_UpdateUsage(py::wrapper::Windows::Networking::NetworkOperators::ProvisionedProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ProvisionedProfile", L"UpdateUsage", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::NetworkOperators::ProfileUsage>(args, 0);

                self->obj.UpdateUsage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProvisionedProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ProvisionedProfile>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProvisionedProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ProvisionedProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProvisionedProfile[] = {
        { "update_cost", reinterpret_cast<PyCFunction>(ProvisionedProfile_UpdateCost), METH_VARARGS, nullptr },
        { "update_usage", reinterpret_cast<PyCFunction>(ProvisionedProfile_UpdateUsage), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ProvisionedProfile, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProvisionedProfile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProvisionedProfile[] = {
        { }
    };

    static PyType_Slot _type_slots_ProvisionedProfile[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProvisionedProfile) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProvisionedProfile) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProvisionedProfile) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProvisionedProfile) },
        { },
    };

    static PyType_Spec type_spec_ProvisionedProfile =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ProvisionedProfile",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ProvisionedProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProvisionedProfile
    };

    // ----- ProvisioningAgent class --------------------
    static constexpr const char* const type_name_ProvisioningAgent = "ProvisioningAgent";

    static PyObject* _new_ProvisioningAgent(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::NetworkOperators::ProvisioningAgent instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProvisioningAgent(py::wrapper::Windows::Networking::NetworkOperators::ProvisioningAgent* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProvisioningAgent_CreateFromNetworkAccountId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ProvisioningAgent", L"CreateFromNetworkAccountId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::ProvisioningAgent::CreateFromNetworkAccountId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProvisioningAgent_GetProvisionedProfile(py::wrapper::Windows::Networking::NetworkOperators::ProvisioningAgent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ProvisioningAgent", L"GetProvisionedProfile", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::NetworkOperators::ProfileMediaType>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetProvisionedProfile(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProvisioningAgent_ProvisionFromXmlDocumentAsync(py::wrapper::Windows::Networking::NetworkOperators::ProvisioningAgent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ProvisioningAgent", L"ProvisionFromXmlDocumentAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ProvisionFromXmlDocumentAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProvisioningAgent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ProvisioningAgent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProvisioningAgent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ProvisioningAgent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProvisioningAgent[] = {
        { "create_from_network_account_id", reinterpret_cast<PyCFunction>(ProvisioningAgent_CreateFromNetworkAccountId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_provisioned_profile", reinterpret_cast<PyCFunction>(ProvisioningAgent_GetProvisionedProfile), METH_VARARGS, nullptr },
        { "provision_from_xml_document_async", reinterpret_cast<PyCFunction>(ProvisioningAgent_ProvisionFromXmlDocumentAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ProvisioningAgent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProvisioningAgent), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProvisioningAgent[] = {
        { }
    };

    static PyType_Slot _type_slots_ProvisioningAgent[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProvisioningAgent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProvisioningAgent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProvisioningAgent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProvisioningAgent) },
        { },
    };

    static PyType_Spec type_spec_ProvisioningAgent =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ProvisioningAgent",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ProvisioningAgent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProvisioningAgent
    };

    // ----- TetheringEntitlementCheckTriggerDetails class --------------------
    static constexpr const char* const type_name_TetheringEntitlementCheckTriggerDetails = "TetheringEntitlementCheckTriggerDetails";

    static PyObject* _new_TetheringEntitlementCheckTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TetheringEntitlementCheckTriggerDetails);
        return nullptr;
    }

    static void _dealloc_TetheringEntitlementCheckTriggerDetails(py::wrapper::Windows::Networking::NetworkOperators::TetheringEntitlementCheckTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TetheringEntitlementCheckTriggerDetails_AllowTethering(py::wrapper::Windows::Networking::NetworkOperators::TetheringEntitlementCheckTriggerDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.TetheringEntitlementCheckTriggerDetails", L"AllowTethering", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.AllowTethering();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TetheringEntitlementCheckTriggerDetails_DenyTethering(py::wrapper::Windows::Networking::NetworkOperators::TetheringEntitlementCheckTriggerDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.TetheringEntitlementCheckTriggerDetails", L"DenyTethering", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.DenyTethering(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TetheringEntitlementCheckTriggerDetails_get_NetworkAccountId(py::wrapper::Windows::Networking::NetworkOperators::TetheringEntitlementCheckTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.TetheringEntitlementCheckTriggerDetails", L"NetworkAccountId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TetheringEntitlementCheckTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::TetheringEntitlementCheckTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TetheringEntitlementCheckTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::TetheringEntitlementCheckTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TetheringEntitlementCheckTriggerDetails[] = {
        { "allow_tethering", reinterpret_cast<PyCFunction>(TetheringEntitlementCheckTriggerDetails_AllowTethering), METH_VARARGS, nullptr },
        { "deny_tethering", reinterpret_cast<PyCFunction>(TetheringEntitlementCheckTriggerDetails_DenyTethering), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TetheringEntitlementCheckTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TetheringEntitlementCheckTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TetheringEntitlementCheckTriggerDetails[] = {
        { "network_account_id", reinterpret_cast<getter>(TetheringEntitlementCheckTriggerDetails_get_NetworkAccountId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TetheringEntitlementCheckTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TetheringEntitlementCheckTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TetheringEntitlementCheckTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TetheringEntitlementCheckTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TetheringEntitlementCheckTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_TetheringEntitlementCheckTriggerDetails =
    {
        "_winsdk_Windows_Networking_NetworkOperators.TetheringEntitlementCheckTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::TetheringEntitlementCheckTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TetheringEntitlementCheckTriggerDetails
    };

    // ----- UssdMessage class --------------------
    static constexpr const char* const type_name_UssdMessage = "UssdMessage";

    static PyObject* _new_UssdMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Networking::NetworkOperators::UssdMessage instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UssdMessage(py::wrapper::Windows::Networking::NetworkOperators::UssdMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UssdMessage_GetPayload(py::wrapper::Windows::Networking::NetworkOperators::UssdMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.UssdMessage", L"GetPayload", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetPayload());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UssdMessage_SetPayload(py::wrapper::Windows::Networking::NetworkOperators::UssdMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.UssdMessage", L"SetPayload", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                self->obj.SetPayload(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UssdMessage_get_PayloadAsText(py::wrapper::Windows::Networking::NetworkOperators::UssdMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.UssdMessage", L"PayloadAsText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PayloadAsText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UssdMessage_put_PayloadAsText(py::wrapper::Windows::Networking::NetworkOperators::UssdMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.UssdMessage", L"PayloadAsText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PayloadAsText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UssdMessage_get_DataCodingScheme(py::wrapper::Windows::Networking::NetworkOperators::UssdMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.UssdMessage", L"DataCodingScheme"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DataCodingScheme());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UssdMessage_put_DataCodingScheme(py::wrapper::Windows::Networking::NetworkOperators::UssdMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.UssdMessage", L"DataCodingScheme"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.DataCodingScheme(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_UssdMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::UssdMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UssdMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::UssdMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UssdMessage[] = {
        { "get_payload", reinterpret_cast<PyCFunction>(UssdMessage_GetPayload), METH_VARARGS, nullptr },
        { "set_payload", reinterpret_cast<PyCFunction>(UssdMessage_SetPayload), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_UssdMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UssdMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UssdMessage[] = {
        { "payload_as_text", reinterpret_cast<getter>(UssdMessage_get_PayloadAsText), reinterpret_cast<setter>(UssdMessage_put_PayloadAsText), nullptr, nullptr },
        { "data_coding_scheme", reinterpret_cast<getter>(UssdMessage_get_DataCodingScheme), reinterpret_cast<setter>(UssdMessage_put_DataCodingScheme), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UssdMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UssdMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UssdMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UssdMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UssdMessage) },
        { },
    };

    static PyType_Spec type_spec_UssdMessage =
    {
        "_winsdk_Windows_Networking_NetworkOperators.UssdMessage",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::UssdMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UssdMessage
    };

    // ----- UssdReply class --------------------
    static constexpr const char* const type_name_UssdReply = "UssdReply";

    static PyObject* _new_UssdReply(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UssdReply);
        return nullptr;
    }

    static void _dealloc_UssdReply(py::wrapper::Windows::Networking::NetworkOperators::UssdReply* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UssdReply_get_Message(py::wrapper::Windows::Networking::NetworkOperators::UssdReply* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.UssdReply", L"Message"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UssdReply_get_ResultCode(py::wrapper::Windows::Networking::NetworkOperators::UssdReply* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.UssdReply", L"ResultCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ResultCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UssdReply(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::UssdReply>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UssdReply(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::UssdReply>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UssdReply[] = {
        { "_assign_array_", _assign_array_UssdReply, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UssdReply), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UssdReply[] = {
        { "message", reinterpret_cast<getter>(UssdReply_get_Message), nullptr, nullptr, nullptr },
        { "result_code", reinterpret_cast<getter>(UssdReply_get_ResultCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UssdReply[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UssdReply) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UssdReply) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UssdReply) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UssdReply) },
        { },
    };

    static PyType_Spec type_spec_UssdReply =
    {
        "_winsdk_Windows_Networking_NetworkOperators.UssdReply",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::UssdReply),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UssdReply
    };

    // ----- UssdSession class --------------------
    static constexpr const char* const type_name_UssdSession = "UssdSession";

    static PyObject* _new_UssdSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UssdSession);
        return nullptr;
    }

    static void _dealloc_UssdSession(py::wrapper::Windows::Networking::NetworkOperators::UssdSession* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UssdSession_Close(py::wrapper::Windows::Networking::NetworkOperators::UssdSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.UssdSession", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UssdSession_CreateFromNetworkAccountId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.UssdSession", L"CreateFromNetworkAccountId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::UssdSession::CreateFromNetworkAccountId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UssdSession_CreateFromNetworkInterfaceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.UssdSession", L"CreateFromNetworkInterfaceId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::UssdSession::CreateFromNetworkInterfaceId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UssdSession_SendMessageAndGetReplyAsync(py::wrapper::Windows::Networking::NetworkOperators::UssdSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.UssdSession", L"SendMessageAndGetReplyAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::NetworkOperators::UssdMessage>(args, 0);

                return py::convert(self->obj.SendMessageAndGetReplyAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_UssdSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::UssdSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UssdSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::UssdSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UssdSession[] = {
        { "close", reinterpret_cast<PyCFunction>(UssdSession_Close), METH_VARARGS, nullptr },
        { "create_from_network_account_id", reinterpret_cast<PyCFunction>(UssdSession_CreateFromNetworkAccountId), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_network_interface_id", reinterpret_cast<PyCFunction>(UssdSession_CreateFromNetworkInterfaceId), METH_VARARGS | METH_STATIC, nullptr },
        { "send_message_and_get_reply_async", reinterpret_cast<PyCFunction>(UssdSession_SendMessageAndGetReplyAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_UssdSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UssdSession), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UssdSession[] = {
        { }
    };

    static PyType_Slot _type_slots_UssdSession[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UssdSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UssdSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UssdSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UssdSession) },
        { },
    };

    static PyType_Spec type_spec_UssdSession =
    {
        "_winsdk_Windows_Networking_NetworkOperators.UssdSession",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::UssdSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UssdSession
    };

    // ----- ESimProfileInstallProgress struct --------------------
    static constexpr const char* const type_name_ESimProfileInstallProgress = "ESimProfileInstallProgress";

    PyObject* _new_ESimProfileInstallProgress(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        int32_t _TotalSizeInBytes{};
        int32_t _InstalledSizeInBytes{};

        static const char* kwlist[] = {"total_size_in_bytes", "installed_size_in_bytes", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ii", const_cast<char**>(kwlist), &_TotalSizeInBytes, &_InstalledSizeInBytes))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress return_value{ _TotalSizeInBytes, _InstalledSizeInBytes };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_ESimProfileInstallProgress(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileInstallProgress* self) noexcept
    {
    }

    static PyObject* ESimProfileInstallProgress_get_TotalSizeInBytes(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileInstallProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalSizeInBytes);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ESimProfileInstallProgress_set_TotalSizeInBytes(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileInstallProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.TotalSizeInBytes = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ESimProfileInstallProgress_get_InstalledSizeInBytes(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileInstallProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstalledSizeInBytes);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ESimProfileInstallProgress_set_InstalledSizeInBytes(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileInstallProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.InstalledSizeInBytes = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_ESimProfileInstallProgress[] = {
        { "total_size_in_bytes", reinterpret_cast<getter>(ESimProfileInstallProgress_get_TotalSizeInBytes), reinterpret_cast<setter>(ESimProfileInstallProgress_set_TotalSizeInBytes), nullptr, nullptr },
        { "installed_size_in_bytes", reinterpret_cast<getter>(ESimProfileInstallProgress_get_InstalledSizeInBytes), reinterpret_cast<setter>(ESimProfileInstallProgress_set_InstalledSizeInBytes), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimProfileInstallProgress[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimProfileInstallProgress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimProfileInstallProgress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimProfileInstallProgress) },
        { },
    };

    static PyType_Spec type_spec_ESimProfileInstallProgress =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimProfileInstallProgress",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileInstallProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimProfileInstallProgress
    };

    // ----- ProfileUsage struct --------------------
    static constexpr const char* const type_name_ProfileUsage = "ProfileUsage";

    PyObject* _new_ProfileUsage(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Networking::NetworkOperators::ProfileUsage return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        uint32_t _UsageInMegabytes{};
        PyObject* _LastSyncTime{};

        static const char* kwlist[] = {"usage_in_megabytes", "last_sync_time", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "IO", const_cast<char**>(kwlist), &_UsageInMegabytes, &_LastSyncTime))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Networking::NetworkOperators::ProfileUsage return_value{ _UsageInMegabytes, py::converter<winrt::Windows::Foundation::DateTime>::convert_to(_LastSyncTime) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_ProfileUsage(py::wrapper::Windows::Networking::NetworkOperators::ProfileUsage* self) noexcept
    {
    }

    static PyObject* ProfileUsage_get_UsageInMegabytes(py::wrapper::Windows::Networking::NetworkOperators::ProfileUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UsageInMegabytes);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProfileUsage_set_UsageInMegabytes(py::wrapper::Windows::Networking::NetworkOperators::ProfileUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.UsageInMegabytes = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProfileUsage_get_LastSyncTime(py::wrapper::Windows::Networking::NetworkOperators::ProfileUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastSyncTime);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProfileUsage_set_LastSyncTime(py::wrapper::Windows::Networking::NetworkOperators::ProfileUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.LastSyncTime = py::converter<winrt::Windows::Foundation::DateTime>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_ProfileUsage[] = {
        { "usage_in_megabytes", reinterpret_cast<getter>(ProfileUsage_get_UsageInMegabytes), reinterpret_cast<setter>(ProfileUsage_set_UsageInMegabytes), nullptr, nullptr },
        { "last_sync_time", reinterpret_cast<getter>(ProfileUsage_get_LastSyncTime), reinterpret_cast<setter>(ProfileUsage_set_LastSyncTime), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProfileUsage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProfileUsage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProfileUsage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProfileUsage) },
        { },
    };

    static PyType_Spec type_spec_ProfileUsage =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ProfileUsage",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ProfileUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProfileUsage
    };

    // ----- Windows.Networking.NetworkOperators Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Networking::NetworkOperators");

    static PyMethodDef module_methods[] = {
        {"_register_DataClasses", register_DataClasses, METH_O, "registers type"},
        {"_register_ESimAuthenticationPreference", register_ESimAuthenticationPreference, METH_O, "registers type"},
        {"_register_ESimDiscoverResultKind", register_ESimDiscoverResultKind, METH_O, "registers type"},
        {"_register_ESimOperationStatus", register_ESimOperationStatus, METH_O, "registers type"},
        {"_register_ESimProfileClass", register_ESimProfileClass, METH_O, "registers type"},
        {"_register_ESimProfileMetadataState", register_ESimProfileMetadataState, METH_O, "registers type"},
        {"_register_ESimProfileState", register_ESimProfileState, METH_O, "registers type"},
        {"_register_ESimState", register_ESimState, METH_O, "registers type"},
        {"_register_ESimWatcherStatus", register_ESimWatcherStatus, METH_O, "registers type"},
        {"_register_HotspotAuthenticationResponseCode", register_HotspotAuthenticationResponseCode, METH_O, "registers type"},
        {"_register_MobileBroadbandAccountWatcherStatus", register_MobileBroadbandAccountWatcherStatus, METH_O, "registers type"},
        {"_register_MobileBroadbandDeviceType", register_MobileBroadbandDeviceType, METH_O, "registers type"},
        {"_register_MobileBroadbandModemStatus", register_MobileBroadbandModemStatus, METH_O, "registers type"},
        {"_register_MobileBroadbandPinFormat", register_MobileBroadbandPinFormat, METH_O, "registers type"},
        {"_register_MobileBroadbandPinLockState", register_MobileBroadbandPinLockState, METH_O, "registers type"},
        {"_register_MobileBroadbandPinType", register_MobileBroadbandPinType, METH_O, "registers type"},
        {"_register_MobileBroadbandRadioState", register_MobileBroadbandRadioState, METH_O, "registers type"},
        {"_register_MobileBroadbandSlotState", register_MobileBroadbandSlotState, METH_O, "registers type"},
        {"_register_MobileBroadbandUiccAppOperationStatus", register_MobileBroadbandUiccAppOperationStatus, METH_O, "registers type"},
        {"_register_NetworkDeviceStatus", register_NetworkDeviceStatus, METH_O, "registers type"},
        {"_register_NetworkOperatorDataUsageNotificationKind", register_NetworkOperatorDataUsageNotificationKind, METH_O, "registers type"},
        {"_register_NetworkOperatorEventMessageType", register_NetworkOperatorEventMessageType, METH_O, "registers type"},
        {"_register_NetworkRegistrationState", register_NetworkRegistrationState, METH_O, "registers type"},
        {"_register_ProfileMediaType", register_ProfileMediaType, METH_O, "registers type"},
        {"_register_TetheringCapability", register_TetheringCapability, METH_O, "registers type"},
        {"_register_TetheringOperationStatus", register_TetheringOperationStatus, METH_O, "registers type"},
        {"_register_TetheringOperationalState", register_TetheringOperationalState, METH_O, "registers type"},
        {"_register_TetheringWiFiBand", register_TetheringWiFiBand, METH_O, "registers type"},
        {"_register_UiccAccessCondition", register_UiccAccessCondition, METH_O, "registers type"},
        {"_register_UiccAppKind", register_UiccAppKind, METH_O, "registers type"},
        {"_register_UiccAppRecordKind", register_UiccAppRecordKind, METH_O, "registers type"},
        {"_register_UssdResultCode", register_UssdResultCode, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_DataClasses);
        Py_VISIT(state->type_ESimAuthenticationPreference);
        Py_VISIT(state->type_ESimDiscoverResultKind);
        Py_VISIT(state->type_ESimOperationStatus);
        Py_VISIT(state->type_ESimProfileClass);
        Py_VISIT(state->type_ESimProfileMetadataState);
        Py_VISIT(state->type_ESimProfileState);
        Py_VISIT(state->type_ESimState);
        Py_VISIT(state->type_ESimWatcherStatus);
        Py_VISIT(state->type_HotspotAuthenticationResponseCode);
        Py_VISIT(state->type_MobileBroadbandAccountWatcherStatus);
        Py_VISIT(state->type_MobileBroadbandDeviceType);
        Py_VISIT(state->type_MobileBroadbandModemStatus);
        Py_VISIT(state->type_MobileBroadbandPinFormat);
        Py_VISIT(state->type_MobileBroadbandPinLockState);
        Py_VISIT(state->type_MobileBroadbandPinType);
        Py_VISIT(state->type_MobileBroadbandRadioState);
        Py_VISIT(state->type_MobileBroadbandSlotState);
        Py_VISIT(state->type_MobileBroadbandUiccAppOperationStatus);
        Py_VISIT(state->type_NetworkDeviceStatus);
        Py_VISIT(state->type_NetworkOperatorDataUsageNotificationKind);
        Py_VISIT(state->type_NetworkOperatorEventMessageType);
        Py_VISIT(state->type_NetworkRegistrationState);
        Py_VISIT(state->type_ProfileMediaType);
        Py_VISIT(state->type_TetheringCapability);
        Py_VISIT(state->type_TetheringOperationStatus);
        Py_VISIT(state->type_TetheringOperationalState);
        Py_VISIT(state->type_TetheringWiFiBand);
        Py_VISIT(state->type_UiccAccessCondition);
        Py_VISIT(state->type_UiccAppKind);
        Py_VISIT(state->type_UiccAppRecordKind);
        Py_VISIT(state->type_UssdResultCode);
        Py_VISIT(state->type_ESim);
        Py_VISIT(state->type_ESimAddedEventArgs);
        Py_VISIT(state->type_ESimDiscoverEvent);
        Py_VISIT(state->type_ESimDiscoverResult);
        Py_VISIT(state->type_ESimDownloadProfileMetadataResult);
        Py_VISIT(state->type_ESimManager);
        Py_VISIT(state->type_ESimOperationResult);
        Py_VISIT(state->type_ESimPolicy);
        Py_VISIT(state->type_ESimProfile);
        Py_VISIT(state->type_ESimProfileMetadata);
        Py_VISIT(state->type_ESimProfilePolicy);
        Py_VISIT(state->type_ESimRemovedEventArgs);
        Py_VISIT(state->type_ESimServiceInfo);
        Py_VISIT(state->type_ESimUpdatedEventArgs);
        Py_VISIT(state->type_ESimWatcher);
        Py_VISIT(state->type_FdnAccessManager);
        Py_VISIT(state->type_HotspotAuthenticationContext);
        Py_VISIT(state->type_HotspotAuthenticationEventDetails);
        Py_VISIT(state->type_HotspotCredentialsAuthenticationResult);
        Py_VISIT(state->type_KnownCSimFilePaths);
        Py_VISIT(state->type_KnownRuimFilePaths);
        Py_VISIT(state->type_KnownSimFilePaths);
        Py_VISIT(state->type_KnownUSimFilePaths);
        Py_VISIT(state->type_MobileBroadbandAccount);
        Py_VISIT(state->type_MobileBroadbandAccountEventArgs);
        Py_VISIT(state->type_MobileBroadbandAccountUpdatedEventArgs);
        Py_VISIT(state->type_MobileBroadbandAccountWatcher);
        Py_VISIT(state->type_MobileBroadbandAntennaSar);
        Py_VISIT(state->type_MobileBroadbandCellCdma);
        Py_VISIT(state->type_MobileBroadbandCellGsm);
        Py_VISIT(state->type_MobileBroadbandCellLte);
        Py_VISIT(state->type_MobileBroadbandCellNR);
        Py_VISIT(state->type_MobileBroadbandCellTdscdma);
        Py_VISIT(state->type_MobileBroadbandCellUmts);
        Py_VISIT(state->type_MobileBroadbandCellsInfo);
        Py_VISIT(state->type_MobileBroadbandCurrentSlotIndexChangedEventArgs);
        Py_VISIT(state->type_MobileBroadbandDeviceInformation);
        Py_VISIT(state->type_MobileBroadbandDeviceService);
        Py_VISIT(state->type_MobileBroadbandDeviceServiceCommandResult);
        Py_VISIT(state->type_MobileBroadbandDeviceServiceCommandSession);
        Py_VISIT(state->type_MobileBroadbandDeviceServiceDataReceivedEventArgs);
        Py_VISIT(state->type_MobileBroadbandDeviceServiceDataSession);
        Py_VISIT(state->type_MobileBroadbandDeviceServiceInformation);
        Py_VISIT(state->type_MobileBroadbandDeviceServiceTriggerDetails);
        Py_VISIT(state->type_MobileBroadbandModem);
        Py_VISIT(state->type_MobileBroadbandModemConfiguration);
        Py_VISIT(state->type_MobileBroadbandModemIsolation);
        Py_VISIT(state->type_MobileBroadbandNetwork);
        Py_VISIT(state->type_MobileBroadbandNetworkRegistrationStateChange);
        Py_VISIT(state->type_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails);
        Py_VISIT(state->type_MobileBroadbandPco);
        Py_VISIT(state->type_MobileBroadbandPcoDataChangeTriggerDetails);
        Py_VISIT(state->type_MobileBroadbandPin);
        Py_VISIT(state->type_MobileBroadbandPinLockStateChange);
        Py_VISIT(state->type_MobileBroadbandPinLockStateChangeTriggerDetails);
        Py_VISIT(state->type_MobileBroadbandPinManager);
        Py_VISIT(state->type_MobileBroadbandPinOperationResult);
        Py_VISIT(state->type_MobileBroadbandRadioStateChange);
        Py_VISIT(state->type_MobileBroadbandRadioStateChangeTriggerDetails);
        Py_VISIT(state->type_MobileBroadbandSarManager);
        Py_VISIT(state->type_MobileBroadbandSlotInfo);
        Py_VISIT(state->type_MobileBroadbandSlotInfoChangedEventArgs);
        Py_VISIT(state->type_MobileBroadbandSlotManager);
        Py_VISIT(state->type_MobileBroadbandTransmissionStateChangedEventArgs);
        Py_VISIT(state->type_MobileBroadbandUicc);
        Py_VISIT(state->type_MobileBroadbandUiccApp);
        Py_VISIT(state->type_MobileBroadbandUiccAppReadRecordResult);
        Py_VISIT(state->type_MobileBroadbandUiccAppRecordDetailsResult);
        Py_VISIT(state->type_MobileBroadbandUiccAppsResult);
        Py_VISIT(state->type_NetworkOperatorDataUsageTriggerDetails);
        Py_VISIT(state->type_NetworkOperatorNotificationEventDetails);
        Py_VISIT(state->type_NetworkOperatorTetheringAccessPointConfiguration);
        Py_VISIT(state->type_NetworkOperatorTetheringClient);
        Py_VISIT(state->type_NetworkOperatorTetheringManager);
        Py_VISIT(state->type_NetworkOperatorTetheringOperationResult);
        Py_VISIT(state->type_ProvisionFromXmlDocumentResults);
        Py_VISIT(state->type_ProvisionedProfile);
        Py_VISIT(state->type_ProvisioningAgent);
        Py_VISIT(state->type_TetheringEntitlementCheckTriggerDetails);
        Py_VISIT(state->type_UssdMessage);
        Py_VISIT(state->type_UssdReply);
        Py_VISIT(state->type_UssdSession);
        Py_VISIT(state->type_ESimProfileInstallProgress);
        Py_VISIT(state->type_ProfileUsage);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_DataClasses);
        Py_CLEAR(state->type_ESimAuthenticationPreference);
        Py_CLEAR(state->type_ESimDiscoverResultKind);
        Py_CLEAR(state->type_ESimOperationStatus);
        Py_CLEAR(state->type_ESimProfileClass);
        Py_CLEAR(state->type_ESimProfileMetadataState);
        Py_CLEAR(state->type_ESimProfileState);
        Py_CLEAR(state->type_ESimState);
        Py_CLEAR(state->type_ESimWatcherStatus);
        Py_CLEAR(state->type_HotspotAuthenticationResponseCode);
        Py_CLEAR(state->type_MobileBroadbandAccountWatcherStatus);
        Py_CLEAR(state->type_MobileBroadbandDeviceType);
        Py_CLEAR(state->type_MobileBroadbandModemStatus);
        Py_CLEAR(state->type_MobileBroadbandPinFormat);
        Py_CLEAR(state->type_MobileBroadbandPinLockState);
        Py_CLEAR(state->type_MobileBroadbandPinType);
        Py_CLEAR(state->type_MobileBroadbandRadioState);
        Py_CLEAR(state->type_MobileBroadbandSlotState);
        Py_CLEAR(state->type_MobileBroadbandUiccAppOperationStatus);
        Py_CLEAR(state->type_NetworkDeviceStatus);
        Py_CLEAR(state->type_NetworkOperatorDataUsageNotificationKind);
        Py_CLEAR(state->type_NetworkOperatorEventMessageType);
        Py_CLEAR(state->type_NetworkRegistrationState);
        Py_CLEAR(state->type_ProfileMediaType);
        Py_CLEAR(state->type_TetheringCapability);
        Py_CLEAR(state->type_TetheringOperationStatus);
        Py_CLEAR(state->type_TetheringOperationalState);
        Py_CLEAR(state->type_TetheringWiFiBand);
        Py_CLEAR(state->type_UiccAccessCondition);
        Py_CLEAR(state->type_UiccAppKind);
        Py_CLEAR(state->type_UiccAppRecordKind);
        Py_CLEAR(state->type_UssdResultCode);
        Py_CLEAR(state->type_ESim);
        Py_CLEAR(state->type_ESimAddedEventArgs);
        Py_CLEAR(state->type_ESimDiscoverEvent);
        Py_CLEAR(state->type_ESimDiscoverResult);
        Py_CLEAR(state->type_ESimDownloadProfileMetadataResult);
        Py_CLEAR(state->type_ESimManager);
        Py_CLEAR(state->type_ESimOperationResult);
        Py_CLEAR(state->type_ESimPolicy);
        Py_CLEAR(state->type_ESimProfile);
        Py_CLEAR(state->type_ESimProfileMetadata);
        Py_CLEAR(state->type_ESimProfilePolicy);
        Py_CLEAR(state->type_ESimRemovedEventArgs);
        Py_CLEAR(state->type_ESimServiceInfo);
        Py_CLEAR(state->type_ESimUpdatedEventArgs);
        Py_CLEAR(state->type_ESimWatcher);
        Py_CLEAR(state->type_FdnAccessManager);
        Py_CLEAR(state->type_HotspotAuthenticationContext);
        Py_CLEAR(state->type_HotspotAuthenticationEventDetails);
        Py_CLEAR(state->type_HotspotCredentialsAuthenticationResult);
        Py_CLEAR(state->type_KnownCSimFilePaths);
        Py_CLEAR(state->type_KnownRuimFilePaths);
        Py_CLEAR(state->type_KnownSimFilePaths);
        Py_CLEAR(state->type_KnownUSimFilePaths);
        Py_CLEAR(state->type_MobileBroadbandAccount);
        Py_CLEAR(state->type_MobileBroadbandAccountEventArgs);
        Py_CLEAR(state->type_MobileBroadbandAccountUpdatedEventArgs);
        Py_CLEAR(state->type_MobileBroadbandAccountWatcher);
        Py_CLEAR(state->type_MobileBroadbandAntennaSar);
        Py_CLEAR(state->type_MobileBroadbandCellCdma);
        Py_CLEAR(state->type_MobileBroadbandCellGsm);
        Py_CLEAR(state->type_MobileBroadbandCellLte);
        Py_CLEAR(state->type_MobileBroadbandCellNR);
        Py_CLEAR(state->type_MobileBroadbandCellTdscdma);
        Py_CLEAR(state->type_MobileBroadbandCellUmts);
        Py_CLEAR(state->type_MobileBroadbandCellsInfo);
        Py_CLEAR(state->type_MobileBroadbandCurrentSlotIndexChangedEventArgs);
        Py_CLEAR(state->type_MobileBroadbandDeviceInformation);
        Py_CLEAR(state->type_MobileBroadbandDeviceService);
        Py_CLEAR(state->type_MobileBroadbandDeviceServiceCommandResult);
        Py_CLEAR(state->type_MobileBroadbandDeviceServiceCommandSession);
        Py_CLEAR(state->type_MobileBroadbandDeviceServiceDataReceivedEventArgs);
        Py_CLEAR(state->type_MobileBroadbandDeviceServiceDataSession);
        Py_CLEAR(state->type_MobileBroadbandDeviceServiceInformation);
        Py_CLEAR(state->type_MobileBroadbandDeviceServiceTriggerDetails);
        Py_CLEAR(state->type_MobileBroadbandModem);
        Py_CLEAR(state->type_MobileBroadbandModemConfiguration);
        Py_CLEAR(state->type_MobileBroadbandModemIsolation);
        Py_CLEAR(state->type_MobileBroadbandNetwork);
        Py_CLEAR(state->type_MobileBroadbandNetworkRegistrationStateChange);
        Py_CLEAR(state->type_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails);
        Py_CLEAR(state->type_MobileBroadbandPco);
        Py_CLEAR(state->type_MobileBroadbandPcoDataChangeTriggerDetails);
        Py_CLEAR(state->type_MobileBroadbandPin);
        Py_CLEAR(state->type_MobileBroadbandPinLockStateChange);
        Py_CLEAR(state->type_MobileBroadbandPinLockStateChangeTriggerDetails);
        Py_CLEAR(state->type_MobileBroadbandPinManager);
        Py_CLEAR(state->type_MobileBroadbandPinOperationResult);
        Py_CLEAR(state->type_MobileBroadbandRadioStateChange);
        Py_CLEAR(state->type_MobileBroadbandRadioStateChangeTriggerDetails);
        Py_CLEAR(state->type_MobileBroadbandSarManager);
        Py_CLEAR(state->type_MobileBroadbandSlotInfo);
        Py_CLEAR(state->type_MobileBroadbandSlotInfoChangedEventArgs);
        Py_CLEAR(state->type_MobileBroadbandSlotManager);
        Py_CLEAR(state->type_MobileBroadbandTransmissionStateChangedEventArgs);
        Py_CLEAR(state->type_MobileBroadbandUicc);
        Py_CLEAR(state->type_MobileBroadbandUiccApp);
        Py_CLEAR(state->type_MobileBroadbandUiccAppReadRecordResult);
        Py_CLEAR(state->type_MobileBroadbandUiccAppRecordDetailsResult);
        Py_CLEAR(state->type_MobileBroadbandUiccAppsResult);
        Py_CLEAR(state->type_NetworkOperatorDataUsageTriggerDetails);
        Py_CLEAR(state->type_NetworkOperatorNotificationEventDetails);
        Py_CLEAR(state->type_NetworkOperatorTetheringAccessPointConfiguration);
        Py_CLEAR(state->type_NetworkOperatorTetheringClient);
        Py_CLEAR(state->type_NetworkOperatorTetheringManager);
        Py_CLEAR(state->type_NetworkOperatorTetheringOperationResult);
        Py_CLEAR(state->type_ProvisionFromXmlDocumentResults);
        Py_CLEAR(state->type_ProvisionedProfile);
        Py_CLEAR(state->type_ProvisioningAgent);
        Py_CLEAR(state->type_TetheringEntitlementCheckTriggerDetails);
        Py_CLEAR(state->type_UssdMessage);
        Py_CLEAR(state->type_UssdReply);
        Py_CLEAR(state->type_UssdSession);
        Py_CLEAR(state->type_ESimProfileInstallProgress);
        Py_CLEAR(state->type_ProfileUsage);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Networking_NetworkOperators",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Networking::NetworkOperators

PyMODINIT_FUNC PyInit__winsdk_Windows_Networking_NetworkOperators(void) noexcept
{
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_ESim = py::register_python_type(module.get(), type_name_ESim, &type_spec_ESim, bases.get(), nullptr);
    if (!state->type_ESim)
    {
        return nullptr;
    }

    state->type_ESimAddedEventArgs = py::register_python_type(module.get(), type_name_ESimAddedEventArgs, &type_spec_ESimAddedEventArgs, bases.get(), nullptr);
    if (!state->type_ESimAddedEventArgs)
    {
        return nullptr;
    }

    state->type_ESimDiscoverEvent = py::register_python_type(module.get(), type_name_ESimDiscoverEvent, &type_spec_ESimDiscoverEvent, bases.get(), nullptr);
    if (!state->type_ESimDiscoverEvent)
    {
        return nullptr;
    }

    state->type_ESimDiscoverResult = py::register_python_type(module.get(), type_name_ESimDiscoverResult, &type_spec_ESimDiscoverResult, bases.get(), nullptr);
    if (!state->type_ESimDiscoverResult)
    {
        return nullptr;
    }

    state->type_ESimDownloadProfileMetadataResult = py::register_python_type(module.get(), type_name_ESimDownloadProfileMetadataResult, &type_spec_ESimDownloadProfileMetadataResult, bases.get(), nullptr);
    if (!state->type_ESimDownloadProfileMetadataResult)
    {
        return nullptr;
    }

    py::pyobj_handle type_ESimManager_Meta{PyType_FromSpec(&type_spec_ESimManager_Meta)};
    if (!type_ESimManager_Meta)
    {
        return nullptr;
    }

    state->type_ESimManager = py::register_python_type(module.get(), type_name_ESimManager, &type_spec_ESimManager, nullptr, reinterpret_cast<PyTypeObject*>(type_ESimManager_Meta.get()));
    if (!state->type_ESimManager)
    {
        return nullptr;
    }

    state->type_ESimOperationResult = py::register_python_type(module.get(), type_name_ESimOperationResult, &type_spec_ESimOperationResult, bases.get(), nullptr);
    if (!state->type_ESimOperationResult)
    {
        return nullptr;
    }

    state->type_ESimPolicy = py::register_python_type(module.get(), type_name_ESimPolicy, &type_spec_ESimPolicy, bases.get(), nullptr);
    if (!state->type_ESimPolicy)
    {
        return nullptr;
    }

    state->type_ESimProfile = py::register_python_type(module.get(), type_name_ESimProfile, &type_spec_ESimProfile, bases.get(), nullptr);
    if (!state->type_ESimProfile)
    {
        return nullptr;
    }

    state->type_ESimProfileMetadata = py::register_python_type(module.get(), type_name_ESimProfileMetadata, &type_spec_ESimProfileMetadata, bases.get(), nullptr);
    if (!state->type_ESimProfileMetadata)
    {
        return nullptr;
    }

    state->type_ESimProfilePolicy = py::register_python_type(module.get(), type_name_ESimProfilePolicy, &type_spec_ESimProfilePolicy, bases.get(), nullptr);
    if (!state->type_ESimProfilePolicy)
    {
        return nullptr;
    }

    state->type_ESimRemovedEventArgs = py::register_python_type(module.get(), type_name_ESimRemovedEventArgs, &type_spec_ESimRemovedEventArgs, bases.get(), nullptr);
    if (!state->type_ESimRemovedEventArgs)
    {
        return nullptr;
    }

    state->type_ESimServiceInfo = py::register_python_type(module.get(), type_name_ESimServiceInfo, &type_spec_ESimServiceInfo, bases.get(), nullptr);
    if (!state->type_ESimServiceInfo)
    {
        return nullptr;
    }

    state->type_ESimUpdatedEventArgs = py::register_python_type(module.get(), type_name_ESimUpdatedEventArgs, &type_spec_ESimUpdatedEventArgs, bases.get(), nullptr);
    if (!state->type_ESimUpdatedEventArgs)
    {
        return nullptr;
    }

    state->type_ESimWatcher = py::register_python_type(module.get(), type_name_ESimWatcher, &type_spec_ESimWatcher, bases.get(), nullptr);
    if (!state->type_ESimWatcher)
    {
        return nullptr;
    }

    state->type_FdnAccessManager = py::register_python_type(module.get(), type_name_FdnAccessManager, &type_spec_FdnAccessManager, nullptr, nullptr);
    if (!state->type_FdnAccessManager)
    {
        return nullptr;
    }

    state->type_HotspotAuthenticationContext = py::register_python_type(module.get(), type_name_HotspotAuthenticationContext, &type_spec_HotspotAuthenticationContext, bases.get(), nullptr);
    if (!state->type_HotspotAuthenticationContext)
    {
        return nullptr;
    }

    state->type_HotspotAuthenticationEventDetails = py::register_python_type(module.get(), type_name_HotspotAuthenticationEventDetails, &type_spec_HotspotAuthenticationEventDetails, bases.get(), nullptr);
    if (!state->type_HotspotAuthenticationEventDetails)
    {
        return nullptr;
    }

    state->type_HotspotCredentialsAuthenticationResult = py::register_python_type(module.get(), type_name_HotspotCredentialsAuthenticationResult, &type_spec_HotspotCredentialsAuthenticationResult, bases.get(), nullptr);
    if (!state->type_HotspotCredentialsAuthenticationResult)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownCSimFilePaths_Meta{PyType_FromSpec(&type_spec_KnownCSimFilePaths_Meta)};
    if (!type_KnownCSimFilePaths_Meta)
    {
        return nullptr;
    }

    state->type_KnownCSimFilePaths = py::register_python_type(module.get(), type_name_KnownCSimFilePaths, &type_spec_KnownCSimFilePaths, nullptr, reinterpret_cast<PyTypeObject*>(type_KnownCSimFilePaths_Meta.get()));
    if (!state->type_KnownCSimFilePaths)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownRuimFilePaths_Meta{PyType_FromSpec(&type_spec_KnownRuimFilePaths_Meta)};
    if (!type_KnownRuimFilePaths_Meta)
    {
        return nullptr;
    }

    state->type_KnownRuimFilePaths = py::register_python_type(module.get(), type_name_KnownRuimFilePaths, &type_spec_KnownRuimFilePaths, nullptr, reinterpret_cast<PyTypeObject*>(type_KnownRuimFilePaths_Meta.get()));
    if (!state->type_KnownRuimFilePaths)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownSimFilePaths_Meta{PyType_FromSpec(&type_spec_KnownSimFilePaths_Meta)};
    if (!type_KnownSimFilePaths_Meta)
    {
        return nullptr;
    }

    state->type_KnownSimFilePaths = py::register_python_type(module.get(), type_name_KnownSimFilePaths, &type_spec_KnownSimFilePaths, nullptr, reinterpret_cast<PyTypeObject*>(type_KnownSimFilePaths_Meta.get()));
    if (!state->type_KnownSimFilePaths)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownUSimFilePaths_Meta{PyType_FromSpec(&type_spec_KnownUSimFilePaths_Meta)};
    if (!type_KnownUSimFilePaths_Meta)
    {
        return nullptr;
    }

    state->type_KnownUSimFilePaths = py::register_python_type(module.get(), type_name_KnownUSimFilePaths, &type_spec_KnownUSimFilePaths, nullptr, reinterpret_cast<PyTypeObject*>(type_KnownUSimFilePaths_Meta.get()));
    if (!state->type_KnownUSimFilePaths)
    {
        return nullptr;
    }

    py::pyobj_handle type_MobileBroadbandAccount_Meta{PyType_FromSpec(&type_spec_MobileBroadbandAccount_Meta)};
    if (!type_MobileBroadbandAccount_Meta)
    {
        return nullptr;
    }

    state->type_MobileBroadbandAccount = py::register_python_type(module.get(), type_name_MobileBroadbandAccount, &type_spec_MobileBroadbandAccount, bases.get(), reinterpret_cast<PyTypeObject*>(type_MobileBroadbandAccount_Meta.get()));
    if (!state->type_MobileBroadbandAccount)
    {
        return nullptr;
    }

    state->type_MobileBroadbandAccountEventArgs = py::register_python_type(module.get(), type_name_MobileBroadbandAccountEventArgs, &type_spec_MobileBroadbandAccountEventArgs, bases.get(), nullptr);
    if (!state->type_MobileBroadbandAccountEventArgs)
    {
        return nullptr;
    }

    state->type_MobileBroadbandAccountUpdatedEventArgs = py::register_python_type(module.get(), type_name_MobileBroadbandAccountUpdatedEventArgs, &type_spec_MobileBroadbandAccountUpdatedEventArgs, bases.get(), nullptr);
    if (!state->type_MobileBroadbandAccountUpdatedEventArgs)
    {
        return nullptr;
    }

    state->type_MobileBroadbandAccountWatcher = py::register_python_type(module.get(), type_name_MobileBroadbandAccountWatcher, &type_spec_MobileBroadbandAccountWatcher, bases.get(), nullptr);
    if (!state->type_MobileBroadbandAccountWatcher)
    {
        return nullptr;
    }

    state->type_MobileBroadbandAntennaSar = py::register_python_type(module.get(), type_name_MobileBroadbandAntennaSar, &type_spec_MobileBroadbandAntennaSar, bases.get(), nullptr);
    if (!state->type_MobileBroadbandAntennaSar)
    {
        return nullptr;
    }

    state->type_MobileBroadbandCellCdma = py::register_python_type(module.get(), type_name_MobileBroadbandCellCdma, &type_spec_MobileBroadbandCellCdma, bases.get(), nullptr);
    if (!state->type_MobileBroadbandCellCdma)
    {
        return nullptr;
    }

    state->type_MobileBroadbandCellGsm = py::register_python_type(module.get(), type_name_MobileBroadbandCellGsm, &type_spec_MobileBroadbandCellGsm, bases.get(), nullptr);
    if (!state->type_MobileBroadbandCellGsm)
    {
        return nullptr;
    }

    state->type_MobileBroadbandCellLte = py::register_python_type(module.get(), type_name_MobileBroadbandCellLte, &type_spec_MobileBroadbandCellLte, bases.get(), nullptr);
    if (!state->type_MobileBroadbandCellLte)
    {
        return nullptr;
    }

    state->type_MobileBroadbandCellNR = py::register_python_type(module.get(), type_name_MobileBroadbandCellNR, &type_spec_MobileBroadbandCellNR, bases.get(), nullptr);
    if (!state->type_MobileBroadbandCellNR)
    {
        return nullptr;
    }

    state->type_MobileBroadbandCellTdscdma = py::register_python_type(module.get(), type_name_MobileBroadbandCellTdscdma, &type_spec_MobileBroadbandCellTdscdma, bases.get(), nullptr);
    if (!state->type_MobileBroadbandCellTdscdma)
    {
        return nullptr;
    }

    state->type_MobileBroadbandCellUmts = py::register_python_type(module.get(), type_name_MobileBroadbandCellUmts, &type_spec_MobileBroadbandCellUmts, bases.get(), nullptr);
    if (!state->type_MobileBroadbandCellUmts)
    {
        return nullptr;
    }

    state->type_MobileBroadbandCellsInfo = py::register_python_type(module.get(), type_name_MobileBroadbandCellsInfo, &type_spec_MobileBroadbandCellsInfo, bases.get(), nullptr);
    if (!state->type_MobileBroadbandCellsInfo)
    {
        return nullptr;
    }

    state->type_MobileBroadbandCurrentSlotIndexChangedEventArgs = py::register_python_type(module.get(), type_name_MobileBroadbandCurrentSlotIndexChangedEventArgs, &type_spec_MobileBroadbandCurrentSlotIndexChangedEventArgs, bases.get(), nullptr);
    if (!state->type_MobileBroadbandCurrentSlotIndexChangedEventArgs)
    {
        return nullptr;
    }

    state->type_MobileBroadbandDeviceInformation = py::register_python_type(module.get(), type_name_MobileBroadbandDeviceInformation, &type_spec_MobileBroadbandDeviceInformation, bases.get(), nullptr);
    if (!state->type_MobileBroadbandDeviceInformation)
    {
        return nullptr;
    }

    state->type_MobileBroadbandDeviceService = py::register_python_type(module.get(), type_name_MobileBroadbandDeviceService, &type_spec_MobileBroadbandDeviceService, bases.get(), nullptr);
    if (!state->type_MobileBroadbandDeviceService)
    {
        return nullptr;
    }

    state->type_MobileBroadbandDeviceServiceCommandResult = py::register_python_type(module.get(), type_name_MobileBroadbandDeviceServiceCommandResult, &type_spec_MobileBroadbandDeviceServiceCommandResult, bases.get(), nullptr);
    if (!state->type_MobileBroadbandDeviceServiceCommandResult)
    {
        return nullptr;
    }

    state->type_MobileBroadbandDeviceServiceCommandSession = py::register_python_type(module.get(), type_name_MobileBroadbandDeviceServiceCommandSession, &type_spec_MobileBroadbandDeviceServiceCommandSession, bases.get(), nullptr);
    if (!state->type_MobileBroadbandDeviceServiceCommandSession)
    {
        return nullptr;
    }

    state->type_MobileBroadbandDeviceServiceDataReceivedEventArgs = py::register_python_type(module.get(), type_name_MobileBroadbandDeviceServiceDataReceivedEventArgs, &type_spec_MobileBroadbandDeviceServiceDataReceivedEventArgs, bases.get(), nullptr);
    if (!state->type_MobileBroadbandDeviceServiceDataReceivedEventArgs)
    {
        return nullptr;
    }

    state->type_MobileBroadbandDeviceServiceDataSession = py::register_python_type(module.get(), type_name_MobileBroadbandDeviceServiceDataSession, &type_spec_MobileBroadbandDeviceServiceDataSession, bases.get(), nullptr);
    if (!state->type_MobileBroadbandDeviceServiceDataSession)
    {
        return nullptr;
    }

    state->type_MobileBroadbandDeviceServiceInformation = py::register_python_type(module.get(), type_name_MobileBroadbandDeviceServiceInformation, &type_spec_MobileBroadbandDeviceServiceInformation, bases.get(), nullptr);
    if (!state->type_MobileBroadbandDeviceServiceInformation)
    {
        return nullptr;
    }

    state->type_MobileBroadbandDeviceServiceTriggerDetails = py::register_python_type(module.get(), type_name_MobileBroadbandDeviceServiceTriggerDetails, &type_spec_MobileBroadbandDeviceServiceTriggerDetails, bases.get(), nullptr);
    if (!state->type_MobileBroadbandDeviceServiceTriggerDetails)
    {
        return nullptr;
    }

    state->type_MobileBroadbandModem = py::register_python_type(module.get(), type_name_MobileBroadbandModem, &type_spec_MobileBroadbandModem, bases.get(), nullptr);
    if (!state->type_MobileBroadbandModem)
    {
        return nullptr;
    }

    state->type_MobileBroadbandModemConfiguration = py::register_python_type(module.get(), type_name_MobileBroadbandModemConfiguration, &type_spec_MobileBroadbandModemConfiguration, bases.get(), nullptr);
    if (!state->type_MobileBroadbandModemConfiguration)
    {
        return nullptr;
    }

    state->type_MobileBroadbandModemIsolation = py::register_python_type(module.get(), type_name_MobileBroadbandModemIsolation, &type_spec_MobileBroadbandModemIsolation, bases.get(), nullptr);
    if (!state->type_MobileBroadbandModemIsolation)
    {
        return nullptr;
    }

    state->type_MobileBroadbandNetwork = py::register_python_type(module.get(), type_name_MobileBroadbandNetwork, &type_spec_MobileBroadbandNetwork, bases.get(), nullptr);
    if (!state->type_MobileBroadbandNetwork)
    {
        return nullptr;
    }

    state->type_MobileBroadbandNetworkRegistrationStateChange = py::register_python_type(module.get(), type_name_MobileBroadbandNetworkRegistrationStateChange, &type_spec_MobileBroadbandNetworkRegistrationStateChange, bases.get(), nullptr);
    if (!state->type_MobileBroadbandNetworkRegistrationStateChange)
    {
        return nullptr;
    }

    state->type_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails = py::register_python_type(module.get(), type_name_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails, &type_spec_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails, bases.get(), nullptr);
    if (!state->type_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails)
    {
        return nullptr;
    }

    state->type_MobileBroadbandPco = py::register_python_type(module.get(), type_name_MobileBroadbandPco, &type_spec_MobileBroadbandPco, bases.get(), nullptr);
    if (!state->type_MobileBroadbandPco)
    {
        return nullptr;
    }

    state->type_MobileBroadbandPcoDataChangeTriggerDetails = py::register_python_type(module.get(), type_name_MobileBroadbandPcoDataChangeTriggerDetails, &type_spec_MobileBroadbandPcoDataChangeTriggerDetails, bases.get(), nullptr);
    if (!state->type_MobileBroadbandPcoDataChangeTriggerDetails)
    {
        return nullptr;
    }

    state->type_MobileBroadbandPin = py::register_python_type(module.get(), type_name_MobileBroadbandPin, &type_spec_MobileBroadbandPin, bases.get(), nullptr);
    if (!state->type_MobileBroadbandPin)
    {
        return nullptr;
    }

    state->type_MobileBroadbandPinLockStateChange = py::register_python_type(module.get(), type_name_MobileBroadbandPinLockStateChange, &type_spec_MobileBroadbandPinLockStateChange, bases.get(), nullptr);
    if (!state->type_MobileBroadbandPinLockStateChange)
    {
        return nullptr;
    }

    state->type_MobileBroadbandPinLockStateChangeTriggerDetails = py::register_python_type(module.get(), type_name_MobileBroadbandPinLockStateChangeTriggerDetails, &type_spec_MobileBroadbandPinLockStateChangeTriggerDetails, bases.get(), nullptr);
    if (!state->type_MobileBroadbandPinLockStateChangeTriggerDetails)
    {
        return nullptr;
    }

    state->type_MobileBroadbandPinManager = py::register_python_type(module.get(), type_name_MobileBroadbandPinManager, &type_spec_MobileBroadbandPinManager, bases.get(), nullptr);
    if (!state->type_MobileBroadbandPinManager)
    {
        return nullptr;
    }

    state->type_MobileBroadbandPinOperationResult = py::register_python_type(module.get(), type_name_MobileBroadbandPinOperationResult, &type_spec_MobileBroadbandPinOperationResult, bases.get(), nullptr);
    if (!state->type_MobileBroadbandPinOperationResult)
    {
        return nullptr;
    }

    state->type_MobileBroadbandRadioStateChange = py::register_python_type(module.get(), type_name_MobileBroadbandRadioStateChange, &type_spec_MobileBroadbandRadioStateChange, bases.get(), nullptr);
    if (!state->type_MobileBroadbandRadioStateChange)
    {
        return nullptr;
    }

    state->type_MobileBroadbandRadioStateChangeTriggerDetails = py::register_python_type(module.get(), type_name_MobileBroadbandRadioStateChangeTriggerDetails, &type_spec_MobileBroadbandRadioStateChangeTriggerDetails, bases.get(), nullptr);
    if (!state->type_MobileBroadbandRadioStateChangeTriggerDetails)
    {
        return nullptr;
    }

    state->type_MobileBroadbandSarManager = py::register_python_type(module.get(), type_name_MobileBroadbandSarManager, &type_spec_MobileBroadbandSarManager, bases.get(), nullptr);
    if (!state->type_MobileBroadbandSarManager)
    {
        return nullptr;
    }

    state->type_MobileBroadbandSlotInfo = py::register_python_type(module.get(), type_name_MobileBroadbandSlotInfo, &type_spec_MobileBroadbandSlotInfo, bases.get(), nullptr);
    if (!state->type_MobileBroadbandSlotInfo)
    {
        return nullptr;
    }

    state->type_MobileBroadbandSlotInfoChangedEventArgs = py::register_python_type(module.get(), type_name_MobileBroadbandSlotInfoChangedEventArgs, &type_spec_MobileBroadbandSlotInfoChangedEventArgs, bases.get(), nullptr);
    if (!state->type_MobileBroadbandSlotInfoChangedEventArgs)
    {
        return nullptr;
    }

    state->type_MobileBroadbandSlotManager = py::register_python_type(module.get(), type_name_MobileBroadbandSlotManager, &type_spec_MobileBroadbandSlotManager, bases.get(), nullptr);
    if (!state->type_MobileBroadbandSlotManager)
    {
        return nullptr;
    }

    state->type_MobileBroadbandTransmissionStateChangedEventArgs = py::register_python_type(module.get(), type_name_MobileBroadbandTransmissionStateChangedEventArgs, &type_spec_MobileBroadbandTransmissionStateChangedEventArgs, bases.get(), nullptr);
    if (!state->type_MobileBroadbandTransmissionStateChangedEventArgs)
    {
        return nullptr;
    }

    state->type_MobileBroadbandUicc = py::register_python_type(module.get(), type_name_MobileBroadbandUicc, &type_spec_MobileBroadbandUicc, bases.get(), nullptr);
    if (!state->type_MobileBroadbandUicc)
    {
        return nullptr;
    }

    state->type_MobileBroadbandUiccApp = py::register_python_type(module.get(), type_name_MobileBroadbandUiccApp, &type_spec_MobileBroadbandUiccApp, bases.get(), nullptr);
    if (!state->type_MobileBroadbandUiccApp)
    {
        return nullptr;
    }

    state->type_MobileBroadbandUiccAppReadRecordResult = py::register_python_type(module.get(), type_name_MobileBroadbandUiccAppReadRecordResult, &type_spec_MobileBroadbandUiccAppReadRecordResult, bases.get(), nullptr);
    if (!state->type_MobileBroadbandUiccAppReadRecordResult)
    {
        return nullptr;
    }

    state->type_MobileBroadbandUiccAppRecordDetailsResult = py::register_python_type(module.get(), type_name_MobileBroadbandUiccAppRecordDetailsResult, &type_spec_MobileBroadbandUiccAppRecordDetailsResult, bases.get(), nullptr);
    if (!state->type_MobileBroadbandUiccAppRecordDetailsResult)
    {
        return nullptr;
    }

    state->type_MobileBroadbandUiccAppsResult = py::register_python_type(module.get(), type_name_MobileBroadbandUiccAppsResult, &type_spec_MobileBroadbandUiccAppsResult, bases.get(), nullptr);
    if (!state->type_MobileBroadbandUiccAppsResult)
    {
        return nullptr;
    }

    state->type_NetworkOperatorDataUsageTriggerDetails = py::register_python_type(module.get(), type_name_NetworkOperatorDataUsageTriggerDetails, &type_spec_NetworkOperatorDataUsageTriggerDetails, bases.get(), nullptr);
    if (!state->type_NetworkOperatorDataUsageTriggerDetails)
    {
        return nullptr;
    }

    state->type_NetworkOperatorNotificationEventDetails = py::register_python_type(module.get(), type_name_NetworkOperatorNotificationEventDetails, &type_spec_NetworkOperatorNotificationEventDetails, bases.get(), nullptr);
    if (!state->type_NetworkOperatorNotificationEventDetails)
    {
        return nullptr;
    }

    state->type_NetworkOperatorTetheringAccessPointConfiguration = py::register_python_type(module.get(), type_name_NetworkOperatorTetheringAccessPointConfiguration, &type_spec_NetworkOperatorTetheringAccessPointConfiguration, bases.get(), nullptr);
    if (!state->type_NetworkOperatorTetheringAccessPointConfiguration)
    {
        return nullptr;
    }

    state->type_NetworkOperatorTetheringClient = py::register_python_type(module.get(), type_name_NetworkOperatorTetheringClient, &type_spec_NetworkOperatorTetheringClient, bases.get(), nullptr);
    if (!state->type_NetworkOperatorTetheringClient)
    {
        return nullptr;
    }

    state->type_NetworkOperatorTetheringManager = py::register_python_type(module.get(), type_name_NetworkOperatorTetheringManager, &type_spec_NetworkOperatorTetheringManager, bases.get(), nullptr);
    if (!state->type_NetworkOperatorTetheringManager)
    {
        return nullptr;
    }

    state->type_NetworkOperatorTetheringOperationResult = py::register_python_type(module.get(), type_name_NetworkOperatorTetheringOperationResult, &type_spec_NetworkOperatorTetheringOperationResult, bases.get(), nullptr);
    if (!state->type_NetworkOperatorTetheringOperationResult)
    {
        return nullptr;
    }

    state->type_ProvisionFromXmlDocumentResults = py::register_python_type(module.get(), type_name_ProvisionFromXmlDocumentResults, &type_spec_ProvisionFromXmlDocumentResults, bases.get(), nullptr);
    if (!state->type_ProvisionFromXmlDocumentResults)
    {
        return nullptr;
    }

    state->type_ProvisionedProfile = py::register_python_type(module.get(), type_name_ProvisionedProfile, &type_spec_ProvisionedProfile, bases.get(), nullptr);
    if (!state->type_ProvisionedProfile)
    {
        return nullptr;
    }

    state->type_ProvisioningAgent = py::register_python_type(module.get(), type_name_ProvisioningAgent, &type_spec_ProvisioningAgent, bases.get(), nullptr);
    if (!state->type_ProvisioningAgent)
    {
        return nullptr;
    }

    state->type_TetheringEntitlementCheckTriggerDetails = py::register_python_type(module.get(), type_name_TetheringEntitlementCheckTriggerDetails, &type_spec_TetheringEntitlementCheckTriggerDetails, bases.get(), nullptr);
    if (!state->type_TetheringEntitlementCheckTriggerDetails)
    {
        return nullptr;
    }

    state->type_UssdMessage = py::register_python_type(module.get(), type_name_UssdMessage, &type_spec_UssdMessage, bases.get(), nullptr);
    if (!state->type_UssdMessage)
    {
        return nullptr;
    }

    state->type_UssdReply = py::register_python_type(module.get(), type_name_UssdReply, &type_spec_UssdReply, bases.get(), nullptr);
    if (!state->type_UssdReply)
    {
        return nullptr;
    }

    state->type_UssdSession = py::register_python_type(module.get(), type_name_UssdSession, &type_spec_UssdSession, bases.get(), nullptr);
    if (!state->type_UssdSession)
    {
        return nullptr;
    }

    state->type_ESimProfileInstallProgress = py::register_python_type(module.get(), type_name_ESimProfileInstallProgress, &type_spec_ESimProfileInstallProgress, bases.get(), nullptr);
    if (!state->type_ESimProfileInstallProgress)
    {
        return nullptr;
    }

    state->type_ProfileUsage = py::register_python_type(module.get(), type_name_ProfileUsage, &type_spec_ProfileUsage, bases.get(), nullptr);
    if (!state->type_ProfileUsage)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::DataClasses>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DataClasses;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::DataClasses is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::ESimAuthenticationPreference>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimAuthenticationPreference;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimAuthenticationPreference is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::ESimDiscoverResultKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimDiscoverResultKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimDiscoverResultKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::ESimOperationStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimOperationStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimOperationStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::ESimProfileClass>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimProfileClass;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimProfileClass is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::ESimProfileMetadataState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimProfileMetadataState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimProfileMetadataState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::ESimProfileState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimProfileState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimProfileState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::ESimState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::ESimWatcherStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimWatcherStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimWatcherStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationResponseCode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HotspotAuthenticationResponseCode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationResponseCode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcherStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandAccountWatcherStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcherStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandDeviceType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModemStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandModemStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandModemStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinFormat>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandPinFormat;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinFormat is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinLockState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandPinLockState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinLockState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandPinType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandRadioState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandRadioState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandRadioState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandSlotState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppOperationStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandUiccAppOperationStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppOperationStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::NetworkDeviceStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkDeviceStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::NetworkDeviceStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::NetworkOperatorDataUsageNotificationKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkOperatorDataUsageNotificationKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::NetworkOperatorDataUsageNotificationKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::NetworkOperatorEventMessageType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkOperatorEventMessageType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::NetworkOperatorEventMessageType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::NetworkRegistrationState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkRegistrationState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::NetworkRegistrationState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::ProfileMediaType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProfileMediaType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ProfileMediaType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::TetheringCapability>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TetheringCapability;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::TetheringCapability is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::TetheringOperationStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TetheringOperationStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::TetheringOperationStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::TetheringOperationalState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TetheringOperationalState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::TetheringOperationalState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::TetheringWiFiBand>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TetheringWiFiBand;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::TetheringWiFiBand is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::UiccAccessCondition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UiccAccessCondition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::UiccAccessCondition is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::UiccAppKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UiccAppKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::UiccAppKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::UiccAppRecordKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UiccAppRecordKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::UiccAppRecordKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::UssdResultCode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UssdResultCode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::UssdResultCode is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESim>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESim;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESim is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimAddedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimAddedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimAddedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimDiscoverEvent>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimDiscoverEvent;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimDiscoverEvent is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimDiscoverResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimDiscoverResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimDiscoverResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimDownloadProfileMetadataResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimDownloadProfileMetadataResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimDownloadProfileMetadataResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimOperationResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimOperationResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimOperationResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimPolicy>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimPolicy;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimPolicy is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimProfile>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimProfile;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimProfile is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimProfileMetadata>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimProfileMetadata;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimProfileMetadata is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimProfilePolicy>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimProfilePolicy;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimProfilePolicy is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimRemovedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimRemovedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimRemovedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimServiceInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimServiceInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimServiceInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimUpdatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimUpdatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimUpdatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimWatcher>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimWatcher;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimWatcher is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::FdnAccessManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FdnAccessManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::FdnAccessManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationContext>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HotspotAuthenticationContext;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationContext is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationEventDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HotspotAuthenticationEventDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationEventDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HotspotCredentialsAuthenticationResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::KnownCSimFilePaths>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownCSimFilePaths;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::KnownCSimFilePaths is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::KnownRuimFilePaths>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownRuimFilePaths;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::KnownRuimFilePaths is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::KnownSimFilePaths>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownSimFilePaths;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::KnownSimFilePaths is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::KnownUSimFilePaths>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownUSimFilePaths;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::KnownUSimFilePaths is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccount>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandAccount;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccount is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandAccountEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandAccountUpdatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandAccountWatcher;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAntennaSar>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandAntennaSar;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandAntennaSar is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandCellCdma;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandCellGsm;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellLte>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandCellLte;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellLte is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellNR>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandCellNR;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellNR is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandCellTdscdma;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandCellUmts;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandCellsInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCurrentSlotIndexChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandCurrentSlotIndexChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandCurrentSlotIndexChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandDeviceInformation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandDeviceService;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandDeviceServiceCommandResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandSession>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandDeviceServiceCommandSession;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandSession is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataReceivedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandDeviceServiceDataReceivedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataReceivedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandDeviceServiceDataSession;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceInformation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandDeviceServiceInformation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceInformation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandDeviceServiceTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModem>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandModem;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandModem is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandModemConfiguration;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandModemIsolation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetwork>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandNetwork;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetwork is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChange>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandNetworkRegistrationStateChange;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChange is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChangeTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChangeTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPco>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandPco;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandPco is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPcoDataChangeTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandPcoDataChangeTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandPcoDataChangeTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPin>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandPin;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandPin is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChange>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandPinLockStateChange;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChange is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChangeTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandPinLockStateChangeTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChangeTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandPinManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinOperationResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandPinOperationResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinOperationResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChange>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandRadioStateChange;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChange is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChangeTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandRadioStateChangeTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChangeTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSarManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandSarManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandSarManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandSlotInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfoChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandSlotInfoChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfoChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandSlotManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandTransmissionStateChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandTransmissionStateChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandTransmissionStateChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUicc>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandUicc;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandUicc is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandUiccApp;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppReadRecordResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandUiccAppReadRecordResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppReadRecordResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandUiccAppRecordDetailsResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppsResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandUiccAppsResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppsResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::NetworkOperatorDataUsageTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkOperatorDataUsageTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::NetworkOperatorDataUsageTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::NetworkOperatorNotificationEventDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkOperatorNotificationEventDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::NetworkOperatorNotificationEventDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkOperatorTetheringAccessPointConfiguration;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringClient>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkOperatorTetheringClient;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringClient is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkOperatorTetheringManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringOperationResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkOperatorTetheringOperationResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringOperationResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ProvisionFromXmlDocumentResults>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProvisionFromXmlDocumentResults;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ProvisionFromXmlDocumentResults is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ProvisionedProfile>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProvisionedProfile;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ProvisionedProfile is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ProvisioningAgent>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProvisioningAgent;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ProvisioningAgent is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::TetheringEntitlementCheckTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TetheringEntitlementCheckTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::TetheringEntitlementCheckTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::UssdMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UssdMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::UssdMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::UssdReply>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UssdReply;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::UssdReply is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::UssdSession>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UssdSession;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::UssdSession is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimProfileInstallProgress;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ProfileUsage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProfileUsage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ProfileUsage is not registered");
        return nullptr;
    }

    return python_type;
}
