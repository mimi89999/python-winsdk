// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.Media.h"


PyObject* py::converter<winrt::Windows::Media::MediaTimeRange>::convert(winrt::Windows::Media::MediaTimeRange instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Media::MediaTimeRange>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Media::MediaTimeRange py::converter<winrt::Windows::Media::MediaTimeRange>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Media::MediaTimeRange>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Media::MediaTimeRange>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Media::MediaTimeRange");
    throw python_exception();
}

namespace py::cpp::Windows::Media
{
    struct module_state
    {
        PyObject* type_AudioBufferAccessMode;
        PyObject* type_AudioProcessing;
        PyObject* type_MediaPlaybackAutoRepeatMode;
        PyObject* type_MediaPlaybackStatus;
        PyObject* type_MediaPlaybackType;
        PyObject* type_MediaTimelineControllerState;
        PyObject* type_SoundLevel;
        PyObject* type_SystemMediaTransportControlsButton;
        PyObject* type_SystemMediaTransportControlsProperty;
        PyTypeObject* type_AudioBuffer;
        PyTypeObject* type_AudioFrame;
        PyTypeObject* type_AutoRepeatModeChangeRequestedEventArgs;
        PyTypeObject* type_ImageDisplayProperties;
        PyTypeObject* type_MediaControl;
        PyTypeObject* type_MediaExtensionManager;
        PyTypeObject* type_MediaMarkerTypes;
        PyTypeObject* type_MediaProcessingTriggerDetails;
        PyTypeObject* type_MediaTimelineController;
        PyTypeObject* type_MediaTimelineControllerFailedEventArgs;
        PyTypeObject* type_MusicDisplayProperties;
        PyTypeObject* type_PlaybackPositionChangeRequestedEventArgs;
        PyTypeObject* type_PlaybackRateChangeRequestedEventArgs;
        PyTypeObject* type_ShuffleEnabledChangeRequestedEventArgs;
        PyTypeObject* type_SystemMediaTransportControls;
        PyTypeObject* type_SystemMediaTransportControlsButtonPressedEventArgs;
        PyTypeObject* type_SystemMediaTransportControlsDisplayUpdater;
        PyTypeObject* type_SystemMediaTransportControlsPropertyChangedEventArgs;
        PyTypeObject* type_SystemMediaTransportControlsTimelineProperties;
        PyTypeObject* type_VideoDisplayProperties;
        PyTypeObject* type_VideoEffects;
        PyTypeObject* type_VideoFrame;
        PyTypeObject* type_IMediaExtension;
        PyTypeObject* type_IMediaFrame;
        PyTypeObject* type_IMediaMarker;
        PyTypeObject* type_IMediaMarkers;
        PyTypeObject* type_MediaTimeRange;
    };

    static PyObject* register_AudioBufferAccessMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AudioBufferAccessMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AudioBufferAccessMode = type;
        Py_INCREF(state->type_AudioBufferAccessMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_AudioProcessing(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AudioProcessing)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AudioProcessing = type;
        Py_INCREF(state->type_AudioProcessing);


        Py_RETURN_NONE;
    }

    static PyObject* register_MediaPlaybackAutoRepeatMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MediaPlaybackAutoRepeatMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MediaPlaybackAutoRepeatMode = type;
        Py_INCREF(state->type_MediaPlaybackAutoRepeatMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_MediaPlaybackStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MediaPlaybackStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MediaPlaybackStatus = type;
        Py_INCREF(state->type_MediaPlaybackStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_MediaPlaybackType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MediaPlaybackType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MediaPlaybackType = type;
        Py_INCREF(state->type_MediaPlaybackType);


        Py_RETURN_NONE;
    }

    static PyObject* register_MediaTimelineControllerState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MediaTimelineControllerState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MediaTimelineControllerState = type;
        Py_INCREF(state->type_MediaTimelineControllerState);


        Py_RETURN_NONE;
    }

    static PyObject* register_SoundLevel(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SoundLevel)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SoundLevel = type;
        Py_INCREF(state->type_SoundLevel);


        Py_RETURN_NONE;
    }

    static PyObject* register_SystemMediaTransportControlsButton(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SystemMediaTransportControlsButton)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SystemMediaTransportControlsButton = type;
        Py_INCREF(state->type_SystemMediaTransportControlsButton);


        Py_RETURN_NONE;
    }

    static PyObject* register_SystemMediaTransportControlsProperty(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SystemMediaTransportControlsProperty)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SystemMediaTransportControlsProperty = type;
        Py_INCREF(state->type_SystemMediaTransportControlsProperty);


        Py_RETURN_NONE;
    }

    // ----- AudioBuffer class --------------------
    static constexpr const char* const type_name_AudioBuffer = "AudioBuffer";

    static PyObject* _new_AudioBuffer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioBuffer);
        return nullptr;
    }

    static void _dealloc_AudioBuffer(py::wrapper::Windows::Media::AudioBuffer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioBuffer_Close(py::wrapper::Windows::Media::AudioBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.AudioBuffer", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioBuffer_CreateReference(py::wrapper::Windows::Media::AudioBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.AudioBuffer", L"CreateReference", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioBuffer_get_Length(py::wrapper::Windows::Media::AudioBuffer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.AudioBuffer", L"Length"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioBuffer_put_Length(py::wrapper::Windows::Media::AudioBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.AudioBuffer", L"Length"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Length(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioBuffer_get_Capacity(py::wrapper::Windows::Media::AudioBuffer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.AudioBuffer", L"Capacity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Capacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::AudioBuffer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::AudioBuffer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioBuffer(py::wrapper::Windows::Media::AudioBuffer* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_AudioBuffer(py::wrapper::Windows::Media::AudioBuffer* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioBuffer[] = {
        { "close", reinterpret_cast<PyCFunction>(AudioBuffer_Close), METH_VARARGS, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(AudioBuffer_CreateReference), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AudioBuffer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioBuffer), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioBuffer), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioBuffer), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioBuffer[] = {
        { "length", reinterpret_cast<getter>(AudioBuffer_get_Length), reinterpret_cast<setter>(AudioBuffer_put_Length), nullptr, nullptr },
        { "capacity", reinterpret_cast<getter>(AudioBuffer_get_Capacity), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioBuffer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioBuffer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioBuffer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioBuffer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioBuffer) },
        { },
    };

    static PyType_Spec type_spec_AudioBuffer =
    {
        "_winsdk_Windows_Media.AudioBuffer",
        sizeof(py::wrapper::Windows::Media::AudioBuffer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioBuffer
    };

    // ----- AudioFrame class --------------------
    static constexpr const char* const type_name_AudioFrame = "AudioFrame";

    static PyObject* _new_AudioFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::Media::AudioFrame instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioFrame(py::wrapper::Windows::Media::AudioFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioFrame_Close(py::wrapper::Windows::Media::AudioFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.AudioFrame", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrame_LockBuffer(py::wrapper::Windows::Media::AudioFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.AudioFrame", L"LockBuffer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::AudioBufferAccessMode>(args, 0);

                return py::convert(self->obj.LockBuffer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrame_get_SystemRelativeTime(py::wrapper::Windows::Media::AudioFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.AudioFrame", L"SystemRelativeTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SystemRelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrame_put_SystemRelativeTime(py::wrapper::Windows::Media::AudioFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.AudioFrame", L"SystemRelativeTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.SystemRelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrame_get_RelativeTime(py::wrapper::Windows::Media::AudioFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.AudioFrame", L"RelativeTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrame_put_RelativeTime(py::wrapper::Windows::Media::AudioFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.AudioFrame", L"RelativeTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.RelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrame_get_IsDiscontinuous(py::wrapper::Windows::Media::AudioFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.AudioFrame", L"IsDiscontinuous"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDiscontinuous());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrame_put_IsDiscontinuous(py::wrapper::Windows::Media::AudioFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.AudioFrame", L"IsDiscontinuous"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDiscontinuous(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrame_get_Duration(py::wrapper::Windows::Media::AudioFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.AudioFrame", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrame_put_Duration(py::wrapper::Windows::Media::AudioFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.AudioFrame", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrame_get_ExtendedProperties(py::wrapper::Windows::Media::AudioFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.AudioFrame", L"ExtendedProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrame_get_IsReadOnly(py::wrapper::Windows::Media::AudioFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.AudioFrame", L"IsReadOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrame_get_Type(py::wrapper::Windows::Media::AudioFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.AudioFrame", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::AudioFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::AudioFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioFrame(py::wrapper::Windows::Media::AudioFrame* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_AudioFrame(py::wrapper::Windows::Media::AudioFrame* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioFrame[] = {
        { "close", reinterpret_cast<PyCFunction>(AudioFrame_Close), METH_VARARGS, nullptr },
        { "lock_buffer", reinterpret_cast<PyCFunction>(AudioFrame_LockBuffer), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AudioFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioFrame), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioFrame), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioFrame), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioFrame[] = {
        { "system_relative_time", reinterpret_cast<getter>(AudioFrame_get_SystemRelativeTime), reinterpret_cast<setter>(AudioFrame_put_SystemRelativeTime), nullptr, nullptr },
        { "relative_time", reinterpret_cast<getter>(AudioFrame_get_RelativeTime), reinterpret_cast<setter>(AudioFrame_put_RelativeTime), nullptr, nullptr },
        { "is_discontinuous", reinterpret_cast<getter>(AudioFrame_get_IsDiscontinuous), reinterpret_cast<setter>(AudioFrame_put_IsDiscontinuous), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(AudioFrame_get_Duration), reinterpret_cast<setter>(AudioFrame_put_Duration), nullptr, nullptr },
        { "extended_properties", reinterpret_cast<getter>(AudioFrame_get_ExtendedProperties), nullptr, nullptr, nullptr },
        { "is_read_only", reinterpret_cast<getter>(AudioFrame_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(AudioFrame_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioFrame) },
        { },
    };

    static PyType_Spec type_spec_AudioFrame =
    {
        "_winsdk_Windows_Media.AudioFrame",
        sizeof(py::wrapper::Windows::Media::AudioFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioFrame
    };

    // ----- AutoRepeatModeChangeRequestedEventArgs class --------------------
    static constexpr const char* const type_name_AutoRepeatModeChangeRequestedEventArgs = "AutoRepeatModeChangeRequestedEventArgs";

    static PyObject* _new_AutoRepeatModeChangeRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AutoRepeatModeChangeRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_AutoRepeatModeChangeRequestedEventArgs(py::wrapper::Windows::Media::AutoRepeatModeChangeRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AutoRepeatModeChangeRequestedEventArgs_get_RequestedAutoRepeatMode(py::wrapper::Windows::Media::AutoRepeatModeChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.AutoRepeatModeChangeRequestedEventArgs", L"RequestedAutoRepeatMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestedAutoRepeatMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AutoRepeatModeChangeRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::AutoRepeatModeChangeRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AutoRepeatModeChangeRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::AutoRepeatModeChangeRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutoRepeatModeChangeRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_AutoRepeatModeChangeRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AutoRepeatModeChangeRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AutoRepeatModeChangeRequestedEventArgs[] = {
        { "requested_auto_repeat_mode", reinterpret_cast<getter>(AutoRepeatModeChangeRequestedEventArgs_get_RequestedAutoRepeatMode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AutoRepeatModeChangeRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutoRepeatModeChangeRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutoRepeatModeChangeRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AutoRepeatModeChangeRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutoRepeatModeChangeRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AutoRepeatModeChangeRequestedEventArgs =
    {
        "_winsdk_Windows_Media.AutoRepeatModeChangeRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::AutoRepeatModeChangeRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutoRepeatModeChangeRequestedEventArgs
    };

    // ----- ImageDisplayProperties class --------------------
    static constexpr const char* const type_name_ImageDisplayProperties = "ImageDisplayProperties";

    static PyObject* _new_ImageDisplayProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ImageDisplayProperties);
        return nullptr;
    }

    static void _dealloc_ImageDisplayProperties(py::wrapper::Windows::Media::ImageDisplayProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageDisplayProperties_get_Title(py::wrapper::Windows::Media::ImageDisplayProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.ImageDisplayProperties", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageDisplayProperties_put_Title(py::wrapper::Windows::Media::ImageDisplayProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.ImageDisplayProperties", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageDisplayProperties_get_Subtitle(py::wrapper::Windows::Media::ImageDisplayProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.ImageDisplayProperties", L"Subtitle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Subtitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageDisplayProperties_put_Subtitle(py::wrapper::Windows::Media::ImageDisplayProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.ImageDisplayProperties", L"Subtitle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtitle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ImageDisplayProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::ImageDisplayProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageDisplayProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::ImageDisplayProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageDisplayProperties[] = {
        { "_assign_array_", _assign_array_ImageDisplayProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageDisplayProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageDisplayProperties[] = {
        { "title", reinterpret_cast<getter>(ImageDisplayProperties_get_Title), reinterpret_cast<setter>(ImageDisplayProperties_put_Title), nullptr, nullptr },
        { "subtitle", reinterpret_cast<getter>(ImageDisplayProperties_get_Subtitle), reinterpret_cast<setter>(ImageDisplayProperties_put_Subtitle), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageDisplayProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageDisplayProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageDisplayProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageDisplayProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageDisplayProperties) },
        { },
    };

    static PyType_Spec type_spec_ImageDisplayProperties =
    {
        "_winsdk_Windows_Media.ImageDisplayProperties",
        sizeof(py::wrapper::Windows::Media::ImageDisplayProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageDisplayProperties
    };

    // ----- MediaControl class --------------------
    static constexpr const char* const type_name_MediaControl = "MediaControl";

    static PyObject* _new_MediaControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaControl);
        return nullptr;
    }

    static PyObject* MediaControl_get_TrackName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaControl", L"TrackName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaControl::TrackName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_put_TrackName(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaControl", L"TrackName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            winrt::Windows::Media::MediaControl::TrackName(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_get_IsPlaying(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaControl", L"IsPlaying"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaControl::IsPlaying());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_put_IsPlaying(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaControl", L"IsPlaying"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            winrt::Windows::Media::MediaControl::IsPlaying(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_get_ArtistName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaControl", L"ArtistName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaControl::ArtistName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_put_ArtistName(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaControl", L"ArtistName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            winrt::Windows::Media::MediaControl::ArtistName(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_get_AlbumArt(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaControl", L"AlbumArt"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaControl::AlbumArt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_put_AlbumArt(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaControl", L"AlbumArt"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            winrt::Windows::Media::MediaControl::AlbumArt(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_get_SoundLevel(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaControl", L"SoundLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaControl::SoundLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_add_ChannelDownPressed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaControl", L"ChannelDownPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::Media::MediaControl::ChannelDownPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_remove_ChannelDownPressed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaControl", L"ChannelDownPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Media::MediaControl::ChannelDownPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_add_ChannelUpPressed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaControl", L"ChannelUpPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::Media::MediaControl::ChannelUpPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_remove_ChannelUpPressed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaControl", L"ChannelUpPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Media::MediaControl::ChannelUpPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_add_FastForwardPressed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaControl", L"FastForwardPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::Media::MediaControl::FastForwardPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_remove_FastForwardPressed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaControl", L"FastForwardPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Media::MediaControl::FastForwardPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_add_NextTrackPressed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaControl", L"NextTrackPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::Media::MediaControl::NextTrackPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_remove_NextTrackPressed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaControl", L"NextTrackPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Media::MediaControl::NextTrackPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_add_PausePressed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaControl", L"PausePressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::Media::MediaControl::PausePressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_remove_PausePressed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaControl", L"PausePressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Media::MediaControl::PausePressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_add_PlayPauseTogglePressed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaControl", L"PlayPauseTogglePressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::Media::MediaControl::PlayPauseTogglePressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_remove_PlayPauseTogglePressed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaControl", L"PlayPauseTogglePressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Media::MediaControl::PlayPauseTogglePressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_add_PlayPressed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaControl", L"PlayPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::Media::MediaControl::PlayPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_remove_PlayPressed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaControl", L"PlayPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Media::MediaControl::PlayPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_add_PreviousTrackPressed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaControl", L"PreviousTrackPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::Media::MediaControl::PreviousTrackPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_remove_PreviousTrackPressed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaControl", L"PreviousTrackPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Media::MediaControl::PreviousTrackPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_add_RecordPressed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaControl", L"RecordPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::Media::MediaControl::RecordPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_remove_RecordPressed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaControl", L"RecordPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Media::MediaControl::RecordPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_add_RewindPressed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaControl", L"RewindPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::Media::MediaControl::RewindPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_remove_RewindPressed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaControl", L"RewindPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Media::MediaControl::RewindPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_add_SoundLevelChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaControl", L"SoundLevelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::Media::MediaControl::SoundLevelChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_remove_SoundLevelChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaControl", L"SoundLevelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Media::MediaControl::SoundLevelChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_add_StopPressed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaControl", L"StopPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::Media::MediaControl::StopPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControl_remove_StopPressed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaControl", L"StopPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Media::MediaControl::StopPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaControl[] = {
        { "add_channel_down_pressed", reinterpret_cast<PyCFunction>(MediaControl_add_ChannelDownPressed), METH_O | METH_STATIC, nullptr },
        { "remove_channel_down_pressed", reinterpret_cast<PyCFunction>(MediaControl_remove_ChannelDownPressed), METH_O | METH_STATIC, nullptr },
        { "add_channel_up_pressed", reinterpret_cast<PyCFunction>(MediaControl_add_ChannelUpPressed), METH_O | METH_STATIC, nullptr },
        { "remove_channel_up_pressed", reinterpret_cast<PyCFunction>(MediaControl_remove_ChannelUpPressed), METH_O | METH_STATIC, nullptr },
        { "add_fast_forward_pressed", reinterpret_cast<PyCFunction>(MediaControl_add_FastForwardPressed), METH_O | METH_STATIC, nullptr },
        { "remove_fast_forward_pressed", reinterpret_cast<PyCFunction>(MediaControl_remove_FastForwardPressed), METH_O | METH_STATIC, nullptr },
        { "add_next_track_pressed", reinterpret_cast<PyCFunction>(MediaControl_add_NextTrackPressed), METH_O | METH_STATIC, nullptr },
        { "remove_next_track_pressed", reinterpret_cast<PyCFunction>(MediaControl_remove_NextTrackPressed), METH_O | METH_STATIC, nullptr },
        { "add_pause_pressed", reinterpret_cast<PyCFunction>(MediaControl_add_PausePressed), METH_O | METH_STATIC, nullptr },
        { "remove_pause_pressed", reinterpret_cast<PyCFunction>(MediaControl_remove_PausePressed), METH_O | METH_STATIC, nullptr },
        { "add_play_pause_toggle_pressed", reinterpret_cast<PyCFunction>(MediaControl_add_PlayPauseTogglePressed), METH_O | METH_STATIC, nullptr },
        { "remove_play_pause_toggle_pressed", reinterpret_cast<PyCFunction>(MediaControl_remove_PlayPauseTogglePressed), METH_O | METH_STATIC, nullptr },
        { "add_play_pressed", reinterpret_cast<PyCFunction>(MediaControl_add_PlayPressed), METH_O | METH_STATIC, nullptr },
        { "remove_play_pressed", reinterpret_cast<PyCFunction>(MediaControl_remove_PlayPressed), METH_O | METH_STATIC, nullptr },
        { "add_previous_track_pressed", reinterpret_cast<PyCFunction>(MediaControl_add_PreviousTrackPressed), METH_O | METH_STATIC, nullptr },
        { "remove_previous_track_pressed", reinterpret_cast<PyCFunction>(MediaControl_remove_PreviousTrackPressed), METH_O | METH_STATIC, nullptr },
        { "add_record_pressed", reinterpret_cast<PyCFunction>(MediaControl_add_RecordPressed), METH_O | METH_STATIC, nullptr },
        { "remove_record_pressed", reinterpret_cast<PyCFunction>(MediaControl_remove_RecordPressed), METH_O | METH_STATIC, nullptr },
        { "add_rewind_pressed", reinterpret_cast<PyCFunction>(MediaControl_add_RewindPressed), METH_O | METH_STATIC, nullptr },
        { "remove_rewind_pressed", reinterpret_cast<PyCFunction>(MediaControl_remove_RewindPressed), METH_O | METH_STATIC, nullptr },
        { "add_sound_level_changed", reinterpret_cast<PyCFunction>(MediaControl_add_SoundLevelChanged), METH_O | METH_STATIC, nullptr },
        { "remove_sound_level_changed", reinterpret_cast<PyCFunction>(MediaControl_remove_SoundLevelChanged), METH_O | METH_STATIC, nullptr },
        { "add_stop_pressed", reinterpret_cast<PyCFunction>(MediaControl_add_StopPressed), METH_O | METH_STATIC, nullptr },
        { "remove_stop_pressed", reinterpret_cast<PyCFunction>(MediaControl_remove_StopPressed), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaControl[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaControl) },
        { },
    };

    static PyType_Spec type_spec_MediaControl =
    {
        "_winsdk_Windows_Media.MediaControl",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaControl
    };

    static PyGetSetDef getset_MediaControl_Meta[] = {
        { "track_name", reinterpret_cast<getter>(MediaControl_get_TrackName), reinterpret_cast<setter>(MediaControl_put_TrackName), nullptr, nullptr },
        { "is_playing", reinterpret_cast<getter>(MediaControl_get_IsPlaying), reinterpret_cast<setter>(MediaControl_put_IsPlaying), nullptr, nullptr },
        { "artist_name", reinterpret_cast<getter>(MediaControl_get_ArtistName), reinterpret_cast<setter>(MediaControl_put_ArtistName), nullptr, nullptr },
        { "album_art", reinterpret_cast<getter>(MediaControl_get_AlbumArt), reinterpret_cast<setter>(MediaControl_put_AlbumArt), nullptr, nullptr },
        { "sound_level", reinterpret_cast<getter>(MediaControl_get_SoundLevel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_MediaControl_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MediaControl_Meta) },
        { }
    };

    static PyType_Spec type_spec_MediaControl_Meta =
    {
        "_winsdk_Windows_Media.MediaControl_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MediaControl_Meta
    };

    // ----- MediaExtensionManager class --------------------
    static constexpr const char* const type_name_MediaExtensionManager = "MediaExtensionManager";

    static PyObject* _new_MediaExtensionManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaExtensionManager instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaExtensionManager(py::wrapper::Windows::Media::MediaExtensionManager* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaExtensionManager_RegisterAudioDecoder(py::wrapper::Windows::Media::MediaExtensionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaExtensionManager", L"RegisterAudioDecoder", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);

                self->obj.RegisterAudioDecoder(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaExtensionManager", L"RegisterAudioDecoder", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 3);

                self->obj.RegisterAudioDecoder(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaExtensionManager_RegisterAudioEncoder(py::wrapper::Windows::Media::MediaExtensionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaExtensionManager", L"RegisterAudioEncoder", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);

                self->obj.RegisterAudioEncoder(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaExtensionManager", L"RegisterAudioEncoder", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 3);

                self->obj.RegisterAudioEncoder(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaExtensionManager_RegisterByteStreamHandler(py::wrapper::Windows::Media::MediaExtensionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaExtensionManager", L"RegisterByteStreamHandler", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                self->obj.RegisterByteStreamHandler(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaExtensionManager", L"RegisterByteStreamHandler", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 3);

                self->obj.RegisterByteStreamHandler(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaExtensionManager_RegisterMediaExtensionForAppService(py::wrapper::Windows::Media::MediaExtensionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaExtensionManager", L"RegisterMediaExtensionForAppService", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::IMediaExtension>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::AppService::AppServiceConnection>(args, 1);

                self->obj.RegisterMediaExtensionForAppService(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaExtensionManager_RegisterSchemeHandler(py::wrapper::Windows::Media::MediaExtensionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaExtensionManager", L"RegisterSchemeHandler", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.RegisterSchemeHandler(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaExtensionManager", L"RegisterSchemeHandler", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);

                self->obj.RegisterSchemeHandler(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaExtensionManager_RegisterVideoDecoder(py::wrapper::Windows::Media::MediaExtensionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaExtensionManager", L"RegisterVideoDecoder", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);

                self->obj.RegisterVideoDecoder(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaExtensionManager", L"RegisterVideoDecoder", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 3);

                self->obj.RegisterVideoDecoder(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaExtensionManager_RegisterVideoEncoder(py::wrapper::Windows::Media::MediaExtensionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaExtensionManager", L"RegisterVideoEncoder", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);

                self->obj.RegisterVideoEncoder(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaExtensionManager", L"RegisterVideoEncoder", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 3);

                self->obj.RegisterVideoEncoder(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaExtensionManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::MediaExtensionManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaExtensionManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaExtensionManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaExtensionManager[] = {
        { "register_audio_decoder", reinterpret_cast<PyCFunction>(MediaExtensionManager_RegisterAudioDecoder), METH_VARARGS, nullptr },
        { "register_audio_encoder", reinterpret_cast<PyCFunction>(MediaExtensionManager_RegisterAudioEncoder), METH_VARARGS, nullptr },
        { "register_byte_stream_handler", reinterpret_cast<PyCFunction>(MediaExtensionManager_RegisterByteStreamHandler), METH_VARARGS, nullptr },
        { "register_media_extension_for_app_service", reinterpret_cast<PyCFunction>(MediaExtensionManager_RegisterMediaExtensionForAppService), METH_VARARGS, nullptr },
        { "register_scheme_handler", reinterpret_cast<PyCFunction>(MediaExtensionManager_RegisterSchemeHandler), METH_VARARGS, nullptr },
        { "register_video_decoder", reinterpret_cast<PyCFunction>(MediaExtensionManager_RegisterVideoDecoder), METH_VARARGS, nullptr },
        { "register_video_encoder", reinterpret_cast<PyCFunction>(MediaExtensionManager_RegisterVideoEncoder), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaExtensionManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaExtensionManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaExtensionManager[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaExtensionManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaExtensionManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaExtensionManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaExtensionManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaExtensionManager) },
        { },
    };

    static PyType_Spec type_spec_MediaExtensionManager =
    {
        "_winsdk_Windows_Media.MediaExtensionManager",
        sizeof(py::wrapper::Windows::Media::MediaExtensionManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaExtensionManager
    };

    // ----- MediaMarkerTypes class --------------------
    static constexpr const char* const type_name_MediaMarkerTypes = "MediaMarkerTypes";

    static PyObject* _new_MediaMarkerTypes(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaMarkerTypes);
        return nullptr;
    }

    static PyObject* MediaMarkerTypes_get_Bookmark(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaMarkerTypes", L"Bookmark"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaMarkerTypes::Bookmark());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaMarkerTypes[] = {
        { }
    };

    static PyGetSetDef _getset_MediaMarkerTypes[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaMarkerTypes[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaMarkerTypes) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaMarkerTypes) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaMarkerTypes) },
        { },
    };

    static PyType_Spec type_spec_MediaMarkerTypes =
    {
        "_winsdk_Windows_Media.MediaMarkerTypes",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaMarkerTypes
    };

    static PyGetSetDef getset_MediaMarkerTypes_Meta[] = {
        { "bookmark", reinterpret_cast<getter>(MediaMarkerTypes_get_Bookmark), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_MediaMarkerTypes_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MediaMarkerTypes_Meta) },
        { }
    };

    static PyType_Spec type_spec_MediaMarkerTypes_Meta =
    {
        "_winsdk_Windows_Media.MediaMarkerTypes_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MediaMarkerTypes_Meta
    };

    // ----- MediaProcessingTriggerDetails class --------------------
    static constexpr const char* const type_name_MediaProcessingTriggerDetails = "MediaProcessingTriggerDetails";

    static PyObject* _new_MediaProcessingTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaProcessingTriggerDetails);
        return nullptr;
    }

    static void _dealloc_MediaProcessingTriggerDetails(py::wrapper::Windows::Media::MediaProcessingTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaProcessingTriggerDetails_get_Arguments(py::wrapper::Windows::Media::MediaProcessingTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProcessingTriggerDetails", L"Arguments"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaProcessingTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::MediaProcessingTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaProcessingTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProcessingTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaProcessingTriggerDetails[] = {
        { "_assign_array_", _assign_array_MediaProcessingTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaProcessingTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaProcessingTriggerDetails[] = {
        { "arguments", reinterpret_cast<getter>(MediaProcessingTriggerDetails_get_Arguments), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaProcessingTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaProcessingTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaProcessingTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaProcessingTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaProcessingTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_MediaProcessingTriggerDetails =
    {
        "_winsdk_Windows_Media.MediaProcessingTriggerDetails",
        sizeof(py::wrapper::Windows::Media::MediaProcessingTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaProcessingTriggerDetails
    };

    // ----- MediaTimelineController class --------------------
    static constexpr const char* const type_name_MediaTimelineController = "MediaTimelineController";

    static PyObject* _new_MediaTimelineController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaTimelineController instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaTimelineController(py::wrapper::Windows::Media::MediaTimelineController* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaTimelineController_Pause(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaTimelineController", L"Pause", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Pause();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaTimelineController_Resume(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaTimelineController", L"Resume", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Resume();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaTimelineController_Start(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaTimelineController", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaTimelineController_get_Position(py::wrapper::Windows::Media::MediaTimelineController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaTimelineController", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaTimelineController_put_Position(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaTimelineController", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaTimelineController_get_ClockRate(py::wrapper::Windows::Media::MediaTimelineController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaTimelineController", L"ClockRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ClockRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaTimelineController_put_ClockRate(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaTimelineController", L"ClockRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ClockRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaTimelineController_get_State(py::wrapper::Windows::Media::MediaTimelineController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaTimelineController", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaTimelineController_get_IsLoopingEnabled(py::wrapper::Windows::Media::MediaTimelineController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaTimelineController", L"IsLoopingEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsLoopingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaTimelineController_put_IsLoopingEnabled(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaTimelineController", L"IsLoopingEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLoopingEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaTimelineController_get_Duration(py::wrapper::Windows::Media::MediaTimelineController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaTimelineController", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaTimelineController_put_Duration(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaTimelineController", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaTimelineController_add_PositionChanged(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaTimelineController", L"PositionChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::MediaTimelineController, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.PositionChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaTimelineController_remove_PositionChanged(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaTimelineController", L"PositionChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PositionChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaTimelineController_add_StateChanged(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaTimelineController", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::MediaTimelineController, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaTimelineController_remove_StateChanged(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaTimelineController", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaTimelineController_add_Ended(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaTimelineController", L"Ended"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::MediaTimelineController, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Ended(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaTimelineController_remove_Ended(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaTimelineController", L"Ended"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Ended(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaTimelineController_add_Failed(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaTimelineController", L"Failed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::MediaTimelineController, winrt::Windows::Media::MediaTimelineControllerFailedEventArgs>>(arg);

            return py::convert(self->obj.Failed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaTimelineController_remove_Failed(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.MediaTimelineController", L"Failed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Failed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaTimelineController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::MediaTimelineController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaTimelineController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaTimelineController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaTimelineController[] = {
        { "pause", reinterpret_cast<PyCFunction>(MediaTimelineController_Pause), METH_VARARGS, nullptr },
        { "resume", reinterpret_cast<PyCFunction>(MediaTimelineController_Resume), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(MediaTimelineController_Start), METH_VARARGS, nullptr },
        { "add_position_changed", reinterpret_cast<PyCFunction>(MediaTimelineController_add_PositionChanged), METH_O, nullptr },
        { "remove_position_changed", reinterpret_cast<PyCFunction>(MediaTimelineController_remove_PositionChanged), METH_O, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(MediaTimelineController_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(MediaTimelineController_remove_StateChanged), METH_O, nullptr },
        { "add_ended", reinterpret_cast<PyCFunction>(MediaTimelineController_add_Ended), METH_O, nullptr },
        { "remove_ended", reinterpret_cast<PyCFunction>(MediaTimelineController_remove_Ended), METH_O, nullptr },
        { "add_failed", reinterpret_cast<PyCFunction>(MediaTimelineController_add_Failed), METH_O, nullptr },
        { "remove_failed", reinterpret_cast<PyCFunction>(MediaTimelineController_remove_Failed), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaTimelineController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaTimelineController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaTimelineController[] = {
        { "position", reinterpret_cast<getter>(MediaTimelineController_get_Position), reinterpret_cast<setter>(MediaTimelineController_put_Position), nullptr, nullptr },
        { "clock_rate", reinterpret_cast<getter>(MediaTimelineController_get_ClockRate), reinterpret_cast<setter>(MediaTimelineController_put_ClockRate), nullptr, nullptr },
        { "state", reinterpret_cast<getter>(MediaTimelineController_get_State), nullptr, nullptr, nullptr },
        { "is_looping_enabled", reinterpret_cast<getter>(MediaTimelineController_get_IsLoopingEnabled), reinterpret_cast<setter>(MediaTimelineController_put_IsLoopingEnabled), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(MediaTimelineController_get_Duration), reinterpret_cast<setter>(MediaTimelineController_put_Duration), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaTimelineController[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaTimelineController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaTimelineController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaTimelineController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaTimelineController) },
        { },
    };

    static PyType_Spec type_spec_MediaTimelineController =
    {
        "_winsdk_Windows_Media.MediaTimelineController",
        sizeof(py::wrapper::Windows::Media::MediaTimelineController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaTimelineController
    };

    // ----- MediaTimelineControllerFailedEventArgs class --------------------
    static constexpr const char* const type_name_MediaTimelineControllerFailedEventArgs = "MediaTimelineControllerFailedEventArgs";

    static PyObject* _new_MediaTimelineControllerFailedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaTimelineControllerFailedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaTimelineControllerFailedEventArgs(py::wrapper::Windows::Media::MediaTimelineControllerFailedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaTimelineControllerFailedEventArgs_get_ExtendedError(py::wrapper::Windows::Media::MediaTimelineControllerFailedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaTimelineControllerFailedEventArgs", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaTimelineControllerFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::MediaTimelineControllerFailedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaTimelineControllerFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaTimelineControllerFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaTimelineControllerFailedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaTimelineControllerFailedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaTimelineControllerFailedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaTimelineControllerFailedEventArgs[] = {
        { "extended_error", reinterpret_cast<getter>(MediaTimelineControllerFailedEventArgs_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaTimelineControllerFailedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaTimelineControllerFailedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaTimelineControllerFailedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaTimelineControllerFailedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaTimelineControllerFailedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaTimelineControllerFailedEventArgs =
    {
        "_winsdk_Windows_Media.MediaTimelineControllerFailedEventArgs",
        sizeof(py::wrapper::Windows::Media::MediaTimelineControllerFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaTimelineControllerFailedEventArgs
    };

    // ----- MusicDisplayProperties class --------------------
    static constexpr const char* const type_name_MusicDisplayProperties = "MusicDisplayProperties";

    static PyObject* _new_MusicDisplayProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MusicDisplayProperties);
        return nullptr;
    }

    static void _dealloc_MusicDisplayProperties(py::wrapper::Windows::Media::MusicDisplayProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MusicDisplayProperties_get_Title(py::wrapper::Windows::Media::MusicDisplayProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MusicDisplayProperties", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MusicDisplayProperties_put_Title(py::wrapper::Windows::Media::MusicDisplayProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MusicDisplayProperties", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MusicDisplayProperties_get_Artist(py::wrapper::Windows::Media::MusicDisplayProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MusicDisplayProperties", L"Artist"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Artist());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MusicDisplayProperties_put_Artist(py::wrapper::Windows::Media::MusicDisplayProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MusicDisplayProperties", L"Artist"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Artist(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MusicDisplayProperties_get_AlbumArtist(py::wrapper::Windows::Media::MusicDisplayProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MusicDisplayProperties", L"AlbumArtist"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AlbumArtist());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MusicDisplayProperties_put_AlbumArtist(py::wrapper::Windows::Media::MusicDisplayProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MusicDisplayProperties", L"AlbumArtist"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AlbumArtist(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MusicDisplayProperties_get_TrackNumber(py::wrapper::Windows::Media::MusicDisplayProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MusicDisplayProperties", L"TrackNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrackNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MusicDisplayProperties_put_TrackNumber(py::wrapper::Windows::Media::MusicDisplayProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MusicDisplayProperties", L"TrackNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.TrackNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MusicDisplayProperties_get_AlbumTitle(py::wrapper::Windows::Media::MusicDisplayProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MusicDisplayProperties", L"AlbumTitle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AlbumTitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MusicDisplayProperties_put_AlbumTitle(py::wrapper::Windows::Media::MusicDisplayProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MusicDisplayProperties", L"AlbumTitle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AlbumTitle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MusicDisplayProperties_get_Genres(py::wrapper::Windows::Media::MusicDisplayProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MusicDisplayProperties", L"Genres"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Genres());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MusicDisplayProperties_get_AlbumTrackCount(py::wrapper::Windows::Media::MusicDisplayProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MusicDisplayProperties", L"AlbumTrackCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AlbumTrackCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MusicDisplayProperties_put_AlbumTrackCount(py::wrapper::Windows::Media::MusicDisplayProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MusicDisplayProperties", L"AlbumTrackCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.AlbumTrackCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MusicDisplayProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::MusicDisplayProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MusicDisplayProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MusicDisplayProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MusicDisplayProperties[] = {
        { "_assign_array_", _assign_array_MusicDisplayProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MusicDisplayProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MusicDisplayProperties[] = {
        { "title", reinterpret_cast<getter>(MusicDisplayProperties_get_Title), reinterpret_cast<setter>(MusicDisplayProperties_put_Title), nullptr, nullptr },
        { "artist", reinterpret_cast<getter>(MusicDisplayProperties_get_Artist), reinterpret_cast<setter>(MusicDisplayProperties_put_Artist), nullptr, nullptr },
        { "album_artist", reinterpret_cast<getter>(MusicDisplayProperties_get_AlbumArtist), reinterpret_cast<setter>(MusicDisplayProperties_put_AlbumArtist), nullptr, nullptr },
        { "track_number", reinterpret_cast<getter>(MusicDisplayProperties_get_TrackNumber), reinterpret_cast<setter>(MusicDisplayProperties_put_TrackNumber), nullptr, nullptr },
        { "album_title", reinterpret_cast<getter>(MusicDisplayProperties_get_AlbumTitle), reinterpret_cast<setter>(MusicDisplayProperties_put_AlbumTitle), nullptr, nullptr },
        { "genres", reinterpret_cast<getter>(MusicDisplayProperties_get_Genres), nullptr, nullptr, nullptr },
        { "album_track_count", reinterpret_cast<getter>(MusicDisplayProperties_get_AlbumTrackCount), reinterpret_cast<setter>(MusicDisplayProperties_put_AlbumTrackCount), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MusicDisplayProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MusicDisplayProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MusicDisplayProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MusicDisplayProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MusicDisplayProperties) },
        { },
    };

    static PyType_Spec type_spec_MusicDisplayProperties =
    {
        "_winsdk_Windows_Media.MusicDisplayProperties",
        sizeof(py::wrapper::Windows::Media::MusicDisplayProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MusicDisplayProperties
    };

    // ----- PlaybackPositionChangeRequestedEventArgs class --------------------
    static constexpr const char* const type_name_PlaybackPositionChangeRequestedEventArgs = "PlaybackPositionChangeRequestedEventArgs";

    static PyObject* _new_PlaybackPositionChangeRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PlaybackPositionChangeRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_PlaybackPositionChangeRequestedEventArgs(py::wrapper::Windows::Media::PlaybackPositionChangeRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlaybackPositionChangeRequestedEventArgs_get_RequestedPlaybackPosition(py::wrapper::Windows::Media::PlaybackPositionChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.PlaybackPositionChangeRequestedEventArgs", L"RequestedPlaybackPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestedPlaybackPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlaybackPositionChangeRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::PlaybackPositionChangeRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlaybackPositionChangeRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlaybackPositionChangeRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlaybackPositionChangeRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_PlaybackPositionChangeRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlaybackPositionChangeRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlaybackPositionChangeRequestedEventArgs[] = {
        { "requested_playback_position", reinterpret_cast<getter>(PlaybackPositionChangeRequestedEventArgs_get_RequestedPlaybackPosition), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlaybackPositionChangeRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlaybackPositionChangeRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlaybackPositionChangeRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlaybackPositionChangeRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlaybackPositionChangeRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PlaybackPositionChangeRequestedEventArgs =
    {
        "_winsdk_Windows_Media.PlaybackPositionChangeRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::PlaybackPositionChangeRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlaybackPositionChangeRequestedEventArgs
    };

    // ----- PlaybackRateChangeRequestedEventArgs class --------------------
    static constexpr const char* const type_name_PlaybackRateChangeRequestedEventArgs = "PlaybackRateChangeRequestedEventArgs";

    static PyObject* _new_PlaybackRateChangeRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PlaybackRateChangeRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_PlaybackRateChangeRequestedEventArgs(py::wrapper::Windows::Media::PlaybackRateChangeRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlaybackRateChangeRequestedEventArgs_get_RequestedPlaybackRate(py::wrapper::Windows::Media::PlaybackRateChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.PlaybackRateChangeRequestedEventArgs", L"RequestedPlaybackRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestedPlaybackRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlaybackRateChangeRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::PlaybackRateChangeRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlaybackRateChangeRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlaybackRateChangeRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlaybackRateChangeRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_PlaybackRateChangeRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlaybackRateChangeRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlaybackRateChangeRequestedEventArgs[] = {
        { "requested_playback_rate", reinterpret_cast<getter>(PlaybackRateChangeRequestedEventArgs_get_RequestedPlaybackRate), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlaybackRateChangeRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlaybackRateChangeRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlaybackRateChangeRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlaybackRateChangeRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlaybackRateChangeRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PlaybackRateChangeRequestedEventArgs =
    {
        "_winsdk_Windows_Media.PlaybackRateChangeRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::PlaybackRateChangeRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlaybackRateChangeRequestedEventArgs
    };

    // ----- ShuffleEnabledChangeRequestedEventArgs class --------------------
    static constexpr const char* const type_name_ShuffleEnabledChangeRequestedEventArgs = "ShuffleEnabledChangeRequestedEventArgs";

    static PyObject* _new_ShuffleEnabledChangeRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ShuffleEnabledChangeRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_ShuffleEnabledChangeRequestedEventArgs(py::wrapper::Windows::Media::ShuffleEnabledChangeRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ShuffleEnabledChangeRequestedEventArgs_get_RequestedShuffleEnabled(py::wrapper::Windows::Media::ShuffleEnabledChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.ShuffleEnabledChangeRequestedEventArgs", L"RequestedShuffleEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestedShuffleEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ShuffleEnabledChangeRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::ShuffleEnabledChangeRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ShuffleEnabledChangeRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::ShuffleEnabledChangeRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShuffleEnabledChangeRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_ShuffleEnabledChangeRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ShuffleEnabledChangeRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ShuffleEnabledChangeRequestedEventArgs[] = {
        { "requested_shuffle_enabled", reinterpret_cast<getter>(ShuffleEnabledChangeRequestedEventArgs_get_RequestedShuffleEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ShuffleEnabledChangeRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ShuffleEnabledChangeRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ShuffleEnabledChangeRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ShuffleEnabledChangeRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ShuffleEnabledChangeRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ShuffleEnabledChangeRequestedEventArgs =
    {
        "_winsdk_Windows_Media.ShuffleEnabledChangeRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::ShuffleEnabledChangeRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShuffleEnabledChangeRequestedEventArgs
    };

    // ----- SystemMediaTransportControls class --------------------
    static constexpr const char* const type_name_SystemMediaTransportControls = "SystemMediaTransportControls";

    static PyObject* _new_SystemMediaTransportControls(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SystemMediaTransportControls);
        return nullptr;
    }

    static void _dealloc_SystemMediaTransportControls(py::wrapper::Windows::Media::SystemMediaTransportControls* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemMediaTransportControls_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SystemMediaTransportControls", L"GetForCurrentView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::SystemMediaTransportControls::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_UpdateTimelineProperties(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SystemMediaTransportControls", L"UpdateTimelineProperties", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties>(args, 0);

                self->obj.UpdateTimelineProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_get_IsPlayEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"IsPlayEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPlayEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_IsPlayEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"IsPlayEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPlayEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_IsPauseEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"IsPauseEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPauseEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_IsPauseEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"IsPauseEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPauseEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_IsNextEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"IsNextEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsNextEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_IsNextEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"IsNextEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsNextEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_IsPreviousEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"IsPreviousEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPreviousEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_IsPreviousEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"IsPreviousEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPreviousEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_IsEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_IsEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_IsChannelDownEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"IsChannelDownEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsChannelDownEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_IsChannelDownEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"IsChannelDownEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsChannelDownEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_IsFastForwardEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"IsFastForwardEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsFastForwardEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_IsFastForwardEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"IsFastForwardEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsFastForwardEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_IsChannelUpEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"IsChannelUpEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsChannelUpEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_IsChannelUpEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"IsChannelUpEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsChannelUpEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_PlaybackStatus(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"PlaybackStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_PlaybackStatus(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"PlaybackStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaPlaybackStatus>(arg);

            self->obj.PlaybackStatus(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_IsStopEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"IsStopEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStopEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_IsStopEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"IsStopEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsStopEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_IsRewindEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"IsRewindEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRewindEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_IsRewindEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"IsRewindEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRewindEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_IsRecordEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"IsRecordEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRecordEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_IsRecordEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"IsRecordEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRecordEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_DisplayUpdater(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"DisplayUpdater"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayUpdater());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_get_SoundLevel(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"SoundLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SoundLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_get_ShuffleEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"ShuffleEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShuffleEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_ShuffleEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"ShuffleEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShuffleEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_PlaybackRate(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"PlaybackRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_PlaybackRate(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"PlaybackRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.PlaybackRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_AutoRepeatMode(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"AutoRepeatMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoRepeatMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_AutoRepeatMode(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControls", L"AutoRepeatMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaPlaybackAutoRepeatMode>(arg);

            self->obj.AutoRepeatMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_add_ButtonPressed(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SystemMediaTransportControls", L"ButtonPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SystemMediaTransportControls, winrt::Windows::Media::SystemMediaTransportControlsButtonPressedEventArgs>>(arg);

            return py::convert(self->obj.ButtonPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_remove_ButtonPressed(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SystemMediaTransportControls", L"ButtonPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ButtonPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_add_PropertyChanged(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SystemMediaTransportControls", L"PropertyChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SystemMediaTransportControls, winrt::Windows::Media::SystemMediaTransportControlsPropertyChangedEventArgs>>(arg);

            return py::convert(self->obj.PropertyChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_remove_PropertyChanged(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SystemMediaTransportControls", L"PropertyChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PropertyChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_add_AutoRepeatModeChangeRequested(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SystemMediaTransportControls", L"AutoRepeatModeChangeRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SystemMediaTransportControls, winrt::Windows::Media::AutoRepeatModeChangeRequestedEventArgs>>(arg);

            return py::convert(self->obj.AutoRepeatModeChangeRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_remove_AutoRepeatModeChangeRequested(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SystemMediaTransportControls", L"AutoRepeatModeChangeRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AutoRepeatModeChangeRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_add_PlaybackPositionChangeRequested(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SystemMediaTransportControls", L"PlaybackPositionChangeRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SystemMediaTransportControls, winrt::Windows::Media::PlaybackPositionChangeRequestedEventArgs>>(arg);

            return py::convert(self->obj.PlaybackPositionChangeRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_remove_PlaybackPositionChangeRequested(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SystemMediaTransportControls", L"PlaybackPositionChangeRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PlaybackPositionChangeRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_add_PlaybackRateChangeRequested(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SystemMediaTransportControls", L"PlaybackRateChangeRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SystemMediaTransportControls, winrt::Windows::Media::PlaybackRateChangeRequestedEventArgs>>(arg);

            return py::convert(self->obj.PlaybackRateChangeRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_remove_PlaybackRateChangeRequested(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SystemMediaTransportControls", L"PlaybackRateChangeRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PlaybackRateChangeRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_add_ShuffleEnabledChangeRequested(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SystemMediaTransportControls", L"ShuffleEnabledChangeRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SystemMediaTransportControls, winrt::Windows::Media::ShuffleEnabledChangeRequestedEventArgs>>(arg);

            return py::convert(self->obj.ShuffleEnabledChangeRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_remove_ShuffleEnabledChangeRequested(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SystemMediaTransportControls", L"ShuffleEnabledChangeRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ShuffleEnabledChangeRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemMediaTransportControls(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SystemMediaTransportControls>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemMediaTransportControls(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SystemMediaTransportControls>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMediaTransportControls[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(SystemMediaTransportControls_GetForCurrentView), METH_VARARGS | METH_STATIC, nullptr },
        { "update_timeline_properties", reinterpret_cast<PyCFunction>(SystemMediaTransportControls_UpdateTimelineProperties), METH_VARARGS, nullptr },
        { "add_button_pressed", reinterpret_cast<PyCFunction>(SystemMediaTransportControls_add_ButtonPressed), METH_O, nullptr },
        { "remove_button_pressed", reinterpret_cast<PyCFunction>(SystemMediaTransportControls_remove_ButtonPressed), METH_O, nullptr },
        { "add_property_changed", reinterpret_cast<PyCFunction>(SystemMediaTransportControls_add_PropertyChanged), METH_O, nullptr },
        { "remove_property_changed", reinterpret_cast<PyCFunction>(SystemMediaTransportControls_remove_PropertyChanged), METH_O, nullptr },
        { "add_auto_repeat_mode_change_requested", reinterpret_cast<PyCFunction>(SystemMediaTransportControls_add_AutoRepeatModeChangeRequested), METH_O, nullptr },
        { "remove_auto_repeat_mode_change_requested", reinterpret_cast<PyCFunction>(SystemMediaTransportControls_remove_AutoRepeatModeChangeRequested), METH_O, nullptr },
        { "add_playback_position_change_requested", reinterpret_cast<PyCFunction>(SystemMediaTransportControls_add_PlaybackPositionChangeRequested), METH_O, nullptr },
        { "remove_playback_position_change_requested", reinterpret_cast<PyCFunction>(SystemMediaTransportControls_remove_PlaybackPositionChangeRequested), METH_O, nullptr },
        { "add_playback_rate_change_requested", reinterpret_cast<PyCFunction>(SystemMediaTransportControls_add_PlaybackRateChangeRequested), METH_O, nullptr },
        { "remove_playback_rate_change_requested", reinterpret_cast<PyCFunction>(SystemMediaTransportControls_remove_PlaybackRateChangeRequested), METH_O, nullptr },
        { "add_shuffle_enabled_change_requested", reinterpret_cast<PyCFunction>(SystemMediaTransportControls_add_ShuffleEnabledChangeRequested), METH_O, nullptr },
        { "remove_shuffle_enabled_change_requested", reinterpret_cast<PyCFunction>(SystemMediaTransportControls_remove_ShuffleEnabledChangeRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_SystemMediaTransportControls, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemMediaTransportControls), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemMediaTransportControls[] = {
        { "is_play_enabled", reinterpret_cast<getter>(SystemMediaTransportControls_get_IsPlayEnabled), reinterpret_cast<setter>(SystemMediaTransportControls_put_IsPlayEnabled), nullptr, nullptr },
        { "is_pause_enabled", reinterpret_cast<getter>(SystemMediaTransportControls_get_IsPauseEnabled), reinterpret_cast<setter>(SystemMediaTransportControls_put_IsPauseEnabled), nullptr, nullptr },
        { "is_next_enabled", reinterpret_cast<getter>(SystemMediaTransportControls_get_IsNextEnabled), reinterpret_cast<setter>(SystemMediaTransportControls_put_IsNextEnabled), nullptr, nullptr },
        { "is_previous_enabled", reinterpret_cast<getter>(SystemMediaTransportControls_get_IsPreviousEnabled), reinterpret_cast<setter>(SystemMediaTransportControls_put_IsPreviousEnabled), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(SystemMediaTransportControls_get_IsEnabled), reinterpret_cast<setter>(SystemMediaTransportControls_put_IsEnabled), nullptr, nullptr },
        { "is_channel_down_enabled", reinterpret_cast<getter>(SystemMediaTransportControls_get_IsChannelDownEnabled), reinterpret_cast<setter>(SystemMediaTransportControls_put_IsChannelDownEnabled), nullptr, nullptr },
        { "is_fast_forward_enabled", reinterpret_cast<getter>(SystemMediaTransportControls_get_IsFastForwardEnabled), reinterpret_cast<setter>(SystemMediaTransportControls_put_IsFastForwardEnabled), nullptr, nullptr },
        { "is_channel_up_enabled", reinterpret_cast<getter>(SystemMediaTransportControls_get_IsChannelUpEnabled), reinterpret_cast<setter>(SystemMediaTransportControls_put_IsChannelUpEnabled), nullptr, nullptr },
        { "playback_status", reinterpret_cast<getter>(SystemMediaTransportControls_get_PlaybackStatus), reinterpret_cast<setter>(SystemMediaTransportControls_put_PlaybackStatus), nullptr, nullptr },
        { "is_stop_enabled", reinterpret_cast<getter>(SystemMediaTransportControls_get_IsStopEnabled), reinterpret_cast<setter>(SystemMediaTransportControls_put_IsStopEnabled), nullptr, nullptr },
        { "is_rewind_enabled", reinterpret_cast<getter>(SystemMediaTransportControls_get_IsRewindEnabled), reinterpret_cast<setter>(SystemMediaTransportControls_put_IsRewindEnabled), nullptr, nullptr },
        { "is_record_enabled", reinterpret_cast<getter>(SystemMediaTransportControls_get_IsRecordEnabled), reinterpret_cast<setter>(SystemMediaTransportControls_put_IsRecordEnabled), nullptr, nullptr },
        { "display_updater", reinterpret_cast<getter>(SystemMediaTransportControls_get_DisplayUpdater), nullptr, nullptr, nullptr },
        { "sound_level", reinterpret_cast<getter>(SystemMediaTransportControls_get_SoundLevel), nullptr, nullptr, nullptr },
        { "shuffle_enabled", reinterpret_cast<getter>(SystemMediaTransportControls_get_ShuffleEnabled), reinterpret_cast<setter>(SystemMediaTransportControls_put_ShuffleEnabled), nullptr, nullptr },
        { "playback_rate", reinterpret_cast<getter>(SystemMediaTransportControls_get_PlaybackRate), reinterpret_cast<setter>(SystemMediaTransportControls_put_PlaybackRate), nullptr, nullptr },
        { "auto_repeat_mode", reinterpret_cast<getter>(SystemMediaTransportControls_get_AutoRepeatMode), reinterpret_cast<setter>(SystemMediaTransportControls_put_AutoRepeatMode), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemMediaTransportControls[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemMediaTransportControls) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemMediaTransportControls) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemMediaTransportControls) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemMediaTransportControls) },
        { },
    };

    static PyType_Spec type_spec_SystemMediaTransportControls =
    {
        "_winsdk_Windows_Media.SystemMediaTransportControls",
        sizeof(py::wrapper::Windows::Media::SystemMediaTransportControls),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMediaTransportControls
    };

    // ----- SystemMediaTransportControlsButtonPressedEventArgs class --------------------
    static constexpr const char* const type_name_SystemMediaTransportControlsButtonPressedEventArgs = "SystemMediaTransportControlsButtonPressedEventArgs";

    static PyObject* _new_SystemMediaTransportControlsButtonPressedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SystemMediaTransportControlsButtonPressedEventArgs);
        return nullptr;
    }

    static void _dealloc_SystemMediaTransportControlsButtonPressedEventArgs(py::wrapper::Windows::Media::SystemMediaTransportControlsButtonPressedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemMediaTransportControlsButtonPressedEventArgs_get_Button(py::wrapper::Windows::Media::SystemMediaTransportControlsButtonPressedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControlsButtonPressedEventArgs", L"Button"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Button());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemMediaTransportControlsButtonPressedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SystemMediaTransportControlsButtonPressedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemMediaTransportControlsButtonPressedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SystemMediaTransportControlsButtonPressedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMediaTransportControlsButtonPressedEventArgs[] = {
        { "_assign_array_", _assign_array_SystemMediaTransportControlsButtonPressedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemMediaTransportControlsButtonPressedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemMediaTransportControlsButtonPressedEventArgs[] = {
        { "button", reinterpret_cast<getter>(SystemMediaTransportControlsButtonPressedEventArgs_get_Button), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemMediaTransportControlsButtonPressedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemMediaTransportControlsButtonPressedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemMediaTransportControlsButtonPressedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemMediaTransportControlsButtonPressedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemMediaTransportControlsButtonPressedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SystemMediaTransportControlsButtonPressedEventArgs =
    {
        "_winsdk_Windows_Media.SystemMediaTransportControlsButtonPressedEventArgs",
        sizeof(py::wrapper::Windows::Media::SystemMediaTransportControlsButtonPressedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMediaTransportControlsButtonPressedEventArgs
    };

    // ----- SystemMediaTransportControlsDisplayUpdater class --------------------
    static constexpr const char* const type_name_SystemMediaTransportControlsDisplayUpdater = "SystemMediaTransportControlsDisplayUpdater";

    static PyObject* _new_SystemMediaTransportControlsDisplayUpdater(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SystemMediaTransportControlsDisplayUpdater);
        return nullptr;
    }

    static void _dealloc_SystemMediaTransportControlsDisplayUpdater(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemMediaTransportControlsDisplayUpdater_ClearAll(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SystemMediaTransportControlsDisplayUpdater", L"ClearAll", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ClearAll();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControlsDisplayUpdater_CopyFromFileAsync(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SystemMediaTransportControlsDisplayUpdater", L"CopyFromFileAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaPlaybackType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 1);

                return py::convert(self->obj.CopyFromFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControlsDisplayUpdater_Update(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SystemMediaTransportControlsDisplayUpdater", L"Update", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Update();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControlsDisplayUpdater_get_Type(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControlsDisplayUpdater", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControlsDisplayUpdater_put_Type(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControlsDisplayUpdater", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaPlaybackType>(arg);

            self->obj.Type(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControlsDisplayUpdater_get_Thumbnail(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControlsDisplayUpdater", L"Thumbnail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControlsDisplayUpdater_put_Thumbnail(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControlsDisplayUpdater", L"Thumbnail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::RandomAccessStreamReference>(arg);

            self->obj.Thumbnail(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControlsDisplayUpdater_get_AppMediaId(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControlsDisplayUpdater", L"AppMediaId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppMediaId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControlsDisplayUpdater_put_AppMediaId(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControlsDisplayUpdater", L"AppMediaId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AppMediaId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControlsDisplayUpdater_get_ImageProperties(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControlsDisplayUpdater", L"ImageProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ImageProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControlsDisplayUpdater_get_MusicProperties(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControlsDisplayUpdater", L"MusicProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MusicProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControlsDisplayUpdater_get_VideoProperties(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControlsDisplayUpdater", L"VideoProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemMediaTransportControlsDisplayUpdater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SystemMediaTransportControlsDisplayUpdater>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemMediaTransportControlsDisplayUpdater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SystemMediaTransportControlsDisplayUpdater>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMediaTransportControlsDisplayUpdater[] = {
        { "clear_all", reinterpret_cast<PyCFunction>(SystemMediaTransportControlsDisplayUpdater_ClearAll), METH_VARARGS, nullptr },
        { "copy_from_file_async", reinterpret_cast<PyCFunction>(SystemMediaTransportControlsDisplayUpdater_CopyFromFileAsync), METH_VARARGS, nullptr },
        { "update", reinterpret_cast<PyCFunction>(SystemMediaTransportControlsDisplayUpdater_Update), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SystemMediaTransportControlsDisplayUpdater, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemMediaTransportControlsDisplayUpdater), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemMediaTransportControlsDisplayUpdater[] = {
        { "type", reinterpret_cast<getter>(SystemMediaTransportControlsDisplayUpdater_get_Type), reinterpret_cast<setter>(SystemMediaTransportControlsDisplayUpdater_put_Type), nullptr, nullptr },
        { "thumbnail", reinterpret_cast<getter>(SystemMediaTransportControlsDisplayUpdater_get_Thumbnail), reinterpret_cast<setter>(SystemMediaTransportControlsDisplayUpdater_put_Thumbnail), nullptr, nullptr },
        { "app_media_id", reinterpret_cast<getter>(SystemMediaTransportControlsDisplayUpdater_get_AppMediaId), reinterpret_cast<setter>(SystemMediaTransportControlsDisplayUpdater_put_AppMediaId), nullptr, nullptr },
        { "image_properties", reinterpret_cast<getter>(SystemMediaTransportControlsDisplayUpdater_get_ImageProperties), nullptr, nullptr, nullptr },
        { "music_properties", reinterpret_cast<getter>(SystemMediaTransportControlsDisplayUpdater_get_MusicProperties), nullptr, nullptr, nullptr },
        { "video_properties", reinterpret_cast<getter>(SystemMediaTransportControlsDisplayUpdater_get_VideoProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemMediaTransportControlsDisplayUpdater[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemMediaTransportControlsDisplayUpdater) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemMediaTransportControlsDisplayUpdater) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemMediaTransportControlsDisplayUpdater) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemMediaTransportControlsDisplayUpdater) },
        { },
    };

    static PyType_Spec type_spec_SystemMediaTransportControlsDisplayUpdater =
    {
        "_winsdk_Windows_Media.SystemMediaTransportControlsDisplayUpdater",
        sizeof(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMediaTransportControlsDisplayUpdater
    };

    // ----- SystemMediaTransportControlsPropertyChangedEventArgs class --------------------
    static constexpr const char* const type_name_SystemMediaTransportControlsPropertyChangedEventArgs = "SystemMediaTransportControlsPropertyChangedEventArgs";

    static PyObject* _new_SystemMediaTransportControlsPropertyChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SystemMediaTransportControlsPropertyChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_SystemMediaTransportControlsPropertyChangedEventArgs(py::wrapper::Windows::Media::SystemMediaTransportControlsPropertyChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemMediaTransportControlsPropertyChangedEventArgs_get_Property(py::wrapper::Windows::Media::SystemMediaTransportControlsPropertyChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControlsPropertyChangedEventArgs", L"Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemMediaTransportControlsPropertyChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SystemMediaTransportControlsPropertyChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemMediaTransportControlsPropertyChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SystemMediaTransportControlsPropertyChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMediaTransportControlsPropertyChangedEventArgs[] = {
        { "_assign_array_", _assign_array_SystemMediaTransportControlsPropertyChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemMediaTransportControlsPropertyChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemMediaTransportControlsPropertyChangedEventArgs[] = {
        { "property", reinterpret_cast<getter>(SystemMediaTransportControlsPropertyChangedEventArgs_get_Property), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemMediaTransportControlsPropertyChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemMediaTransportControlsPropertyChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemMediaTransportControlsPropertyChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemMediaTransportControlsPropertyChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemMediaTransportControlsPropertyChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SystemMediaTransportControlsPropertyChangedEventArgs =
    {
        "_winsdk_Windows_Media.SystemMediaTransportControlsPropertyChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::SystemMediaTransportControlsPropertyChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMediaTransportControlsPropertyChangedEventArgs
    };

    // ----- SystemMediaTransportControlsTimelineProperties class --------------------
    static constexpr const char* const type_name_SystemMediaTransportControlsTimelineProperties = "SystemMediaTransportControlsTimelineProperties";

    static PyObject* _new_SystemMediaTransportControlsTimelineProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SystemMediaTransportControlsTimelineProperties(py::wrapper::Windows::Media::SystemMediaTransportControlsTimelineProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemMediaTransportControlsTimelineProperties_get_StartTime(py::wrapper::Windows::Media::SystemMediaTransportControlsTimelineProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControlsTimelineProperties", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControlsTimelineProperties_put_StartTime(py::wrapper::Windows::Media::SystemMediaTransportControlsTimelineProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControlsTimelineProperties", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControlsTimelineProperties_get_Position(py::wrapper::Windows::Media::SystemMediaTransportControlsTimelineProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControlsTimelineProperties", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControlsTimelineProperties_put_Position(py::wrapper::Windows::Media::SystemMediaTransportControlsTimelineProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControlsTimelineProperties", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControlsTimelineProperties_get_MinSeekTime(py::wrapper::Windows::Media::SystemMediaTransportControlsTimelineProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControlsTimelineProperties", L"MinSeekTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinSeekTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControlsTimelineProperties_put_MinSeekTime(py::wrapper::Windows::Media::SystemMediaTransportControlsTimelineProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControlsTimelineProperties", L"MinSeekTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.MinSeekTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControlsTimelineProperties_get_MaxSeekTime(py::wrapper::Windows::Media::SystemMediaTransportControlsTimelineProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControlsTimelineProperties", L"MaxSeekTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxSeekTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControlsTimelineProperties_put_MaxSeekTime(py::wrapper::Windows::Media::SystemMediaTransportControlsTimelineProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControlsTimelineProperties", L"MaxSeekTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.MaxSeekTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControlsTimelineProperties_get_EndTime(py::wrapper::Windows::Media::SystemMediaTransportControlsTimelineProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControlsTimelineProperties", L"EndTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControlsTimelineProperties_put_EndTime(py::wrapper::Windows::Media::SystemMediaTransportControlsTimelineProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SystemMediaTransportControlsTimelineProperties", L"EndTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.EndTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SystemMediaTransportControlsTimelineProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemMediaTransportControlsTimelineProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMediaTransportControlsTimelineProperties[] = {
        { "_assign_array_", _assign_array_SystemMediaTransportControlsTimelineProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemMediaTransportControlsTimelineProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemMediaTransportControlsTimelineProperties[] = {
        { "start_time", reinterpret_cast<getter>(SystemMediaTransportControlsTimelineProperties_get_StartTime), reinterpret_cast<setter>(SystemMediaTransportControlsTimelineProperties_put_StartTime), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(SystemMediaTransportControlsTimelineProperties_get_Position), reinterpret_cast<setter>(SystemMediaTransportControlsTimelineProperties_put_Position), nullptr, nullptr },
        { "min_seek_time", reinterpret_cast<getter>(SystemMediaTransportControlsTimelineProperties_get_MinSeekTime), reinterpret_cast<setter>(SystemMediaTransportControlsTimelineProperties_put_MinSeekTime), nullptr, nullptr },
        { "max_seek_time", reinterpret_cast<getter>(SystemMediaTransportControlsTimelineProperties_get_MaxSeekTime), reinterpret_cast<setter>(SystemMediaTransportControlsTimelineProperties_put_MaxSeekTime), nullptr, nullptr },
        { "end_time", reinterpret_cast<getter>(SystemMediaTransportControlsTimelineProperties_get_EndTime), reinterpret_cast<setter>(SystemMediaTransportControlsTimelineProperties_put_EndTime), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemMediaTransportControlsTimelineProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemMediaTransportControlsTimelineProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemMediaTransportControlsTimelineProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemMediaTransportControlsTimelineProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemMediaTransportControlsTimelineProperties) },
        { },
    };

    static PyType_Spec type_spec_SystemMediaTransportControlsTimelineProperties =
    {
        "_winsdk_Windows_Media.SystemMediaTransportControlsTimelineProperties",
        sizeof(py::wrapper::Windows::Media::SystemMediaTransportControlsTimelineProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMediaTransportControlsTimelineProperties
    };

    // ----- VideoDisplayProperties class --------------------
    static constexpr const char* const type_name_VideoDisplayProperties = "VideoDisplayProperties";

    static PyObject* _new_VideoDisplayProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_VideoDisplayProperties);
        return nullptr;
    }

    static void _dealloc_VideoDisplayProperties(py::wrapper::Windows::Media::VideoDisplayProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoDisplayProperties_get_Title(py::wrapper::Windows::Media::VideoDisplayProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.VideoDisplayProperties", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoDisplayProperties_put_Title(py::wrapper::Windows::Media::VideoDisplayProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.VideoDisplayProperties", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoDisplayProperties_get_Subtitle(py::wrapper::Windows::Media::VideoDisplayProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.VideoDisplayProperties", L"Subtitle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Subtitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoDisplayProperties_put_Subtitle(py::wrapper::Windows::Media::VideoDisplayProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.VideoDisplayProperties", L"Subtitle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtitle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoDisplayProperties_get_Genres(py::wrapper::Windows::Media::VideoDisplayProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.VideoDisplayProperties", L"Genres"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Genres());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoDisplayProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::VideoDisplayProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoDisplayProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::VideoDisplayProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoDisplayProperties[] = {
        { "_assign_array_", _assign_array_VideoDisplayProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoDisplayProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoDisplayProperties[] = {
        { "title", reinterpret_cast<getter>(VideoDisplayProperties_get_Title), reinterpret_cast<setter>(VideoDisplayProperties_put_Title), nullptr, nullptr },
        { "subtitle", reinterpret_cast<getter>(VideoDisplayProperties_get_Subtitle), reinterpret_cast<setter>(VideoDisplayProperties_put_Subtitle), nullptr, nullptr },
        { "genres", reinterpret_cast<getter>(VideoDisplayProperties_get_Genres), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoDisplayProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoDisplayProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoDisplayProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoDisplayProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoDisplayProperties) },
        { },
    };

    static PyType_Spec type_spec_VideoDisplayProperties =
    {
        "_winsdk_Windows_Media.VideoDisplayProperties",
        sizeof(py::wrapper::Windows::Media::VideoDisplayProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoDisplayProperties
    };

    // ----- VideoEffects class --------------------
    static constexpr const char* const type_name_VideoEffects = "VideoEffects";

    static PyObject* _new_VideoEffects(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_VideoEffects);
        return nullptr;
    }

    static PyObject* VideoEffects_get_VideoStabilization(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.VideoEffects", L"VideoStabilization"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::VideoEffects::VideoStabilization());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoEffects[] = {
        { }
    };

    static PyGetSetDef _getset_VideoEffects[] = {
        { }
    };

    static PyType_Slot _type_slots_VideoEffects[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoEffects) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoEffects) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoEffects) },
        { },
    };

    static PyType_Spec type_spec_VideoEffects =
    {
        "_winsdk_Windows_Media.VideoEffects",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoEffects
    };

    static PyGetSetDef getset_VideoEffects_Meta[] = {
        { "video_stabilization", reinterpret_cast<getter>(VideoEffects_get_VideoStabilization), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_VideoEffects_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_VideoEffects_Meta) },
        { }
    };

    static PyType_Spec type_spec_VideoEffects_Meta =
    {
        "_winsdk_Windows_Media.VideoEffects_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_VideoEffects_Meta
    };

    // ----- VideoFrame class --------------------
    static constexpr const char* const type_name_VideoFrame = "VideoFrame";

    static PyObject* _new_VideoFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                winrt::Windows::Media::VideoFrame instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 3);

                winrt::Windows::Media::VideoFrame instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VideoFrame(py::wrapper::Windows::Media::VideoFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoFrame_Close(py::wrapper::Windows::Media::VideoFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.VideoFrame", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoFrame_CopyToAsync(py::wrapper::Windows::Media::VideoFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.VideoFrame", L"CopyToAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::VideoFrame>(args, 0);

                return py::convert(self->obj.CopyToAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.VideoFrame", L"CopyToAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::VideoFrame>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Graphics::Imaging::BitmapBounds>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Graphics::Imaging::BitmapBounds>>(args, 2);

                return py::convert(self->obj.CopyToAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoFrame_CreateAsDirect3D11SurfaceBacked(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.VideoFrame", L"CreateAsDirect3D11SurfaceBacked", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXPixelFormat>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                return py::convert(winrt::Windows::Media::VideoFrame::CreateAsDirect3D11SurfaceBacked(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.VideoFrame", L"CreateAsDirect3D11SurfaceBacked", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXPixelFormat>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DDevice>(args, 3);

                return py::convert(winrt::Windows::Media::VideoFrame::CreateAsDirect3D11SurfaceBacked(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoFrame_CreateWithDirect3D11Surface(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.VideoFrame", L"CreateWithDirect3D11Surface", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);

                return py::convert(winrt::Windows::Media::VideoFrame::CreateWithDirect3D11Surface(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoFrame_CreateWithSoftwareBitmap(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.VideoFrame", L"CreateWithSoftwareBitmap", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);

                return py::convert(winrt::Windows::Media::VideoFrame::CreateWithSoftwareBitmap(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoFrame_get_SystemRelativeTime(py::wrapper::Windows::Media::VideoFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.VideoFrame", L"SystemRelativeTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SystemRelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoFrame_put_SystemRelativeTime(py::wrapper::Windows::Media::VideoFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.VideoFrame", L"SystemRelativeTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.SystemRelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoFrame_get_RelativeTime(py::wrapper::Windows::Media::VideoFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.VideoFrame", L"RelativeTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoFrame_put_RelativeTime(py::wrapper::Windows::Media::VideoFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.VideoFrame", L"RelativeTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.RelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoFrame_get_IsDiscontinuous(py::wrapper::Windows::Media::VideoFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.VideoFrame", L"IsDiscontinuous"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDiscontinuous());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoFrame_put_IsDiscontinuous(py::wrapper::Windows::Media::VideoFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.VideoFrame", L"IsDiscontinuous"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDiscontinuous(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoFrame_get_Duration(py::wrapper::Windows::Media::VideoFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.VideoFrame", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoFrame_put_Duration(py::wrapper::Windows::Media::VideoFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.VideoFrame", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoFrame_get_ExtendedProperties(py::wrapper::Windows::Media::VideoFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.VideoFrame", L"ExtendedProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoFrame_get_IsReadOnly(py::wrapper::Windows::Media::VideoFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.VideoFrame", L"IsReadOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoFrame_get_Type(py::wrapper::Windows::Media::VideoFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.VideoFrame", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoFrame_get_Direct3DSurface(py::wrapper::Windows::Media::VideoFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.VideoFrame", L"Direct3DSurface"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Direct3DSurface());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoFrame_get_SoftwareBitmap(py::wrapper::Windows::Media::VideoFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.VideoFrame", L"SoftwareBitmap"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SoftwareBitmap());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::VideoFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::VideoFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_VideoFrame(py::wrapper::Windows::Media::VideoFrame* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_VideoFrame(py::wrapper::Windows::Media::VideoFrame* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoFrame[] = {
        { "close", reinterpret_cast<PyCFunction>(VideoFrame_Close), METH_VARARGS, nullptr },
        { "copy_to_async", reinterpret_cast<PyCFunction>(VideoFrame_CopyToAsync), METH_VARARGS, nullptr },
        { "create_as_direct3_d11_surface_backed", reinterpret_cast<PyCFunction>(VideoFrame_CreateAsDirect3D11SurfaceBacked), METH_VARARGS | METH_STATIC, nullptr },
        { "create_with_direct3_d11_surface", reinterpret_cast<PyCFunction>(VideoFrame_CreateWithDirect3D11Surface), METH_VARARGS | METH_STATIC, nullptr },
        { "create_with_software_bitmap", reinterpret_cast<PyCFunction>(VideoFrame_CreateWithSoftwareBitmap), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_VideoFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoFrame), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_VideoFrame), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_VideoFrame), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoFrame[] = {
        { "system_relative_time", reinterpret_cast<getter>(VideoFrame_get_SystemRelativeTime), reinterpret_cast<setter>(VideoFrame_put_SystemRelativeTime), nullptr, nullptr },
        { "relative_time", reinterpret_cast<getter>(VideoFrame_get_RelativeTime), reinterpret_cast<setter>(VideoFrame_put_RelativeTime), nullptr, nullptr },
        { "is_discontinuous", reinterpret_cast<getter>(VideoFrame_get_IsDiscontinuous), reinterpret_cast<setter>(VideoFrame_put_IsDiscontinuous), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(VideoFrame_get_Duration), reinterpret_cast<setter>(VideoFrame_put_Duration), nullptr, nullptr },
        { "extended_properties", reinterpret_cast<getter>(VideoFrame_get_ExtendedProperties), nullptr, nullptr, nullptr },
        { "is_read_only", reinterpret_cast<getter>(VideoFrame_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(VideoFrame_get_Type), nullptr, nullptr, nullptr },
        { "direct3_d_surface", reinterpret_cast<getter>(VideoFrame_get_Direct3DSurface), nullptr, nullptr, nullptr },
        { "software_bitmap", reinterpret_cast<getter>(VideoFrame_get_SoftwareBitmap), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoFrame) },
        { },
    };

    static PyType_Spec type_spec_VideoFrame =
    {
        "_winsdk_Windows_Media.VideoFrame",
        sizeof(py::wrapper::Windows::Media::VideoFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoFrame
    };

    // ----- IMediaExtension interface --------------------
    static constexpr const char* const type_name_IMediaExtension = "IMediaExtension";

    static PyObject* _new_IMediaExtension(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IMediaExtension);
        return nullptr;
    }

    static void _dealloc_IMediaExtension(py::wrapper::Windows::Media::IMediaExtension* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMediaExtension_SetProperties(py::wrapper::Windows::Media::IMediaExtension* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.IMediaExtension", L"SetProperties", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                self->obj.SetProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IMediaExtension(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::IMediaExtension>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMediaExtension(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::IMediaExtension>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaExtension[] = {
        { "set_properties", reinterpret_cast<PyCFunction>(IMediaExtension_SetProperties), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IMediaExtension, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaExtension), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaExtension[] = {
        { }
    };

    static PyType_Slot _type_slots_IMediaExtension[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMediaExtension) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMediaExtension) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMediaExtension) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMediaExtension) },
        { },
    };

    static PyType_Spec type_spec_IMediaExtension =
    {
        "_winsdk_Windows_Media.IMediaExtension",
        sizeof(py::wrapper::Windows::Media::IMediaExtension),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaExtension
    };

    // ----- IMediaFrame interface --------------------
    static constexpr const char* const type_name_IMediaFrame = "IMediaFrame";

    static PyObject* _new_IMediaFrame(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IMediaFrame);
        return nullptr;
    }

    static void _dealloc_IMediaFrame(py::wrapper::Windows::Media::IMediaFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMediaFrame_Close(py::wrapper::Windows::Media::IMediaFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMediaFrame_get_Duration(py::wrapper::Windows::Media::IMediaFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.IMediaFrame", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaFrame_put_Duration(py::wrapper::Windows::Media::IMediaFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.IMediaFrame", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaFrame_get_ExtendedProperties(py::wrapper::Windows::Media::IMediaFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.IMediaFrame", L"ExtendedProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaFrame_get_IsDiscontinuous(py::wrapper::Windows::Media::IMediaFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.IMediaFrame", L"IsDiscontinuous"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDiscontinuous());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaFrame_put_IsDiscontinuous(py::wrapper::Windows::Media::IMediaFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.IMediaFrame", L"IsDiscontinuous"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDiscontinuous(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaFrame_get_IsReadOnly(py::wrapper::Windows::Media::IMediaFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.IMediaFrame", L"IsReadOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaFrame_get_RelativeTime(py::wrapper::Windows::Media::IMediaFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.IMediaFrame", L"RelativeTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaFrame_put_RelativeTime(py::wrapper::Windows::Media::IMediaFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.IMediaFrame", L"RelativeTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.RelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaFrame_get_SystemRelativeTime(py::wrapper::Windows::Media::IMediaFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.IMediaFrame", L"SystemRelativeTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SystemRelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaFrame_put_SystemRelativeTime(py::wrapper::Windows::Media::IMediaFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.IMediaFrame", L"SystemRelativeTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.SystemRelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaFrame_get_Type(py::wrapper::Windows::Media::IMediaFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.IMediaFrame", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IMediaFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::IMediaFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMediaFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::IMediaFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IMediaFrame(py::wrapper::Windows::Media::IMediaFrame* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_IMediaFrame(py::wrapper::Windows::Media::IMediaFrame* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaFrame[] = {
        { "close", reinterpret_cast<PyCFunction>(IMediaFrame_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IMediaFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaFrame), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IMediaFrame), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IMediaFrame), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaFrame[] = {
        { "duration", reinterpret_cast<getter>(IMediaFrame_get_Duration), reinterpret_cast<setter>(IMediaFrame_put_Duration), nullptr, nullptr },
        { "extended_properties", reinterpret_cast<getter>(IMediaFrame_get_ExtendedProperties), nullptr, nullptr, nullptr },
        { "is_discontinuous", reinterpret_cast<getter>(IMediaFrame_get_IsDiscontinuous), reinterpret_cast<setter>(IMediaFrame_put_IsDiscontinuous), nullptr, nullptr },
        { "is_read_only", reinterpret_cast<getter>(IMediaFrame_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "relative_time", reinterpret_cast<getter>(IMediaFrame_get_RelativeTime), reinterpret_cast<setter>(IMediaFrame_put_RelativeTime), nullptr, nullptr },
        { "system_relative_time", reinterpret_cast<getter>(IMediaFrame_get_SystemRelativeTime), reinterpret_cast<setter>(IMediaFrame_put_SystemRelativeTime), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(IMediaFrame_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMediaFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMediaFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMediaFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMediaFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMediaFrame) },
        { },
    };

    static PyType_Spec type_spec_IMediaFrame =
    {
        "_winsdk_Windows_Media.IMediaFrame",
        sizeof(py::wrapper::Windows::Media::IMediaFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaFrame
    };

    // ----- IMediaMarker interface --------------------
    static constexpr const char* const type_name_IMediaMarker = "IMediaMarker";

    static PyObject* _new_IMediaMarker(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IMediaMarker);
        return nullptr;
    }

    static void _dealloc_IMediaMarker(py::wrapper::Windows::Media::IMediaMarker* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMediaMarker_get_MediaMarkerType(py::wrapper::Windows::Media::IMediaMarker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.IMediaMarker", L"MediaMarkerType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MediaMarkerType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaMarker_get_Text(py::wrapper::Windows::Media::IMediaMarker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.IMediaMarker", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaMarker_get_Time(py::wrapper::Windows::Media::IMediaMarker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.IMediaMarker", L"Time"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Time());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IMediaMarker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::IMediaMarker>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMediaMarker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::IMediaMarker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaMarker[] = {
        { "_assign_array_", _assign_array_IMediaMarker, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaMarker), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaMarker[] = {
        { "media_marker_type", reinterpret_cast<getter>(IMediaMarker_get_MediaMarkerType), nullptr, nullptr, nullptr },
        { "text", reinterpret_cast<getter>(IMediaMarker_get_Text), nullptr, nullptr, nullptr },
        { "time", reinterpret_cast<getter>(IMediaMarker_get_Time), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMediaMarker[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMediaMarker) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMediaMarker) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMediaMarker) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMediaMarker) },
        { },
    };

    static PyType_Spec type_spec_IMediaMarker =
    {
        "_winsdk_Windows_Media.IMediaMarker",
        sizeof(py::wrapper::Windows::Media::IMediaMarker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaMarker
    };

    // ----- IMediaMarkers interface --------------------
    static constexpr const char* const type_name_IMediaMarkers = "IMediaMarkers";

    static PyObject* _new_IMediaMarkers(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IMediaMarkers);
        return nullptr;
    }

    static void _dealloc_IMediaMarkers(py::wrapper::Windows::Media::IMediaMarkers* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMediaMarkers_get_Markers(py::wrapper::Windows::Media::IMediaMarkers* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.IMediaMarkers", L"Markers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Markers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IMediaMarkers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::IMediaMarkers>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMediaMarkers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::IMediaMarkers>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaMarkers[] = {
        { "_assign_array_", _assign_array_IMediaMarkers, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaMarkers), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaMarkers[] = {
        { "markers", reinterpret_cast<getter>(IMediaMarkers_get_Markers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMediaMarkers[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMediaMarkers) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMediaMarkers) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMediaMarkers) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMediaMarkers) },
        { },
    };

    static PyType_Spec type_spec_IMediaMarkers =
    {
        "_winsdk_Windows_Media.IMediaMarkers",
        sizeof(py::wrapper::Windows::Media::IMediaMarkers),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaMarkers
    };

    // ----- MediaTimeRange struct --------------------
    static constexpr const char* const type_name_MediaTimeRange = "MediaTimeRange";

    PyObject* _new_MediaTimeRange(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Media::MediaTimeRange return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        PyObject* _Start{};
        PyObject* _End{};

        static const char* kwlist[] = {"start", "end", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "OO", const_cast<char**>(kwlist), &_Start, &_End))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Media::MediaTimeRange return_value{ py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(_Start), py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(_End) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_MediaTimeRange(py::wrapper::Windows::Media::MediaTimeRange* self) noexcept
    {
    }

    static PyObject* MediaTimeRange_get_Start(py::wrapper::Windows::Media::MediaTimeRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Start);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaTimeRange_set_Start(py::wrapper::Windows::Media::MediaTimeRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Start = py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaTimeRange_get_End(py::wrapper::Windows::Media::MediaTimeRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.End);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaTimeRange_set_End(py::wrapper::Windows::Media::MediaTimeRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.End = py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_MediaTimeRange[] = {
        { "start", reinterpret_cast<getter>(MediaTimeRange_get_Start), reinterpret_cast<setter>(MediaTimeRange_set_Start), nullptr, nullptr },
        { "end", reinterpret_cast<getter>(MediaTimeRange_get_End), reinterpret_cast<setter>(MediaTimeRange_set_End), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaTimeRange[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaTimeRange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaTimeRange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaTimeRange) },
        { },
    };

    static PyType_Spec type_spec_MediaTimeRange =
    {
        "_winsdk_Windows_Media.MediaTimeRange",
        sizeof(py::wrapper::Windows::Media::MediaTimeRange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaTimeRange
    };

    // ----- Windows.Media Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Media");

    static PyMethodDef module_methods[] = {
        {"_register_AudioBufferAccessMode", register_AudioBufferAccessMode, METH_O, "registers type"},
        {"_register_AudioProcessing", register_AudioProcessing, METH_O, "registers type"},
        {"_register_MediaPlaybackAutoRepeatMode", register_MediaPlaybackAutoRepeatMode, METH_O, "registers type"},
        {"_register_MediaPlaybackStatus", register_MediaPlaybackStatus, METH_O, "registers type"},
        {"_register_MediaPlaybackType", register_MediaPlaybackType, METH_O, "registers type"},
        {"_register_MediaTimelineControllerState", register_MediaTimelineControllerState, METH_O, "registers type"},
        {"_register_SoundLevel", register_SoundLevel, METH_O, "registers type"},
        {"_register_SystemMediaTransportControlsButton", register_SystemMediaTransportControlsButton, METH_O, "registers type"},
        {"_register_SystemMediaTransportControlsProperty", register_SystemMediaTransportControlsProperty, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_AudioBufferAccessMode);
        Py_VISIT(state->type_AudioProcessing);
        Py_VISIT(state->type_MediaPlaybackAutoRepeatMode);
        Py_VISIT(state->type_MediaPlaybackStatus);
        Py_VISIT(state->type_MediaPlaybackType);
        Py_VISIT(state->type_MediaTimelineControllerState);
        Py_VISIT(state->type_SoundLevel);
        Py_VISIT(state->type_SystemMediaTransportControlsButton);
        Py_VISIT(state->type_SystemMediaTransportControlsProperty);
        Py_VISIT(state->type_AudioBuffer);
        Py_VISIT(state->type_AudioFrame);
        Py_VISIT(state->type_AutoRepeatModeChangeRequestedEventArgs);
        Py_VISIT(state->type_ImageDisplayProperties);
        Py_VISIT(state->type_MediaControl);
        Py_VISIT(state->type_MediaExtensionManager);
        Py_VISIT(state->type_MediaMarkerTypes);
        Py_VISIT(state->type_MediaProcessingTriggerDetails);
        Py_VISIT(state->type_MediaTimelineController);
        Py_VISIT(state->type_MediaTimelineControllerFailedEventArgs);
        Py_VISIT(state->type_MusicDisplayProperties);
        Py_VISIT(state->type_PlaybackPositionChangeRequestedEventArgs);
        Py_VISIT(state->type_PlaybackRateChangeRequestedEventArgs);
        Py_VISIT(state->type_ShuffleEnabledChangeRequestedEventArgs);
        Py_VISIT(state->type_SystemMediaTransportControls);
        Py_VISIT(state->type_SystemMediaTransportControlsButtonPressedEventArgs);
        Py_VISIT(state->type_SystemMediaTransportControlsDisplayUpdater);
        Py_VISIT(state->type_SystemMediaTransportControlsPropertyChangedEventArgs);
        Py_VISIT(state->type_SystemMediaTransportControlsTimelineProperties);
        Py_VISIT(state->type_VideoDisplayProperties);
        Py_VISIT(state->type_VideoEffects);
        Py_VISIT(state->type_VideoFrame);
        Py_VISIT(state->type_IMediaExtension);
        Py_VISIT(state->type_IMediaFrame);
        Py_VISIT(state->type_IMediaMarker);
        Py_VISIT(state->type_IMediaMarkers);
        Py_VISIT(state->type_MediaTimeRange);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_AudioBufferAccessMode);
        Py_CLEAR(state->type_AudioProcessing);
        Py_CLEAR(state->type_MediaPlaybackAutoRepeatMode);
        Py_CLEAR(state->type_MediaPlaybackStatus);
        Py_CLEAR(state->type_MediaPlaybackType);
        Py_CLEAR(state->type_MediaTimelineControllerState);
        Py_CLEAR(state->type_SoundLevel);
        Py_CLEAR(state->type_SystemMediaTransportControlsButton);
        Py_CLEAR(state->type_SystemMediaTransportControlsProperty);
        Py_CLEAR(state->type_AudioBuffer);
        Py_CLEAR(state->type_AudioFrame);
        Py_CLEAR(state->type_AutoRepeatModeChangeRequestedEventArgs);
        Py_CLEAR(state->type_ImageDisplayProperties);
        Py_CLEAR(state->type_MediaControl);
        Py_CLEAR(state->type_MediaExtensionManager);
        Py_CLEAR(state->type_MediaMarkerTypes);
        Py_CLEAR(state->type_MediaProcessingTriggerDetails);
        Py_CLEAR(state->type_MediaTimelineController);
        Py_CLEAR(state->type_MediaTimelineControllerFailedEventArgs);
        Py_CLEAR(state->type_MusicDisplayProperties);
        Py_CLEAR(state->type_PlaybackPositionChangeRequestedEventArgs);
        Py_CLEAR(state->type_PlaybackRateChangeRequestedEventArgs);
        Py_CLEAR(state->type_ShuffleEnabledChangeRequestedEventArgs);
        Py_CLEAR(state->type_SystemMediaTransportControls);
        Py_CLEAR(state->type_SystemMediaTransportControlsButtonPressedEventArgs);
        Py_CLEAR(state->type_SystemMediaTransportControlsDisplayUpdater);
        Py_CLEAR(state->type_SystemMediaTransportControlsPropertyChangedEventArgs);
        Py_CLEAR(state->type_SystemMediaTransportControlsTimelineProperties);
        Py_CLEAR(state->type_VideoDisplayProperties);
        Py_CLEAR(state->type_VideoEffects);
        Py_CLEAR(state->type_VideoFrame);
        Py_CLEAR(state->type_IMediaExtension);
        Py_CLEAR(state->type_IMediaFrame);
        Py_CLEAR(state->type_IMediaMarker);
        Py_CLEAR(state->type_IMediaMarkers);
        Py_CLEAR(state->type_MediaTimeRange);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Media",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Media

PyMODINIT_FUNC PyInit__winsdk_Windows_Media(void) noexcept
{
    using namespace py::cpp::Windows::Media;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_AudioBuffer = py::register_python_type(module.get(), type_name_AudioBuffer, &type_spec_AudioBuffer, bases.get(), nullptr);
    if (!state->type_AudioBuffer)
    {
        return nullptr;
    }

    state->type_AudioFrame = py::register_python_type(module.get(), type_name_AudioFrame, &type_spec_AudioFrame, bases.get(), nullptr);
    if (!state->type_AudioFrame)
    {
        return nullptr;
    }

    state->type_AutoRepeatModeChangeRequestedEventArgs = py::register_python_type(module.get(), type_name_AutoRepeatModeChangeRequestedEventArgs, &type_spec_AutoRepeatModeChangeRequestedEventArgs, bases.get(), nullptr);
    if (!state->type_AutoRepeatModeChangeRequestedEventArgs)
    {
        return nullptr;
    }

    state->type_ImageDisplayProperties = py::register_python_type(module.get(), type_name_ImageDisplayProperties, &type_spec_ImageDisplayProperties, bases.get(), nullptr);
    if (!state->type_ImageDisplayProperties)
    {
        return nullptr;
    }

    py::pyobj_handle type_MediaControl_Meta{PyType_FromSpec(&type_spec_MediaControl_Meta)};
    if (!type_MediaControl_Meta)
    {
        return nullptr;
    }

    state->type_MediaControl = py::register_python_type(module.get(), type_name_MediaControl, &type_spec_MediaControl, nullptr, reinterpret_cast<PyTypeObject*>(type_MediaControl_Meta.get()));
    if (!state->type_MediaControl)
    {
        return nullptr;
    }

    state->type_MediaExtensionManager = py::register_python_type(module.get(), type_name_MediaExtensionManager, &type_spec_MediaExtensionManager, bases.get(), nullptr);
    if (!state->type_MediaExtensionManager)
    {
        return nullptr;
    }

    py::pyobj_handle type_MediaMarkerTypes_Meta{PyType_FromSpec(&type_spec_MediaMarkerTypes_Meta)};
    if (!type_MediaMarkerTypes_Meta)
    {
        return nullptr;
    }

    state->type_MediaMarkerTypes = py::register_python_type(module.get(), type_name_MediaMarkerTypes, &type_spec_MediaMarkerTypes, nullptr, reinterpret_cast<PyTypeObject*>(type_MediaMarkerTypes_Meta.get()));
    if (!state->type_MediaMarkerTypes)
    {
        return nullptr;
    }

    state->type_MediaProcessingTriggerDetails = py::register_python_type(module.get(), type_name_MediaProcessingTriggerDetails, &type_spec_MediaProcessingTriggerDetails, bases.get(), nullptr);
    if (!state->type_MediaProcessingTriggerDetails)
    {
        return nullptr;
    }

    state->type_MediaTimelineController = py::register_python_type(module.get(), type_name_MediaTimelineController, &type_spec_MediaTimelineController, bases.get(), nullptr);
    if (!state->type_MediaTimelineController)
    {
        return nullptr;
    }

    state->type_MediaTimelineControllerFailedEventArgs = py::register_python_type(module.get(), type_name_MediaTimelineControllerFailedEventArgs, &type_spec_MediaTimelineControllerFailedEventArgs, bases.get(), nullptr);
    if (!state->type_MediaTimelineControllerFailedEventArgs)
    {
        return nullptr;
    }

    state->type_MusicDisplayProperties = py::register_python_type(module.get(), type_name_MusicDisplayProperties, &type_spec_MusicDisplayProperties, bases.get(), nullptr);
    if (!state->type_MusicDisplayProperties)
    {
        return nullptr;
    }

    state->type_PlaybackPositionChangeRequestedEventArgs = py::register_python_type(module.get(), type_name_PlaybackPositionChangeRequestedEventArgs, &type_spec_PlaybackPositionChangeRequestedEventArgs, bases.get(), nullptr);
    if (!state->type_PlaybackPositionChangeRequestedEventArgs)
    {
        return nullptr;
    }

    state->type_PlaybackRateChangeRequestedEventArgs = py::register_python_type(module.get(), type_name_PlaybackRateChangeRequestedEventArgs, &type_spec_PlaybackRateChangeRequestedEventArgs, bases.get(), nullptr);
    if (!state->type_PlaybackRateChangeRequestedEventArgs)
    {
        return nullptr;
    }

    state->type_ShuffleEnabledChangeRequestedEventArgs = py::register_python_type(module.get(), type_name_ShuffleEnabledChangeRequestedEventArgs, &type_spec_ShuffleEnabledChangeRequestedEventArgs, bases.get(), nullptr);
    if (!state->type_ShuffleEnabledChangeRequestedEventArgs)
    {
        return nullptr;
    }

    state->type_SystemMediaTransportControls = py::register_python_type(module.get(), type_name_SystemMediaTransportControls, &type_spec_SystemMediaTransportControls, bases.get(), nullptr);
    if (!state->type_SystemMediaTransportControls)
    {
        return nullptr;
    }

    state->type_SystemMediaTransportControlsButtonPressedEventArgs = py::register_python_type(module.get(), type_name_SystemMediaTransportControlsButtonPressedEventArgs, &type_spec_SystemMediaTransportControlsButtonPressedEventArgs, bases.get(), nullptr);
    if (!state->type_SystemMediaTransportControlsButtonPressedEventArgs)
    {
        return nullptr;
    }

    state->type_SystemMediaTransportControlsDisplayUpdater = py::register_python_type(module.get(), type_name_SystemMediaTransportControlsDisplayUpdater, &type_spec_SystemMediaTransportControlsDisplayUpdater, bases.get(), nullptr);
    if (!state->type_SystemMediaTransportControlsDisplayUpdater)
    {
        return nullptr;
    }

    state->type_SystemMediaTransportControlsPropertyChangedEventArgs = py::register_python_type(module.get(), type_name_SystemMediaTransportControlsPropertyChangedEventArgs, &type_spec_SystemMediaTransportControlsPropertyChangedEventArgs, bases.get(), nullptr);
    if (!state->type_SystemMediaTransportControlsPropertyChangedEventArgs)
    {
        return nullptr;
    }

    state->type_SystemMediaTransportControlsTimelineProperties = py::register_python_type(module.get(), type_name_SystemMediaTransportControlsTimelineProperties, &type_spec_SystemMediaTransportControlsTimelineProperties, bases.get(), nullptr);
    if (!state->type_SystemMediaTransportControlsTimelineProperties)
    {
        return nullptr;
    }

    state->type_VideoDisplayProperties = py::register_python_type(module.get(), type_name_VideoDisplayProperties, &type_spec_VideoDisplayProperties, bases.get(), nullptr);
    if (!state->type_VideoDisplayProperties)
    {
        return nullptr;
    }

    py::pyobj_handle type_VideoEffects_Meta{PyType_FromSpec(&type_spec_VideoEffects_Meta)};
    if (!type_VideoEffects_Meta)
    {
        return nullptr;
    }

    state->type_VideoEffects = py::register_python_type(module.get(), type_name_VideoEffects, &type_spec_VideoEffects, nullptr, reinterpret_cast<PyTypeObject*>(type_VideoEffects_Meta.get()));
    if (!state->type_VideoEffects)
    {
        return nullptr;
    }

    state->type_VideoFrame = py::register_python_type(module.get(), type_name_VideoFrame, &type_spec_VideoFrame, bases.get(), nullptr);
    if (!state->type_VideoFrame)
    {
        return nullptr;
    }

    state->type_IMediaExtension = py::register_python_type(module.get(), type_name_IMediaExtension, &type_spec_IMediaExtension, bases.get(), nullptr);
    if (!state->type_IMediaExtension)
    {
        return nullptr;
    }

    state->type_IMediaFrame = py::register_python_type(module.get(), type_name_IMediaFrame, &type_spec_IMediaFrame, bases.get(), nullptr);
    if (!state->type_IMediaFrame)
    {
        return nullptr;
    }

    state->type_IMediaMarker = py::register_python_type(module.get(), type_name_IMediaMarker, &type_spec_IMediaMarker, bases.get(), nullptr);
    if (!state->type_IMediaMarker)
    {
        return nullptr;
    }

    state->type_IMediaMarkers = py::register_python_type(module.get(), type_name_IMediaMarkers, &type_spec_IMediaMarkers, bases.get(), nullptr);
    if (!state->type_IMediaMarkers)
    {
        return nullptr;
    }

    state->type_MediaTimeRange = py::register_python_type(module.get(), type_name_MediaTimeRange, &type_spec_MediaTimeRange, bases.get(), nullptr);
    if (!state->type_MediaTimeRange)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Media::AudioBufferAccessMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioBufferAccessMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::AudioBufferAccessMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::AudioProcessing>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioProcessing;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::AudioProcessing is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::MediaPlaybackAutoRepeatMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaPlaybackAutoRepeatMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaPlaybackAutoRepeatMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::MediaPlaybackStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaPlaybackStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaPlaybackStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::MediaPlaybackType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaPlaybackType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaPlaybackType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::MediaTimelineControllerState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaTimelineControllerState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaTimelineControllerState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::SoundLevel>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SoundLevel;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SoundLevel is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::SystemMediaTransportControlsButton>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SystemMediaTransportControlsButton;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SystemMediaTransportControlsButton is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::SystemMediaTransportControlsProperty>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SystemMediaTransportControlsProperty;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SystemMediaTransportControlsProperty is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::AudioBuffer>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioBuffer;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::AudioBuffer is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::AudioFrame>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioFrame;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::AudioFrame is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::AutoRepeatModeChangeRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AutoRepeatModeChangeRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::AutoRepeatModeChangeRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::ImageDisplayProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ImageDisplayProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::ImageDisplayProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaControl>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaControl;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaControl is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaExtensionManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaExtensionManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaExtensionManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaMarkerTypes>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaMarkerTypes;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaMarkerTypes is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaProcessingTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaProcessingTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaProcessingTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaTimelineController>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaTimelineController;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaTimelineController is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaTimelineControllerFailedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaTimelineControllerFailedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaTimelineControllerFailedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::MusicDisplayProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MusicDisplayProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MusicDisplayProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::PlaybackPositionChangeRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PlaybackPositionChangeRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::PlaybackPositionChangeRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::PlaybackRateChangeRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PlaybackRateChangeRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::PlaybackRateChangeRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::ShuffleEnabledChangeRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ShuffleEnabledChangeRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::ShuffleEnabledChangeRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::SystemMediaTransportControls>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SystemMediaTransportControls;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SystemMediaTransportControls is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::SystemMediaTransportControlsButtonPressedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SystemMediaTransportControlsButtonPressedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SystemMediaTransportControlsButtonPressedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::SystemMediaTransportControlsDisplayUpdater>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SystemMediaTransportControlsDisplayUpdater;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SystemMediaTransportControlsDisplayUpdater is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::SystemMediaTransportControlsPropertyChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SystemMediaTransportControlsPropertyChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SystemMediaTransportControlsPropertyChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SystemMediaTransportControlsTimelineProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::VideoDisplayProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VideoDisplayProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::VideoDisplayProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::VideoEffects>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VideoEffects;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::VideoEffects is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::VideoFrame>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VideoFrame;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::VideoFrame is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::IMediaExtension>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IMediaExtension;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::IMediaExtension is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::IMediaFrame>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IMediaFrame;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::IMediaFrame is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::IMediaMarker>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IMediaMarker;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::IMediaMarker is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::IMediaMarkers>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IMediaMarkers;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::IMediaMarkers is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaTimeRange>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaTimeRange;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaTimeRange is not registered");
        return nullptr;
    }

    return python_type;
}
