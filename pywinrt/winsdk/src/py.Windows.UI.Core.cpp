// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.UI.Core.h"


PyObject* py::converter<winrt::Windows::UI::Core::CorePhysicalKeyStatus>::convert(winrt::Windows::UI::Core::CorePhysicalKeyStatus instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::UI::Core::CorePhysicalKeyStatus>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::UI::Core::CorePhysicalKeyStatus py::converter<winrt::Windows::UI::Core::CorePhysicalKeyStatus>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::UI::Core::CorePhysicalKeyStatus>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::UI::Core::CorePhysicalKeyStatus>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::UI::Core::CorePhysicalKeyStatus");
    throw python_exception();
}

PyObject* py::converter<winrt::Windows::UI::Core::CoreProximityEvaluation>::convert(winrt::Windows::UI::Core::CoreProximityEvaluation instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::UI::Core::CoreProximityEvaluation>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::UI::Core::CoreProximityEvaluation py::converter<winrt::Windows::UI::Core::CoreProximityEvaluation>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::UI::Core::CoreProximityEvaluation>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::UI::Core::CoreProximityEvaluation>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::UI::Core::CoreProximityEvaluation");
    throw python_exception();
}

namespace py::cpp::Windows::UI::Core
{
    struct module_state
    {
        PyObject* type_AppViewBackButtonVisibility;
        PyObject* type_CoreAcceleratorKeyEventType;
        PyObject* type_CoreCursorType;
        PyObject* type_CoreDispatcherPriority;
        PyObject* type_CoreIndependentInputFilters;
        PyObject* type_CoreInputDeviceTypes;
        PyObject* type_CoreProcessEventsOption;
        PyObject* type_CoreProximityEvaluationScore;
        PyObject* type_CoreVirtualKeyStates;
        PyObject* type_CoreWindowActivationMode;
        PyObject* type_CoreWindowActivationState;
        PyObject* type_CoreWindowFlowDirection;
        PyTypeObject* type_AcceleratorKeyEventArgs;
        PyTypeObject* type_AutomationProviderRequestedEventArgs;
        PyTypeObject* type_BackRequestedEventArgs;
        PyTypeObject* type_CharacterReceivedEventArgs;
        PyTypeObject* type_ClosestInteractiveBoundsRequestedEventArgs;
        PyTypeObject* type_CoreAcceleratorKeys;
        PyTypeObject* type_CoreComponentInputSource;
        PyTypeObject* type_CoreCursor;
        PyTypeObject* type_CoreDispatcher;
        PyTypeObject* type_CoreIndependentInputSource;
        PyTypeObject* type_CoreIndependentInputSourceController;
        PyTypeObject* type_CoreWindow;
        PyTypeObject* type_CoreWindowDialog;
        PyTypeObject* type_CoreWindowEventArgs;
        PyTypeObject* type_CoreWindowFlyout;
        PyTypeObject* type_CoreWindowPopupShowingEventArgs;
        PyTypeObject* type_CoreWindowResizeManager;
        PyTypeObject* type_IdleDispatchedHandlerArgs;
        PyTypeObject* type_InputEnabledEventArgs;
        PyTypeObject* type_KeyEventArgs;
        PyTypeObject* type_PointerEventArgs;
        PyTypeObject* type_SystemNavigationManager;
        PyTypeObject* type_TouchHitTestingEventArgs;
        PyTypeObject* type_VisibilityChangedEventArgs;
        PyTypeObject* type_WindowActivatedEventArgs;
        PyTypeObject* type_WindowSizeChangedEventArgs;
        PyTypeObject* type_ICoreAcceleratorKeys;
        PyTypeObject* type_ICoreInputSourceBase;
        PyTypeObject* type_ICorePointerInputSource;
        PyTypeObject* type_ICorePointerInputSource2;
        PyTypeObject* type_ICorePointerRedirector;
        PyTypeObject* type_ICoreWindow;
        PyTypeObject* type_ICoreWindowEventArgs;
        PyTypeObject* type_IInitializeWithCoreWindow;
        PyTypeObject* type_CorePhysicalKeyStatus;
        PyTypeObject* type_CoreProximityEvaluation;
    };

    static PyObject* register_AppViewBackButtonVisibility(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AppViewBackButtonVisibility)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AppViewBackButtonVisibility = type;
        Py_INCREF(state->type_AppViewBackButtonVisibility);


        Py_RETURN_NONE;
    }

    static PyObject* register_CoreAcceleratorKeyEventType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CoreAcceleratorKeyEventType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CoreAcceleratorKeyEventType = type;
        Py_INCREF(state->type_CoreAcceleratorKeyEventType);


        Py_RETURN_NONE;
    }

    static PyObject* register_CoreCursorType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CoreCursorType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CoreCursorType = type;
        Py_INCREF(state->type_CoreCursorType);


        Py_RETURN_NONE;
    }

    static PyObject* register_CoreDispatcherPriority(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CoreDispatcherPriority)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CoreDispatcherPriority = type;
        Py_INCREF(state->type_CoreDispatcherPriority);


        Py_RETURN_NONE;
    }

    static PyObject* register_CoreIndependentInputFilters(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CoreIndependentInputFilters)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CoreIndependentInputFilters = type;
        Py_INCREF(state->type_CoreIndependentInputFilters);


        Py_RETURN_NONE;
    }

    static PyObject* register_CoreInputDeviceTypes(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CoreInputDeviceTypes)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CoreInputDeviceTypes = type;
        Py_INCREF(state->type_CoreInputDeviceTypes);


        Py_RETURN_NONE;
    }

    static PyObject* register_CoreProcessEventsOption(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CoreProcessEventsOption)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CoreProcessEventsOption = type;
        Py_INCREF(state->type_CoreProcessEventsOption);


        Py_RETURN_NONE;
    }

    static PyObject* register_CoreProximityEvaluationScore(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CoreProximityEvaluationScore)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CoreProximityEvaluationScore = type;
        Py_INCREF(state->type_CoreProximityEvaluationScore);


        Py_RETURN_NONE;
    }

    static PyObject* register_CoreVirtualKeyStates(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CoreVirtualKeyStates)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CoreVirtualKeyStates = type;
        Py_INCREF(state->type_CoreVirtualKeyStates);


        Py_RETURN_NONE;
    }

    static PyObject* register_CoreWindowActivationMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CoreWindowActivationMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CoreWindowActivationMode = type;
        Py_INCREF(state->type_CoreWindowActivationMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_CoreWindowActivationState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CoreWindowActivationState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CoreWindowActivationState = type;
        Py_INCREF(state->type_CoreWindowActivationState);


        Py_RETURN_NONE;
    }

    static PyObject* register_CoreWindowFlowDirection(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CoreWindowFlowDirection)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CoreWindowFlowDirection = type;
        Py_INCREF(state->type_CoreWindowFlowDirection);


        Py_RETURN_NONE;
    }

    // ----- AcceleratorKeyEventArgs class --------------------
    static constexpr const char* const type_name_AcceleratorKeyEventArgs = "AcceleratorKeyEventArgs";

    static PyObject* _new_AcceleratorKeyEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AcceleratorKeyEventArgs);
        return nullptr;
    }

    static void _dealloc_AcceleratorKeyEventArgs(py::wrapper::Windows::UI::Core::AcceleratorKeyEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AcceleratorKeyEventArgs_get_EventType(py::wrapper::Windows::UI::Core::AcceleratorKeyEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.AcceleratorKeyEventArgs", L"EventType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EventType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AcceleratorKeyEventArgs_get_KeyStatus(py::wrapper::Windows::UI::Core::AcceleratorKeyEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.AcceleratorKeyEventArgs", L"KeyStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AcceleratorKeyEventArgs_get_VirtualKey(py::wrapper::Windows::UI::Core::AcceleratorKeyEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.AcceleratorKeyEventArgs", L"VirtualKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VirtualKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AcceleratorKeyEventArgs_get_DeviceId(py::wrapper::Windows::UI::Core::AcceleratorKeyEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.AcceleratorKeyEventArgs", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AcceleratorKeyEventArgs_get_Handled(py::wrapper::Windows::UI::Core::AcceleratorKeyEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.AcceleratorKeyEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AcceleratorKeyEventArgs_put_Handled(py::wrapper::Windows::UI::Core::AcceleratorKeyEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.AcceleratorKeyEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AcceleratorKeyEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::AcceleratorKeyEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AcceleratorKeyEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::AcceleratorKeyEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AcceleratorKeyEventArgs[] = {
        { "_assign_array_", _assign_array_AcceleratorKeyEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AcceleratorKeyEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AcceleratorKeyEventArgs[] = {
        { "event_type", reinterpret_cast<getter>(AcceleratorKeyEventArgs_get_EventType), nullptr, nullptr, nullptr },
        { "key_status", reinterpret_cast<getter>(AcceleratorKeyEventArgs_get_KeyStatus), nullptr, nullptr, nullptr },
        { "virtual_key", reinterpret_cast<getter>(AcceleratorKeyEventArgs_get_VirtualKey), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(AcceleratorKeyEventArgs_get_DeviceId), nullptr, nullptr, nullptr },
        { "handled", reinterpret_cast<getter>(AcceleratorKeyEventArgs_get_Handled), reinterpret_cast<setter>(AcceleratorKeyEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AcceleratorKeyEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AcceleratorKeyEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AcceleratorKeyEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AcceleratorKeyEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AcceleratorKeyEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AcceleratorKeyEventArgs =
    {
        "_winsdk_Windows_UI_Core.AcceleratorKeyEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::AcceleratorKeyEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AcceleratorKeyEventArgs
    };

    // ----- AutomationProviderRequestedEventArgs class --------------------
    static constexpr const char* const type_name_AutomationProviderRequestedEventArgs = "AutomationProviderRequestedEventArgs";

    static PyObject* _new_AutomationProviderRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AutomationProviderRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_AutomationProviderRequestedEventArgs(py::wrapper::Windows::UI::Core::AutomationProviderRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AutomationProviderRequestedEventArgs_get_AutomationProvider(py::wrapper::Windows::UI::Core::AutomationProviderRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.AutomationProviderRequestedEventArgs", L"AutomationProvider"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutomationProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutomationProviderRequestedEventArgs_put_AutomationProvider(py::wrapper::Windows::UI::Core::AutomationProviderRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.AutomationProviderRequestedEventArgs", L"AutomationProvider"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.AutomationProvider(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutomationProviderRequestedEventArgs_get_Handled(py::wrapper::Windows::UI::Core::AutomationProviderRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.AutomationProviderRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutomationProviderRequestedEventArgs_put_Handled(py::wrapper::Windows::UI::Core::AutomationProviderRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.AutomationProviderRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AutomationProviderRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::AutomationProviderRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AutomationProviderRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::AutomationProviderRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutomationProviderRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_AutomationProviderRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AutomationProviderRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AutomationProviderRequestedEventArgs[] = {
        { "automation_provider", reinterpret_cast<getter>(AutomationProviderRequestedEventArgs_get_AutomationProvider), reinterpret_cast<setter>(AutomationProviderRequestedEventArgs_put_AutomationProvider), nullptr, nullptr },
        { "handled", reinterpret_cast<getter>(AutomationProviderRequestedEventArgs_get_Handled), reinterpret_cast<setter>(AutomationProviderRequestedEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AutomationProviderRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutomationProviderRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutomationProviderRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AutomationProviderRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutomationProviderRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AutomationProviderRequestedEventArgs =
    {
        "_winsdk_Windows_UI_Core.AutomationProviderRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::AutomationProviderRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutomationProviderRequestedEventArgs
    };

    // ----- BackRequestedEventArgs class --------------------
    static constexpr const char* const type_name_BackRequestedEventArgs = "BackRequestedEventArgs";

    static PyObject* _new_BackRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BackRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_BackRequestedEventArgs(py::wrapper::Windows::UI::Core::BackRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackRequestedEventArgs_get_Handled(py::wrapper::Windows::UI::Core::BackRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.BackRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackRequestedEventArgs_put_Handled(py::wrapper::Windows::UI::Core::BackRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.BackRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_BackRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::BackRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::BackRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_BackRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackRequestedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(BackRequestedEventArgs_get_Handled), reinterpret_cast<setter>(BackRequestedEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_BackRequestedEventArgs =
    {
        "_winsdk_Windows_UI_Core.BackRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::BackRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackRequestedEventArgs
    };

    // ----- CharacterReceivedEventArgs class --------------------
    static constexpr const char* const type_name_CharacterReceivedEventArgs = "CharacterReceivedEventArgs";

    static PyObject* _new_CharacterReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CharacterReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_CharacterReceivedEventArgs(py::wrapper::Windows::UI::Core::CharacterReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CharacterReceivedEventArgs_get_KeyCode(py::wrapper::Windows::UI::Core::CharacterReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CharacterReceivedEventArgs", L"KeyCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CharacterReceivedEventArgs_get_KeyStatus(py::wrapper::Windows::UI::Core::CharacterReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CharacterReceivedEventArgs", L"KeyStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CharacterReceivedEventArgs_get_Handled(py::wrapper::Windows::UI::Core::CharacterReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CharacterReceivedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CharacterReceivedEventArgs_put_Handled(py::wrapper::Windows::UI::Core::CharacterReceivedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CharacterReceivedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CharacterReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CharacterReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CharacterReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::CharacterReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CharacterReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_CharacterReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CharacterReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CharacterReceivedEventArgs[] = {
        { "key_code", reinterpret_cast<getter>(CharacterReceivedEventArgs_get_KeyCode), nullptr, nullptr, nullptr },
        { "key_status", reinterpret_cast<getter>(CharacterReceivedEventArgs_get_KeyStatus), nullptr, nullptr, nullptr },
        { "handled", reinterpret_cast<getter>(CharacterReceivedEventArgs_get_Handled), reinterpret_cast<setter>(CharacterReceivedEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CharacterReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CharacterReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CharacterReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CharacterReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CharacterReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CharacterReceivedEventArgs =
    {
        "_winsdk_Windows_UI_Core.CharacterReceivedEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::CharacterReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CharacterReceivedEventArgs
    };

    // ----- ClosestInteractiveBoundsRequestedEventArgs class --------------------
    static constexpr const char* const type_name_ClosestInteractiveBoundsRequestedEventArgs = "ClosestInteractiveBoundsRequestedEventArgs";

    static PyObject* _new_ClosestInteractiveBoundsRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ClosestInteractiveBoundsRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_ClosestInteractiveBoundsRequestedEventArgs(py::wrapper::Windows::UI::Core::ClosestInteractiveBoundsRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ClosestInteractiveBoundsRequestedEventArgs_get_ClosestInteractiveBounds(py::wrapper::Windows::UI::Core::ClosestInteractiveBoundsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ClosestInteractiveBoundsRequestedEventArgs", L"ClosestInteractiveBounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ClosestInteractiveBounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClosestInteractiveBoundsRequestedEventArgs_put_ClosestInteractiveBounds(py::wrapper::Windows::UI::Core::ClosestInteractiveBoundsRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ClosestInteractiveBoundsRequestedEventArgs", L"ClosestInteractiveBounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.ClosestInteractiveBounds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClosestInteractiveBoundsRequestedEventArgs_get_PointerPosition(py::wrapper::Windows::UI::Core::ClosestInteractiveBoundsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ClosestInteractiveBoundsRequestedEventArgs", L"PointerPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClosestInteractiveBoundsRequestedEventArgs_get_SearchBounds(py::wrapper::Windows::UI::Core::ClosestInteractiveBoundsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ClosestInteractiveBoundsRequestedEventArgs", L"SearchBounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SearchBounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ClosestInteractiveBoundsRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::ClosestInteractiveBoundsRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClosestInteractiveBoundsRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::ClosestInteractiveBoundsRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClosestInteractiveBoundsRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_ClosestInteractiveBoundsRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClosestInteractiveBoundsRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClosestInteractiveBoundsRequestedEventArgs[] = {
        { "closest_interactive_bounds", reinterpret_cast<getter>(ClosestInteractiveBoundsRequestedEventArgs_get_ClosestInteractiveBounds), reinterpret_cast<setter>(ClosestInteractiveBoundsRequestedEventArgs_put_ClosestInteractiveBounds), nullptr, nullptr },
        { "pointer_position", reinterpret_cast<getter>(ClosestInteractiveBoundsRequestedEventArgs_get_PointerPosition), nullptr, nullptr, nullptr },
        { "search_bounds", reinterpret_cast<getter>(ClosestInteractiveBoundsRequestedEventArgs_get_SearchBounds), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClosestInteractiveBoundsRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClosestInteractiveBoundsRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClosestInteractiveBoundsRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClosestInteractiveBoundsRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClosestInteractiveBoundsRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ClosestInteractiveBoundsRequestedEventArgs =
    {
        "_winsdk_Windows_UI_Core.ClosestInteractiveBoundsRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::ClosestInteractiveBoundsRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClosestInteractiveBoundsRequestedEventArgs
    };

    // ----- CoreAcceleratorKeys class --------------------
    static constexpr const char* const type_name_CoreAcceleratorKeys = "CoreAcceleratorKeys";

    static PyObject* _new_CoreAcceleratorKeys(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreAcceleratorKeys);
        return nullptr;
    }

    static void _dealloc_CoreAcceleratorKeys(py::wrapper::Windows::UI::Core::CoreAcceleratorKeys* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreAcceleratorKeys_add_AcceleratorKeyActivated(py::wrapper::Windows::UI::Core::CoreAcceleratorKeys* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreAcceleratorKeys", L"AcceleratorKeyActivated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreDispatcher, winrt::Windows::UI::Core::AcceleratorKeyEventArgs>>(arg);

            return py::convert(self->obj.AcceleratorKeyActivated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreAcceleratorKeys_remove_AcceleratorKeyActivated(py::wrapper::Windows::UI::Core::CoreAcceleratorKeys* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreAcceleratorKeys", L"AcceleratorKeyActivated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AcceleratorKeyActivated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreAcceleratorKeys(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CoreAcceleratorKeys>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreAcceleratorKeys(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::CoreAcceleratorKeys>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreAcceleratorKeys[] = {
        { "add_accelerator_key_activated", reinterpret_cast<PyCFunction>(CoreAcceleratorKeys_add_AcceleratorKeyActivated), METH_O, nullptr },
        { "remove_accelerator_key_activated", reinterpret_cast<PyCFunction>(CoreAcceleratorKeys_remove_AcceleratorKeyActivated), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreAcceleratorKeys, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreAcceleratorKeys), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreAcceleratorKeys[] = {
        { }
    };

    static PyType_Slot _type_slots_CoreAcceleratorKeys[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreAcceleratorKeys) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreAcceleratorKeys) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreAcceleratorKeys) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreAcceleratorKeys) },
        { },
    };

    static PyType_Spec type_spec_CoreAcceleratorKeys =
    {
        "_winsdk_Windows_UI_Core.CoreAcceleratorKeys",
        sizeof(py::wrapper::Windows::UI::Core::CoreAcceleratorKeys),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreAcceleratorKeys
    };

    // ----- CoreComponentInputSource class --------------------
    static constexpr const char* const type_name_CoreComponentInputSource = "CoreComponentInputSource";

    static PyObject* _new_CoreComponentInputSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreComponentInputSource);
        return nullptr;
    }

    static void _dealloc_CoreComponentInputSource(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreComponentInputSource_GetCurrentKeyEventDeviceId(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreComponentInputSource", L"GetCurrentKeyEventDeviceId", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentKeyEventDeviceId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_GetCurrentKeyState(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreComponentInputSource", L"GetCurrentKeyState", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(args, 0);

                return py::convert(self->obj.GetCurrentKeyState(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_ReleasePointerCapture(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreComponentInputSource", L"ReleasePointerCapture", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ReleasePointerCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_SetPointerCapture(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreComponentInputSource", L"SetPointerCapture", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.SetPointerCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_get_HasFocus(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreComponentInputSource", L"HasFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasFocus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_get_IsInputEnabled(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreComponentInputSource", L"IsInputEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInputEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreComponentInputSource_put_IsInputEnabled(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreComponentInputSource", L"IsInputEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsInputEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreComponentInputSource_get_Dispatcher(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreComponentInputSource", L"Dispatcher"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_get_PointerCursor(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerCursor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerCursor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreComponentInputSource_put_PointerCursor(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerCursor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreCursor>(arg);

            self->obj.PointerCursor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreComponentInputSource_get_HasCapture(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreComponentInputSource", L"HasCapture"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasCapture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_get_PointerPosition(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_get_DispatcherQueue(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreComponentInputSource", L"DispatcherQueue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DispatcherQueue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_InputEnabled(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"InputEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::InputEnabledEventArgs>>(arg);

            return py::convert(self->obj.InputEnabled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_InputEnabled(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"InputEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InputEnabled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_PointerCaptureLost(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerCaptureLost"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerCaptureLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_PointerCaptureLost(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerCaptureLost"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerCaptureLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_PointerEntered(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerEntered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_PointerEntered(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerEntered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_PointerExited(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerExited"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_PointerExited(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerExited"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_PointerMoved(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerMoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerMoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_PointerMoved(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerMoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerMoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_PointerPressed(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_PointerPressed(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_PointerReleased(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerReleased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_PointerReleased(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerReleased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_PointerWheelChanged(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerWheelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerWheelChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_PointerWheelChanged(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerWheelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerWheelChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_CharacterReceived(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"CharacterReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::CharacterReceivedEventArgs>>(arg);

            return py::convert(self->obj.CharacterReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_CharacterReceived(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"CharacterReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CharacterReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_KeyDown(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"KeyDown"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::KeyEventArgs>>(arg);

            return py::convert(self->obj.KeyDown(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_KeyDown(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"KeyDown"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.KeyDown(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_KeyUp(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"KeyUp"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::KeyEventArgs>>(arg);

            return py::convert(self->obj.KeyUp(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_KeyUp(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"KeyUp"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.KeyUp(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_GotFocus(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"GotFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::CoreWindowEventArgs>>(arg);

            return py::convert(self->obj.GotFocus(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_GotFocus(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"GotFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.GotFocus(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_LostFocus(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"LostFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::CoreWindowEventArgs>>(arg);

            return py::convert(self->obj.LostFocus(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_LostFocus(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"LostFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LostFocus(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_TouchHitTesting(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"TouchHitTesting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::TouchHitTestingEventArgs>>(arg);

            return py::convert(self->obj.TouchHitTesting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_TouchHitTesting(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"TouchHitTesting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TouchHitTesting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_ClosestInteractiveBoundsRequested(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"ClosestInteractiveBoundsRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreComponentInputSource, winrt::Windows::UI::Core::ClosestInteractiveBoundsRequestedEventArgs>>(arg);

            return py::convert(self->obj.ClosestInteractiveBoundsRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_ClosestInteractiveBoundsRequested(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"ClosestInteractiveBoundsRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ClosestInteractiveBoundsRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreComponentInputSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CoreComponentInputSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreComponentInputSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::CoreComponentInputSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreComponentInputSource[] = {
        { "get_current_key_event_device_id", reinterpret_cast<PyCFunction>(CoreComponentInputSource_GetCurrentKeyEventDeviceId), METH_VARARGS, nullptr },
        { "get_current_key_state", reinterpret_cast<PyCFunction>(CoreComponentInputSource_GetCurrentKeyState), METH_VARARGS, nullptr },
        { "release_pointer_capture", reinterpret_cast<PyCFunction>(CoreComponentInputSource_ReleasePointerCapture), METH_VARARGS, nullptr },
        { "set_pointer_capture", reinterpret_cast<PyCFunction>(CoreComponentInputSource_SetPointerCapture), METH_VARARGS, nullptr },
        { "add_input_enabled", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_InputEnabled), METH_O, nullptr },
        { "remove_input_enabled", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_InputEnabled), METH_O, nullptr },
        { "add_pointer_capture_lost", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_PointerCaptureLost), METH_O, nullptr },
        { "remove_pointer_capture_lost", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_PointerCaptureLost), METH_O, nullptr },
        { "add_pointer_entered", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_PointerEntered), METH_O, nullptr },
        { "remove_pointer_entered", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_PointerEntered), METH_O, nullptr },
        { "add_pointer_exited", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_PointerExited), METH_O, nullptr },
        { "remove_pointer_exited", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_PointerExited), METH_O, nullptr },
        { "add_pointer_moved", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_PointerMoved), METH_O, nullptr },
        { "remove_pointer_moved", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_PointerMoved), METH_O, nullptr },
        { "add_pointer_pressed", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_PointerPressed), METH_O, nullptr },
        { "remove_pointer_pressed", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_PointerPressed), METH_O, nullptr },
        { "add_pointer_released", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_PointerReleased), METH_O, nullptr },
        { "remove_pointer_released", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_PointerReleased), METH_O, nullptr },
        { "add_pointer_wheel_changed", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_PointerWheelChanged), METH_O, nullptr },
        { "remove_pointer_wheel_changed", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_PointerWheelChanged), METH_O, nullptr },
        { "add_character_received", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_CharacterReceived), METH_O, nullptr },
        { "remove_character_received", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_CharacterReceived), METH_O, nullptr },
        { "add_key_down", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_KeyDown), METH_O, nullptr },
        { "remove_key_down", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_KeyDown), METH_O, nullptr },
        { "add_key_up", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_KeyUp), METH_O, nullptr },
        { "remove_key_up", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_KeyUp), METH_O, nullptr },
        { "add_got_focus", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_GotFocus), METH_O, nullptr },
        { "remove_got_focus", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_GotFocus), METH_O, nullptr },
        { "add_lost_focus", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_LostFocus), METH_O, nullptr },
        { "remove_lost_focus", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_LostFocus), METH_O, nullptr },
        { "add_touch_hit_testing", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_TouchHitTesting), METH_O, nullptr },
        { "remove_touch_hit_testing", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_TouchHitTesting), METH_O, nullptr },
        { "add_closest_interactive_bounds_requested", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_ClosestInteractiveBoundsRequested), METH_O, nullptr },
        { "remove_closest_interactive_bounds_requested", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_ClosestInteractiveBoundsRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreComponentInputSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreComponentInputSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreComponentInputSource[] = {
        { "has_focus", reinterpret_cast<getter>(CoreComponentInputSource_get_HasFocus), nullptr, nullptr, nullptr },
        { "is_input_enabled", reinterpret_cast<getter>(CoreComponentInputSource_get_IsInputEnabled), reinterpret_cast<setter>(CoreComponentInputSource_put_IsInputEnabled), nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(CoreComponentInputSource_get_Dispatcher), nullptr, nullptr, nullptr },
        { "pointer_cursor", reinterpret_cast<getter>(CoreComponentInputSource_get_PointerCursor), reinterpret_cast<setter>(CoreComponentInputSource_put_PointerCursor), nullptr, nullptr },
        { "has_capture", reinterpret_cast<getter>(CoreComponentInputSource_get_HasCapture), nullptr, nullptr, nullptr },
        { "pointer_position", reinterpret_cast<getter>(CoreComponentInputSource_get_PointerPosition), nullptr, nullptr, nullptr },
        { "dispatcher_queue", reinterpret_cast<getter>(CoreComponentInputSource_get_DispatcherQueue), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreComponentInputSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreComponentInputSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreComponentInputSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreComponentInputSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreComponentInputSource) },
        { },
    };

    static PyType_Spec type_spec_CoreComponentInputSource =
    {
        "_winsdk_Windows_UI_Core.CoreComponentInputSource",
        sizeof(py::wrapper::Windows::UI::Core::CoreComponentInputSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreComponentInputSource
    };

    // ----- CoreCursor class --------------------
    static constexpr const char* const type_name_CoreCursor = "CoreCursor";

    static PyObject* _new_CoreCursor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreCursorType>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                winrt::Windows::UI::Core::CoreCursor instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CoreCursor(py::wrapper::Windows::UI::Core::CoreCursor* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreCursor_get_Id(py::wrapper::Windows::UI::Core::CoreCursor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreCursor", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreCursor_get_Type(py::wrapper::Windows::UI::Core::CoreCursor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreCursor", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreCursor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CoreCursor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreCursor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::CoreCursor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreCursor[] = {
        { "_assign_array_", _assign_array_CoreCursor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreCursor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreCursor[] = {
        { "id", reinterpret_cast<getter>(CoreCursor_get_Id), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(CoreCursor_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreCursor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreCursor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreCursor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreCursor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreCursor) },
        { },
    };

    static PyType_Spec type_spec_CoreCursor =
    {
        "_winsdk_Windows_UI_Core.CoreCursor",
        sizeof(py::wrapper::Windows::UI::Core::CoreCursor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreCursor
    };

    // ----- CoreDispatcher class --------------------
    static constexpr const char* const type_name_CoreDispatcher = "CoreDispatcher";

    static PyObject* _new_CoreDispatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreDispatcher);
        return nullptr;
    }

    static void _dealloc_CoreDispatcher(py::wrapper::Windows::UI::Core::CoreDispatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreDispatcher_ProcessEvents(py::wrapper::Windows::UI::Core::CoreDispatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreDispatcher", L"ProcessEvents", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreProcessEventsOption>(args, 0);

                self->obj.ProcessEvents(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreDispatcher_RunAsync(py::wrapper::Windows::UI::Core::CoreDispatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreDispatcher", L"RunAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreDispatcherPriority>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Core::DispatchedHandler>(args, 1);

                return py::convert(self->obj.RunAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreDispatcher_RunIdleAsync(py::wrapper::Windows::UI::Core::CoreDispatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreDispatcher", L"RunIdleAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Core::IdleDispatchedHandler>(args, 0);

                return py::convert(self->obj.RunIdleAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreDispatcher_ShouldYield(py::wrapper::Windows::UI::Core::CoreDispatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreDispatcher", L"ShouldYield", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ShouldYield());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreDispatcher", L"ShouldYield", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreDispatcherPriority>(args, 0);

                return py::convert(self->obj.ShouldYield(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreDispatcher_StopProcessEvents(py::wrapper::Windows::UI::Core::CoreDispatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreDispatcher", L"StopProcessEvents", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.StopProcessEvents();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreDispatcher_TryRunAsync(py::wrapper::Windows::UI::Core::CoreDispatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreDispatcher", L"TryRunAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreDispatcherPriority>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Core::DispatchedHandler>(args, 1);

                return py::convert(self->obj.TryRunAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreDispatcher_TryRunIdleAsync(py::wrapper::Windows::UI::Core::CoreDispatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreDispatcher", L"TryRunIdleAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Core::IdleDispatchedHandler>(args, 0);

                return py::convert(self->obj.TryRunIdleAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreDispatcher_get_HasThreadAccess(py::wrapper::Windows::UI::Core::CoreDispatcher* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreDispatcher", L"HasThreadAccess"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasThreadAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreDispatcher_get_CurrentPriority(py::wrapper::Windows::UI::Core::CoreDispatcher* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreDispatcher", L"CurrentPriority"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentPriority());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreDispatcher_put_CurrentPriority(py::wrapper::Windows::UI::Core::CoreDispatcher* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreDispatcher", L"CurrentPriority"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreDispatcherPriority>(arg);

            self->obj.CurrentPriority(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreDispatcher_add_AcceleratorKeyActivated(py::wrapper::Windows::UI::Core::CoreDispatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreDispatcher", L"AcceleratorKeyActivated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreDispatcher, winrt::Windows::UI::Core::AcceleratorKeyEventArgs>>(arg);

            return py::convert(self->obj.AcceleratorKeyActivated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreDispatcher_remove_AcceleratorKeyActivated(py::wrapper::Windows::UI::Core::CoreDispatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreDispatcher", L"AcceleratorKeyActivated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AcceleratorKeyActivated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreDispatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CoreDispatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreDispatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::CoreDispatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreDispatcher[] = {
        { "process_events", reinterpret_cast<PyCFunction>(CoreDispatcher_ProcessEvents), METH_VARARGS, nullptr },
        { "run_async", reinterpret_cast<PyCFunction>(CoreDispatcher_RunAsync), METH_VARARGS, nullptr },
        { "run_idle_async", reinterpret_cast<PyCFunction>(CoreDispatcher_RunIdleAsync), METH_VARARGS, nullptr },
        { "should_yield", reinterpret_cast<PyCFunction>(CoreDispatcher_ShouldYield), METH_VARARGS, nullptr },
        { "stop_process_events", reinterpret_cast<PyCFunction>(CoreDispatcher_StopProcessEvents), METH_VARARGS, nullptr },
        { "try_run_async", reinterpret_cast<PyCFunction>(CoreDispatcher_TryRunAsync), METH_VARARGS, nullptr },
        { "try_run_idle_async", reinterpret_cast<PyCFunction>(CoreDispatcher_TryRunIdleAsync), METH_VARARGS, nullptr },
        { "add_accelerator_key_activated", reinterpret_cast<PyCFunction>(CoreDispatcher_add_AcceleratorKeyActivated), METH_O, nullptr },
        { "remove_accelerator_key_activated", reinterpret_cast<PyCFunction>(CoreDispatcher_remove_AcceleratorKeyActivated), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreDispatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreDispatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreDispatcher[] = {
        { "has_thread_access", reinterpret_cast<getter>(CoreDispatcher_get_HasThreadAccess), nullptr, nullptr, nullptr },
        { "current_priority", reinterpret_cast<getter>(CoreDispatcher_get_CurrentPriority), reinterpret_cast<setter>(CoreDispatcher_put_CurrentPriority), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreDispatcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreDispatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreDispatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreDispatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreDispatcher) },
        { },
    };

    static PyType_Spec type_spec_CoreDispatcher =
    {
        "_winsdk_Windows_UI_Core.CoreDispatcher",
        sizeof(py::wrapper::Windows::UI::Core::CoreDispatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreDispatcher
    };

    // ----- CoreIndependentInputSource class --------------------
    static constexpr const char* const type_name_CoreIndependentInputSource = "CoreIndependentInputSource";

    static PyObject* _new_CoreIndependentInputSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreIndependentInputSource);
        return nullptr;
    }

    static void _dealloc_CoreIndependentInputSource(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreIndependentInputSource_ReleasePointerCapture(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"ReleasePointerCapture", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ReleasePointerCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_SetPointerCapture(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"SetPointerCapture", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.SetPointerCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_get_IsInputEnabled(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"IsInputEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInputEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreIndependentInputSource_put_IsInputEnabled(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"IsInputEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsInputEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreIndependentInputSource_get_Dispatcher(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"Dispatcher"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_get_PointerCursor(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerCursor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerCursor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreIndependentInputSource_put_PointerCursor(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerCursor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreCursor>(arg);

            self->obj.PointerCursor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreIndependentInputSource_get_HasCapture(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"HasCapture"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasCapture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_get_PointerPosition(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_get_DispatcherQueue(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"DispatcherQueue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DispatcherQueue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_add_InputEnabled(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"InputEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::InputEnabledEventArgs>>(arg);

            return py::convert(self->obj.InputEnabled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_remove_InputEnabled(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"InputEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InputEnabled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_add_PointerCaptureLost(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerCaptureLost"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerCaptureLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_remove_PointerCaptureLost(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerCaptureLost"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerCaptureLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_add_PointerEntered(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerEntered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_remove_PointerEntered(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerEntered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_add_PointerExited(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerExited"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_remove_PointerExited(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerExited"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_add_PointerMoved(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerMoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerMoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_remove_PointerMoved(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerMoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerMoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_add_PointerPressed(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_remove_PointerPressed(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_add_PointerReleased(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerReleased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_remove_PointerReleased(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerReleased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_add_PointerWheelChanged(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerWheelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerWheelChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_remove_PointerWheelChanged(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerWheelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerWheelChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_add_PointerRoutedAway(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerRoutedAway"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::ICorePointerRedirector, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerRoutedAway(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_remove_PointerRoutedAway(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerRoutedAway"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerRoutedAway(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_add_PointerRoutedReleased(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerRoutedReleased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::ICorePointerRedirector, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerRoutedReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_remove_PointerRoutedReleased(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerRoutedReleased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerRoutedReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_add_PointerRoutedTo(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerRoutedTo"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::ICorePointerRedirector, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerRoutedTo(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_remove_PointerRoutedTo(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerRoutedTo"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerRoutedTo(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreIndependentInputSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CoreIndependentInputSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreIndependentInputSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::CoreIndependentInputSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreIndependentInputSource[] = {
        { "release_pointer_capture", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_ReleasePointerCapture), METH_VARARGS, nullptr },
        { "set_pointer_capture", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_SetPointerCapture), METH_VARARGS, nullptr },
        { "add_input_enabled", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_add_InputEnabled), METH_O, nullptr },
        { "remove_input_enabled", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_remove_InputEnabled), METH_O, nullptr },
        { "add_pointer_capture_lost", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_add_PointerCaptureLost), METH_O, nullptr },
        { "remove_pointer_capture_lost", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_remove_PointerCaptureLost), METH_O, nullptr },
        { "add_pointer_entered", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_add_PointerEntered), METH_O, nullptr },
        { "remove_pointer_entered", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_remove_PointerEntered), METH_O, nullptr },
        { "add_pointer_exited", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_add_PointerExited), METH_O, nullptr },
        { "remove_pointer_exited", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_remove_PointerExited), METH_O, nullptr },
        { "add_pointer_moved", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_add_PointerMoved), METH_O, nullptr },
        { "remove_pointer_moved", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_remove_PointerMoved), METH_O, nullptr },
        { "add_pointer_pressed", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_add_PointerPressed), METH_O, nullptr },
        { "remove_pointer_pressed", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_remove_PointerPressed), METH_O, nullptr },
        { "add_pointer_released", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_add_PointerReleased), METH_O, nullptr },
        { "remove_pointer_released", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_remove_PointerReleased), METH_O, nullptr },
        { "add_pointer_wheel_changed", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_add_PointerWheelChanged), METH_O, nullptr },
        { "remove_pointer_wheel_changed", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_remove_PointerWheelChanged), METH_O, nullptr },
        { "add_pointer_routed_away", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_add_PointerRoutedAway), METH_O, nullptr },
        { "remove_pointer_routed_away", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_remove_PointerRoutedAway), METH_O, nullptr },
        { "add_pointer_routed_released", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_add_PointerRoutedReleased), METH_O, nullptr },
        { "remove_pointer_routed_released", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_remove_PointerRoutedReleased), METH_O, nullptr },
        { "add_pointer_routed_to", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_add_PointerRoutedTo), METH_O, nullptr },
        { "remove_pointer_routed_to", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_remove_PointerRoutedTo), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreIndependentInputSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreIndependentInputSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreIndependentInputSource[] = {
        { "is_input_enabled", reinterpret_cast<getter>(CoreIndependentInputSource_get_IsInputEnabled), reinterpret_cast<setter>(CoreIndependentInputSource_put_IsInputEnabled), nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(CoreIndependentInputSource_get_Dispatcher), nullptr, nullptr, nullptr },
        { "pointer_cursor", reinterpret_cast<getter>(CoreIndependentInputSource_get_PointerCursor), reinterpret_cast<setter>(CoreIndependentInputSource_put_PointerCursor), nullptr, nullptr },
        { "has_capture", reinterpret_cast<getter>(CoreIndependentInputSource_get_HasCapture), nullptr, nullptr, nullptr },
        { "pointer_position", reinterpret_cast<getter>(CoreIndependentInputSource_get_PointerPosition), nullptr, nullptr, nullptr },
        { "dispatcher_queue", reinterpret_cast<getter>(CoreIndependentInputSource_get_DispatcherQueue), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreIndependentInputSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreIndependentInputSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreIndependentInputSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreIndependentInputSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreIndependentInputSource) },
        { },
    };

    static PyType_Spec type_spec_CoreIndependentInputSource =
    {
        "_winsdk_Windows_UI_Core.CoreIndependentInputSource",
        sizeof(py::wrapper::Windows::UI::Core::CoreIndependentInputSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreIndependentInputSource
    };

    // ----- CoreIndependentInputSourceController class --------------------
    static constexpr const char* const type_name_CoreIndependentInputSourceController = "CoreIndependentInputSourceController";

    static PyObject* _new_CoreIndependentInputSourceController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreIndependentInputSourceController);
        return nullptr;
    }

    static void _dealloc_CoreIndependentInputSourceController(py::wrapper::Windows::UI::Core::CoreIndependentInputSourceController* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreIndependentInputSourceController_Close(py::wrapper::Windows::UI::Core::CoreIndependentInputSourceController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreIndependentInputSourceController", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSourceController_CreateForIVisualElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreIndependentInputSourceController", L"CreateForIVisualElement", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Composition::IVisualElement>(args, 0);

                return py::convert(winrt::Windows::UI::Core::CoreIndependentInputSourceController::CreateForIVisualElement(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSourceController_CreateForVisual(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreIndependentInputSourceController", L"CreateForVisual", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Visual>(args, 0);

                return py::convert(winrt::Windows::UI::Core::CoreIndependentInputSourceController::CreateForVisual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSourceController_SetControlledInput(py::wrapper::Windows::UI::Core::CoreIndependentInputSourceController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreIndependentInputSourceController", L"SetControlledInput", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreInputDeviceTypes>(args, 0);

                self->obj.SetControlledInput(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreIndependentInputSourceController", L"SetControlledInput", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreInputDeviceTypes>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Core::CoreIndependentInputFilters>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Core::CoreIndependentInputFilters>(args, 2);

                self->obj.SetControlledInput(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSourceController_get_IsTransparentForUncontrolledInput(py::wrapper::Windows::UI::Core::CoreIndependentInputSourceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreIndependentInputSourceController", L"IsTransparentForUncontrolledInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTransparentForUncontrolledInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreIndependentInputSourceController_put_IsTransparentForUncontrolledInput(py::wrapper::Windows::UI::Core::CoreIndependentInputSourceController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreIndependentInputSourceController", L"IsTransparentForUncontrolledInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsTransparentForUncontrolledInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreIndependentInputSourceController_get_IsPalmRejectionEnabled(py::wrapper::Windows::UI::Core::CoreIndependentInputSourceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreIndependentInputSourceController", L"IsPalmRejectionEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPalmRejectionEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreIndependentInputSourceController_put_IsPalmRejectionEnabled(py::wrapper::Windows::UI::Core::CoreIndependentInputSourceController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreIndependentInputSourceController", L"IsPalmRejectionEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPalmRejectionEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreIndependentInputSourceController_get_Source(py::wrapper::Windows::UI::Core::CoreIndependentInputSourceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreIndependentInputSourceController", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreIndependentInputSourceController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CoreIndependentInputSourceController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreIndependentInputSourceController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::CoreIndependentInputSourceController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_CoreIndependentInputSourceController(py::wrapper::Windows::UI::Core::CoreIndependentInputSourceController* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_CoreIndependentInputSourceController(py::wrapper::Windows::UI::Core::CoreIndependentInputSourceController* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreIndependentInputSourceController[] = {
        { "close", reinterpret_cast<PyCFunction>(CoreIndependentInputSourceController_Close), METH_VARARGS, nullptr },
        { "create_for_i_visual_element", reinterpret_cast<PyCFunction>(CoreIndependentInputSourceController_CreateForIVisualElement), METH_VARARGS | METH_STATIC, nullptr },
        { "create_for_visual", reinterpret_cast<PyCFunction>(CoreIndependentInputSourceController_CreateForVisual), METH_VARARGS | METH_STATIC, nullptr },
        { "set_controlled_input", reinterpret_cast<PyCFunction>(CoreIndependentInputSourceController_SetControlledInput), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreIndependentInputSourceController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreIndependentInputSourceController), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_CoreIndependentInputSourceController), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_CoreIndependentInputSourceController), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreIndependentInputSourceController[] = {
        { "is_transparent_for_uncontrolled_input", reinterpret_cast<getter>(CoreIndependentInputSourceController_get_IsTransparentForUncontrolledInput), reinterpret_cast<setter>(CoreIndependentInputSourceController_put_IsTransparentForUncontrolledInput), nullptr, nullptr },
        { "is_palm_rejection_enabled", reinterpret_cast<getter>(CoreIndependentInputSourceController_get_IsPalmRejectionEnabled), reinterpret_cast<setter>(CoreIndependentInputSourceController_put_IsPalmRejectionEnabled), nullptr, nullptr },
        { "source", reinterpret_cast<getter>(CoreIndependentInputSourceController_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreIndependentInputSourceController[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreIndependentInputSourceController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreIndependentInputSourceController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreIndependentInputSourceController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreIndependentInputSourceController) },
        { },
    };

    static PyType_Spec type_spec_CoreIndependentInputSourceController =
    {
        "_winsdk_Windows_UI_Core.CoreIndependentInputSourceController",
        sizeof(py::wrapper::Windows::UI::Core::CoreIndependentInputSourceController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreIndependentInputSourceController
    };

    // ----- CoreWindow class --------------------
    static constexpr const char* const type_name_CoreWindow = "CoreWindow";

    static PyObject* _new_CoreWindow(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreWindow);
        return nullptr;
    }

    static void _dealloc_CoreWindow(py::wrapper::Windows::UI::Core::CoreWindow* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWindow_Activate(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreWindow", L"Activate", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Activate();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWindow_Close(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreWindow", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWindow_GetAsyncKeyState(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreWindow", L"GetAsyncKeyState", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(args, 0);

                return py::convert(self->obj.GetAsyncKeyState(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWindow_GetCurrentKeyEventDeviceId(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreWindow", L"GetCurrentKeyEventDeviceId", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentKeyEventDeviceId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWindow_GetForCurrentThread(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreWindow", L"GetForCurrentThread", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Core::CoreWindow::GetForCurrentThread());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWindow_GetKeyState(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreWindow", L"GetKeyState", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(args, 0);

                return py::convert(self->obj.GetKeyState(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWindow_ReleasePointerCapture(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreWindow", L"ReleasePointerCapture", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ReleasePointerCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWindow_SetPointerCapture(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreWindow", L"SetPointerCapture", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.SetPointerCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWindow_get_PointerPosition(py::wrapper::Windows::UI::Core::CoreWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"PointerPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindow_put_PointerPosition(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"PointerPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.PointerPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWindow_get_PointerCursor(py::wrapper::Windows::UI::Core::CoreWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"PointerCursor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerCursor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindow_put_PointerCursor(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"PointerCursor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreCursor>(arg);

            self->obj.PointerCursor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWindow_get_FlowDirection(py::wrapper::Windows::UI::Core::CoreWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"FlowDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FlowDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindow_put_FlowDirection(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"FlowDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreWindowFlowDirection>(arg);

            self->obj.FlowDirection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWindow_get_IsInputEnabled(py::wrapper::Windows::UI::Core::CoreWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"IsInputEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInputEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindow_put_IsInputEnabled(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"IsInputEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsInputEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWindow_get_Dispatcher(py::wrapper::Windows::UI::Core::CoreWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"Dispatcher"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_get_AutomationHostProvider(py::wrapper::Windows::UI::Core::CoreWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"AutomationHostProvider"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutomationHostProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_get_Bounds(py::wrapper::Windows::UI::Core::CoreWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"Bounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Bounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_get_CustomProperties(py::wrapper::Windows::UI::Core::CoreWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"CustomProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CustomProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_get_Visible(py::wrapper::Windows::UI::Core::CoreWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"Visible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Visible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_get_ActivationMode(py::wrapper::Windows::UI::Core::CoreWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"ActivationMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivationMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_get_DispatcherQueue(py::wrapper::Windows::UI::Core::CoreWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"DispatcherQueue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DispatcherQueue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_get_UIContext(py::wrapper::Windows::UI::Core::CoreWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"UIContext"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UIContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_Activated(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"Activated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::WindowActivatedEventArgs>>(arg);

            return py::convert(self->obj.Activated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_Activated(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"Activated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Activated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_AutomationProviderRequested(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"AutomationProviderRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::AutomationProviderRequestedEventArgs>>(arg);

            return py::convert(self->obj.AutomationProviderRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_AutomationProviderRequested(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"AutomationProviderRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AutomationProviderRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_CharacterReceived(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"CharacterReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::CharacterReceivedEventArgs>>(arg);

            return py::convert(self->obj.CharacterReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_CharacterReceived(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"CharacterReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CharacterReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_Closed(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::CoreWindowEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_Closed(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_InputEnabled(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"InputEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::InputEnabledEventArgs>>(arg);

            return py::convert(self->obj.InputEnabled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_InputEnabled(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"InputEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InputEnabled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_KeyDown(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"KeyDown"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::KeyEventArgs>>(arg);

            return py::convert(self->obj.KeyDown(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_KeyDown(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"KeyDown"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.KeyDown(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_KeyUp(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"KeyUp"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::KeyEventArgs>>(arg);

            return py::convert(self->obj.KeyUp(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_KeyUp(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"KeyUp"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.KeyUp(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_PointerCaptureLost(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerCaptureLost"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerCaptureLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_PointerCaptureLost(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerCaptureLost"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerCaptureLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_PointerEntered(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerEntered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_PointerEntered(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerEntered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_PointerExited(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerExited"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_PointerExited(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerExited"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_PointerMoved(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerMoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerMoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_PointerMoved(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerMoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerMoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_PointerPressed(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_PointerPressed(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_PointerReleased(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerReleased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_PointerReleased(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerReleased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_PointerWheelChanged(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerWheelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerWheelChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_PointerWheelChanged(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerWheelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerWheelChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_SizeChanged(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"SizeChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::WindowSizeChangedEventArgs>>(arg);

            return py::convert(self->obj.SizeChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_SizeChanged(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"SizeChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SizeChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_TouchHitTesting(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"TouchHitTesting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::TouchHitTestingEventArgs>>(arg);

            return py::convert(self->obj.TouchHitTesting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_TouchHitTesting(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"TouchHitTesting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TouchHitTesting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_VisibilityChanged(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"VisibilityChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::VisibilityChangedEventArgs>>(arg);

            return py::convert(self->obj.VisibilityChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_VisibilityChanged(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"VisibilityChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VisibilityChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_PointerRoutedAway(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerRoutedAway"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::ICorePointerRedirector, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerRoutedAway(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_PointerRoutedAway(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerRoutedAway"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerRoutedAway(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_PointerRoutedReleased(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerRoutedReleased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::ICorePointerRedirector, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerRoutedReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_PointerRoutedReleased(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerRoutedReleased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerRoutedReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_PointerRoutedTo(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerRoutedTo"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::ICorePointerRedirector, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerRoutedTo(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_PointerRoutedTo(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerRoutedTo"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerRoutedTo(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_ClosestInteractiveBoundsRequested(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"ClosestInteractiveBoundsRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::ClosestInteractiveBoundsRequestedEventArgs>>(arg);

            return py::convert(self->obj.ClosestInteractiveBoundsRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_ClosestInteractiveBoundsRequested(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"ClosestInteractiveBoundsRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ClosestInteractiveBoundsRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_ResizeCompleted(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"ResizeCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ResizeCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_ResizeCompleted(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"ResizeCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ResizeCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_ResizeStarted(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"ResizeStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ResizeStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_ResizeStarted(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"ResizeStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ResizeStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWindow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CoreWindow>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWindow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::CoreWindow>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWindow[] = {
        { "activate", reinterpret_cast<PyCFunction>(CoreWindow_Activate), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(CoreWindow_Close), METH_VARARGS, nullptr },
        { "get_async_key_state", reinterpret_cast<PyCFunction>(CoreWindow_GetAsyncKeyState), METH_VARARGS, nullptr },
        { "get_current_key_event_device_id", reinterpret_cast<PyCFunction>(CoreWindow_GetCurrentKeyEventDeviceId), METH_VARARGS, nullptr },
        { "get_for_current_thread", reinterpret_cast<PyCFunction>(CoreWindow_GetForCurrentThread), METH_VARARGS | METH_STATIC, nullptr },
        { "get_key_state", reinterpret_cast<PyCFunction>(CoreWindow_GetKeyState), METH_VARARGS, nullptr },
        { "release_pointer_capture", reinterpret_cast<PyCFunction>(CoreWindow_ReleasePointerCapture), METH_VARARGS, nullptr },
        { "set_pointer_capture", reinterpret_cast<PyCFunction>(CoreWindow_SetPointerCapture), METH_VARARGS, nullptr },
        { "add_activated", reinterpret_cast<PyCFunction>(CoreWindow_add_Activated), METH_O, nullptr },
        { "remove_activated", reinterpret_cast<PyCFunction>(CoreWindow_remove_Activated), METH_O, nullptr },
        { "add_automation_provider_requested", reinterpret_cast<PyCFunction>(CoreWindow_add_AutomationProviderRequested), METH_O, nullptr },
        { "remove_automation_provider_requested", reinterpret_cast<PyCFunction>(CoreWindow_remove_AutomationProviderRequested), METH_O, nullptr },
        { "add_character_received", reinterpret_cast<PyCFunction>(CoreWindow_add_CharacterReceived), METH_O, nullptr },
        { "remove_character_received", reinterpret_cast<PyCFunction>(CoreWindow_remove_CharacterReceived), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(CoreWindow_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(CoreWindow_remove_Closed), METH_O, nullptr },
        { "add_input_enabled", reinterpret_cast<PyCFunction>(CoreWindow_add_InputEnabled), METH_O, nullptr },
        { "remove_input_enabled", reinterpret_cast<PyCFunction>(CoreWindow_remove_InputEnabled), METH_O, nullptr },
        { "add_key_down", reinterpret_cast<PyCFunction>(CoreWindow_add_KeyDown), METH_O, nullptr },
        { "remove_key_down", reinterpret_cast<PyCFunction>(CoreWindow_remove_KeyDown), METH_O, nullptr },
        { "add_key_up", reinterpret_cast<PyCFunction>(CoreWindow_add_KeyUp), METH_O, nullptr },
        { "remove_key_up", reinterpret_cast<PyCFunction>(CoreWindow_remove_KeyUp), METH_O, nullptr },
        { "add_pointer_capture_lost", reinterpret_cast<PyCFunction>(CoreWindow_add_PointerCaptureLost), METH_O, nullptr },
        { "remove_pointer_capture_lost", reinterpret_cast<PyCFunction>(CoreWindow_remove_PointerCaptureLost), METH_O, nullptr },
        { "add_pointer_entered", reinterpret_cast<PyCFunction>(CoreWindow_add_PointerEntered), METH_O, nullptr },
        { "remove_pointer_entered", reinterpret_cast<PyCFunction>(CoreWindow_remove_PointerEntered), METH_O, nullptr },
        { "add_pointer_exited", reinterpret_cast<PyCFunction>(CoreWindow_add_PointerExited), METH_O, nullptr },
        { "remove_pointer_exited", reinterpret_cast<PyCFunction>(CoreWindow_remove_PointerExited), METH_O, nullptr },
        { "add_pointer_moved", reinterpret_cast<PyCFunction>(CoreWindow_add_PointerMoved), METH_O, nullptr },
        { "remove_pointer_moved", reinterpret_cast<PyCFunction>(CoreWindow_remove_PointerMoved), METH_O, nullptr },
        { "add_pointer_pressed", reinterpret_cast<PyCFunction>(CoreWindow_add_PointerPressed), METH_O, nullptr },
        { "remove_pointer_pressed", reinterpret_cast<PyCFunction>(CoreWindow_remove_PointerPressed), METH_O, nullptr },
        { "add_pointer_released", reinterpret_cast<PyCFunction>(CoreWindow_add_PointerReleased), METH_O, nullptr },
        { "remove_pointer_released", reinterpret_cast<PyCFunction>(CoreWindow_remove_PointerReleased), METH_O, nullptr },
        { "add_pointer_wheel_changed", reinterpret_cast<PyCFunction>(CoreWindow_add_PointerWheelChanged), METH_O, nullptr },
        { "remove_pointer_wheel_changed", reinterpret_cast<PyCFunction>(CoreWindow_remove_PointerWheelChanged), METH_O, nullptr },
        { "add_size_changed", reinterpret_cast<PyCFunction>(CoreWindow_add_SizeChanged), METH_O, nullptr },
        { "remove_size_changed", reinterpret_cast<PyCFunction>(CoreWindow_remove_SizeChanged), METH_O, nullptr },
        { "add_touch_hit_testing", reinterpret_cast<PyCFunction>(CoreWindow_add_TouchHitTesting), METH_O, nullptr },
        { "remove_touch_hit_testing", reinterpret_cast<PyCFunction>(CoreWindow_remove_TouchHitTesting), METH_O, nullptr },
        { "add_visibility_changed", reinterpret_cast<PyCFunction>(CoreWindow_add_VisibilityChanged), METH_O, nullptr },
        { "remove_visibility_changed", reinterpret_cast<PyCFunction>(CoreWindow_remove_VisibilityChanged), METH_O, nullptr },
        { "add_pointer_routed_away", reinterpret_cast<PyCFunction>(CoreWindow_add_PointerRoutedAway), METH_O, nullptr },
        { "remove_pointer_routed_away", reinterpret_cast<PyCFunction>(CoreWindow_remove_PointerRoutedAway), METH_O, nullptr },
        { "add_pointer_routed_released", reinterpret_cast<PyCFunction>(CoreWindow_add_PointerRoutedReleased), METH_O, nullptr },
        { "remove_pointer_routed_released", reinterpret_cast<PyCFunction>(CoreWindow_remove_PointerRoutedReleased), METH_O, nullptr },
        { "add_pointer_routed_to", reinterpret_cast<PyCFunction>(CoreWindow_add_PointerRoutedTo), METH_O, nullptr },
        { "remove_pointer_routed_to", reinterpret_cast<PyCFunction>(CoreWindow_remove_PointerRoutedTo), METH_O, nullptr },
        { "add_closest_interactive_bounds_requested", reinterpret_cast<PyCFunction>(CoreWindow_add_ClosestInteractiveBoundsRequested), METH_O, nullptr },
        { "remove_closest_interactive_bounds_requested", reinterpret_cast<PyCFunction>(CoreWindow_remove_ClosestInteractiveBoundsRequested), METH_O, nullptr },
        { "add_resize_completed", reinterpret_cast<PyCFunction>(CoreWindow_add_ResizeCompleted), METH_O, nullptr },
        { "remove_resize_completed", reinterpret_cast<PyCFunction>(CoreWindow_remove_ResizeCompleted), METH_O, nullptr },
        { "add_resize_started", reinterpret_cast<PyCFunction>(CoreWindow_add_ResizeStarted), METH_O, nullptr },
        { "remove_resize_started", reinterpret_cast<PyCFunction>(CoreWindow_remove_ResizeStarted), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreWindow, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWindow), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWindow[] = {
        { "pointer_position", reinterpret_cast<getter>(CoreWindow_get_PointerPosition), reinterpret_cast<setter>(CoreWindow_put_PointerPosition), nullptr, nullptr },
        { "pointer_cursor", reinterpret_cast<getter>(CoreWindow_get_PointerCursor), reinterpret_cast<setter>(CoreWindow_put_PointerCursor), nullptr, nullptr },
        { "flow_direction", reinterpret_cast<getter>(CoreWindow_get_FlowDirection), reinterpret_cast<setter>(CoreWindow_put_FlowDirection), nullptr, nullptr },
        { "is_input_enabled", reinterpret_cast<getter>(CoreWindow_get_IsInputEnabled), reinterpret_cast<setter>(CoreWindow_put_IsInputEnabled), nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(CoreWindow_get_Dispatcher), nullptr, nullptr, nullptr },
        { "automation_host_provider", reinterpret_cast<getter>(CoreWindow_get_AutomationHostProvider), nullptr, nullptr, nullptr },
        { "bounds", reinterpret_cast<getter>(CoreWindow_get_Bounds), nullptr, nullptr, nullptr },
        { "custom_properties", reinterpret_cast<getter>(CoreWindow_get_CustomProperties), nullptr, nullptr, nullptr },
        { "visible", reinterpret_cast<getter>(CoreWindow_get_Visible), nullptr, nullptr, nullptr },
        { "activation_mode", reinterpret_cast<getter>(CoreWindow_get_ActivationMode), nullptr, nullptr, nullptr },
        { "dispatcher_queue", reinterpret_cast<getter>(CoreWindow_get_DispatcherQueue), nullptr, nullptr, nullptr },
        { "u_i_context", reinterpret_cast<getter>(CoreWindow_get_UIContext), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWindow[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWindow) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWindow) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWindow) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWindow) },
        { },
    };

    static PyType_Spec type_spec_CoreWindow =
    {
        "_winsdk_Windows_UI_Core.CoreWindow",
        sizeof(py::wrapper::Windows::UI::Core::CoreWindow),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWindow
    };

    // ----- CoreWindowDialog class --------------------
    static constexpr const char* const type_name_CoreWindowDialog = "CoreWindowDialog";

    static PyObject* _new_CoreWindowDialog(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::UI::Core::CoreWindowDialog instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Core::CoreWindowDialog instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CoreWindowDialog(py::wrapper::Windows::UI::Core::CoreWindowDialog* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWindowDialog_ShowAsync(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreWindowDialog", L"ShowAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ShowAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWindowDialog_get_Title(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowDialog", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindowDialog_put_Title(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowDialog", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWindowDialog_get_IsInteractionDelayed(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowDialog", L"IsInteractionDelayed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInteractionDelayed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindowDialog_put_IsInteractionDelayed(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowDialog", L"IsInteractionDelayed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.IsInteractionDelayed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWindowDialog_get_DefaultCommandIndex(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowDialog", L"DefaultCommandIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultCommandIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindowDialog_put_DefaultCommandIndex(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowDialog", L"DefaultCommandIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.DefaultCommandIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWindowDialog_get_CancelCommandIndex(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowDialog", L"CancelCommandIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CancelCommandIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindowDialog_put_CancelCommandIndex(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowDialog", L"CancelCommandIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CancelCommandIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWindowDialog_get_BackButtonCommand(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowDialog", L"BackButtonCommand"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BackButtonCommand());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindowDialog_put_BackButtonCommand(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowDialog", L"BackButtonCommand"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Popups::UICommandInvokedHandler>(arg);

            self->obj.BackButtonCommand(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWindowDialog_get_Commands(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowDialog", L"Commands"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Commands());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindowDialog_get_MaxSize(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowDialog", L"MaxSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindowDialog_get_MinSize(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowDialog", L"MinSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindowDialog_add_Showing(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindowDialog", L"Showing"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::CoreWindowPopupShowingEventArgs>>(arg);

            return py::convert(self->obj.Showing(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindowDialog_remove_Showing(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindowDialog", L"Showing"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Showing(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWindowDialog(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CoreWindowDialog>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWindowDialog(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::CoreWindowDialog>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWindowDialog[] = {
        { "show_async", reinterpret_cast<PyCFunction>(CoreWindowDialog_ShowAsync), METH_VARARGS, nullptr },
        { "add_showing", reinterpret_cast<PyCFunction>(CoreWindowDialog_add_Showing), METH_O, nullptr },
        { "remove_showing", reinterpret_cast<PyCFunction>(CoreWindowDialog_remove_Showing), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreWindowDialog, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWindowDialog), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWindowDialog[] = {
        { "title", reinterpret_cast<getter>(CoreWindowDialog_get_Title), reinterpret_cast<setter>(CoreWindowDialog_put_Title), nullptr, nullptr },
        { "is_interaction_delayed", reinterpret_cast<getter>(CoreWindowDialog_get_IsInteractionDelayed), reinterpret_cast<setter>(CoreWindowDialog_put_IsInteractionDelayed), nullptr, nullptr },
        { "default_command_index", reinterpret_cast<getter>(CoreWindowDialog_get_DefaultCommandIndex), reinterpret_cast<setter>(CoreWindowDialog_put_DefaultCommandIndex), nullptr, nullptr },
        { "cancel_command_index", reinterpret_cast<getter>(CoreWindowDialog_get_CancelCommandIndex), reinterpret_cast<setter>(CoreWindowDialog_put_CancelCommandIndex), nullptr, nullptr },
        { "back_button_command", reinterpret_cast<getter>(CoreWindowDialog_get_BackButtonCommand), reinterpret_cast<setter>(CoreWindowDialog_put_BackButtonCommand), nullptr, nullptr },
        { "commands", reinterpret_cast<getter>(CoreWindowDialog_get_Commands), nullptr, nullptr, nullptr },
        { "max_size", reinterpret_cast<getter>(CoreWindowDialog_get_MaxSize), nullptr, nullptr, nullptr },
        { "min_size", reinterpret_cast<getter>(CoreWindowDialog_get_MinSize), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWindowDialog[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWindowDialog) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWindowDialog) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWindowDialog) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWindowDialog) },
        { },
    };

    static PyType_Spec type_spec_CoreWindowDialog =
    {
        "_winsdk_Windows_UI_Core.CoreWindowDialog",
        sizeof(py::wrapper::Windows::UI::Core::CoreWindowDialog),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWindowDialog
    };

    // ----- CoreWindowEventArgs class --------------------
    static constexpr const char* const type_name_CoreWindowEventArgs = "CoreWindowEventArgs";

    static PyObject* _new_CoreWindowEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreWindowEventArgs);
        return nullptr;
    }

    static void _dealloc_CoreWindowEventArgs(py::wrapper::Windows::UI::Core::CoreWindowEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWindowEventArgs_get_Handled(py::wrapper::Windows::UI::Core::CoreWindowEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindowEventArgs_put_Handled(py::wrapper::Windows::UI::Core::CoreWindowEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CoreWindowEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CoreWindowEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWindowEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::CoreWindowEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWindowEventArgs[] = {
        { "_assign_array_", _assign_array_CoreWindowEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWindowEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWindowEventArgs[] = {
        { "handled", reinterpret_cast<getter>(CoreWindowEventArgs_get_Handled), reinterpret_cast<setter>(CoreWindowEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWindowEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWindowEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWindowEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWindowEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWindowEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreWindowEventArgs =
    {
        "_winsdk_Windows_UI_Core.CoreWindowEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::CoreWindowEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWindowEventArgs
    };

    // ----- CoreWindowFlyout class --------------------
    static constexpr const char* const type_name_CoreWindowFlyout = "CoreWindowFlyout";

    static PyObject* _new_CoreWindowFlyout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                winrt::Windows::UI::Core::CoreWindowFlyout instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::UI::Core::CoreWindowFlyout instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CoreWindowFlyout(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWindowFlyout_ShowAsync(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreWindowFlyout", L"ShowAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ShowAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWindowFlyout_get_Title(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowFlyout", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindowFlyout_put_Title(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowFlyout", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWindowFlyout_get_IsInteractionDelayed(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowFlyout", L"IsInteractionDelayed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInteractionDelayed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindowFlyout_put_IsInteractionDelayed(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowFlyout", L"IsInteractionDelayed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.IsInteractionDelayed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWindowFlyout_get_DefaultCommandIndex(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowFlyout", L"DefaultCommandIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultCommandIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindowFlyout_put_DefaultCommandIndex(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowFlyout", L"DefaultCommandIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.DefaultCommandIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWindowFlyout_get_BackButtonCommand(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowFlyout", L"BackButtonCommand"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BackButtonCommand());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindowFlyout_put_BackButtonCommand(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowFlyout", L"BackButtonCommand"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Popups::UICommandInvokedHandler>(arg);

            self->obj.BackButtonCommand(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWindowFlyout_get_Commands(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowFlyout", L"Commands"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Commands());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindowFlyout_get_MaxSize(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowFlyout", L"MaxSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindowFlyout_get_MinSize(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowFlyout", L"MinSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindowFlyout_add_Showing(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindowFlyout", L"Showing"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::CoreWindowPopupShowingEventArgs>>(arg);

            return py::convert(self->obj.Showing(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindowFlyout_remove_Showing(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindowFlyout", L"Showing"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Showing(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWindowFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CoreWindowFlyout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWindowFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::CoreWindowFlyout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWindowFlyout[] = {
        { "show_async", reinterpret_cast<PyCFunction>(CoreWindowFlyout_ShowAsync), METH_VARARGS, nullptr },
        { "add_showing", reinterpret_cast<PyCFunction>(CoreWindowFlyout_add_Showing), METH_O, nullptr },
        { "remove_showing", reinterpret_cast<PyCFunction>(CoreWindowFlyout_remove_Showing), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreWindowFlyout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWindowFlyout), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWindowFlyout[] = {
        { "title", reinterpret_cast<getter>(CoreWindowFlyout_get_Title), reinterpret_cast<setter>(CoreWindowFlyout_put_Title), nullptr, nullptr },
        { "is_interaction_delayed", reinterpret_cast<getter>(CoreWindowFlyout_get_IsInteractionDelayed), reinterpret_cast<setter>(CoreWindowFlyout_put_IsInteractionDelayed), nullptr, nullptr },
        { "default_command_index", reinterpret_cast<getter>(CoreWindowFlyout_get_DefaultCommandIndex), reinterpret_cast<setter>(CoreWindowFlyout_put_DefaultCommandIndex), nullptr, nullptr },
        { "back_button_command", reinterpret_cast<getter>(CoreWindowFlyout_get_BackButtonCommand), reinterpret_cast<setter>(CoreWindowFlyout_put_BackButtonCommand), nullptr, nullptr },
        { "commands", reinterpret_cast<getter>(CoreWindowFlyout_get_Commands), nullptr, nullptr, nullptr },
        { "max_size", reinterpret_cast<getter>(CoreWindowFlyout_get_MaxSize), nullptr, nullptr, nullptr },
        { "min_size", reinterpret_cast<getter>(CoreWindowFlyout_get_MinSize), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWindowFlyout[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWindowFlyout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWindowFlyout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWindowFlyout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWindowFlyout) },
        { },
    };

    static PyType_Spec type_spec_CoreWindowFlyout =
    {
        "_winsdk_Windows_UI_Core.CoreWindowFlyout",
        sizeof(py::wrapper::Windows::UI::Core::CoreWindowFlyout),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWindowFlyout
    };

    // ----- CoreWindowPopupShowingEventArgs class --------------------
    static constexpr const char* const type_name_CoreWindowPopupShowingEventArgs = "CoreWindowPopupShowingEventArgs";

    static PyObject* _new_CoreWindowPopupShowingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreWindowPopupShowingEventArgs);
        return nullptr;
    }

    static void _dealloc_CoreWindowPopupShowingEventArgs(py::wrapper::Windows::UI::Core::CoreWindowPopupShowingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWindowPopupShowingEventArgs_SetDesiredSize(py::wrapper::Windows::UI::Core::CoreWindowPopupShowingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreWindowPopupShowingEventArgs", L"SetDesiredSize", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

                self->obj.SetDesiredSize(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWindowPopupShowingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CoreWindowPopupShowingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWindowPopupShowingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::CoreWindowPopupShowingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWindowPopupShowingEventArgs[] = {
        { "set_desired_size", reinterpret_cast<PyCFunction>(CoreWindowPopupShowingEventArgs_SetDesiredSize), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreWindowPopupShowingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWindowPopupShowingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWindowPopupShowingEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_CoreWindowPopupShowingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWindowPopupShowingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWindowPopupShowingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWindowPopupShowingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWindowPopupShowingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreWindowPopupShowingEventArgs =
    {
        "_winsdk_Windows_UI_Core.CoreWindowPopupShowingEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::CoreWindowPopupShowingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWindowPopupShowingEventArgs
    };

    // ----- CoreWindowResizeManager class --------------------
    static constexpr const char* const type_name_CoreWindowResizeManager = "CoreWindowResizeManager";

    static PyObject* _new_CoreWindowResizeManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreWindowResizeManager);
        return nullptr;
    }

    static void _dealloc_CoreWindowResizeManager(py::wrapper::Windows::UI::Core::CoreWindowResizeManager* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWindowResizeManager_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreWindowResizeManager", L"GetForCurrentView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Core::CoreWindowResizeManager::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWindowResizeManager_NotifyLayoutCompleted(py::wrapper::Windows::UI::Core::CoreWindowResizeManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreWindowResizeManager", L"NotifyLayoutCompleted", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.NotifyLayoutCompleted();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWindowResizeManager_get_ShouldWaitForLayoutCompletion(py::wrapper::Windows::UI::Core::CoreWindowResizeManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowResizeManager", L"ShouldWaitForLayoutCompletion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShouldWaitForLayoutCompletion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindowResizeManager_put_ShouldWaitForLayoutCompletion(py::wrapper::Windows::UI::Core::CoreWindowResizeManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowResizeManager", L"ShouldWaitForLayoutCompletion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShouldWaitForLayoutCompletion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CoreWindowResizeManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CoreWindowResizeManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWindowResizeManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::CoreWindowResizeManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWindowResizeManager[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(CoreWindowResizeManager_GetForCurrentView), METH_VARARGS | METH_STATIC, nullptr },
        { "notify_layout_completed", reinterpret_cast<PyCFunction>(CoreWindowResizeManager_NotifyLayoutCompleted), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreWindowResizeManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWindowResizeManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWindowResizeManager[] = {
        { "should_wait_for_layout_completion", reinterpret_cast<getter>(CoreWindowResizeManager_get_ShouldWaitForLayoutCompletion), reinterpret_cast<setter>(CoreWindowResizeManager_put_ShouldWaitForLayoutCompletion), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWindowResizeManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWindowResizeManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWindowResizeManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWindowResizeManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWindowResizeManager) },
        { },
    };

    static PyType_Spec type_spec_CoreWindowResizeManager =
    {
        "_winsdk_Windows_UI_Core.CoreWindowResizeManager",
        sizeof(py::wrapper::Windows::UI::Core::CoreWindowResizeManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWindowResizeManager
    };

    // ----- IdleDispatchedHandlerArgs class --------------------
    static constexpr const char* const type_name_IdleDispatchedHandlerArgs = "IdleDispatchedHandlerArgs";

    static PyObject* _new_IdleDispatchedHandlerArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_IdleDispatchedHandlerArgs);
        return nullptr;
    }

    static void _dealloc_IdleDispatchedHandlerArgs(py::wrapper::Windows::UI::Core::IdleDispatchedHandlerArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IdleDispatchedHandlerArgs_get_IsDispatcherIdle(py::wrapper::Windows::UI::Core::IdleDispatchedHandlerArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.IdleDispatchedHandlerArgs", L"IsDispatcherIdle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDispatcherIdle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IdleDispatchedHandlerArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::IdleDispatchedHandlerArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IdleDispatchedHandlerArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::IdleDispatchedHandlerArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IdleDispatchedHandlerArgs[] = {
        { "_assign_array_", _assign_array_IdleDispatchedHandlerArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IdleDispatchedHandlerArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IdleDispatchedHandlerArgs[] = {
        { "is_dispatcher_idle", reinterpret_cast<getter>(IdleDispatchedHandlerArgs_get_IsDispatcherIdle), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IdleDispatchedHandlerArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IdleDispatchedHandlerArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IdleDispatchedHandlerArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IdleDispatchedHandlerArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IdleDispatchedHandlerArgs) },
        { },
    };

    static PyType_Spec type_spec_IdleDispatchedHandlerArgs =
    {
        "_winsdk_Windows_UI_Core.IdleDispatchedHandlerArgs",
        sizeof(py::wrapper::Windows::UI::Core::IdleDispatchedHandlerArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IdleDispatchedHandlerArgs
    };

    // ----- InputEnabledEventArgs class --------------------
    static constexpr const char* const type_name_InputEnabledEventArgs = "InputEnabledEventArgs";

    static PyObject* _new_InputEnabledEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_InputEnabledEventArgs);
        return nullptr;
    }

    static void _dealloc_InputEnabledEventArgs(py::wrapper::Windows::UI::Core::InputEnabledEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputEnabledEventArgs_get_Handled(py::wrapper::Windows::UI::Core::InputEnabledEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.InputEnabledEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InputEnabledEventArgs_put_Handled(py::wrapper::Windows::UI::Core::InputEnabledEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.InputEnabledEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InputEnabledEventArgs_get_InputEnabled(py::wrapper::Windows::UI::Core::InputEnabledEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.InputEnabledEventArgs", L"InputEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InputEnabledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::InputEnabledEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputEnabledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::InputEnabledEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputEnabledEventArgs[] = {
        { "_assign_array_", _assign_array_InputEnabledEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputEnabledEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InputEnabledEventArgs[] = {
        { "handled", reinterpret_cast<getter>(InputEnabledEventArgs_get_Handled), reinterpret_cast<setter>(InputEnabledEventArgs_put_Handled), nullptr, nullptr },
        { "input_enabled", reinterpret_cast<getter>(InputEnabledEventArgs_get_InputEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InputEnabledEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputEnabledEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputEnabledEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputEnabledEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputEnabledEventArgs) },
        { },
    };

    static PyType_Spec type_spec_InputEnabledEventArgs =
    {
        "_winsdk_Windows_UI_Core.InputEnabledEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::InputEnabledEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputEnabledEventArgs
    };

    // ----- KeyEventArgs class --------------------
    static constexpr const char* const type_name_KeyEventArgs = "KeyEventArgs";

    static PyObject* _new_KeyEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KeyEventArgs);
        return nullptr;
    }

    static void _dealloc_KeyEventArgs(py::wrapper::Windows::UI::Core::KeyEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* KeyEventArgs_get_Handled(py::wrapper::Windows::UI::Core::KeyEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.KeyEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyEventArgs_put_Handled(py::wrapper::Windows::UI::Core::KeyEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.KeyEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeyEventArgs_get_KeyStatus(py::wrapper::Windows::UI::Core::KeyEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.KeyEventArgs", L"KeyStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyEventArgs_get_VirtualKey(py::wrapper::Windows::UI::Core::KeyEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.KeyEventArgs", L"VirtualKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VirtualKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyEventArgs_get_DeviceId(py::wrapper::Windows::UI::Core::KeyEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.KeyEventArgs", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_KeyEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::KeyEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_KeyEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::KeyEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyEventArgs[] = {
        { "_assign_array_", _assign_array_KeyEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_KeyEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KeyEventArgs[] = {
        { "handled", reinterpret_cast<getter>(KeyEventArgs_get_Handled), reinterpret_cast<setter>(KeyEventArgs_put_Handled), nullptr, nullptr },
        { "key_status", reinterpret_cast<getter>(KeyEventArgs_get_KeyStatus), nullptr, nullptr, nullptr },
        { "virtual_key", reinterpret_cast<getter>(KeyEventArgs_get_VirtualKey), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(KeyEventArgs_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_KeyEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_KeyEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeyEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyEventArgs) },
        { },
    };

    static PyType_Spec type_spec_KeyEventArgs =
    {
        "_winsdk_Windows_UI_Core.KeyEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::KeyEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyEventArgs
    };

    // ----- PointerEventArgs class --------------------
    static constexpr const char* const type_name_PointerEventArgs = "PointerEventArgs";

    static PyObject* _new_PointerEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PointerEventArgs);
        return nullptr;
    }

    static void _dealloc_PointerEventArgs(py::wrapper::Windows::UI::Core::PointerEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PointerEventArgs_GetIntermediatePoints(py::wrapper::Windows::UI::Core::PointerEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.PointerEventArgs", L"GetIntermediatePoints", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetIntermediatePoints());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerEventArgs_get_Handled(py::wrapper::Windows::UI::Core::PointerEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.PointerEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerEventArgs_put_Handled(py::wrapper::Windows::UI::Core::PointerEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.PointerEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerEventArgs_get_CurrentPoint(py::wrapper::Windows::UI::Core::PointerEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.PointerEventArgs", L"CurrentPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerEventArgs_get_KeyModifiers(py::wrapper::Windows::UI::Core::PointerEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.PointerEventArgs", L"KeyModifiers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyModifiers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PointerEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::PointerEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PointerEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::PointerEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PointerEventArgs[] = {
        { "get_intermediate_points", reinterpret_cast<PyCFunction>(PointerEventArgs_GetIntermediatePoints), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PointerEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PointerEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PointerEventArgs[] = {
        { "handled", reinterpret_cast<getter>(PointerEventArgs_get_Handled), reinterpret_cast<setter>(PointerEventArgs_put_Handled), nullptr, nullptr },
        { "current_point", reinterpret_cast<getter>(PointerEventArgs_get_CurrentPoint), nullptr, nullptr, nullptr },
        { "key_modifiers", reinterpret_cast<getter>(PointerEventArgs_get_KeyModifiers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PointerEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointerEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointerEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PointerEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointerEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PointerEventArgs =
    {
        "_winsdk_Windows_UI_Core.PointerEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::PointerEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointerEventArgs
    };

    // ----- SystemNavigationManager class --------------------
    static constexpr const char* const type_name_SystemNavigationManager = "SystemNavigationManager";

    static PyObject* _new_SystemNavigationManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SystemNavigationManager);
        return nullptr;
    }

    static void _dealloc_SystemNavigationManager(py::wrapper::Windows::UI::Core::SystemNavigationManager* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemNavigationManager_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.SystemNavigationManager", L"GetForCurrentView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Core::SystemNavigationManager::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemNavigationManager_get_AppViewBackButtonVisibility(py::wrapper::Windows::UI::Core::SystemNavigationManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.SystemNavigationManager", L"AppViewBackButtonVisibility"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppViewBackButtonVisibility());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemNavigationManager_put_AppViewBackButtonVisibility(py::wrapper::Windows::UI::Core::SystemNavigationManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.SystemNavigationManager", L"AppViewBackButtonVisibility"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Core::AppViewBackButtonVisibility>(arg);

            self->obj.AppViewBackButtonVisibility(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemNavigationManager_add_BackRequested(py::wrapper::Windows::UI::Core::SystemNavigationManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.SystemNavigationManager", L"BackRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::UI::Core::BackRequestedEventArgs>>(arg);

            return py::convert(self->obj.BackRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemNavigationManager_remove_BackRequested(py::wrapper::Windows::UI::Core::SystemNavigationManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.SystemNavigationManager", L"BackRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BackRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemNavigationManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::SystemNavigationManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemNavigationManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::SystemNavigationManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemNavigationManager[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(SystemNavigationManager_GetForCurrentView), METH_VARARGS | METH_STATIC, nullptr },
        { "add_back_requested", reinterpret_cast<PyCFunction>(SystemNavigationManager_add_BackRequested), METH_O, nullptr },
        { "remove_back_requested", reinterpret_cast<PyCFunction>(SystemNavigationManager_remove_BackRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_SystemNavigationManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemNavigationManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemNavigationManager[] = {
        { "app_view_back_button_visibility", reinterpret_cast<getter>(SystemNavigationManager_get_AppViewBackButtonVisibility), reinterpret_cast<setter>(SystemNavigationManager_put_AppViewBackButtonVisibility), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemNavigationManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemNavigationManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemNavigationManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemNavigationManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemNavigationManager) },
        { },
    };

    static PyType_Spec type_spec_SystemNavigationManager =
    {
        "_winsdk_Windows_UI_Core.SystemNavigationManager",
        sizeof(py::wrapper::Windows::UI::Core::SystemNavigationManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemNavigationManager
    };

    // ----- TouchHitTestingEventArgs class --------------------
    static constexpr const char* const type_name_TouchHitTestingEventArgs = "TouchHitTestingEventArgs";

    static PyObject* _new_TouchHitTestingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TouchHitTestingEventArgs);
        return nullptr;
    }

    static void _dealloc_TouchHitTestingEventArgs(py::wrapper::Windows::UI::Core::TouchHitTestingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TouchHitTestingEventArgs_EvaluateProximity(py::wrapper::Windows::UI::Core::TouchHitTestingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.TouchHitTestingEventArgs", L"EvaluateProximity", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                return py::convert(self->obj.EvaluateProximity(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TouchHitTestingEventArgs_get_Handled(py::wrapper::Windows::UI::Core::TouchHitTestingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.TouchHitTestingEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TouchHitTestingEventArgs_put_Handled(py::wrapper::Windows::UI::Core::TouchHitTestingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.TouchHitTestingEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TouchHitTestingEventArgs_get_ProximityEvaluation(py::wrapper::Windows::UI::Core::TouchHitTestingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.TouchHitTestingEventArgs", L"ProximityEvaluation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProximityEvaluation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TouchHitTestingEventArgs_put_ProximityEvaluation(py::wrapper::Windows::UI::Core::TouchHitTestingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.TouchHitTestingEventArgs", L"ProximityEvaluation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreProximityEvaluation>(arg);

            self->obj.ProximityEvaluation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TouchHitTestingEventArgs_get_BoundingBox(py::wrapper::Windows::UI::Core::TouchHitTestingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.TouchHitTestingEventArgs", L"BoundingBox"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BoundingBox());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TouchHitTestingEventArgs_get_Point(py::wrapper::Windows::UI::Core::TouchHitTestingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.TouchHitTestingEventArgs", L"Point"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Point());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TouchHitTestingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::TouchHitTestingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TouchHitTestingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::TouchHitTestingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TouchHitTestingEventArgs[] = {
        { "evaluate_proximity", reinterpret_cast<PyCFunction>(TouchHitTestingEventArgs_EvaluateProximity), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TouchHitTestingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TouchHitTestingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TouchHitTestingEventArgs[] = {
        { "handled", reinterpret_cast<getter>(TouchHitTestingEventArgs_get_Handled), reinterpret_cast<setter>(TouchHitTestingEventArgs_put_Handled), nullptr, nullptr },
        { "proximity_evaluation", reinterpret_cast<getter>(TouchHitTestingEventArgs_get_ProximityEvaluation), reinterpret_cast<setter>(TouchHitTestingEventArgs_put_ProximityEvaluation), nullptr, nullptr },
        { "bounding_box", reinterpret_cast<getter>(TouchHitTestingEventArgs_get_BoundingBox), nullptr, nullptr, nullptr },
        { "point", reinterpret_cast<getter>(TouchHitTestingEventArgs_get_Point), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TouchHitTestingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TouchHitTestingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TouchHitTestingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TouchHitTestingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TouchHitTestingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_TouchHitTestingEventArgs =
    {
        "_winsdk_Windows_UI_Core.TouchHitTestingEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::TouchHitTestingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TouchHitTestingEventArgs
    };

    // ----- VisibilityChangedEventArgs class --------------------
    static constexpr const char* const type_name_VisibilityChangedEventArgs = "VisibilityChangedEventArgs";

    static PyObject* _new_VisibilityChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_VisibilityChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_VisibilityChangedEventArgs(py::wrapper::Windows::UI::Core::VisibilityChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VisibilityChangedEventArgs_get_Handled(py::wrapper::Windows::UI::Core::VisibilityChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.VisibilityChangedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisibilityChangedEventArgs_put_Handled(py::wrapper::Windows::UI::Core::VisibilityChangedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.VisibilityChangedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VisibilityChangedEventArgs_get_Visible(py::wrapper::Windows::UI::Core::VisibilityChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.VisibilityChangedEventArgs", L"Visible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Visible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VisibilityChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::VisibilityChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VisibilityChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::VisibilityChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VisibilityChangedEventArgs[] = {
        { "_assign_array_", _assign_array_VisibilityChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VisibilityChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VisibilityChangedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(VisibilityChangedEventArgs_get_Handled), reinterpret_cast<setter>(VisibilityChangedEventArgs_put_Handled), nullptr, nullptr },
        { "visible", reinterpret_cast<getter>(VisibilityChangedEventArgs_get_Visible), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VisibilityChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VisibilityChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VisibilityChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VisibilityChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VisibilityChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_VisibilityChangedEventArgs =
    {
        "_winsdk_Windows_UI_Core.VisibilityChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::VisibilityChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VisibilityChangedEventArgs
    };

    // ----- WindowActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WindowActivatedEventArgs = "WindowActivatedEventArgs";

    static PyObject* _new_WindowActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WindowActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WindowActivatedEventArgs(py::wrapper::Windows::UI::Core::WindowActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowActivatedEventArgs_get_Handled(py::wrapper::Windows::UI::Core::WindowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.WindowActivatedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowActivatedEventArgs_put_Handled(py::wrapper::Windows::UI::Core::WindowActivatedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.WindowActivatedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowActivatedEventArgs_get_WindowActivationState(py::wrapper::Windows::UI::Core::WindowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.WindowActivatedEventArgs", L"WindowActivationState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WindowActivationState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::WindowActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::WindowActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WindowActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowActivatedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(WindowActivatedEventArgs_get_Handled), reinterpret_cast<setter>(WindowActivatedEventArgs_put_Handled), nullptr, nullptr },
        { "window_activation_state", reinterpret_cast<getter>(WindowActivatedEventArgs_get_WindowActivationState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WindowActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WindowActivatedEventArgs =
    {
        "_winsdk_Windows_UI_Core.WindowActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::WindowActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowActivatedEventArgs
    };

    // ----- WindowSizeChangedEventArgs class --------------------
    static constexpr const char* const type_name_WindowSizeChangedEventArgs = "WindowSizeChangedEventArgs";

    static PyObject* _new_WindowSizeChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WindowSizeChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_WindowSizeChangedEventArgs(py::wrapper::Windows::UI::Core::WindowSizeChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowSizeChangedEventArgs_get_Handled(py::wrapper::Windows::UI::Core::WindowSizeChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.WindowSizeChangedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowSizeChangedEventArgs_put_Handled(py::wrapper::Windows::UI::Core::WindowSizeChangedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.WindowSizeChangedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowSizeChangedEventArgs_get_Size(py::wrapper::Windows::UI::Core::WindowSizeChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.WindowSizeChangedEventArgs", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowSizeChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::WindowSizeChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowSizeChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::WindowSizeChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowSizeChangedEventArgs[] = {
        { "_assign_array_", _assign_array_WindowSizeChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowSizeChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowSizeChangedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(WindowSizeChangedEventArgs_get_Handled), reinterpret_cast<setter>(WindowSizeChangedEventArgs_put_Handled), nullptr, nullptr },
        { "size", reinterpret_cast<getter>(WindowSizeChangedEventArgs_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WindowSizeChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowSizeChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowSizeChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowSizeChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowSizeChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WindowSizeChangedEventArgs =
    {
        "_winsdk_Windows_UI_Core.WindowSizeChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::WindowSizeChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowSizeChangedEventArgs
    };

    // ----- ICoreAcceleratorKeys interface --------------------
    static constexpr const char* const type_name_ICoreAcceleratorKeys = "ICoreAcceleratorKeys";

    static PyObject* _new_ICoreAcceleratorKeys(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_ICoreAcceleratorKeys);
        return nullptr;
    }

    static void _dealloc_ICoreAcceleratorKeys(py::wrapper::Windows::UI::Core::ICoreAcceleratorKeys* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICoreAcceleratorKeys_add_AcceleratorKeyActivated(py::wrapper::Windows::UI::Core::ICoreAcceleratorKeys* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreAcceleratorKeys", L"AcceleratorKeyActivated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreDispatcher, winrt::Windows::UI::Core::AcceleratorKeyEventArgs>>(arg);

            return py::convert(self->obj.AcceleratorKeyActivated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreAcceleratorKeys_remove_AcceleratorKeyActivated(py::wrapper::Windows::UI::Core::ICoreAcceleratorKeys* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreAcceleratorKeys", L"AcceleratorKeyActivated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AcceleratorKeyActivated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICoreAcceleratorKeys(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::ICoreAcceleratorKeys>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICoreAcceleratorKeys(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::ICoreAcceleratorKeys>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICoreAcceleratorKeys[] = {
        { "add_accelerator_key_activated", reinterpret_cast<PyCFunction>(ICoreAcceleratorKeys_add_AcceleratorKeyActivated), METH_O, nullptr },
        { "remove_accelerator_key_activated", reinterpret_cast<PyCFunction>(ICoreAcceleratorKeys_remove_AcceleratorKeyActivated), METH_O, nullptr },
        { "_assign_array_", _assign_array_ICoreAcceleratorKeys, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICoreAcceleratorKeys), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICoreAcceleratorKeys[] = {
        { }
    };

    static PyType_Slot _type_slots_ICoreAcceleratorKeys[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICoreAcceleratorKeys) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICoreAcceleratorKeys) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICoreAcceleratorKeys) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICoreAcceleratorKeys) },
        { },
    };

    static PyType_Spec type_spec_ICoreAcceleratorKeys =
    {
        "_winsdk_Windows_UI_Core.ICoreAcceleratorKeys",
        sizeof(py::wrapper::Windows::UI::Core::ICoreAcceleratorKeys),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICoreAcceleratorKeys
    };

    // ----- ICoreInputSourceBase interface --------------------
    static constexpr const char* const type_name_ICoreInputSourceBase = "ICoreInputSourceBase";

    static PyObject* _new_ICoreInputSourceBase(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_ICoreInputSourceBase);
        return nullptr;
    }

    static void _dealloc_ICoreInputSourceBase(py::wrapper::Windows::UI::Core::ICoreInputSourceBase* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICoreInputSourceBase_get_Dispatcher(py::wrapper::Windows::UI::Core::ICoreInputSourceBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreInputSourceBase", L"Dispatcher"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreInputSourceBase_get_IsInputEnabled(py::wrapper::Windows::UI::Core::ICoreInputSourceBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreInputSourceBase", L"IsInputEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInputEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICoreInputSourceBase_put_IsInputEnabled(py::wrapper::Windows::UI::Core::ICoreInputSourceBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreInputSourceBase", L"IsInputEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsInputEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICoreInputSourceBase_add_InputEnabled(py::wrapper::Windows::UI::Core::ICoreInputSourceBase* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreInputSourceBase", L"InputEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::InputEnabledEventArgs>>(arg);

            return py::convert(self->obj.InputEnabled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreInputSourceBase_remove_InputEnabled(py::wrapper::Windows::UI::Core::ICoreInputSourceBase* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreInputSourceBase", L"InputEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InputEnabled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICoreInputSourceBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::ICoreInputSourceBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICoreInputSourceBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::ICoreInputSourceBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICoreInputSourceBase[] = {
        { "add_input_enabled", reinterpret_cast<PyCFunction>(ICoreInputSourceBase_add_InputEnabled), METH_O, nullptr },
        { "remove_input_enabled", reinterpret_cast<PyCFunction>(ICoreInputSourceBase_remove_InputEnabled), METH_O, nullptr },
        { "_assign_array_", _assign_array_ICoreInputSourceBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICoreInputSourceBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICoreInputSourceBase[] = {
        { "dispatcher", reinterpret_cast<getter>(ICoreInputSourceBase_get_Dispatcher), nullptr, nullptr, nullptr },
        { "is_input_enabled", reinterpret_cast<getter>(ICoreInputSourceBase_get_IsInputEnabled), reinterpret_cast<setter>(ICoreInputSourceBase_put_IsInputEnabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICoreInputSourceBase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICoreInputSourceBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICoreInputSourceBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICoreInputSourceBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICoreInputSourceBase) },
        { },
    };

    static PyType_Spec type_spec_ICoreInputSourceBase =
    {
        "_winsdk_Windows_UI_Core.ICoreInputSourceBase",
        sizeof(py::wrapper::Windows::UI::Core::ICoreInputSourceBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICoreInputSourceBase
    };

    // ----- ICorePointerInputSource interface --------------------
    static constexpr const char* const type_name_ICorePointerInputSource = "ICorePointerInputSource";

    static PyObject* _new_ICorePointerInputSource(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_ICorePointerInputSource);
        return nullptr;
    }

    static void _dealloc_ICorePointerInputSource(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICorePointerInputSource_ReleasePointerCapture(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.ICorePointerInputSource", L"ReleasePointerCapture", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ReleasePointerCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_SetPointerCapture(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.ICorePointerInputSource", L"SetPointerCapture", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.SetPointerCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_get_HasCapture(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICorePointerInputSource", L"HasCapture"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasCapture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_get_PointerCursor(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerCursor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerCursor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICorePointerInputSource_put_PointerCursor(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerCursor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreCursor>(arg);

            self->obj.PointerCursor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICorePointerInputSource_get_PointerPosition(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_add_PointerCaptureLost(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerCaptureLost"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerCaptureLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_remove_PointerCaptureLost(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerCaptureLost"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerCaptureLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_add_PointerEntered(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerEntered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_remove_PointerEntered(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerEntered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_add_PointerExited(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerExited"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_remove_PointerExited(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerExited"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_add_PointerMoved(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerMoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerMoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_remove_PointerMoved(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerMoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerMoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_add_PointerPressed(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_remove_PointerPressed(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_add_PointerReleased(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerReleased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_remove_PointerReleased(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerReleased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_add_PointerWheelChanged(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerWheelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerWheelChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_remove_PointerWheelChanged(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerWheelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerWheelChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICorePointerInputSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::ICorePointerInputSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICorePointerInputSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::ICorePointerInputSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICorePointerInputSource[] = {
        { "release_pointer_capture", reinterpret_cast<PyCFunction>(ICorePointerInputSource_ReleasePointerCapture), METH_VARARGS, nullptr },
        { "set_pointer_capture", reinterpret_cast<PyCFunction>(ICorePointerInputSource_SetPointerCapture), METH_VARARGS, nullptr },
        { "add_pointer_capture_lost", reinterpret_cast<PyCFunction>(ICorePointerInputSource_add_PointerCaptureLost), METH_O, nullptr },
        { "remove_pointer_capture_lost", reinterpret_cast<PyCFunction>(ICorePointerInputSource_remove_PointerCaptureLost), METH_O, nullptr },
        { "add_pointer_entered", reinterpret_cast<PyCFunction>(ICorePointerInputSource_add_PointerEntered), METH_O, nullptr },
        { "remove_pointer_entered", reinterpret_cast<PyCFunction>(ICorePointerInputSource_remove_PointerEntered), METH_O, nullptr },
        { "add_pointer_exited", reinterpret_cast<PyCFunction>(ICorePointerInputSource_add_PointerExited), METH_O, nullptr },
        { "remove_pointer_exited", reinterpret_cast<PyCFunction>(ICorePointerInputSource_remove_PointerExited), METH_O, nullptr },
        { "add_pointer_moved", reinterpret_cast<PyCFunction>(ICorePointerInputSource_add_PointerMoved), METH_O, nullptr },
        { "remove_pointer_moved", reinterpret_cast<PyCFunction>(ICorePointerInputSource_remove_PointerMoved), METH_O, nullptr },
        { "add_pointer_pressed", reinterpret_cast<PyCFunction>(ICorePointerInputSource_add_PointerPressed), METH_O, nullptr },
        { "remove_pointer_pressed", reinterpret_cast<PyCFunction>(ICorePointerInputSource_remove_PointerPressed), METH_O, nullptr },
        { "add_pointer_released", reinterpret_cast<PyCFunction>(ICorePointerInputSource_add_PointerReleased), METH_O, nullptr },
        { "remove_pointer_released", reinterpret_cast<PyCFunction>(ICorePointerInputSource_remove_PointerReleased), METH_O, nullptr },
        { "add_pointer_wheel_changed", reinterpret_cast<PyCFunction>(ICorePointerInputSource_add_PointerWheelChanged), METH_O, nullptr },
        { "remove_pointer_wheel_changed", reinterpret_cast<PyCFunction>(ICorePointerInputSource_remove_PointerWheelChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ICorePointerInputSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICorePointerInputSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICorePointerInputSource[] = {
        { "has_capture", reinterpret_cast<getter>(ICorePointerInputSource_get_HasCapture), nullptr, nullptr, nullptr },
        { "pointer_cursor", reinterpret_cast<getter>(ICorePointerInputSource_get_PointerCursor), reinterpret_cast<setter>(ICorePointerInputSource_put_PointerCursor), nullptr, nullptr },
        { "pointer_position", reinterpret_cast<getter>(ICorePointerInputSource_get_PointerPosition), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICorePointerInputSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICorePointerInputSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICorePointerInputSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICorePointerInputSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICorePointerInputSource) },
        { },
    };

    static PyType_Spec type_spec_ICorePointerInputSource =
    {
        "_winsdk_Windows_UI_Core.ICorePointerInputSource",
        sizeof(py::wrapper::Windows::UI::Core::ICorePointerInputSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICorePointerInputSource
    };

    // ----- ICorePointerInputSource2 interface --------------------
    static constexpr const char* const type_name_ICorePointerInputSource2 = "ICorePointerInputSource2";

    static PyObject* _new_ICorePointerInputSource2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_ICorePointerInputSource2);
        return nullptr;
    }

    static void _dealloc_ICorePointerInputSource2(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICorePointerInputSource2_ReleasePointerCapture(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.ICorePointerInputSource", L"ReleasePointerCapture", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ReleasePointerCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_SetPointerCapture(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.ICorePointerInputSource", L"SetPointerCapture", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.SetPointerCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_get_DispatcherQueue(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICorePointerInputSource2", L"DispatcherQueue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DispatcherQueue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_get_HasCapture(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICorePointerInputSource", L"HasCapture"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasCapture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_get_PointerCursor(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerCursor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerCursor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICorePointerInputSource2_put_PointerCursor(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerCursor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreCursor>(arg);

            self->obj.PointerCursor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICorePointerInputSource2_get_PointerPosition(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_add_PointerCaptureLost(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerCaptureLost"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerCaptureLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_remove_PointerCaptureLost(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerCaptureLost"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerCaptureLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_add_PointerEntered(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerEntered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_remove_PointerEntered(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerEntered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_add_PointerExited(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerExited"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_remove_PointerExited(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerExited"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_add_PointerMoved(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerMoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerMoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_remove_PointerMoved(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerMoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerMoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_add_PointerPressed(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_remove_PointerPressed(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_add_PointerReleased(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerReleased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_remove_PointerReleased(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerReleased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_add_PointerWheelChanged(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerWheelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerWheelChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_remove_PointerWheelChanged(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerWheelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerWheelChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICorePointerInputSource2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::ICorePointerInputSource2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICorePointerInputSource2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::ICorePointerInputSource2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICorePointerInputSource2[] = {
        { "release_pointer_capture", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_ReleasePointerCapture), METH_VARARGS, nullptr },
        { "set_pointer_capture", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_SetPointerCapture), METH_VARARGS, nullptr },
        { "add_pointer_capture_lost", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_add_PointerCaptureLost), METH_O, nullptr },
        { "remove_pointer_capture_lost", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_remove_PointerCaptureLost), METH_O, nullptr },
        { "add_pointer_entered", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_add_PointerEntered), METH_O, nullptr },
        { "remove_pointer_entered", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_remove_PointerEntered), METH_O, nullptr },
        { "add_pointer_exited", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_add_PointerExited), METH_O, nullptr },
        { "remove_pointer_exited", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_remove_PointerExited), METH_O, nullptr },
        { "add_pointer_moved", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_add_PointerMoved), METH_O, nullptr },
        { "remove_pointer_moved", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_remove_PointerMoved), METH_O, nullptr },
        { "add_pointer_pressed", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_add_PointerPressed), METH_O, nullptr },
        { "remove_pointer_pressed", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_remove_PointerPressed), METH_O, nullptr },
        { "add_pointer_released", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_add_PointerReleased), METH_O, nullptr },
        { "remove_pointer_released", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_remove_PointerReleased), METH_O, nullptr },
        { "add_pointer_wheel_changed", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_add_PointerWheelChanged), METH_O, nullptr },
        { "remove_pointer_wheel_changed", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_remove_PointerWheelChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ICorePointerInputSource2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICorePointerInputSource2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICorePointerInputSource2[] = {
        { "dispatcher_queue", reinterpret_cast<getter>(ICorePointerInputSource2_get_DispatcherQueue), nullptr, nullptr, nullptr },
        { "has_capture", reinterpret_cast<getter>(ICorePointerInputSource2_get_HasCapture), nullptr, nullptr, nullptr },
        { "pointer_cursor", reinterpret_cast<getter>(ICorePointerInputSource2_get_PointerCursor), reinterpret_cast<setter>(ICorePointerInputSource2_put_PointerCursor), nullptr, nullptr },
        { "pointer_position", reinterpret_cast<getter>(ICorePointerInputSource2_get_PointerPosition), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICorePointerInputSource2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICorePointerInputSource2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICorePointerInputSource2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICorePointerInputSource2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICorePointerInputSource2) },
        { },
    };

    static PyType_Spec type_spec_ICorePointerInputSource2 =
    {
        "_winsdk_Windows_UI_Core.ICorePointerInputSource2",
        sizeof(py::wrapper::Windows::UI::Core::ICorePointerInputSource2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICorePointerInputSource2
    };

    // ----- ICorePointerRedirector interface --------------------
    static constexpr const char* const type_name_ICorePointerRedirector = "ICorePointerRedirector";

    static PyObject* _new_ICorePointerRedirector(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_ICorePointerRedirector);
        return nullptr;
    }

    static void _dealloc_ICorePointerRedirector(py::wrapper::Windows::UI::Core::ICorePointerRedirector* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICorePointerRedirector_add_PointerRoutedAway(py::wrapper::Windows::UI::Core::ICorePointerRedirector* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerRedirector", L"PointerRoutedAway"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::ICorePointerRedirector, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerRoutedAway(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerRedirector_remove_PointerRoutedAway(py::wrapper::Windows::UI::Core::ICorePointerRedirector* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerRedirector", L"PointerRoutedAway"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerRoutedAway(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerRedirector_add_PointerRoutedReleased(py::wrapper::Windows::UI::Core::ICorePointerRedirector* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerRedirector", L"PointerRoutedReleased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::ICorePointerRedirector, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerRoutedReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerRedirector_remove_PointerRoutedReleased(py::wrapper::Windows::UI::Core::ICorePointerRedirector* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerRedirector", L"PointerRoutedReleased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerRoutedReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerRedirector_add_PointerRoutedTo(py::wrapper::Windows::UI::Core::ICorePointerRedirector* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerRedirector", L"PointerRoutedTo"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::ICorePointerRedirector, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerRoutedTo(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerRedirector_remove_PointerRoutedTo(py::wrapper::Windows::UI::Core::ICorePointerRedirector* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerRedirector", L"PointerRoutedTo"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerRoutedTo(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICorePointerRedirector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::ICorePointerRedirector>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICorePointerRedirector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::ICorePointerRedirector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICorePointerRedirector[] = {
        { "add_pointer_routed_away", reinterpret_cast<PyCFunction>(ICorePointerRedirector_add_PointerRoutedAway), METH_O, nullptr },
        { "remove_pointer_routed_away", reinterpret_cast<PyCFunction>(ICorePointerRedirector_remove_PointerRoutedAway), METH_O, nullptr },
        { "add_pointer_routed_released", reinterpret_cast<PyCFunction>(ICorePointerRedirector_add_PointerRoutedReleased), METH_O, nullptr },
        { "remove_pointer_routed_released", reinterpret_cast<PyCFunction>(ICorePointerRedirector_remove_PointerRoutedReleased), METH_O, nullptr },
        { "add_pointer_routed_to", reinterpret_cast<PyCFunction>(ICorePointerRedirector_add_PointerRoutedTo), METH_O, nullptr },
        { "remove_pointer_routed_to", reinterpret_cast<PyCFunction>(ICorePointerRedirector_remove_PointerRoutedTo), METH_O, nullptr },
        { "_assign_array_", _assign_array_ICorePointerRedirector, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICorePointerRedirector), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICorePointerRedirector[] = {
        { }
    };

    static PyType_Slot _type_slots_ICorePointerRedirector[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICorePointerRedirector) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICorePointerRedirector) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICorePointerRedirector) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICorePointerRedirector) },
        { },
    };

    static PyType_Spec type_spec_ICorePointerRedirector =
    {
        "_winsdk_Windows_UI_Core.ICorePointerRedirector",
        sizeof(py::wrapper::Windows::UI::Core::ICorePointerRedirector),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICorePointerRedirector
    };

    // ----- ICoreWindow interface --------------------
    static constexpr const char* const type_name_ICoreWindow = "ICoreWindow";

    static PyObject* _new_ICoreWindow(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_ICoreWindow);
        return nullptr;
    }

    static void _dealloc_ICoreWindow(py::wrapper::Windows::UI::Core::ICoreWindow* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICoreWindow_Activate(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.ICoreWindow", L"Activate", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Activate();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_Close(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.ICoreWindow", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_GetAsyncKeyState(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.ICoreWindow", L"GetAsyncKeyState", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(args, 0);

                return py::convert(self->obj.GetAsyncKeyState(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_GetKeyState(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.ICoreWindow", L"GetKeyState", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(args, 0);

                return py::convert(self->obj.GetKeyState(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_ReleasePointerCapture(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.ICoreWindow", L"ReleasePointerCapture", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ReleasePointerCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_SetPointerCapture(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.ICoreWindow", L"SetPointerCapture", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.SetPointerCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_get_AutomationHostProvider(py::wrapper::Windows::UI::Core::ICoreWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindow", L"AutomationHostProvider"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutomationHostProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_get_Bounds(py::wrapper::Windows::UI::Core::ICoreWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindow", L"Bounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Bounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_get_CustomProperties(py::wrapper::Windows::UI::Core::ICoreWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindow", L"CustomProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CustomProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_get_Dispatcher(py::wrapper::Windows::UI::Core::ICoreWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindow", L"Dispatcher"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_get_FlowDirection(py::wrapper::Windows::UI::Core::ICoreWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindow", L"FlowDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FlowDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICoreWindow_put_FlowDirection(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindow", L"FlowDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreWindowFlowDirection>(arg);

            self->obj.FlowDirection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICoreWindow_get_IsInputEnabled(py::wrapper::Windows::UI::Core::ICoreWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindow", L"IsInputEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInputEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICoreWindow_put_IsInputEnabled(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindow", L"IsInputEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsInputEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICoreWindow_get_PointerCursor(py::wrapper::Windows::UI::Core::ICoreWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindow", L"PointerCursor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerCursor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICoreWindow_put_PointerCursor(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindow", L"PointerCursor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreCursor>(arg);

            self->obj.PointerCursor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICoreWindow_get_PointerPosition(py::wrapper::Windows::UI::Core::ICoreWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindow", L"PointerPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_get_Visible(py::wrapper::Windows::UI::Core::ICoreWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindow", L"Visible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Visible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_Activated(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"Activated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::WindowActivatedEventArgs>>(arg);

            return py::convert(self->obj.Activated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_Activated(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"Activated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Activated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_AutomationProviderRequested(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"AutomationProviderRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::AutomationProviderRequestedEventArgs>>(arg);

            return py::convert(self->obj.AutomationProviderRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_AutomationProviderRequested(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"AutomationProviderRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AutomationProviderRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_CharacterReceived(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"CharacterReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::CharacterReceivedEventArgs>>(arg);

            return py::convert(self->obj.CharacterReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_CharacterReceived(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"CharacterReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CharacterReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_Closed(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::CoreWindowEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_Closed(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_InputEnabled(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"InputEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::InputEnabledEventArgs>>(arg);

            return py::convert(self->obj.InputEnabled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_InputEnabled(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"InputEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InputEnabled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_KeyDown(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"KeyDown"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::KeyEventArgs>>(arg);

            return py::convert(self->obj.KeyDown(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_KeyDown(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"KeyDown"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.KeyDown(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_KeyUp(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"KeyUp"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::KeyEventArgs>>(arg);

            return py::convert(self->obj.KeyUp(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_KeyUp(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"KeyUp"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.KeyUp(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_PointerCaptureLost(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerCaptureLost"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerCaptureLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_PointerCaptureLost(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerCaptureLost"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerCaptureLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_PointerEntered(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerEntered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_PointerEntered(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerEntered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_PointerExited(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerExited"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_PointerExited(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerExited"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_PointerMoved(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerMoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerMoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_PointerMoved(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerMoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerMoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_PointerPressed(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_PointerPressed(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_PointerReleased(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerReleased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_PointerReleased(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerReleased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_PointerWheelChanged(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerWheelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerWheelChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_PointerWheelChanged(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerWheelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerWheelChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_SizeChanged(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"SizeChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::WindowSizeChangedEventArgs>>(arg);

            return py::convert(self->obj.SizeChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_SizeChanged(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"SizeChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SizeChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_TouchHitTesting(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"TouchHitTesting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::TouchHitTestingEventArgs>>(arg);

            return py::convert(self->obj.TouchHitTesting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_TouchHitTesting(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"TouchHitTesting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TouchHitTesting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_VisibilityChanged(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"VisibilityChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::VisibilityChangedEventArgs>>(arg);

            return py::convert(self->obj.VisibilityChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_VisibilityChanged(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"VisibilityChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VisibilityChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICoreWindow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::ICoreWindow>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICoreWindow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::ICoreWindow>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICoreWindow[] = {
        { "activate", reinterpret_cast<PyCFunction>(ICoreWindow_Activate), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(ICoreWindow_Close), METH_VARARGS, nullptr },
        { "get_async_key_state", reinterpret_cast<PyCFunction>(ICoreWindow_GetAsyncKeyState), METH_VARARGS, nullptr },
        { "get_key_state", reinterpret_cast<PyCFunction>(ICoreWindow_GetKeyState), METH_VARARGS, nullptr },
        { "release_pointer_capture", reinterpret_cast<PyCFunction>(ICoreWindow_ReleasePointerCapture), METH_VARARGS, nullptr },
        { "set_pointer_capture", reinterpret_cast<PyCFunction>(ICoreWindow_SetPointerCapture), METH_VARARGS, nullptr },
        { "add_activated", reinterpret_cast<PyCFunction>(ICoreWindow_add_Activated), METH_O, nullptr },
        { "remove_activated", reinterpret_cast<PyCFunction>(ICoreWindow_remove_Activated), METH_O, nullptr },
        { "add_automation_provider_requested", reinterpret_cast<PyCFunction>(ICoreWindow_add_AutomationProviderRequested), METH_O, nullptr },
        { "remove_automation_provider_requested", reinterpret_cast<PyCFunction>(ICoreWindow_remove_AutomationProviderRequested), METH_O, nullptr },
        { "add_character_received", reinterpret_cast<PyCFunction>(ICoreWindow_add_CharacterReceived), METH_O, nullptr },
        { "remove_character_received", reinterpret_cast<PyCFunction>(ICoreWindow_remove_CharacterReceived), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(ICoreWindow_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(ICoreWindow_remove_Closed), METH_O, nullptr },
        { "add_input_enabled", reinterpret_cast<PyCFunction>(ICoreWindow_add_InputEnabled), METH_O, nullptr },
        { "remove_input_enabled", reinterpret_cast<PyCFunction>(ICoreWindow_remove_InputEnabled), METH_O, nullptr },
        { "add_key_down", reinterpret_cast<PyCFunction>(ICoreWindow_add_KeyDown), METH_O, nullptr },
        { "remove_key_down", reinterpret_cast<PyCFunction>(ICoreWindow_remove_KeyDown), METH_O, nullptr },
        { "add_key_up", reinterpret_cast<PyCFunction>(ICoreWindow_add_KeyUp), METH_O, nullptr },
        { "remove_key_up", reinterpret_cast<PyCFunction>(ICoreWindow_remove_KeyUp), METH_O, nullptr },
        { "add_pointer_capture_lost", reinterpret_cast<PyCFunction>(ICoreWindow_add_PointerCaptureLost), METH_O, nullptr },
        { "remove_pointer_capture_lost", reinterpret_cast<PyCFunction>(ICoreWindow_remove_PointerCaptureLost), METH_O, nullptr },
        { "add_pointer_entered", reinterpret_cast<PyCFunction>(ICoreWindow_add_PointerEntered), METH_O, nullptr },
        { "remove_pointer_entered", reinterpret_cast<PyCFunction>(ICoreWindow_remove_PointerEntered), METH_O, nullptr },
        { "add_pointer_exited", reinterpret_cast<PyCFunction>(ICoreWindow_add_PointerExited), METH_O, nullptr },
        { "remove_pointer_exited", reinterpret_cast<PyCFunction>(ICoreWindow_remove_PointerExited), METH_O, nullptr },
        { "add_pointer_moved", reinterpret_cast<PyCFunction>(ICoreWindow_add_PointerMoved), METH_O, nullptr },
        { "remove_pointer_moved", reinterpret_cast<PyCFunction>(ICoreWindow_remove_PointerMoved), METH_O, nullptr },
        { "add_pointer_pressed", reinterpret_cast<PyCFunction>(ICoreWindow_add_PointerPressed), METH_O, nullptr },
        { "remove_pointer_pressed", reinterpret_cast<PyCFunction>(ICoreWindow_remove_PointerPressed), METH_O, nullptr },
        { "add_pointer_released", reinterpret_cast<PyCFunction>(ICoreWindow_add_PointerReleased), METH_O, nullptr },
        { "remove_pointer_released", reinterpret_cast<PyCFunction>(ICoreWindow_remove_PointerReleased), METH_O, nullptr },
        { "add_pointer_wheel_changed", reinterpret_cast<PyCFunction>(ICoreWindow_add_PointerWheelChanged), METH_O, nullptr },
        { "remove_pointer_wheel_changed", reinterpret_cast<PyCFunction>(ICoreWindow_remove_PointerWheelChanged), METH_O, nullptr },
        { "add_size_changed", reinterpret_cast<PyCFunction>(ICoreWindow_add_SizeChanged), METH_O, nullptr },
        { "remove_size_changed", reinterpret_cast<PyCFunction>(ICoreWindow_remove_SizeChanged), METH_O, nullptr },
        { "add_touch_hit_testing", reinterpret_cast<PyCFunction>(ICoreWindow_add_TouchHitTesting), METH_O, nullptr },
        { "remove_touch_hit_testing", reinterpret_cast<PyCFunction>(ICoreWindow_remove_TouchHitTesting), METH_O, nullptr },
        { "add_visibility_changed", reinterpret_cast<PyCFunction>(ICoreWindow_add_VisibilityChanged), METH_O, nullptr },
        { "remove_visibility_changed", reinterpret_cast<PyCFunction>(ICoreWindow_remove_VisibilityChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ICoreWindow, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICoreWindow), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICoreWindow[] = {
        { "automation_host_provider", reinterpret_cast<getter>(ICoreWindow_get_AutomationHostProvider), nullptr, nullptr, nullptr },
        { "bounds", reinterpret_cast<getter>(ICoreWindow_get_Bounds), nullptr, nullptr, nullptr },
        { "custom_properties", reinterpret_cast<getter>(ICoreWindow_get_CustomProperties), nullptr, nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(ICoreWindow_get_Dispatcher), nullptr, nullptr, nullptr },
        { "flow_direction", reinterpret_cast<getter>(ICoreWindow_get_FlowDirection), reinterpret_cast<setter>(ICoreWindow_put_FlowDirection), nullptr, nullptr },
        { "is_input_enabled", reinterpret_cast<getter>(ICoreWindow_get_IsInputEnabled), reinterpret_cast<setter>(ICoreWindow_put_IsInputEnabled), nullptr, nullptr },
        { "pointer_cursor", reinterpret_cast<getter>(ICoreWindow_get_PointerCursor), reinterpret_cast<setter>(ICoreWindow_put_PointerCursor), nullptr, nullptr },
        { "pointer_position", reinterpret_cast<getter>(ICoreWindow_get_PointerPosition), nullptr, nullptr, nullptr },
        { "visible", reinterpret_cast<getter>(ICoreWindow_get_Visible), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICoreWindow[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICoreWindow) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICoreWindow) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICoreWindow) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICoreWindow) },
        { },
    };

    static PyType_Spec type_spec_ICoreWindow =
    {
        "_winsdk_Windows_UI_Core.ICoreWindow",
        sizeof(py::wrapper::Windows::UI::Core::ICoreWindow),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICoreWindow
    };

    // ----- ICoreWindowEventArgs interface --------------------
    static constexpr const char* const type_name_ICoreWindowEventArgs = "ICoreWindowEventArgs";

    static PyObject* _new_ICoreWindowEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_ICoreWindowEventArgs);
        return nullptr;
    }

    static void _dealloc_ICoreWindowEventArgs(py::wrapper::Windows::UI::Core::ICoreWindowEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICoreWindowEventArgs_get_Handled(py::wrapper::Windows::UI::Core::ICoreWindowEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindowEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICoreWindowEventArgs_put_Handled(py::wrapper::Windows::UI::Core::ICoreWindowEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindowEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ICoreWindowEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::ICoreWindowEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICoreWindowEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::ICoreWindowEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICoreWindowEventArgs[] = {
        { "_assign_array_", _assign_array_ICoreWindowEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICoreWindowEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICoreWindowEventArgs[] = {
        { "handled", reinterpret_cast<getter>(ICoreWindowEventArgs_get_Handled), reinterpret_cast<setter>(ICoreWindowEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICoreWindowEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICoreWindowEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICoreWindowEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICoreWindowEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICoreWindowEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ICoreWindowEventArgs =
    {
        "_winsdk_Windows_UI_Core.ICoreWindowEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::ICoreWindowEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICoreWindowEventArgs
    };

    // ----- IInitializeWithCoreWindow interface --------------------
    static constexpr const char* const type_name_IInitializeWithCoreWindow = "IInitializeWithCoreWindow";

    static PyObject* _new_IInitializeWithCoreWindow(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IInitializeWithCoreWindow);
        return nullptr;
    }

    static void _dealloc_IInitializeWithCoreWindow(py::wrapper::Windows::UI::Core::IInitializeWithCoreWindow* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IInitializeWithCoreWindow_Initialize(py::wrapper::Windows::UI::Core::IInitializeWithCoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.IInitializeWithCoreWindow", L"Initialize", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreWindow>(args, 0);

                self->obj.Initialize(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IInitializeWithCoreWindow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::IInitializeWithCoreWindow>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IInitializeWithCoreWindow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::IInitializeWithCoreWindow>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IInitializeWithCoreWindow[] = {
        { "initialize", reinterpret_cast<PyCFunction>(IInitializeWithCoreWindow_Initialize), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IInitializeWithCoreWindow, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IInitializeWithCoreWindow), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IInitializeWithCoreWindow[] = {
        { }
    };

    static PyType_Slot _type_slots_IInitializeWithCoreWindow[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IInitializeWithCoreWindow) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IInitializeWithCoreWindow) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IInitializeWithCoreWindow) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IInitializeWithCoreWindow) },
        { },
    };

    static PyType_Spec type_spec_IInitializeWithCoreWindow =
    {
        "_winsdk_Windows_UI_Core.IInitializeWithCoreWindow",
        sizeof(py::wrapper::Windows::UI::Core::IInitializeWithCoreWindow),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IInitializeWithCoreWindow
    };

    // ----- CorePhysicalKeyStatus struct --------------------
    static constexpr const char* const type_name_CorePhysicalKeyStatus = "CorePhysicalKeyStatus";

    PyObject* _new_CorePhysicalKeyStatus(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::UI::Core::CorePhysicalKeyStatus return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        uint32_t _RepeatCount{};
        uint32_t _ScanCode{};
        bool _IsExtendedKey{};
        bool _IsMenuKeyDown{};
        bool _WasKeyDown{};
        bool _IsKeyReleased{};

        static const char* kwlist[] = {"repeat_count", "scan_code", "is_extended_key", "is_menu_key_down", "was_key_down", "is_key_released", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "IIpppp", const_cast<char**>(kwlist), &_RepeatCount, &_ScanCode, &_IsExtendedKey, &_IsMenuKeyDown, &_WasKeyDown, &_IsKeyReleased))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::UI::Core::CorePhysicalKeyStatus return_value{ _RepeatCount, _ScanCode, _IsExtendedKey, _IsMenuKeyDown, _WasKeyDown, _IsKeyReleased };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_CorePhysicalKeyStatus(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus* self) noexcept
    {
    }

    static PyObject* CorePhysicalKeyStatus_get_RepeatCount(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RepeatCount);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CorePhysicalKeyStatus_set_RepeatCount(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.RepeatCount = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CorePhysicalKeyStatus_get_ScanCode(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScanCode);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CorePhysicalKeyStatus_set_ScanCode(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.ScanCode = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CorePhysicalKeyStatus_get_IsExtendedKey(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsExtendedKey);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CorePhysicalKeyStatus_set_IsExtendedKey(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.IsExtendedKey = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CorePhysicalKeyStatus_get_IsMenuKeyDown(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsMenuKeyDown);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CorePhysicalKeyStatus_set_IsMenuKeyDown(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.IsMenuKeyDown = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CorePhysicalKeyStatus_get_WasKeyDown(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WasKeyDown);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CorePhysicalKeyStatus_set_WasKeyDown(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.WasKeyDown = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CorePhysicalKeyStatus_get_IsKeyReleased(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsKeyReleased);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CorePhysicalKeyStatus_set_IsKeyReleased(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.IsKeyReleased = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_CorePhysicalKeyStatus[] = {
        { "repeat_count", reinterpret_cast<getter>(CorePhysicalKeyStatus_get_RepeatCount), reinterpret_cast<setter>(CorePhysicalKeyStatus_set_RepeatCount), nullptr, nullptr },
        { "scan_code", reinterpret_cast<getter>(CorePhysicalKeyStatus_get_ScanCode), reinterpret_cast<setter>(CorePhysicalKeyStatus_set_ScanCode), nullptr, nullptr },
        { "is_extended_key", reinterpret_cast<getter>(CorePhysicalKeyStatus_get_IsExtendedKey), reinterpret_cast<setter>(CorePhysicalKeyStatus_set_IsExtendedKey), nullptr, nullptr },
        { "is_menu_key_down", reinterpret_cast<getter>(CorePhysicalKeyStatus_get_IsMenuKeyDown), reinterpret_cast<setter>(CorePhysicalKeyStatus_set_IsMenuKeyDown), nullptr, nullptr },
        { "was_key_down", reinterpret_cast<getter>(CorePhysicalKeyStatus_get_WasKeyDown), reinterpret_cast<setter>(CorePhysicalKeyStatus_set_WasKeyDown), nullptr, nullptr },
        { "is_key_released", reinterpret_cast<getter>(CorePhysicalKeyStatus_get_IsKeyReleased), reinterpret_cast<setter>(CorePhysicalKeyStatus_set_IsKeyReleased), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CorePhysicalKeyStatus[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CorePhysicalKeyStatus) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CorePhysicalKeyStatus) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CorePhysicalKeyStatus) },
        { },
    };

    static PyType_Spec type_spec_CorePhysicalKeyStatus =
    {
        "_winsdk_Windows_UI_Core.CorePhysicalKeyStatus",
        sizeof(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CorePhysicalKeyStatus
    };

    // ----- CoreProximityEvaluation struct --------------------
    static constexpr const char* const type_name_CoreProximityEvaluation = "CoreProximityEvaluation";

    PyObject* _new_CoreProximityEvaluation(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::UI::Core::CoreProximityEvaluation return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        int32_t _Score{};
        PyObject* _AdjustedPoint{};

        static const char* kwlist[] = {"score", "adjusted_point", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "iO", const_cast<char**>(kwlist), &_Score, &_AdjustedPoint))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::UI::Core::CoreProximityEvaluation return_value{ _Score, py::converter<winrt::Windows::Foundation::Point>::convert_to(_AdjustedPoint) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_CoreProximityEvaluation(py::wrapper::Windows::UI::Core::CoreProximityEvaluation* self) noexcept
    {
    }

    static PyObject* CoreProximityEvaluation_get_Score(py::wrapper::Windows::UI::Core::CoreProximityEvaluation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Score);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreProximityEvaluation_set_Score(py::wrapper::Windows::UI::Core::CoreProximityEvaluation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Score = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreProximityEvaluation_get_AdjustedPoint(py::wrapper::Windows::UI::Core::CoreProximityEvaluation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AdjustedPoint);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreProximityEvaluation_set_AdjustedPoint(py::wrapper::Windows::UI::Core::CoreProximityEvaluation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.AdjustedPoint = py::converter<winrt::Windows::Foundation::Point>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_CoreProximityEvaluation[] = {
        { "score", reinterpret_cast<getter>(CoreProximityEvaluation_get_Score), reinterpret_cast<setter>(CoreProximityEvaluation_set_Score), nullptr, nullptr },
        { "adjusted_point", reinterpret_cast<getter>(CoreProximityEvaluation_get_AdjustedPoint), reinterpret_cast<setter>(CoreProximityEvaluation_set_AdjustedPoint), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreProximityEvaluation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreProximityEvaluation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreProximityEvaluation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreProximityEvaluation) },
        { },
    };

    static PyType_Spec type_spec_CoreProximityEvaluation =
    {
        "_winsdk_Windows_UI_Core.CoreProximityEvaluation",
        sizeof(py::wrapper::Windows::UI::Core::CoreProximityEvaluation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreProximityEvaluation
    };

    // ----- Windows.UI.Core Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::UI::Core");

    static PyMethodDef module_methods[] = {
        {"_register_AppViewBackButtonVisibility", register_AppViewBackButtonVisibility, METH_O, "registers type"},
        {"_register_CoreAcceleratorKeyEventType", register_CoreAcceleratorKeyEventType, METH_O, "registers type"},
        {"_register_CoreCursorType", register_CoreCursorType, METH_O, "registers type"},
        {"_register_CoreDispatcherPriority", register_CoreDispatcherPriority, METH_O, "registers type"},
        {"_register_CoreIndependentInputFilters", register_CoreIndependentInputFilters, METH_O, "registers type"},
        {"_register_CoreInputDeviceTypes", register_CoreInputDeviceTypes, METH_O, "registers type"},
        {"_register_CoreProcessEventsOption", register_CoreProcessEventsOption, METH_O, "registers type"},
        {"_register_CoreProximityEvaluationScore", register_CoreProximityEvaluationScore, METH_O, "registers type"},
        {"_register_CoreVirtualKeyStates", register_CoreVirtualKeyStates, METH_O, "registers type"},
        {"_register_CoreWindowActivationMode", register_CoreWindowActivationMode, METH_O, "registers type"},
        {"_register_CoreWindowActivationState", register_CoreWindowActivationState, METH_O, "registers type"},
        {"_register_CoreWindowFlowDirection", register_CoreWindowFlowDirection, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_AppViewBackButtonVisibility);
        Py_VISIT(state->type_CoreAcceleratorKeyEventType);
        Py_VISIT(state->type_CoreCursorType);
        Py_VISIT(state->type_CoreDispatcherPriority);
        Py_VISIT(state->type_CoreIndependentInputFilters);
        Py_VISIT(state->type_CoreInputDeviceTypes);
        Py_VISIT(state->type_CoreProcessEventsOption);
        Py_VISIT(state->type_CoreProximityEvaluationScore);
        Py_VISIT(state->type_CoreVirtualKeyStates);
        Py_VISIT(state->type_CoreWindowActivationMode);
        Py_VISIT(state->type_CoreWindowActivationState);
        Py_VISIT(state->type_CoreWindowFlowDirection);
        Py_VISIT(state->type_AcceleratorKeyEventArgs);
        Py_VISIT(state->type_AutomationProviderRequestedEventArgs);
        Py_VISIT(state->type_BackRequestedEventArgs);
        Py_VISIT(state->type_CharacterReceivedEventArgs);
        Py_VISIT(state->type_ClosestInteractiveBoundsRequestedEventArgs);
        Py_VISIT(state->type_CoreAcceleratorKeys);
        Py_VISIT(state->type_CoreComponentInputSource);
        Py_VISIT(state->type_CoreCursor);
        Py_VISIT(state->type_CoreDispatcher);
        Py_VISIT(state->type_CoreIndependentInputSource);
        Py_VISIT(state->type_CoreIndependentInputSourceController);
        Py_VISIT(state->type_CoreWindow);
        Py_VISIT(state->type_CoreWindowDialog);
        Py_VISIT(state->type_CoreWindowEventArgs);
        Py_VISIT(state->type_CoreWindowFlyout);
        Py_VISIT(state->type_CoreWindowPopupShowingEventArgs);
        Py_VISIT(state->type_CoreWindowResizeManager);
        Py_VISIT(state->type_IdleDispatchedHandlerArgs);
        Py_VISIT(state->type_InputEnabledEventArgs);
        Py_VISIT(state->type_KeyEventArgs);
        Py_VISIT(state->type_PointerEventArgs);
        Py_VISIT(state->type_SystemNavigationManager);
        Py_VISIT(state->type_TouchHitTestingEventArgs);
        Py_VISIT(state->type_VisibilityChangedEventArgs);
        Py_VISIT(state->type_WindowActivatedEventArgs);
        Py_VISIT(state->type_WindowSizeChangedEventArgs);
        Py_VISIT(state->type_ICoreAcceleratorKeys);
        Py_VISIT(state->type_ICoreInputSourceBase);
        Py_VISIT(state->type_ICorePointerInputSource);
        Py_VISIT(state->type_ICorePointerInputSource2);
        Py_VISIT(state->type_ICorePointerRedirector);
        Py_VISIT(state->type_ICoreWindow);
        Py_VISIT(state->type_ICoreWindowEventArgs);
        Py_VISIT(state->type_IInitializeWithCoreWindow);
        Py_VISIT(state->type_CorePhysicalKeyStatus);
        Py_VISIT(state->type_CoreProximityEvaluation);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_AppViewBackButtonVisibility);
        Py_CLEAR(state->type_CoreAcceleratorKeyEventType);
        Py_CLEAR(state->type_CoreCursorType);
        Py_CLEAR(state->type_CoreDispatcherPriority);
        Py_CLEAR(state->type_CoreIndependentInputFilters);
        Py_CLEAR(state->type_CoreInputDeviceTypes);
        Py_CLEAR(state->type_CoreProcessEventsOption);
        Py_CLEAR(state->type_CoreProximityEvaluationScore);
        Py_CLEAR(state->type_CoreVirtualKeyStates);
        Py_CLEAR(state->type_CoreWindowActivationMode);
        Py_CLEAR(state->type_CoreWindowActivationState);
        Py_CLEAR(state->type_CoreWindowFlowDirection);
        Py_CLEAR(state->type_AcceleratorKeyEventArgs);
        Py_CLEAR(state->type_AutomationProviderRequestedEventArgs);
        Py_CLEAR(state->type_BackRequestedEventArgs);
        Py_CLEAR(state->type_CharacterReceivedEventArgs);
        Py_CLEAR(state->type_ClosestInteractiveBoundsRequestedEventArgs);
        Py_CLEAR(state->type_CoreAcceleratorKeys);
        Py_CLEAR(state->type_CoreComponentInputSource);
        Py_CLEAR(state->type_CoreCursor);
        Py_CLEAR(state->type_CoreDispatcher);
        Py_CLEAR(state->type_CoreIndependentInputSource);
        Py_CLEAR(state->type_CoreIndependentInputSourceController);
        Py_CLEAR(state->type_CoreWindow);
        Py_CLEAR(state->type_CoreWindowDialog);
        Py_CLEAR(state->type_CoreWindowEventArgs);
        Py_CLEAR(state->type_CoreWindowFlyout);
        Py_CLEAR(state->type_CoreWindowPopupShowingEventArgs);
        Py_CLEAR(state->type_CoreWindowResizeManager);
        Py_CLEAR(state->type_IdleDispatchedHandlerArgs);
        Py_CLEAR(state->type_InputEnabledEventArgs);
        Py_CLEAR(state->type_KeyEventArgs);
        Py_CLEAR(state->type_PointerEventArgs);
        Py_CLEAR(state->type_SystemNavigationManager);
        Py_CLEAR(state->type_TouchHitTestingEventArgs);
        Py_CLEAR(state->type_VisibilityChangedEventArgs);
        Py_CLEAR(state->type_WindowActivatedEventArgs);
        Py_CLEAR(state->type_WindowSizeChangedEventArgs);
        Py_CLEAR(state->type_ICoreAcceleratorKeys);
        Py_CLEAR(state->type_ICoreInputSourceBase);
        Py_CLEAR(state->type_ICorePointerInputSource);
        Py_CLEAR(state->type_ICorePointerInputSource2);
        Py_CLEAR(state->type_ICorePointerRedirector);
        Py_CLEAR(state->type_ICoreWindow);
        Py_CLEAR(state->type_ICoreWindowEventArgs);
        Py_CLEAR(state->type_IInitializeWithCoreWindow);
        Py_CLEAR(state->type_CorePhysicalKeyStatus);
        Py_CLEAR(state->type_CoreProximityEvaluation);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_UI_Core",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::UI::Core

PyMODINIT_FUNC PyInit__winsdk_Windows_UI_Core(void) noexcept
{
    using namespace py::cpp::Windows::UI::Core;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_AcceleratorKeyEventArgs = py::register_python_type(module.get(), type_name_AcceleratorKeyEventArgs, &type_spec_AcceleratorKeyEventArgs, bases.get(), nullptr);
    if (!state->type_AcceleratorKeyEventArgs)
    {
        return nullptr;
    }

    state->type_AutomationProviderRequestedEventArgs = py::register_python_type(module.get(), type_name_AutomationProviderRequestedEventArgs, &type_spec_AutomationProviderRequestedEventArgs, bases.get(), nullptr);
    if (!state->type_AutomationProviderRequestedEventArgs)
    {
        return nullptr;
    }

    state->type_BackRequestedEventArgs = py::register_python_type(module.get(), type_name_BackRequestedEventArgs, &type_spec_BackRequestedEventArgs, bases.get(), nullptr);
    if (!state->type_BackRequestedEventArgs)
    {
        return nullptr;
    }

    state->type_CharacterReceivedEventArgs = py::register_python_type(module.get(), type_name_CharacterReceivedEventArgs, &type_spec_CharacterReceivedEventArgs, bases.get(), nullptr);
    if (!state->type_CharacterReceivedEventArgs)
    {
        return nullptr;
    }

    state->type_ClosestInteractiveBoundsRequestedEventArgs = py::register_python_type(module.get(), type_name_ClosestInteractiveBoundsRequestedEventArgs, &type_spec_ClosestInteractiveBoundsRequestedEventArgs, bases.get(), nullptr);
    if (!state->type_ClosestInteractiveBoundsRequestedEventArgs)
    {
        return nullptr;
    }

    state->type_CoreAcceleratorKeys = py::register_python_type(module.get(), type_name_CoreAcceleratorKeys, &type_spec_CoreAcceleratorKeys, bases.get(), nullptr);
    if (!state->type_CoreAcceleratorKeys)
    {
        return nullptr;
    }

    state->type_CoreComponentInputSource = py::register_python_type(module.get(), type_name_CoreComponentInputSource, &type_spec_CoreComponentInputSource, bases.get(), nullptr);
    if (!state->type_CoreComponentInputSource)
    {
        return nullptr;
    }

    state->type_CoreCursor = py::register_python_type(module.get(), type_name_CoreCursor, &type_spec_CoreCursor, bases.get(), nullptr);
    if (!state->type_CoreCursor)
    {
        return nullptr;
    }

    state->type_CoreDispatcher = py::register_python_type(module.get(), type_name_CoreDispatcher, &type_spec_CoreDispatcher, bases.get(), nullptr);
    if (!state->type_CoreDispatcher)
    {
        return nullptr;
    }

    state->type_CoreIndependentInputSource = py::register_python_type(module.get(), type_name_CoreIndependentInputSource, &type_spec_CoreIndependentInputSource, bases.get(), nullptr);
    if (!state->type_CoreIndependentInputSource)
    {
        return nullptr;
    }

    state->type_CoreIndependentInputSourceController = py::register_python_type(module.get(), type_name_CoreIndependentInputSourceController, &type_spec_CoreIndependentInputSourceController, bases.get(), nullptr);
    if (!state->type_CoreIndependentInputSourceController)
    {
        return nullptr;
    }

    state->type_CoreWindow = py::register_python_type(module.get(), type_name_CoreWindow, &type_spec_CoreWindow, bases.get(), nullptr);
    if (!state->type_CoreWindow)
    {
        return nullptr;
    }

    state->type_CoreWindowDialog = py::register_python_type(module.get(), type_name_CoreWindowDialog, &type_spec_CoreWindowDialog, bases.get(), nullptr);
    if (!state->type_CoreWindowDialog)
    {
        return nullptr;
    }

    state->type_CoreWindowEventArgs = py::register_python_type(module.get(), type_name_CoreWindowEventArgs, &type_spec_CoreWindowEventArgs, bases.get(), nullptr);
    if (!state->type_CoreWindowEventArgs)
    {
        return nullptr;
    }

    state->type_CoreWindowFlyout = py::register_python_type(module.get(), type_name_CoreWindowFlyout, &type_spec_CoreWindowFlyout, bases.get(), nullptr);
    if (!state->type_CoreWindowFlyout)
    {
        return nullptr;
    }

    state->type_CoreWindowPopupShowingEventArgs = py::register_python_type(module.get(), type_name_CoreWindowPopupShowingEventArgs, &type_spec_CoreWindowPopupShowingEventArgs, bases.get(), nullptr);
    if (!state->type_CoreWindowPopupShowingEventArgs)
    {
        return nullptr;
    }

    state->type_CoreWindowResizeManager = py::register_python_type(module.get(), type_name_CoreWindowResizeManager, &type_spec_CoreWindowResizeManager, bases.get(), nullptr);
    if (!state->type_CoreWindowResizeManager)
    {
        return nullptr;
    }

    state->type_IdleDispatchedHandlerArgs = py::register_python_type(module.get(), type_name_IdleDispatchedHandlerArgs, &type_spec_IdleDispatchedHandlerArgs, bases.get(), nullptr);
    if (!state->type_IdleDispatchedHandlerArgs)
    {
        return nullptr;
    }

    state->type_InputEnabledEventArgs = py::register_python_type(module.get(), type_name_InputEnabledEventArgs, &type_spec_InputEnabledEventArgs, bases.get(), nullptr);
    if (!state->type_InputEnabledEventArgs)
    {
        return nullptr;
    }

    state->type_KeyEventArgs = py::register_python_type(module.get(), type_name_KeyEventArgs, &type_spec_KeyEventArgs, bases.get(), nullptr);
    if (!state->type_KeyEventArgs)
    {
        return nullptr;
    }

    state->type_PointerEventArgs = py::register_python_type(module.get(), type_name_PointerEventArgs, &type_spec_PointerEventArgs, bases.get(), nullptr);
    if (!state->type_PointerEventArgs)
    {
        return nullptr;
    }

    state->type_SystemNavigationManager = py::register_python_type(module.get(), type_name_SystemNavigationManager, &type_spec_SystemNavigationManager, bases.get(), nullptr);
    if (!state->type_SystemNavigationManager)
    {
        return nullptr;
    }

    state->type_TouchHitTestingEventArgs = py::register_python_type(module.get(), type_name_TouchHitTestingEventArgs, &type_spec_TouchHitTestingEventArgs, bases.get(), nullptr);
    if (!state->type_TouchHitTestingEventArgs)
    {
        return nullptr;
    }

    state->type_VisibilityChangedEventArgs = py::register_python_type(module.get(), type_name_VisibilityChangedEventArgs, &type_spec_VisibilityChangedEventArgs, bases.get(), nullptr);
    if (!state->type_VisibilityChangedEventArgs)
    {
        return nullptr;
    }

    state->type_WindowActivatedEventArgs = py::register_python_type(module.get(), type_name_WindowActivatedEventArgs, &type_spec_WindowActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WindowActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WindowSizeChangedEventArgs = py::register_python_type(module.get(), type_name_WindowSizeChangedEventArgs, &type_spec_WindowSizeChangedEventArgs, bases.get(), nullptr);
    if (!state->type_WindowSizeChangedEventArgs)
    {
        return nullptr;
    }

    state->type_ICoreAcceleratorKeys = py::register_python_type(module.get(), type_name_ICoreAcceleratorKeys, &type_spec_ICoreAcceleratorKeys, bases.get(), nullptr);
    if (!state->type_ICoreAcceleratorKeys)
    {
        return nullptr;
    }

    state->type_ICoreInputSourceBase = py::register_python_type(module.get(), type_name_ICoreInputSourceBase, &type_spec_ICoreInputSourceBase, bases.get(), nullptr);
    if (!state->type_ICoreInputSourceBase)
    {
        return nullptr;
    }

    state->type_ICorePointerInputSource = py::register_python_type(module.get(), type_name_ICorePointerInputSource, &type_spec_ICorePointerInputSource, bases.get(), nullptr);
    if (!state->type_ICorePointerInputSource)
    {
        return nullptr;
    }

    state->type_ICorePointerInputSource2 = py::register_python_type(module.get(), type_name_ICorePointerInputSource2, &type_spec_ICorePointerInputSource2, bases.get(), nullptr);
    if (!state->type_ICorePointerInputSource2)
    {
        return nullptr;
    }

    state->type_ICorePointerRedirector = py::register_python_type(module.get(), type_name_ICorePointerRedirector, &type_spec_ICorePointerRedirector, bases.get(), nullptr);
    if (!state->type_ICorePointerRedirector)
    {
        return nullptr;
    }

    state->type_ICoreWindow = py::register_python_type(module.get(), type_name_ICoreWindow, &type_spec_ICoreWindow, bases.get(), nullptr);
    if (!state->type_ICoreWindow)
    {
        return nullptr;
    }

    state->type_ICoreWindowEventArgs = py::register_python_type(module.get(), type_name_ICoreWindowEventArgs, &type_spec_ICoreWindowEventArgs, bases.get(), nullptr);
    if (!state->type_ICoreWindowEventArgs)
    {
        return nullptr;
    }

    state->type_IInitializeWithCoreWindow = py::register_python_type(module.get(), type_name_IInitializeWithCoreWindow, &type_spec_IInitializeWithCoreWindow, bases.get(), nullptr);
    if (!state->type_IInitializeWithCoreWindow)
    {
        return nullptr;
    }

    state->type_CorePhysicalKeyStatus = py::register_python_type(module.get(), type_name_CorePhysicalKeyStatus, &type_spec_CorePhysicalKeyStatus, bases.get(), nullptr);
    if (!state->type_CorePhysicalKeyStatus)
    {
        return nullptr;
    }

    state->type_CoreProximityEvaluation = py::register_python_type(module.get(), type_name_CoreProximityEvaluation, &type_spec_CoreProximityEvaluation, bases.get(), nullptr);
    if (!state->type_CoreProximityEvaluation)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::UI::Core::AppViewBackButtonVisibility>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppViewBackButtonVisibility;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::AppViewBackButtonVisibility is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Core::CoreAcceleratorKeyEventType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreAcceleratorKeyEventType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::CoreAcceleratorKeyEventType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Core::CoreCursorType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreCursorType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::CoreCursorType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Core::CoreDispatcherPriority>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreDispatcherPriority;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::CoreDispatcherPriority is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Core::CoreIndependentInputFilters>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreIndependentInputFilters;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::CoreIndependentInputFilters is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Core::CoreInputDeviceTypes>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreInputDeviceTypes;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::CoreInputDeviceTypes is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Core::CoreProcessEventsOption>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreProcessEventsOption;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::CoreProcessEventsOption is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Core::CoreProximityEvaluationScore>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreProximityEvaluationScore;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::CoreProximityEvaluationScore is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Core::CoreVirtualKeyStates>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreVirtualKeyStates;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::CoreVirtualKeyStates is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Core::CoreWindowActivationMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreWindowActivationMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::CoreWindowActivationMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Core::CoreWindowActivationState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreWindowActivationState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::CoreWindowActivationState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Core::CoreWindowFlowDirection>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreWindowFlowDirection;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::CoreWindowFlowDirection is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::AcceleratorKeyEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AcceleratorKeyEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::AcceleratorKeyEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::AutomationProviderRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AutomationProviderRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::AutomationProviderRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::BackRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::BackRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::CharacterReceivedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CharacterReceivedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::CharacterReceivedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::ClosestInteractiveBoundsRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ClosestInteractiveBoundsRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::ClosestInteractiveBoundsRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::CoreAcceleratorKeys>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreAcceleratorKeys;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::CoreAcceleratorKeys is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::CoreComponentInputSource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreComponentInputSource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::CoreComponentInputSource is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::CoreCursor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreCursor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::CoreCursor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::CoreDispatcher>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreDispatcher;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::CoreDispatcher is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::CoreIndependentInputSource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreIndependentInputSource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::CoreIndependentInputSource is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::CoreIndependentInputSourceController>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreIndependentInputSourceController;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::CoreIndependentInputSourceController is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::CoreWindow>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreWindow;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::CoreWindow is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::CoreWindowDialog>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreWindowDialog;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::CoreWindowDialog is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::CoreWindowEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreWindowEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::CoreWindowEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::CoreWindowFlyout>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreWindowFlyout;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::CoreWindowFlyout is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::CoreWindowPopupShowingEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreWindowPopupShowingEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::CoreWindowPopupShowingEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::CoreWindowResizeManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreWindowResizeManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::CoreWindowResizeManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::IdleDispatchedHandlerArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IdleDispatchedHandlerArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::IdleDispatchedHandlerArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::InputEnabledEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_InputEnabledEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::InputEnabledEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::KeyEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KeyEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::KeyEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::PointerEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PointerEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::PointerEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::SystemNavigationManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SystemNavigationManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::SystemNavigationManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::TouchHitTestingEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TouchHitTestingEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::TouchHitTestingEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::VisibilityChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VisibilityChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::VisibilityChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::WindowActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WindowActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::WindowActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::WindowSizeChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WindowSizeChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::WindowSizeChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::ICoreAcceleratorKeys>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ICoreAcceleratorKeys;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::ICoreAcceleratorKeys is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::ICoreInputSourceBase>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ICoreInputSourceBase;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::ICoreInputSourceBase is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::ICorePointerInputSource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ICorePointerInputSource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::ICorePointerInputSource is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::ICorePointerInputSource2>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ICorePointerInputSource2;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::ICorePointerInputSource2 is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::ICorePointerRedirector>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ICorePointerRedirector;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::ICorePointerRedirector is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::ICoreWindow>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ICoreWindow;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::ICoreWindow is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::ICoreWindowEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ICoreWindowEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::ICoreWindowEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::IInitializeWithCoreWindow>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IInitializeWithCoreWindow;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::IInitializeWithCoreWindow is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::CorePhysicalKeyStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CorePhysicalKeyStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::CorePhysicalKeyStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::CoreProximityEvaluation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreProximityEvaluation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::CoreProximityEvaluation is not registered");
        return nullptr;
    }

    return python_type;
}
