// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.Media.Capture.h"


PyObject* py::converter<winrt::Windows::Media::Capture::WhiteBalanceGain>::convert(winrt::Windows::Media::Capture::WhiteBalanceGain instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Media::Capture::WhiteBalanceGain>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Media::Capture::WhiteBalanceGain py::converter<winrt::Windows::Media::Capture::WhiteBalanceGain>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Media::Capture::WhiteBalanceGain>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Media::Capture::WhiteBalanceGain>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Media::Capture::WhiteBalanceGain");
    throw python_exception();
}

namespace py::cpp::Windows::Media::Capture
{
    struct module_state
    {
        PyObject* type_AppBroadcastCameraCaptureState;
        PyObject* type_AppBroadcastCameraOverlayLocation;
        PyObject* type_AppBroadcastCameraOverlaySize;
        PyObject* type_AppBroadcastCaptureTargetType;
        PyObject* type_AppBroadcastExitBroadcastModeReason;
        PyObject* type_AppBroadcastMicrophoneCaptureState;
        PyObject* type_AppBroadcastPlugInState;
        PyObject* type_AppBroadcastPreviewState;
        PyObject* type_AppBroadcastSignInResult;
        PyObject* type_AppBroadcastSignInState;
        PyObject* type_AppBroadcastStreamState;
        PyObject* type_AppBroadcastTerminationReason;
        PyObject* type_AppBroadcastVideoEncodingBitrateMode;
        PyObject* type_AppBroadcastVideoEncodingResolutionMode;
        PyObject* type_AppCaptureHistoricalBufferLengthUnit;
        PyObject* type_AppCaptureMetadataPriority;
        PyObject* type_AppCaptureMicrophoneCaptureState;
        PyObject* type_AppCaptureRecordingState;
        PyObject* type_AppCaptureVideoEncodingBitrateMode;
        PyObject* type_AppCaptureVideoEncodingFrameRateMode;
        PyObject* type_AppCaptureVideoEncodingResolutionMode;
        PyObject* type_CameraCaptureUIMaxPhotoResolution;
        PyObject* type_CameraCaptureUIMaxVideoResolution;
        PyObject* type_CameraCaptureUIMode;
        PyObject* type_CameraCaptureUIPhotoFormat;
        PyObject* type_CameraCaptureUIVideoFormat;
        PyObject* type_ForegroundActivationArgument;
        PyObject* type_GameBarCommand;
        PyObject* type_GameBarCommandOrigin;
        PyObject* type_GameBarServicesDisplayMode;
        PyObject* type_GameBarTargetCapturePolicy;
        PyObject* type_KnownVideoProfile;
        PyObject* type_MediaCaptureDeviceExclusiveControlReleaseMode;
        PyObject* type_MediaCaptureDeviceExclusiveControlStatus;
        PyObject* type_MediaCaptureMemoryPreference;
        PyObject* type_MediaCaptureSharingMode;
        PyObject* type_MediaCaptureThermalStatus;
        PyObject* type_MediaCategory;
        PyObject* type_MediaStreamType;
        PyObject* type_PhotoCaptureSource;
        PyObject* type_PowerlineFrequency;
        PyObject* type_StreamingCaptureMode;
        PyObject* type_VideoDeviceCharacteristic;
        PyObject* type_VideoRotation;
        PyTypeObject* type_AdvancedCapturedPhoto;
        PyTypeObject* type_AdvancedPhotoCapture;
        PyTypeObject* type_AppBroadcastBackgroundService;
        PyTypeObject* type_AppBroadcastBackgroundServiceSignInInfo;
        PyTypeObject* type_AppBroadcastBackgroundServiceStreamInfo;
        PyTypeObject* type_AppBroadcastCameraCaptureStateChangedEventArgs;
        PyTypeObject* type_AppBroadcastGlobalSettings;
        PyTypeObject* type_AppBroadcastHeartbeatRequestedEventArgs;
        PyTypeObject* type_AppBroadcastManager;
        PyTypeObject* type_AppBroadcastMicrophoneCaptureStateChangedEventArgs;
        PyTypeObject* type_AppBroadcastPlugIn;
        PyTypeObject* type_AppBroadcastPlugInManager;
        PyTypeObject* type_AppBroadcastPlugInStateChangedEventArgs;
        PyTypeObject* type_AppBroadcastPreview;
        PyTypeObject* type_AppBroadcastPreviewStateChangedEventArgs;
        PyTypeObject* type_AppBroadcastPreviewStreamReader;
        PyTypeObject* type_AppBroadcastPreviewStreamVideoFrame;
        PyTypeObject* type_AppBroadcastPreviewStreamVideoHeader;
        PyTypeObject* type_AppBroadcastProviderSettings;
        PyTypeObject* type_AppBroadcastServices;
        PyTypeObject* type_AppBroadcastSignInStateChangedEventArgs;
        PyTypeObject* type_AppBroadcastState;
        PyTypeObject* type_AppBroadcastStreamAudioFrame;
        PyTypeObject* type_AppBroadcastStreamAudioHeader;
        PyTypeObject* type_AppBroadcastStreamReader;
        PyTypeObject* type_AppBroadcastStreamStateChangedEventArgs;
        PyTypeObject* type_AppBroadcastStreamVideoFrame;
        PyTypeObject* type_AppBroadcastStreamVideoHeader;
        PyTypeObject* type_AppBroadcastTriggerDetails;
        PyTypeObject* type_AppBroadcastViewerCountChangedEventArgs;
        PyTypeObject* type_AppCapture;
        PyTypeObject* type_AppCaptureAlternateShortcutKeys;
        PyTypeObject* type_AppCaptureDurationGeneratedEventArgs;
        PyTypeObject* type_AppCaptureFileGeneratedEventArgs;
        PyTypeObject* type_AppCaptureManager;
        PyTypeObject* type_AppCaptureMetadataWriter;
        PyTypeObject* type_AppCaptureMicrophoneCaptureStateChangedEventArgs;
        PyTypeObject* type_AppCaptureRecordOperation;
        PyTypeObject* type_AppCaptureRecordingStateChangedEventArgs;
        PyTypeObject* type_AppCaptureServices;
        PyTypeObject* type_AppCaptureSettings;
        PyTypeObject* type_AppCaptureState;
        PyTypeObject* type_CameraCaptureUI;
        PyTypeObject* type_CameraCaptureUIPhotoCaptureSettings;
        PyTypeObject* type_CameraCaptureUIVideoCaptureSettings;
        PyTypeObject* type_CameraOptionsUI;
        PyTypeObject* type_CapturedFrame;
        PyTypeObject* type_CapturedFrameControlValues;
        PyTypeObject* type_CapturedPhoto;
        PyTypeObject* type_GameBarServices;
        PyTypeObject* type_GameBarServicesCommandEventArgs;
        PyTypeObject* type_GameBarServicesManager;
        PyTypeObject* type_GameBarServicesManagerGameBarServicesCreatedEventArgs;
        PyTypeObject* type_GameBarServicesTargetInfo;
        PyTypeObject* type_LowLagMediaRecording;
        PyTypeObject* type_LowLagPhotoCapture;
        PyTypeObject* type_LowLagPhotoSequenceCapture;
        PyTypeObject* type_MediaCapture;
        PyTypeObject* type_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs;
        PyTypeObject* type_MediaCaptureFailedEventArgs;
        PyTypeObject* type_MediaCaptureFocusChangedEventArgs;
        PyTypeObject* type_MediaCaptureInitializationSettings;
        PyTypeObject* type_MediaCapturePauseResult;
        PyTypeObject* type_MediaCaptureRelativePanelWatcher;
        PyTypeObject* type_MediaCaptureSettings;
        PyTypeObject* type_MediaCaptureStopResult;
        PyTypeObject* type_MediaCaptureVideoProfile;
        PyTypeObject* type_MediaCaptureVideoProfileMediaDescription;
        PyTypeObject* type_OptionalReferencePhotoCapturedEventArgs;
        PyTypeObject* type_PhotoCapturedEventArgs;
        PyTypeObject* type_PhotoConfirmationCapturedEventArgs;
        PyTypeObject* type_ScreenCapture;
        PyTypeObject* type_SourceSuspensionChangedEventArgs;
        PyTypeObject* type_VideoStreamConfiguration;
        PyTypeObject* type_WhiteBalanceGain;
    };

    static PyObject* register_AppBroadcastCameraCaptureState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AppBroadcastCameraCaptureState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AppBroadcastCameraCaptureState = type;
        Py_INCREF(state->type_AppBroadcastCameraCaptureState);


        Py_RETURN_NONE;
    }

    static PyObject* register_AppBroadcastCameraOverlayLocation(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AppBroadcastCameraOverlayLocation)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AppBroadcastCameraOverlayLocation = type;
        Py_INCREF(state->type_AppBroadcastCameraOverlayLocation);


        Py_RETURN_NONE;
    }

    static PyObject* register_AppBroadcastCameraOverlaySize(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AppBroadcastCameraOverlaySize)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AppBroadcastCameraOverlaySize = type;
        Py_INCREF(state->type_AppBroadcastCameraOverlaySize);


        Py_RETURN_NONE;
    }

    static PyObject* register_AppBroadcastCaptureTargetType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AppBroadcastCaptureTargetType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AppBroadcastCaptureTargetType = type;
        Py_INCREF(state->type_AppBroadcastCaptureTargetType);


        Py_RETURN_NONE;
    }

    static PyObject* register_AppBroadcastExitBroadcastModeReason(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AppBroadcastExitBroadcastModeReason)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AppBroadcastExitBroadcastModeReason = type;
        Py_INCREF(state->type_AppBroadcastExitBroadcastModeReason);


        Py_RETURN_NONE;
    }

    static PyObject* register_AppBroadcastMicrophoneCaptureState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AppBroadcastMicrophoneCaptureState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AppBroadcastMicrophoneCaptureState = type;
        Py_INCREF(state->type_AppBroadcastMicrophoneCaptureState);


        Py_RETURN_NONE;
    }

    static PyObject* register_AppBroadcastPlugInState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AppBroadcastPlugInState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AppBroadcastPlugInState = type;
        Py_INCREF(state->type_AppBroadcastPlugInState);


        Py_RETURN_NONE;
    }

    static PyObject* register_AppBroadcastPreviewState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AppBroadcastPreviewState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AppBroadcastPreviewState = type;
        Py_INCREF(state->type_AppBroadcastPreviewState);


        Py_RETURN_NONE;
    }

    static PyObject* register_AppBroadcastSignInResult(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AppBroadcastSignInResult)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AppBroadcastSignInResult = type;
        Py_INCREF(state->type_AppBroadcastSignInResult);


        Py_RETURN_NONE;
    }

    static PyObject* register_AppBroadcastSignInState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AppBroadcastSignInState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AppBroadcastSignInState = type;
        Py_INCREF(state->type_AppBroadcastSignInState);


        Py_RETURN_NONE;
    }

    static PyObject* register_AppBroadcastStreamState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AppBroadcastStreamState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AppBroadcastStreamState = type;
        Py_INCREF(state->type_AppBroadcastStreamState);


        Py_RETURN_NONE;
    }

    static PyObject* register_AppBroadcastTerminationReason(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AppBroadcastTerminationReason)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AppBroadcastTerminationReason = type;
        Py_INCREF(state->type_AppBroadcastTerminationReason);


        Py_RETURN_NONE;
    }

    static PyObject* register_AppBroadcastVideoEncodingBitrateMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AppBroadcastVideoEncodingBitrateMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AppBroadcastVideoEncodingBitrateMode = type;
        Py_INCREF(state->type_AppBroadcastVideoEncodingBitrateMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_AppBroadcastVideoEncodingResolutionMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AppBroadcastVideoEncodingResolutionMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AppBroadcastVideoEncodingResolutionMode = type;
        Py_INCREF(state->type_AppBroadcastVideoEncodingResolutionMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_AppCaptureHistoricalBufferLengthUnit(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AppCaptureHistoricalBufferLengthUnit)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AppCaptureHistoricalBufferLengthUnit = type;
        Py_INCREF(state->type_AppCaptureHistoricalBufferLengthUnit);


        Py_RETURN_NONE;
    }

    static PyObject* register_AppCaptureMetadataPriority(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AppCaptureMetadataPriority)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AppCaptureMetadataPriority = type;
        Py_INCREF(state->type_AppCaptureMetadataPriority);


        Py_RETURN_NONE;
    }

    static PyObject* register_AppCaptureMicrophoneCaptureState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AppCaptureMicrophoneCaptureState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AppCaptureMicrophoneCaptureState = type;
        Py_INCREF(state->type_AppCaptureMicrophoneCaptureState);


        Py_RETURN_NONE;
    }

    static PyObject* register_AppCaptureRecordingState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AppCaptureRecordingState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AppCaptureRecordingState = type;
        Py_INCREF(state->type_AppCaptureRecordingState);


        Py_RETURN_NONE;
    }

    static PyObject* register_AppCaptureVideoEncodingBitrateMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AppCaptureVideoEncodingBitrateMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AppCaptureVideoEncodingBitrateMode = type;
        Py_INCREF(state->type_AppCaptureVideoEncodingBitrateMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_AppCaptureVideoEncodingFrameRateMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AppCaptureVideoEncodingFrameRateMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AppCaptureVideoEncodingFrameRateMode = type;
        Py_INCREF(state->type_AppCaptureVideoEncodingFrameRateMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_AppCaptureVideoEncodingResolutionMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AppCaptureVideoEncodingResolutionMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AppCaptureVideoEncodingResolutionMode = type;
        Py_INCREF(state->type_AppCaptureVideoEncodingResolutionMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_CameraCaptureUIMaxPhotoResolution(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CameraCaptureUIMaxPhotoResolution)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CameraCaptureUIMaxPhotoResolution = type;
        Py_INCREF(state->type_CameraCaptureUIMaxPhotoResolution);


        Py_RETURN_NONE;
    }

    static PyObject* register_CameraCaptureUIMaxVideoResolution(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CameraCaptureUIMaxVideoResolution)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CameraCaptureUIMaxVideoResolution = type;
        Py_INCREF(state->type_CameraCaptureUIMaxVideoResolution);


        Py_RETURN_NONE;
    }

    static PyObject* register_CameraCaptureUIMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CameraCaptureUIMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CameraCaptureUIMode = type;
        Py_INCREF(state->type_CameraCaptureUIMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_CameraCaptureUIPhotoFormat(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CameraCaptureUIPhotoFormat)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CameraCaptureUIPhotoFormat = type;
        Py_INCREF(state->type_CameraCaptureUIPhotoFormat);


        Py_RETURN_NONE;
    }

    static PyObject* register_CameraCaptureUIVideoFormat(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CameraCaptureUIVideoFormat)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CameraCaptureUIVideoFormat = type;
        Py_INCREF(state->type_CameraCaptureUIVideoFormat);


        Py_RETURN_NONE;
    }

    static PyObject* register_ForegroundActivationArgument(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ForegroundActivationArgument)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ForegroundActivationArgument = type;
        Py_INCREF(state->type_ForegroundActivationArgument);


        Py_RETURN_NONE;
    }

    static PyObject* register_GameBarCommand(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_GameBarCommand)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_GameBarCommand = type;
        Py_INCREF(state->type_GameBarCommand);


        Py_RETURN_NONE;
    }

    static PyObject* register_GameBarCommandOrigin(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_GameBarCommandOrigin)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_GameBarCommandOrigin = type;
        Py_INCREF(state->type_GameBarCommandOrigin);


        Py_RETURN_NONE;
    }

    static PyObject* register_GameBarServicesDisplayMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_GameBarServicesDisplayMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_GameBarServicesDisplayMode = type;
        Py_INCREF(state->type_GameBarServicesDisplayMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_GameBarTargetCapturePolicy(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_GameBarTargetCapturePolicy)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_GameBarTargetCapturePolicy = type;
        Py_INCREF(state->type_GameBarTargetCapturePolicy);


        Py_RETURN_NONE;
    }

    static PyObject* register_KnownVideoProfile(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_KnownVideoProfile)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_KnownVideoProfile = type;
        Py_INCREF(state->type_KnownVideoProfile);


        Py_RETURN_NONE;
    }

    static PyObject* register_MediaCaptureDeviceExclusiveControlReleaseMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MediaCaptureDeviceExclusiveControlReleaseMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MediaCaptureDeviceExclusiveControlReleaseMode = type;
        Py_INCREF(state->type_MediaCaptureDeviceExclusiveControlReleaseMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_MediaCaptureDeviceExclusiveControlStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MediaCaptureDeviceExclusiveControlStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MediaCaptureDeviceExclusiveControlStatus = type;
        Py_INCREF(state->type_MediaCaptureDeviceExclusiveControlStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_MediaCaptureMemoryPreference(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MediaCaptureMemoryPreference)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MediaCaptureMemoryPreference = type;
        Py_INCREF(state->type_MediaCaptureMemoryPreference);


        Py_RETURN_NONE;
    }

    static PyObject* register_MediaCaptureSharingMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MediaCaptureSharingMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MediaCaptureSharingMode = type;
        Py_INCREF(state->type_MediaCaptureSharingMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_MediaCaptureThermalStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MediaCaptureThermalStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MediaCaptureThermalStatus = type;
        Py_INCREF(state->type_MediaCaptureThermalStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_MediaCategory(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MediaCategory)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MediaCategory = type;
        Py_INCREF(state->type_MediaCategory);


        Py_RETURN_NONE;
    }

    static PyObject* register_MediaStreamType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MediaStreamType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MediaStreamType = type;
        Py_INCREF(state->type_MediaStreamType);


        Py_RETURN_NONE;
    }

    static PyObject* register_PhotoCaptureSource(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PhotoCaptureSource)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PhotoCaptureSource = type;
        Py_INCREF(state->type_PhotoCaptureSource);


        Py_RETURN_NONE;
    }

    static PyObject* register_PowerlineFrequency(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PowerlineFrequency)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PowerlineFrequency = type;
        Py_INCREF(state->type_PowerlineFrequency);


        Py_RETURN_NONE;
    }

    static PyObject* register_StreamingCaptureMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_StreamingCaptureMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_StreamingCaptureMode = type;
        Py_INCREF(state->type_StreamingCaptureMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_VideoDeviceCharacteristic(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_VideoDeviceCharacteristic)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_VideoDeviceCharacteristic = type;
        Py_INCREF(state->type_VideoDeviceCharacteristic);


        Py_RETURN_NONE;
    }

    static PyObject* register_VideoRotation(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_VideoRotation)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_VideoRotation = type;
        Py_INCREF(state->type_VideoRotation);


        Py_RETURN_NONE;
    }

    // ----- AdvancedCapturedPhoto class --------------------
    static constexpr const char* const type_name_AdvancedCapturedPhoto = "AdvancedCapturedPhoto";

    static PyObject* _new_AdvancedCapturedPhoto(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AdvancedCapturedPhoto);
        return nullptr;
    }

    static void _dealloc_AdvancedCapturedPhoto(py::wrapper::Windows::Media::Capture::AdvancedCapturedPhoto* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AdvancedCapturedPhoto_get_Context(py::wrapper::Windows::Media::Capture::AdvancedCapturedPhoto* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AdvancedCapturedPhoto", L"Context"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Context());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedCapturedPhoto_get_Frame(py::wrapper::Windows::Media::Capture::AdvancedCapturedPhoto* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AdvancedCapturedPhoto", L"Frame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedCapturedPhoto_get_Mode(py::wrapper::Windows::Media::Capture::AdvancedCapturedPhoto* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AdvancedCapturedPhoto", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedCapturedPhoto_get_FrameBoundsRelativeToReferencePhoto(py::wrapper::Windows::Media::Capture::AdvancedCapturedPhoto* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AdvancedCapturedPhoto", L"FrameBoundsRelativeToReferencePhoto"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameBoundsRelativeToReferencePhoto());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AdvancedCapturedPhoto(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AdvancedCapturedPhoto>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AdvancedCapturedPhoto(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AdvancedCapturedPhoto>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdvancedCapturedPhoto[] = {
        { "_assign_array_", _assign_array_AdvancedCapturedPhoto, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AdvancedCapturedPhoto), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdvancedCapturedPhoto[] = {
        { "context", reinterpret_cast<getter>(AdvancedCapturedPhoto_get_Context), nullptr, nullptr, nullptr },
        { "frame", reinterpret_cast<getter>(AdvancedCapturedPhoto_get_Frame), nullptr, nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(AdvancedCapturedPhoto_get_Mode), nullptr, nullptr, nullptr },
        { "frame_bounds_relative_to_reference_photo", reinterpret_cast<getter>(AdvancedCapturedPhoto_get_FrameBoundsRelativeToReferencePhoto), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AdvancedCapturedPhoto[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AdvancedCapturedPhoto) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AdvancedCapturedPhoto) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AdvancedCapturedPhoto) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AdvancedCapturedPhoto) },
        { },
    };

    static PyType_Spec type_spec_AdvancedCapturedPhoto =
    {
        "_winsdk_Windows_Media_Capture.AdvancedCapturedPhoto",
        sizeof(py::wrapper::Windows::Media::Capture::AdvancedCapturedPhoto),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdvancedCapturedPhoto
    };

    // ----- AdvancedPhotoCapture class --------------------
    static constexpr const char* const type_name_AdvancedPhotoCapture = "AdvancedPhotoCapture";

    static PyObject* _new_AdvancedPhotoCapture(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AdvancedPhotoCapture);
        return nullptr;
    }

    static void _dealloc_AdvancedPhotoCapture(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AdvancedPhotoCapture_CaptureAsync(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AdvancedPhotoCapture", L"CaptureAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CaptureAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AdvancedPhotoCapture", L"CaptureAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.CaptureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoCapture_FinishAsync(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AdvancedPhotoCapture", L"FinishAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FinishAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoCapture_add_AllPhotosCaptured(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AdvancedPhotoCapture", L"AllPhotosCaptured"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AdvancedPhotoCapture, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AllPhotosCaptured(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoCapture_remove_AllPhotosCaptured(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AdvancedPhotoCapture", L"AllPhotosCaptured"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AllPhotosCaptured(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoCapture_add_OptionalReferencePhotoCaptured(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AdvancedPhotoCapture", L"OptionalReferencePhotoCaptured"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AdvancedPhotoCapture, winrt::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs>>(arg);

            return py::convert(self->obj.OptionalReferencePhotoCaptured(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoCapture_remove_OptionalReferencePhotoCaptured(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AdvancedPhotoCapture", L"OptionalReferencePhotoCaptured"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OptionalReferencePhotoCaptured(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AdvancedPhotoCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AdvancedPhotoCapture>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AdvancedPhotoCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AdvancedPhotoCapture>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdvancedPhotoCapture[] = {
        { "capture_async", reinterpret_cast<PyCFunction>(AdvancedPhotoCapture_CaptureAsync), METH_VARARGS, nullptr },
        { "finish_async", reinterpret_cast<PyCFunction>(AdvancedPhotoCapture_FinishAsync), METH_VARARGS, nullptr },
        { "add_all_photos_captured", reinterpret_cast<PyCFunction>(AdvancedPhotoCapture_add_AllPhotosCaptured), METH_O, nullptr },
        { "remove_all_photos_captured", reinterpret_cast<PyCFunction>(AdvancedPhotoCapture_remove_AllPhotosCaptured), METH_O, nullptr },
        { "add_optional_reference_photo_captured", reinterpret_cast<PyCFunction>(AdvancedPhotoCapture_add_OptionalReferencePhotoCaptured), METH_O, nullptr },
        { "remove_optional_reference_photo_captured", reinterpret_cast<PyCFunction>(AdvancedPhotoCapture_remove_OptionalReferencePhotoCaptured), METH_O, nullptr },
        { "_assign_array_", _assign_array_AdvancedPhotoCapture, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AdvancedPhotoCapture), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdvancedPhotoCapture[] = {
        { }
    };

    static PyType_Slot _type_slots_AdvancedPhotoCapture[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AdvancedPhotoCapture) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AdvancedPhotoCapture) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AdvancedPhotoCapture) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AdvancedPhotoCapture) },
        { },
    };

    static PyType_Spec type_spec_AdvancedPhotoCapture =
    {
        "_winsdk_Windows_Media_Capture.AdvancedPhotoCapture",
        sizeof(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdvancedPhotoCapture
    };

    // ----- AppBroadcastBackgroundService class --------------------
    static constexpr const char* const type_name_AppBroadcastBackgroundService = "AppBroadcastBackgroundService";

    static PyObject* _new_AppBroadcastBackgroundService(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastBackgroundService);
        return nullptr;
    }

    static void _dealloc_AppBroadcastBackgroundService(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastBackgroundService_TerminateBroadcast(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"TerminateBroadcast", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastTerminationReason>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                self->obj.TerminateBroadcast(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundService_get_ViewerCount(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"ViewerCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ViewerCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastBackgroundService_put_ViewerCount(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"ViewerCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ViewerCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastBackgroundService_get_StreamInfo(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"StreamInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StreamInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastBackgroundService_put_StreamInfo(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"StreamInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo>(arg);

            self->obj.StreamInfo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastBackgroundService_get_SignInInfo(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"SignInInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SignInInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastBackgroundService_put_SignInInfo(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"SignInInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo>(arg);

            self->obj.SignInInfo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastBackgroundService_get_PlugInState(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"PlugInState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlugInState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastBackgroundService_put_PlugInState(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"PlugInState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastPlugInState>(arg);

            self->obj.PlugInState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastBackgroundService_get_BroadcastTitle(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"BroadcastTitle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BroadcastTitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastBackgroundService_put_BroadcastTitle(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"BroadcastTitle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.BroadcastTitle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastBackgroundService_get_AppId(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"AppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundService_get_TitleId(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"TitleId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TitleId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundService_get_BroadcastLanguage(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"BroadcastLanguage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BroadcastLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastBackgroundService_put_BroadcastLanguage(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"BroadcastLanguage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.BroadcastLanguage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastBackgroundService_get_BroadcastChannel(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"BroadcastChannel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BroadcastChannel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastBackgroundService_put_BroadcastChannel(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"BroadcastChannel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.BroadcastChannel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastBackgroundService_add_HeartbeatRequested(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"HeartbeatRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastBackgroundService, winrt::Windows::Media::Capture::AppBroadcastHeartbeatRequestedEventArgs>>(arg);

            return py::convert(self->obj.HeartbeatRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundService_remove_HeartbeatRequested(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"HeartbeatRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeartbeatRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundService_add_BroadcastChannelChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"BroadcastChannelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastBackgroundService, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.BroadcastChannelChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundService_remove_BroadcastChannelChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"BroadcastChannelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BroadcastChannelChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundService_add_BroadcastLanguageChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"BroadcastLanguageChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastBackgroundService, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.BroadcastLanguageChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundService_remove_BroadcastLanguageChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"BroadcastLanguageChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BroadcastLanguageChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundService_add_BroadcastTitleChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"BroadcastTitleChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastBackgroundService, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.BroadcastTitleChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundService_remove_BroadcastTitleChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"BroadcastTitleChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BroadcastTitleChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastBackgroundService(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastBackgroundService>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastBackgroundService(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastBackgroundService>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastBackgroundService[] = {
        { "terminate_broadcast", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundService_TerminateBroadcast), METH_VARARGS, nullptr },
        { "add_heartbeat_requested", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundService_add_HeartbeatRequested), METH_O, nullptr },
        { "remove_heartbeat_requested", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundService_remove_HeartbeatRequested), METH_O, nullptr },
        { "add_broadcast_channel_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundService_add_BroadcastChannelChanged), METH_O, nullptr },
        { "remove_broadcast_channel_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundService_remove_BroadcastChannelChanged), METH_O, nullptr },
        { "add_broadcast_language_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundService_add_BroadcastLanguageChanged), METH_O, nullptr },
        { "remove_broadcast_language_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundService_remove_BroadcastLanguageChanged), METH_O, nullptr },
        { "add_broadcast_title_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundService_add_BroadcastTitleChanged), METH_O, nullptr },
        { "remove_broadcast_title_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundService_remove_BroadcastTitleChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppBroadcastBackgroundService, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastBackgroundService), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastBackgroundService[] = {
        { "viewer_count", reinterpret_cast<getter>(AppBroadcastBackgroundService_get_ViewerCount), reinterpret_cast<setter>(AppBroadcastBackgroundService_put_ViewerCount), nullptr, nullptr },
        { "stream_info", reinterpret_cast<getter>(AppBroadcastBackgroundService_get_StreamInfo), reinterpret_cast<setter>(AppBroadcastBackgroundService_put_StreamInfo), nullptr, nullptr },
        { "sign_in_info", reinterpret_cast<getter>(AppBroadcastBackgroundService_get_SignInInfo), reinterpret_cast<setter>(AppBroadcastBackgroundService_put_SignInInfo), nullptr, nullptr },
        { "plug_in_state", reinterpret_cast<getter>(AppBroadcastBackgroundService_get_PlugInState), reinterpret_cast<setter>(AppBroadcastBackgroundService_put_PlugInState), nullptr, nullptr },
        { "broadcast_title", reinterpret_cast<getter>(AppBroadcastBackgroundService_get_BroadcastTitle), reinterpret_cast<setter>(AppBroadcastBackgroundService_put_BroadcastTitle), nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(AppBroadcastBackgroundService_get_AppId), nullptr, nullptr, nullptr },
        { "title_id", reinterpret_cast<getter>(AppBroadcastBackgroundService_get_TitleId), nullptr, nullptr, nullptr },
        { "broadcast_language", reinterpret_cast<getter>(AppBroadcastBackgroundService_get_BroadcastLanguage), reinterpret_cast<setter>(AppBroadcastBackgroundService_put_BroadcastLanguage), nullptr, nullptr },
        { "broadcast_channel", reinterpret_cast<getter>(AppBroadcastBackgroundService_get_BroadcastChannel), reinterpret_cast<setter>(AppBroadcastBackgroundService_put_BroadcastChannel), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastBackgroundService[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastBackgroundService) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastBackgroundService) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastBackgroundService) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastBackgroundService) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastBackgroundService =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastBackgroundService",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastBackgroundService
    };

    // ----- AppBroadcastBackgroundServiceSignInInfo class --------------------
    static constexpr const char* const type_name_AppBroadcastBackgroundServiceSignInInfo = "AppBroadcastBackgroundServiceSignInInfo";

    static PyObject* _new_AppBroadcastBackgroundServiceSignInInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastBackgroundServiceSignInInfo);
        return nullptr;
    }

    static void _dealloc_AppBroadcastBackgroundServiceSignInInfo(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastBackgroundServiceSignInInfo_get_UserName(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceSignInInfo", L"UserName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UserName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastBackgroundServiceSignInInfo_put_UserName(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceSignInInfo", L"UserName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.UserName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceSignInInfo_get_OAuthRequestUri(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceSignInInfo", L"OAuthRequestUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OAuthRequestUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastBackgroundServiceSignInInfo_put_OAuthRequestUri(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceSignInInfo", L"OAuthRequestUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.OAuthRequestUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceSignInInfo_get_OAuthCallbackUri(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceSignInInfo", L"OAuthCallbackUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OAuthCallbackUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastBackgroundServiceSignInInfo_put_OAuthCallbackUri(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceSignInInfo", L"OAuthCallbackUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.OAuthCallbackUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceSignInInfo_get_AuthenticationResult(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceSignInInfo", L"AuthenticationResult"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AuthenticationResult());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceSignInInfo_get_SignInState(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceSignInInfo", L"SignInState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SignInState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceSignInInfo_add_SignInStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceSignInInfo", L"SignInStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo, winrt::Windows::Media::Capture::AppBroadcastSignInStateChangedEventArgs>>(arg);

            return py::convert(self->obj.SignInStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceSignInInfo_remove_SignInStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceSignInInfo", L"SignInStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SignInStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceSignInInfo_add_UserNameChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceSignInInfo", L"UserNameChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.UserNameChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceSignInInfo_remove_UserNameChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceSignInInfo", L"UserNameChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UserNameChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastBackgroundServiceSignInInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastBackgroundServiceSignInInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastBackgroundServiceSignInInfo[] = {
        { "add_sign_in_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundServiceSignInInfo_add_SignInStateChanged), METH_O, nullptr },
        { "remove_sign_in_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundServiceSignInInfo_remove_SignInStateChanged), METH_O, nullptr },
        { "add_user_name_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundServiceSignInInfo_add_UserNameChanged), METH_O, nullptr },
        { "remove_user_name_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundServiceSignInInfo_remove_UserNameChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppBroadcastBackgroundServiceSignInInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastBackgroundServiceSignInInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastBackgroundServiceSignInInfo[] = {
        { "user_name", reinterpret_cast<getter>(AppBroadcastBackgroundServiceSignInInfo_get_UserName), reinterpret_cast<setter>(AppBroadcastBackgroundServiceSignInInfo_put_UserName), nullptr, nullptr },
        { "o_auth_request_uri", reinterpret_cast<getter>(AppBroadcastBackgroundServiceSignInInfo_get_OAuthRequestUri), reinterpret_cast<setter>(AppBroadcastBackgroundServiceSignInInfo_put_OAuthRequestUri), nullptr, nullptr },
        { "o_auth_callback_uri", reinterpret_cast<getter>(AppBroadcastBackgroundServiceSignInInfo_get_OAuthCallbackUri), reinterpret_cast<setter>(AppBroadcastBackgroundServiceSignInInfo_put_OAuthCallbackUri), nullptr, nullptr },
        { "authentication_result", reinterpret_cast<getter>(AppBroadcastBackgroundServiceSignInInfo_get_AuthenticationResult), nullptr, nullptr, nullptr },
        { "sign_in_state", reinterpret_cast<getter>(AppBroadcastBackgroundServiceSignInInfo_get_SignInState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastBackgroundServiceSignInInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastBackgroundServiceSignInInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastBackgroundServiceSignInInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastBackgroundServiceSignInInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastBackgroundServiceSignInInfo) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastBackgroundServiceSignInInfo =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastBackgroundServiceSignInInfo",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastBackgroundServiceSignInInfo
    };

    // ----- AppBroadcastBackgroundServiceStreamInfo class --------------------
    static constexpr const char* const type_name_AppBroadcastBackgroundServiceStreamInfo = "AppBroadcastBackgroundServiceStreamInfo";

    static PyObject* _new_AppBroadcastBackgroundServiceStreamInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastBackgroundServiceStreamInfo);
        return nullptr;
    }

    static void _dealloc_AppBroadcastBackgroundServiceStreamInfo(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastBackgroundServiceStreamInfo_ReportProblemWithStream(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"ReportProblemWithStream", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ReportProblemWithStream();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceStreamInfo_get_DesiredVideoEncodingBitrate(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"DesiredVideoEncodingBitrate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredVideoEncodingBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastBackgroundServiceStreamInfo_put_DesiredVideoEncodingBitrate(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"DesiredVideoEncodingBitrate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.DesiredVideoEncodingBitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceStreamInfo_get_BandwidthTestBitrate(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"BandwidthTestBitrate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BandwidthTestBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastBackgroundServiceStreamInfo_put_BandwidthTestBitrate(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"BandwidthTestBitrate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.BandwidthTestBitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceStreamInfo_get_AudioCodec(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"AudioCodec"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioCodec());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastBackgroundServiceStreamInfo_put_AudioCodec(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"AudioCodec"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AudioCodec(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceStreamInfo_get_BroadcastStreamReader(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"BroadcastStreamReader"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BroadcastStreamReader());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceStreamInfo_get_StreamState(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"StreamState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StreamState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceStreamInfo_add_StreamStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"StreamStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo, winrt::Windows::Media::Capture::AppBroadcastStreamStateChangedEventArgs>>(arg);

            return py::convert(self->obj.StreamStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceStreamInfo_remove_StreamStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"StreamStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StreamStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceStreamInfo_add_VideoEncodingBitrateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"VideoEncodingBitrateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VideoEncodingBitrateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceStreamInfo_remove_VideoEncodingBitrateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"VideoEncodingBitrateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VideoEncodingBitrateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceStreamInfo_add_VideoEncodingResolutionChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"VideoEncodingResolutionChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VideoEncodingResolutionChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceStreamInfo_remove_VideoEncodingResolutionChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"VideoEncodingResolutionChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VideoEncodingResolutionChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastBackgroundServiceStreamInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastBackgroundServiceStreamInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastBackgroundServiceStreamInfo[] = {
        { "report_problem_with_stream", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundServiceStreamInfo_ReportProblemWithStream), METH_VARARGS, nullptr },
        { "add_stream_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundServiceStreamInfo_add_StreamStateChanged), METH_O, nullptr },
        { "remove_stream_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundServiceStreamInfo_remove_StreamStateChanged), METH_O, nullptr },
        { "add_video_encoding_bitrate_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundServiceStreamInfo_add_VideoEncodingBitrateChanged), METH_O, nullptr },
        { "remove_video_encoding_bitrate_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundServiceStreamInfo_remove_VideoEncodingBitrateChanged), METH_O, nullptr },
        { "add_video_encoding_resolution_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundServiceStreamInfo_add_VideoEncodingResolutionChanged), METH_O, nullptr },
        { "remove_video_encoding_resolution_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundServiceStreamInfo_remove_VideoEncodingResolutionChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppBroadcastBackgroundServiceStreamInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastBackgroundServiceStreamInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastBackgroundServiceStreamInfo[] = {
        { "desired_video_encoding_bitrate", reinterpret_cast<getter>(AppBroadcastBackgroundServiceStreamInfo_get_DesiredVideoEncodingBitrate), reinterpret_cast<setter>(AppBroadcastBackgroundServiceStreamInfo_put_DesiredVideoEncodingBitrate), nullptr, nullptr },
        { "bandwidth_test_bitrate", reinterpret_cast<getter>(AppBroadcastBackgroundServiceStreamInfo_get_BandwidthTestBitrate), reinterpret_cast<setter>(AppBroadcastBackgroundServiceStreamInfo_put_BandwidthTestBitrate), nullptr, nullptr },
        { "audio_codec", reinterpret_cast<getter>(AppBroadcastBackgroundServiceStreamInfo_get_AudioCodec), reinterpret_cast<setter>(AppBroadcastBackgroundServiceStreamInfo_put_AudioCodec), nullptr, nullptr },
        { "broadcast_stream_reader", reinterpret_cast<getter>(AppBroadcastBackgroundServiceStreamInfo_get_BroadcastStreamReader), nullptr, nullptr, nullptr },
        { "stream_state", reinterpret_cast<getter>(AppBroadcastBackgroundServiceStreamInfo_get_StreamState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastBackgroundServiceStreamInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastBackgroundServiceStreamInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastBackgroundServiceStreamInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastBackgroundServiceStreamInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastBackgroundServiceStreamInfo) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastBackgroundServiceStreamInfo =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastBackgroundServiceStreamInfo",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastBackgroundServiceStreamInfo
    };

    // ----- AppBroadcastCameraCaptureStateChangedEventArgs class --------------------
    static constexpr const char* const type_name_AppBroadcastCameraCaptureStateChangedEventArgs = "AppBroadcastCameraCaptureStateChangedEventArgs";

    static PyObject* _new_AppBroadcastCameraCaptureStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastCameraCaptureStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_AppBroadcastCameraCaptureStateChangedEventArgs(py::wrapper::Windows::Media::Capture::AppBroadcastCameraCaptureStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastCameraCaptureStateChangedEventArgs_get_ErrorCode(py::wrapper::Windows::Media::Capture::AppBroadcastCameraCaptureStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastCameraCaptureStateChangedEventArgs", L"ErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastCameraCaptureStateChangedEventArgs_get_State(py::wrapper::Windows::Media::Capture::AppBroadcastCameraCaptureStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastCameraCaptureStateChangedEventArgs", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastCameraCaptureStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastCameraCaptureStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastCameraCaptureStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastCameraCaptureStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastCameraCaptureStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AppBroadcastCameraCaptureStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastCameraCaptureStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastCameraCaptureStateChangedEventArgs[] = {
        { "error_code", reinterpret_cast<getter>(AppBroadcastCameraCaptureStateChangedEventArgs_get_ErrorCode), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(AppBroadcastCameraCaptureStateChangedEventArgs_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastCameraCaptureStateChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastCameraCaptureStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastCameraCaptureStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastCameraCaptureStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastCameraCaptureStateChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastCameraCaptureStateChangedEventArgs =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastCameraCaptureStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastCameraCaptureStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastCameraCaptureStateChangedEventArgs
    };

    // ----- AppBroadcastGlobalSettings class --------------------
    static constexpr const char* const type_name_AppBroadcastGlobalSettings = "AppBroadcastGlobalSettings";

    static PyObject* _new_AppBroadcastGlobalSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastGlobalSettings);
        return nullptr;
    }

    static void _dealloc_AppBroadcastGlobalSettings(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastGlobalSettings_get_SystemAudioGain(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"SystemAudioGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SystemAudioGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastGlobalSettings_put_SystemAudioGain(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"SystemAudioGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.SystemAudioGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastGlobalSettings_get_SelectedCameraId(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"SelectedCameraId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedCameraId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastGlobalSettings_put_SelectedCameraId(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"SelectedCameraId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SelectedCameraId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastGlobalSettings_get_MicrophoneGain(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"MicrophoneGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MicrophoneGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastGlobalSettings_put_MicrophoneGain(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"MicrophoneGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.MicrophoneGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastGlobalSettings_get_IsMicrophoneCaptureEnabledByDefault(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"IsMicrophoneCaptureEnabledByDefault"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsMicrophoneCaptureEnabledByDefault());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastGlobalSettings_put_IsMicrophoneCaptureEnabledByDefault(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"IsMicrophoneCaptureEnabledByDefault"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsMicrophoneCaptureEnabledByDefault(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastGlobalSettings_get_IsEchoCancellationEnabled(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"IsEchoCancellationEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEchoCancellationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastGlobalSettings_put_IsEchoCancellationEnabled(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"IsEchoCancellationEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEchoCancellationEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastGlobalSettings_get_IsCursorImageCaptureEnabled(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"IsCursorImageCaptureEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCursorImageCaptureEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastGlobalSettings_put_IsCursorImageCaptureEnabled(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"IsCursorImageCaptureEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCursorImageCaptureEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastGlobalSettings_get_IsCameraCaptureEnabledByDefault(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"IsCameraCaptureEnabledByDefault"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCameraCaptureEnabledByDefault());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastGlobalSettings_put_IsCameraCaptureEnabledByDefault(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"IsCameraCaptureEnabledByDefault"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCameraCaptureEnabledByDefault(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastGlobalSettings_get_IsAudioCaptureEnabled(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"IsAudioCaptureEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsAudioCaptureEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastGlobalSettings_put_IsAudioCaptureEnabled(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"IsAudioCaptureEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAudioCaptureEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastGlobalSettings_get_CameraOverlaySize(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"CameraOverlaySize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CameraOverlaySize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastGlobalSettings_put_CameraOverlaySize(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"CameraOverlaySize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastCameraOverlaySize>(arg);

            self->obj.CameraOverlaySize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastGlobalSettings_get_CameraOverlayLocation(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"CameraOverlayLocation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CameraOverlayLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastGlobalSettings_put_CameraOverlayLocation(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"CameraOverlayLocation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastCameraOverlayLocation>(arg);

            self->obj.CameraOverlayLocation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastGlobalSettings_get_HasHardwareEncoder(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"HasHardwareEncoder"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasHardwareEncoder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastGlobalSettings_get_IsBroadcastEnabled(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"IsBroadcastEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsBroadcastEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastGlobalSettings_get_IsDisabledByPolicy(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"IsDisabledByPolicy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDisabledByPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastGlobalSettings_get_IsGpuConstrained(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"IsGpuConstrained"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsGpuConstrained());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastGlobalSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastGlobalSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastGlobalSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastGlobalSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastGlobalSettings[] = {
        { "_assign_array_", _assign_array_AppBroadcastGlobalSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastGlobalSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastGlobalSettings[] = {
        { "system_audio_gain", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_SystemAudioGain), reinterpret_cast<setter>(AppBroadcastGlobalSettings_put_SystemAudioGain), nullptr, nullptr },
        { "selected_camera_id", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_SelectedCameraId), reinterpret_cast<setter>(AppBroadcastGlobalSettings_put_SelectedCameraId), nullptr, nullptr },
        { "microphone_gain", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_MicrophoneGain), reinterpret_cast<setter>(AppBroadcastGlobalSettings_put_MicrophoneGain), nullptr, nullptr },
        { "is_microphone_capture_enabled_by_default", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_IsMicrophoneCaptureEnabledByDefault), reinterpret_cast<setter>(AppBroadcastGlobalSettings_put_IsMicrophoneCaptureEnabledByDefault), nullptr, nullptr },
        { "is_echo_cancellation_enabled", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_IsEchoCancellationEnabled), reinterpret_cast<setter>(AppBroadcastGlobalSettings_put_IsEchoCancellationEnabled), nullptr, nullptr },
        { "is_cursor_image_capture_enabled", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_IsCursorImageCaptureEnabled), reinterpret_cast<setter>(AppBroadcastGlobalSettings_put_IsCursorImageCaptureEnabled), nullptr, nullptr },
        { "is_camera_capture_enabled_by_default", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_IsCameraCaptureEnabledByDefault), reinterpret_cast<setter>(AppBroadcastGlobalSettings_put_IsCameraCaptureEnabledByDefault), nullptr, nullptr },
        { "is_audio_capture_enabled", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_IsAudioCaptureEnabled), reinterpret_cast<setter>(AppBroadcastGlobalSettings_put_IsAudioCaptureEnabled), nullptr, nullptr },
        { "camera_overlay_size", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_CameraOverlaySize), reinterpret_cast<setter>(AppBroadcastGlobalSettings_put_CameraOverlaySize), nullptr, nullptr },
        { "camera_overlay_location", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_CameraOverlayLocation), reinterpret_cast<setter>(AppBroadcastGlobalSettings_put_CameraOverlayLocation), nullptr, nullptr },
        { "has_hardware_encoder", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_HasHardwareEncoder), nullptr, nullptr, nullptr },
        { "is_broadcast_enabled", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_IsBroadcastEnabled), nullptr, nullptr, nullptr },
        { "is_disabled_by_policy", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_IsDisabledByPolicy), nullptr, nullptr, nullptr },
        { "is_gpu_constrained", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_IsGpuConstrained), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastGlobalSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastGlobalSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastGlobalSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastGlobalSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastGlobalSettings) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastGlobalSettings =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastGlobalSettings",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastGlobalSettings
    };

    // ----- AppBroadcastHeartbeatRequestedEventArgs class --------------------
    static constexpr const char* const type_name_AppBroadcastHeartbeatRequestedEventArgs = "AppBroadcastHeartbeatRequestedEventArgs";

    static PyObject* _new_AppBroadcastHeartbeatRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastHeartbeatRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_AppBroadcastHeartbeatRequestedEventArgs(py::wrapper::Windows::Media::Capture::AppBroadcastHeartbeatRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastHeartbeatRequestedEventArgs_get_Handled(py::wrapper::Windows::Media::Capture::AppBroadcastHeartbeatRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastHeartbeatRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastHeartbeatRequestedEventArgs_put_Handled(py::wrapper::Windows::Media::Capture::AppBroadcastHeartbeatRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastHeartbeatRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AppBroadcastHeartbeatRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastHeartbeatRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastHeartbeatRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastHeartbeatRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastHeartbeatRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_AppBroadcastHeartbeatRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastHeartbeatRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastHeartbeatRequestedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(AppBroadcastHeartbeatRequestedEventArgs_get_Handled), reinterpret_cast<setter>(AppBroadcastHeartbeatRequestedEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastHeartbeatRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastHeartbeatRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastHeartbeatRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastHeartbeatRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastHeartbeatRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastHeartbeatRequestedEventArgs =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastHeartbeatRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastHeartbeatRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastHeartbeatRequestedEventArgs
    };

    // ----- AppBroadcastManager class --------------------
    static constexpr const char* const type_name_AppBroadcastManager = "AppBroadcastManager";

    static PyObject* _new_AppBroadcastManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastManager);
        return nullptr;
    }

    static PyObject* AppBroadcastManager_ApplyGlobalSettings(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastManager", L"ApplyGlobalSettings", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastGlobalSettings>(args, 0);

                winrt::Windows::Media::Capture::AppBroadcastManager::ApplyGlobalSettings(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastManager_ApplyProviderSettings(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastManager", L"ApplyProviderSettings", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastProviderSettings>(args, 0);

                winrt::Windows::Media::Capture::AppBroadcastManager::ApplyProviderSettings(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastManager_GetGlobalSettings(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastManager", L"GetGlobalSettings", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::Capture::AppBroadcastManager::GetGlobalSettings());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastManager_GetProviderSettings(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastManager", L"GetProviderSettings", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::Capture::AppBroadcastManager::GetProviderSettings());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastManager[] = {
        { "apply_global_settings", reinterpret_cast<PyCFunction>(AppBroadcastManager_ApplyGlobalSettings), METH_VARARGS | METH_STATIC, nullptr },
        { "apply_provider_settings", reinterpret_cast<PyCFunction>(AppBroadcastManager_ApplyProviderSettings), METH_VARARGS | METH_STATIC, nullptr },
        { "get_global_settings", reinterpret_cast<PyCFunction>(AppBroadcastManager_GetGlobalSettings), METH_VARARGS | METH_STATIC, nullptr },
        { "get_provider_settings", reinterpret_cast<PyCFunction>(AppBroadcastManager_GetProviderSettings), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastManager[] = {
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastManager) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastManager =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastManager
    };

    // ----- AppBroadcastMicrophoneCaptureStateChangedEventArgs class --------------------
    static constexpr const char* const type_name_AppBroadcastMicrophoneCaptureStateChangedEventArgs = "AppBroadcastMicrophoneCaptureStateChangedEventArgs";

    static PyObject* _new_AppBroadcastMicrophoneCaptureStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastMicrophoneCaptureStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_AppBroadcastMicrophoneCaptureStateChangedEventArgs(py::wrapper::Windows::Media::Capture::AppBroadcastMicrophoneCaptureStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastMicrophoneCaptureStateChangedEventArgs_get_ErrorCode(py::wrapper::Windows::Media::Capture::AppBroadcastMicrophoneCaptureStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastMicrophoneCaptureStateChangedEventArgs", L"ErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastMicrophoneCaptureStateChangedEventArgs_get_State(py::wrapper::Windows::Media::Capture::AppBroadcastMicrophoneCaptureStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastMicrophoneCaptureStateChangedEventArgs", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastMicrophoneCaptureStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastMicrophoneCaptureStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastMicrophoneCaptureStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastMicrophoneCaptureStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastMicrophoneCaptureStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AppBroadcastMicrophoneCaptureStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastMicrophoneCaptureStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastMicrophoneCaptureStateChangedEventArgs[] = {
        { "error_code", reinterpret_cast<getter>(AppBroadcastMicrophoneCaptureStateChangedEventArgs_get_ErrorCode), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(AppBroadcastMicrophoneCaptureStateChangedEventArgs_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastMicrophoneCaptureStateChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastMicrophoneCaptureStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastMicrophoneCaptureStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastMicrophoneCaptureStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastMicrophoneCaptureStateChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastMicrophoneCaptureStateChangedEventArgs =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastMicrophoneCaptureStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastMicrophoneCaptureStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastMicrophoneCaptureStateChangedEventArgs
    };

    // ----- AppBroadcastPlugIn class --------------------
    static constexpr const char* const type_name_AppBroadcastPlugIn = "AppBroadcastPlugIn";

    static PyObject* _new_AppBroadcastPlugIn(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastPlugIn);
        return nullptr;
    }

    static void _dealloc_AppBroadcastPlugIn(py::wrapper::Windows::Media::Capture::AppBroadcastPlugIn* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastPlugIn_get_AppId(py::wrapper::Windows::Media::Capture::AppBroadcastPlugIn* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPlugIn", L"AppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPlugIn_get_DisplayName(py::wrapper::Windows::Media::Capture::AppBroadcastPlugIn* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPlugIn", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPlugIn_get_Logo(py::wrapper::Windows::Media::Capture::AppBroadcastPlugIn* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPlugIn", L"Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Logo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPlugIn_get_ProviderSettings(py::wrapper::Windows::Media::Capture::AppBroadcastPlugIn* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPlugIn", L"ProviderSettings"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastPlugIn(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastPlugIn>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastPlugIn(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastPlugIn>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastPlugIn[] = {
        { "_assign_array_", _assign_array_AppBroadcastPlugIn, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastPlugIn), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastPlugIn[] = {
        { "app_id", reinterpret_cast<getter>(AppBroadcastPlugIn_get_AppId), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(AppBroadcastPlugIn_get_DisplayName), nullptr, nullptr, nullptr },
        { "logo", reinterpret_cast<getter>(AppBroadcastPlugIn_get_Logo), nullptr, nullptr, nullptr },
        { "provider_settings", reinterpret_cast<getter>(AppBroadcastPlugIn_get_ProviderSettings), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastPlugIn[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastPlugIn) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastPlugIn) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastPlugIn) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastPlugIn) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastPlugIn =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastPlugIn",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastPlugIn),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastPlugIn
    };

    // ----- AppBroadcastPlugInManager class --------------------
    static constexpr const char* const type_name_AppBroadcastPlugInManager = "AppBroadcastPlugInManager";

    static PyObject* _new_AppBroadcastPlugInManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastPlugInManager);
        return nullptr;
    }

    static void _dealloc_AppBroadcastPlugInManager(py::wrapper::Windows::Media::Capture::AppBroadcastPlugInManager* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastPlugInManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastPlugInManager", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::Capture::AppBroadcastPlugInManager::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPlugInManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastPlugInManager", L"GetForUser", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::Media::Capture::AppBroadcastPlugInManager::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPlugInManager_get_DefaultPlugIn(py::wrapper::Windows::Media::Capture::AppBroadcastPlugInManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPlugInManager", L"DefaultPlugIn"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultPlugIn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastPlugInManager_put_DefaultPlugIn(py::wrapper::Windows::Media::Capture::AppBroadcastPlugInManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPlugInManager", L"DefaultPlugIn"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastPlugIn>(arg);

            self->obj.DefaultPlugIn(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastPlugInManager_get_IsBroadcastProviderAvailable(py::wrapper::Windows::Media::Capture::AppBroadcastPlugInManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPlugInManager", L"IsBroadcastProviderAvailable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsBroadcastProviderAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPlugInManager_get_PlugInList(py::wrapper::Windows::Media::Capture::AppBroadcastPlugInManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPlugInManager", L"PlugInList"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlugInList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastPlugInManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastPlugInManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastPlugInManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastPlugInManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastPlugInManager[] = {
        { "get_default", reinterpret_cast<PyCFunction>(AppBroadcastPlugInManager_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(AppBroadcastPlugInManager_GetForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_AppBroadcastPlugInManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastPlugInManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastPlugInManager[] = {
        { "default_plug_in", reinterpret_cast<getter>(AppBroadcastPlugInManager_get_DefaultPlugIn), reinterpret_cast<setter>(AppBroadcastPlugInManager_put_DefaultPlugIn), nullptr, nullptr },
        { "is_broadcast_provider_available", reinterpret_cast<getter>(AppBroadcastPlugInManager_get_IsBroadcastProviderAvailable), nullptr, nullptr, nullptr },
        { "plug_in_list", reinterpret_cast<getter>(AppBroadcastPlugInManager_get_PlugInList), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastPlugInManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastPlugInManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastPlugInManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastPlugInManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastPlugInManager) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastPlugInManager =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastPlugInManager",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastPlugInManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastPlugInManager
    };

    // ----- AppBroadcastPlugInStateChangedEventArgs class --------------------
    static constexpr const char* const type_name_AppBroadcastPlugInStateChangedEventArgs = "AppBroadcastPlugInStateChangedEventArgs";

    static PyObject* _new_AppBroadcastPlugInStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastPlugInStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_AppBroadcastPlugInStateChangedEventArgs(py::wrapper::Windows::Media::Capture::AppBroadcastPlugInStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastPlugInStateChangedEventArgs_get_PlugInState(py::wrapper::Windows::Media::Capture::AppBroadcastPlugInStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPlugInStateChangedEventArgs", L"PlugInState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlugInState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastPlugInStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastPlugInStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastPlugInStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastPlugInStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastPlugInStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AppBroadcastPlugInStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastPlugInStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastPlugInStateChangedEventArgs[] = {
        { "plug_in_state", reinterpret_cast<getter>(AppBroadcastPlugInStateChangedEventArgs_get_PlugInState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastPlugInStateChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastPlugInStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastPlugInStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastPlugInStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastPlugInStateChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastPlugInStateChangedEventArgs =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastPlugInStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastPlugInStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastPlugInStateChangedEventArgs
    };

    // ----- AppBroadcastPreview class --------------------
    static constexpr const char* const type_name_AppBroadcastPreview = "AppBroadcastPreview";

    static PyObject* _new_AppBroadcastPreview(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastPreview);
        return nullptr;
    }

    static void _dealloc_AppBroadcastPreview(py::wrapper::Windows::Media::Capture::AppBroadcastPreview* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastPreview_StopPreview(py::wrapper::Windows::Media::Capture::AppBroadcastPreview* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastPreview", L"StopPreview", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.StopPreview();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreview_get_ErrorCode(py::wrapper::Windows::Media::Capture::AppBroadcastPreview* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreview", L"ErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreview_get_PreviewState(py::wrapper::Windows::Media::Capture::AppBroadcastPreview* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreview", L"PreviewState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviewState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreview_get_PreviewStreamReader(py::wrapper::Windows::Media::Capture::AppBroadcastPreview* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreview", L"PreviewStreamReader"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviewStreamReader());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreview_add_PreviewStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastPreview* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastPreview", L"PreviewStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastPreview, winrt::Windows::Media::Capture::AppBroadcastPreviewStateChangedEventArgs>>(arg);

            return py::convert(self->obj.PreviewStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreview_remove_PreviewStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastPreview* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastPreview", L"PreviewStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PreviewStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastPreview(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastPreview>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastPreview(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastPreview>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastPreview[] = {
        { "stop_preview", reinterpret_cast<PyCFunction>(AppBroadcastPreview_StopPreview), METH_VARARGS, nullptr },
        { "add_preview_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastPreview_add_PreviewStateChanged), METH_O, nullptr },
        { "remove_preview_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastPreview_remove_PreviewStateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppBroadcastPreview, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastPreview), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastPreview[] = {
        { "error_code", reinterpret_cast<getter>(AppBroadcastPreview_get_ErrorCode), nullptr, nullptr, nullptr },
        { "preview_state", reinterpret_cast<getter>(AppBroadcastPreview_get_PreviewState), nullptr, nullptr, nullptr },
        { "preview_stream_reader", reinterpret_cast<getter>(AppBroadcastPreview_get_PreviewStreamReader), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastPreview[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastPreview) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastPreview) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastPreview) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastPreview) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastPreview =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastPreview",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastPreview),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastPreview
    };

    // ----- AppBroadcastPreviewStateChangedEventArgs class --------------------
    static constexpr const char* const type_name_AppBroadcastPreviewStateChangedEventArgs = "AppBroadcastPreviewStateChangedEventArgs";

    static PyObject* _new_AppBroadcastPreviewStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastPreviewStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_AppBroadcastPreviewStateChangedEventArgs(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastPreviewStateChangedEventArgs_get_ErrorCode(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreviewStateChangedEventArgs", L"ErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreviewStateChangedEventArgs_get_PreviewState(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreviewStateChangedEventArgs", L"PreviewState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviewState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastPreviewStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastPreviewStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastPreviewStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastPreviewStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastPreviewStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AppBroadcastPreviewStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastPreviewStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastPreviewStateChangedEventArgs[] = {
        { "error_code", reinterpret_cast<getter>(AppBroadcastPreviewStateChangedEventArgs_get_ErrorCode), nullptr, nullptr, nullptr },
        { "preview_state", reinterpret_cast<getter>(AppBroadcastPreviewStateChangedEventArgs_get_PreviewState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastPreviewStateChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastPreviewStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastPreviewStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastPreviewStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastPreviewStateChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastPreviewStateChangedEventArgs =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastPreviewStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastPreviewStateChangedEventArgs
    };

    // ----- AppBroadcastPreviewStreamReader class --------------------
    static constexpr const char* const type_name_AppBroadcastPreviewStreamReader = "AppBroadcastPreviewStreamReader";

    static PyObject* _new_AppBroadcastPreviewStreamReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastPreviewStreamReader);
        return nullptr;
    }

    static void _dealloc_AppBroadcastPreviewStreamReader(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamReader* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastPreviewStreamReader_TryGetNextVideoFrame(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamReader", L"TryGetNextVideoFrame", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryGetNextVideoFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreviewStreamReader_get_VideoBitmapAlphaMode(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamReader", L"VideoBitmapAlphaMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoBitmapAlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreviewStreamReader_get_VideoBitmapPixelFormat(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamReader", L"VideoBitmapPixelFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoBitmapPixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreviewStreamReader_get_VideoHeight(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamReader", L"VideoHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreviewStreamReader_get_VideoStride(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamReader", L"VideoStride"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoStride());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreviewStreamReader_get_VideoWidth(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamReader", L"VideoWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreviewStreamReader_add_VideoFrameArrived(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamReader", L"VideoFrameArrived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastPreviewStreamReader, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VideoFrameArrived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreviewStreamReader_remove_VideoFrameArrived(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamReader", L"VideoFrameArrived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VideoFrameArrived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastPreviewStreamReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastPreviewStreamReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastPreviewStreamReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastPreviewStreamReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastPreviewStreamReader[] = {
        { "try_get_next_video_frame", reinterpret_cast<PyCFunction>(AppBroadcastPreviewStreamReader_TryGetNextVideoFrame), METH_VARARGS, nullptr },
        { "add_video_frame_arrived", reinterpret_cast<PyCFunction>(AppBroadcastPreviewStreamReader_add_VideoFrameArrived), METH_O, nullptr },
        { "remove_video_frame_arrived", reinterpret_cast<PyCFunction>(AppBroadcastPreviewStreamReader_remove_VideoFrameArrived), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppBroadcastPreviewStreamReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastPreviewStreamReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastPreviewStreamReader[] = {
        { "video_bitmap_alpha_mode", reinterpret_cast<getter>(AppBroadcastPreviewStreamReader_get_VideoBitmapAlphaMode), nullptr, nullptr, nullptr },
        { "video_bitmap_pixel_format", reinterpret_cast<getter>(AppBroadcastPreviewStreamReader_get_VideoBitmapPixelFormat), nullptr, nullptr, nullptr },
        { "video_height", reinterpret_cast<getter>(AppBroadcastPreviewStreamReader_get_VideoHeight), nullptr, nullptr, nullptr },
        { "video_stride", reinterpret_cast<getter>(AppBroadcastPreviewStreamReader_get_VideoStride), nullptr, nullptr, nullptr },
        { "video_width", reinterpret_cast<getter>(AppBroadcastPreviewStreamReader_get_VideoWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastPreviewStreamReader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastPreviewStreamReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastPreviewStreamReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastPreviewStreamReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastPreviewStreamReader) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastPreviewStreamReader =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastPreviewStreamReader",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastPreviewStreamReader
    };

    // ----- AppBroadcastPreviewStreamVideoFrame class --------------------
    static constexpr const char* const type_name_AppBroadcastPreviewStreamVideoFrame = "AppBroadcastPreviewStreamVideoFrame";

    static PyObject* _new_AppBroadcastPreviewStreamVideoFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastPreviewStreamVideoFrame);
        return nullptr;
    }

    static void _dealloc_AppBroadcastPreviewStreamVideoFrame(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamVideoFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastPreviewStreamVideoFrame_get_VideoBuffer(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamVideoFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamVideoFrame", L"VideoBuffer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoBuffer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreviewStreamVideoFrame_get_VideoHeader(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamVideoFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamVideoFrame", L"VideoHeader"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoHeader());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastPreviewStreamVideoFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastPreviewStreamVideoFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastPreviewStreamVideoFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastPreviewStreamVideoFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastPreviewStreamVideoFrame[] = {
        { "_assign_array_", _assign_array_AppBroadcastPreviewStreamVideoFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastPreviewStreamVideoFrame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastPreviewStreamVideoFrame[] = {
        { "video_buffer", reinterpret_cast<getter>(AppBroadcastPreviewStreamVideoFrame_get_VideoBuffer), nullptr, nullptr, nullptr },
        { "video_header", reinterpret_cast<getter>(AppBroadcastPreviewStreamVideoFrame_get_VideoHeader), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastPreviewStreamVideoFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastPreviewStreamVideoFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastPreviewStreamVideoFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastPreviewStreamVideoFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastPreviewStreamVideoFrame) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastPreviewStreamVideoFrame =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastPreviewStreamVideoFrame",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamVideoFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastPreviewStreamVideoFrame
    };

    // ----- AppBroadcastPreviewStreamVideoHeader class --------------------
    static constexpr const char* const type_name_AppBroadcastPreviewStreamVideoHeader = "AppBroadcastPreviewStreamVideoHeader";

    static PyObject* _new_AppBroadcastPreviewStreamVideoHeader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastPreviewStreamVideoHeader);
        return nullptr;
    }

    static void _dealloc_AppBroadcastPreviewStreamVideoHeader(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamVideoHeader* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastPreviewStreamVideoHeader_get_AbsoluteTimestamp(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamVideoHeader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamVideoHeader", L"AbsoluteTimestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AbsoluteTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreviewStreamVideoHeader_get_Duration(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamVideoHeader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamVideoHeader", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreviewStreamVideoHeader_get_FrameId(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamVideoHeader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamVideoHeader", L"FrameId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreviewStreamVideoHeader_get_RelativeTimestamp(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamVideoHeader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamVideoHeader", L"RelativeTimestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RelativeTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastPreviewStreamVideoHeader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastPreviewStreamVideoHeader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastPreviewStreamVideoHeader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastPreviewStreamVideoHeader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastPreviewStreamVideoHeader[] = {
        { "_assign_array_", _assign_array_AppBroadcastPreviewStreamVideoHeader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastPreviewStreamVideoHeader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastPreviewStreamVideoHeader[] = {
        { "absolute_timestamp", reinterpret_cast<getter>(AppBroadcastPreviewStreamVideoHeader_get_AbsoluteTimestamp), nullptr, nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(AppBroadcastPreviewStreamVideoHeader_get_Duration), nullptr, nullptr, nullptr },
        { "frame_id", reinterpret_cast<getter>(AppBroadcastPreviewStreamVideoHeader_get_FrameId), nullptr, nullptr, nullptr },
        { "relative_timestamp", reinterpret_cast<getter>(AppBroadcastPreviewStreamVideoHeader_get_RelativeTimestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastPreviewStreamVideoHeader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastPreviewStreamVideoHeader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastPreviewStreamVideoHeader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastPreviewStreamVideoHeader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastPreviewStreamVideoHeader) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastPreviewStreamVideoHeader =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastPreviewStreamVideoHeader",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamVideoHeader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastPreviewStreamVideoHeader
    };

    // ----- AppBroadcastProviderSettings class --------------------
    static constexpr const char* const type_name_AppBroadcastProviderSettings = "AppBroadcastProviderSettings";

    static PyObject* _new_AppBroadcastProviderSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastProviderSettings);
        return nullptr;
    }

    static void _dealloc_AppBroadcastProviderSettings(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastProviderSettings_get_VideoEncodingResolutionMode(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"VideoEncodingResolutionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoEncodingResolutionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastProviderSettings_put_VideoEncodingResolutionMode(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"VideoEncodingResolutionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastVideoEncodingResolutionMode>(arg);

            self->obj.VideoEncodingResolutionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastProviderSettings_get_VideoEncodingBitrateMode(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"VideoEncodingBitrateMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoEncodingBitrateMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastProviderSettings_put_VideoEncodingBitrateMode(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"VideoEncodingBitrateMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastVideoEncodingBitrateMode>(arg);

            self->obj.VideoEncodingBitrateMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastProviderSettings_get_DefaultBroadcastTitle(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"DefaultBroadcastTitle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultBroadcastTitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastProviderSettings_put_DefaultBroadcastTitle(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"DefaultBroadcastTitle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DefaultBroadcastTitle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastProviderSettings_get_CustomVideoEncodingWidth(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"CustomVideoEncodingWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CustomVideoEncodingWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastProviderSettings_put_CustomVideoEncodingWidth(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"CustomVideoEncodingWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CustomVideoEncodingWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastProviderSettings_get_CustomVideoEncodingHeight(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"CustomVideoEncodingHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CustomVideoEncodingHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastProviderSettings_put_CustomVideoEncodingHeight(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"CustomVideoEncodingHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CustomVideoEncodingHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastProviderSettings_get_CustomVideoEncodingBitrate(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"CustomVideoEncodingBitrate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CustomVideoEncodingBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastProviderSettings_put_CustomVideoEncodingBitrate(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"CustomVideoEncodingBitrate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CustomVideoEncodingBitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastProviderSettings_get_AudioEncodingBitrate(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"AudioEncodingBitrate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioEncodingBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastProviderSettings_put_AudioEncodingBitrate(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"AudioEncodingBitrate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.AudioEncodingBitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AppBroadcastProviderSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastProviderSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastProviderSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastProviderSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastProviderSettings[] = {
        { "_assign_array_", _assign_array_AppBroadcastProviderSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastProviderSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastProviderSettings[] = {
        { "video_encoding_resolution_mode", reinterpret_cast<getter>(AppBroadcastProviderSettings_get_VideoEncodingResolutionMode), reinterpret_cast<setter>(AppBroadcastProviderSettings_put_VideoEncodingResolutionMode), nullptr, nullptr },
        { "video_encoding_bitrate_mode", reinterpret_cast<getter>(AppBroadcastProviderSettings_get_VideoEncodingBitrateMode), reinterpret_cast<setter>(AppBroadcastProviderSettings_put_VideoEncodingBitrateMode), nullptr, nullptr },
        { "default_broadcast_title", reinterpret_cast<getter>(AppBroadcastProviderSettings_get_DefaultBroadcastTitle), reinterpret_cast<setter>(AppBroadcastProviderSettings_put_DefaultBroadcastTitle), nullptr, nullptr },
        { "custom_video_encoding_width", reinterpret_cast<getter>(AppBroadcastProviderSettings_get_CustomVideoEncodingWidth), reinterpret_cast<setter>(AppBroadcastProviderSettings_put_CustomVideoEncodingWidth), nullptr, nullptr },
        { "custom_video_encoding_height", reinterpret_cast<getter>(AppBroadcastProviderSettings_get_CustomVideoEncodingHeight), reinterpret_cast<setter>(AppBroadcastProviderSettings_put_CustomVideoEncodingHeight), nullptr, nullptr },
        { "custom_video_encoding_bitrate", reinterpret_cast<getter>(AppBroadcastProviderSettings_get_CustomVideoEncodingBitrate), reinterpret_cast<setter>(AppBroadcastProviderSettings_put_CustomVideoEncodingBitrate), nullptr, nullptr },
        { "audio_encoding_bitrate", reinterpret_cast<getter>(AppBroadcastProviderSettings_get_AudioEncodingBitrate), reinterpret_cast<setter>(AppBroadcastProviderSettings_put_AudioEncodingBitrate), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastProviderSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastProviderSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastProviderSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastProviderSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastProviderSettings) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastProviderSettings =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastProviderSettings",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastProviderSettings
    };

    // ----- AppBroadcastServices class --------------------
    static constexpr const char* const type_name_AppBroadcastServices = "AppBroadcastServices";

    static PyObject* _new_AppBroadcastServices(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastServices);
        return nullptr;
    }

    static void _dealloc_AppBroadcastServices(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastServices_EnterBroadcastModeAsync(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastServices", L"EnterBroadcastModeAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastPlugIn>(args, 0);

                return py::convert(self->obj.EnterBroadcastModeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastServices_ExitBroadcastMode(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastServices", L"ExitBroadcastMode", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastExitBroadcastModeReason>(args, 0);

                self->obj.ExitBroadcastMode(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastServices_PauseBroadcast(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastServices", L"PauseBroadcast", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.PauseBroadcast();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastServices_ResumeBroadcast(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastServices", L"ResumeBroadcast", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ResumeBroadcast();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastServices_StartBroadcast(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastServices", L"StartBroadcast", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.StartBroadcast();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastServices_StartPreview(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastServices", L"StartPreview", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

                return py::convert(self->obj.StartPreview(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastServices_get_CaptureTargetType(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastServices", L"CaptureTargetType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CaptureTargetType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastServices_put_CaptureTargetType(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastServices", L"CaptureTargetType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastCaptureTargetType>(arg);

            self->obj.CaptureTargetType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastServices_get_BroadcastTitle(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastServices", L"BroadcastTitle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BroadcastTitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastServices_put_BroadcastTitle(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastServices", L"BroadcastTitle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.BroadcastTitle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastServices_get_BroadcastLanguage(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastServices", L"BroadcastLanguage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BroadcastLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastServices_put_BroadcastLanguage(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastServices", L"BroadcastLanguage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.BroadcastLanguage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastServices_get_CanCapture(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastServices", L"CanCapture"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanCapture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastServices_get_State(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastServices", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastServices_get_UserName(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastServices", L"UserName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UserName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastServices(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastServices>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastServices(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastServices>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastServices[] = {
        { "enter_broadcast_mode_async", reinterpret_cast<PyCFunction>(AppBroadcastServices_EnterBroadcastModeAsync), METH_VARARGS, nullptr },
        { "exit_broadcast_mode", reinterpret_cast<PyCFunction>(AppBroadcastServices_ExitBroadcastMode), METH_VARARGS, nullptr },
        { "pause_broadcast", reinterpret_cast<PyCFunction>(AppBroadcastServices_PauseBroadcast), METH_VARARGS, nullptr },
        { "resume_broadcast", reinterpret_cast<PyCFunction>(AppBroadcastServices_ResumeBroadcast), METH_VARARGS, nullptr },
        { "start_broadcast", reinterpret_cast<PyCFunction>(AppBroadcastServices_StartBroadcast), METH_VARARGS, nullptr },
        { "start_preview", reinterpret_cast<PyCFunction>(AppBroadcastServices_StartPreview), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppBroadcastServices, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastServices), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastServices[] = {
        { "capture_target_type", reinterpret_cast<getter>(AppBroadcastServices_get_CaptureTargetType), reinterpret_cast<setter>(AppBroadcastServices_put_CaptureTargetType), nullptr, nullptr },
        { "broadcast_title", reinterpret_cast<getter>(AppBroadcastServices_get_BroadcastTitle), reinterpret_cast<setter>(AppBroadcastServices_put_BroadcastTitle), nullptr, nullptr },
        { "broadcast_language", reinterpret_cast<getter>(AppBroadcastServices_get_BroadcastLanguage), reinterpret_cast<setter>(AppBroadcastServices_put_BroadcastLanguage), nullptr, nullptr },
        { "can_capture", reinterpret_cast<getter>(AppBroadcastServices_get_CanCapture), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(AppBroadcastServices_get_State), nullptr, nullptr, nullptr },
        { "user_name", reinterpret_cast<getter>(AppBroadcastServices_get_UserName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastServices[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastServices) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastServices) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastServices) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastServices) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastServices =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastServices",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastServices),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastServices
    };

    // ----- AppBroadcastSignInStateChangedEventArgs class --------------------
    static constexpr const char* const type_name_AppBroadcastSignInStateChangedEventArgs = "AppBroadcastSignInStateChangedEventArgs";

    static PyObject* _new_AppBroadcastSignInStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastSignInStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_AppBroadcastSignInStateChangedEventArgs(py::wrapper::Windows::Media::Capture::AppBroadcastSignInStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastSignInStateChangedEventArgs_get_Result(py::wrapper::Windows::Media::Capture::AppBroadcastSignInStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastSignInStateChangedEventArgs", L"Result"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastSignInStateChangedEventArgs_get_SignInState(py::wrapper::Windows::Media::Capture::AppBroadcastSignInStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastSignInStateChangedEventArgs", L"SignInState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SignInState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastSignInStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastSignInStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastSignInStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastSignInStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastSignInStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AppBroadcastSignInStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastSignInStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastSignInStateChangedEventArgs[] = {
        { "result", reinterpret_cast<getter>(AppBroadcastSignInStateChangedEventArgs_get_Result), nullptr, nullptr, nullptr },
        { "sign_in_state", reinterpret_cast<getter>(AppBroadcastSignInStateChangedEventArgs_get_SignInState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastSignInStateChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastSignInStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastSignInStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastSignInStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastSignInStateChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastSignInStateChangedEventArgs =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastSignInStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastSignInStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastSignInStateChangedEventArgs
    };

    // ----- AppBroadcastState class --------------------
    static constexpr const char* const type_name_AppBroadcastState = "AppBroadcastState";

    static PyObject* _new_AppBroadcastState(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastState);
        return nullptr;
    }

    static void _dealloc_AppBroadcastState(py::wrapper::Windows::Media::Capture::AppBroadcastState* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastState_RestartCameraCapture(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastState", L"RestartCameraCapture", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RestartCameraCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_RestartMicrophoneCapture(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastState", L"RestartMicrophoneCapture", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RestartMicrophoneCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_get_SignInState(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"SignInState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SignInState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastState_put_SignInState(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"SignInState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastSignInState>(arg);

            self->obj.SignInState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastState_get_ShouldCaptureMicrophone(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"ShouldCaptureMicrophone"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShouldCaptureMicrophone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastState_put_ShouldCaptureMicrophone(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"ShouldCaptureMicrophone"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShouldCaptureMicrophone(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastState_get_ShouldCaptureCamera(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"ShouldCaptureCamera"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShouldCaptureCamera());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastState_put_ShouldCaptureCamera(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"ShouldCaptureCamera"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShouldCaptureCamera(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastState_get_AuthenticationResult(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"AuthenticationResult"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AuthenticationResult());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastState_put_AuthenticationResult(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"AuthenticationResult"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Authentication::Web::WebAuthenticationResult>(arg);

            self->obj.AuthenticationResult(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastState_get_IsCaptureTargetRunning(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"IsCaptureTargetRunning"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCaptureTargetRunning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_get_MicrophoneCaptureError(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"MicrophoneCaptureError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MicrophoneCaptureError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_get_MicrophoneCaptureState(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"MicrophoneCaptureState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MicrophoneCaptureState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_get_OAuthCallbackUri(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"OAuthCallbackUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OAuthCallbackUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_get_OAuthRequestUri(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"OAuthRequestUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OAuthRequestUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_get_PlugInState(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"PlugInState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlugInState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_get_CameraCaptureError(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"CameraCaptureError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CameraCaptureError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_get_CameraCaptureState(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"CameraCaptureState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CameraCaptureState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_get_EncodedVideoSize(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"EncodedVideoSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodedVideoSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_get_StreamState(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"StreamState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StreamState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_get_TerminationReason(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"TerminationReason"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TerminationReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_get_TerminationReasonPlugInSpecific(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"TerminationReasonPlugInSpecific"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TerminationReasonPlugInSpecific());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_get_ViewerCount(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"ViewerCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ViewerCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_add_CameraCaptureStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastState", L"CameraCaptureStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastState, winrt::Windows::Media::Capture::AppBroadcastCameraCaptureStateChangedEventArgs>>(arg);

            return py::convert(self->obj.CameraCaptureStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_remove_CameraCaptureStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastState", L"CameraCaptureStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CameraCaptureStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_add_CaptureTargetClosed(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastState", L"CaptureTargetClosed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastState, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CaptureTargetClosed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_remove_CaptureTargetClosed(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastState", L"CaptureTargetClosed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CaptureTargetClosed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_add_MicrophoneCaptureStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastState", L"MicrophoneCaptureStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastState, winrt::Windows::Media::Capture::AppBroadcastMicrophoneCaptureStateChangedEventArgs>>(arg);

            return py::convert(self->obj.MicrophoneCaptureStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_remove_MicrophoneCaptureStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastState", L"MicrophoneCaptureStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MicrophoneCaptureStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_add_PlugInStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastState", L"PlugInStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastState, winrt::Windows::Media::Capture::AppBroadcastPlugInStateChangedEventArgs>>(arg);

            return py::convert(self->obj.PlugInStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_remove_PlugInStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastState", L"PlugInStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PlugInStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_add_StreamStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastState", L"StreamStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastState, winrt::Windows::Media::Capture::AppBroadcastStreamStateChangedEventArgs>>(arg);

            return py::convert(self->obj.StreamStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_remove_StreamStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastState", L"StreamStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StreamStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_add_ViewerCountChanged(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastState", L"ViewerCountChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastState, winrt::Windows::Media::Capture::AppBroadcastViewerCountChangedEventArgs>>(arg);

            return py::convert(self->obj.ViewerCountChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_remove_ViewerCountChanged(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastState", L"ViewerCountChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ViewerCountChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastState>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastState>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastState[] = {
        { "restart_camera_capture", reinterpret_cast<PyCFunction>(AppBroadcastState_RestartCameraCapture), METH_VARARGS, nullptr },
        { "restart_microphone_capture", reinterpret_cast<PyCFunction>(AppBroadcastState_RestartMicrophoneCapture), METH_VARARGS, nullptr },
        { "add_camera_capture_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastState_add_CameraCaptureStateChanged), METH_O, nullptr },
        { "remove_camera_capture_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastState_remove_CameraCaptureStateChanged), METH_O, nullptr },
        { "add_capture_target_closed", reinterpret_cast<PyCFunction>(AppBroadcastState_add_CaptureTargetClosed), METH_O, nullptr },
        { "remove_capture_target_closed", reinterpret_cast<PyCFunction>(AppBroadcastState_remove_CaptureTargetClosed), METH_O, nullptr },
        { "add_microphone_capture_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastState_add_MicrophoneCaptureStateChanged), METH_O, nullptr },
        { "remove_microphone_capture_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastState_remove_MicrophoneCaptureStateChanged), METH_O, nullptr },
        { "add_plug_in_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastState_add_PlugInStateChanged), METH_O, nullptr },
        { "remove_plug_in_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastState_remove_PlugInStateChanged), METH_O, nullptr },
        { "add_stream_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastState_add_StreamStateChanged), METH_O, nullptr },
        { "remove_stream_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastState_remove_StreamStateChanged), METH_O, nullptr },
        { "add_viewer_count_changed", reinterpret_cast<PyCFunction>(AppBroadcastState_add_ViewerCountChanged), METH_O, nullptr },
        { "remove_viewer_count_changed", reinterpret_cast<PyCFunction>(AppBroadcastState_remove_ViewerCountChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppBroadcastState, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastState), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastState[] = {
        { "sign_in_state", reinterpret_cast<getter>(AppBroadcastState_get_SignInState), reinterpret_cast<setter>(AppBroadcastState_put_SignInState), nullptr, nullptr },
        { "should_capture_microphone", reinterpret_cast<getter>(AppBroadcastState_get_ShouldCaptureMicrophone), reinterpret_cast<setter>(AppBroadcastState_put_ShouldCaptureMicrophone), nullptr, nullptr },
        { "should_capture_camera", reinterpret_cast<getter>(AppBroadcastState_get_ShouldCaptureCamera), reinterpret_cast<setter>(AppBroadcastState_put_ShouldCaptureCamera), nullptr, nullptr },
        { "authentication_result", reinterpret_cast<getter>(AppBroadcastState_get_AuthenticationResult), reinterpret_cast<setter>(AppBroadcastState_put_AuthenticationResult), nullptr, nullptr },
        { "is_capture_target_running", reinterpret_cast<getter>(AppBroadcastState_get_IsCaptureTargetRunning), nullptr, nullptr, nullptr },
        { "microphone_capture_error", reinterpret_cast<getter>(AppBroadcastState_get_MicrophoneCaptureError), nullptr, nullptr, nullptr },
        { "microphone_capture_state", reinterpret_cast<getter>(AppBroadcastState_get_MicrophoneCaptureState), nullptr, nullptr, nullptr },
        { "o_auth_callback_uri", reinterpret_cast<getter>(AppBroadcastState_get_OAuthCallbackUri), nullptr, nullptr, nullptr },
        { "o_auth_request_uri", reinterpret_cast<getter>(AppBroadcastState_get_OAuthRequestUri), nullptr, nullptr, nullptr },
        { "plug_in_state", reinterpret_cast<getter>(AppBroadcastState_get_PlugInState), nullptr, nullptr, nullptr },
        { "camera_capture_error", reinterpret_cast<getter>(AppBroadcastState_get_CameraCaptureError), nullptr, nullptr, nullptr },
        { "camera_capture_state", reinterpret_cast<getter>(AppBroadcastState_get_CameraCaptureState), nullptr, nullptr, nullptr },
        { "encoded_video_size", reinterpret_cast<getter>(AppBroadcastState_get_EncodedVideoSize), nullptr, nullptr, nullptr },
        { "stream_state", reinterpret_cast<getter>(AppBroadcastState_get_StreamState), nullptr, nullptr, nullptr },
        { "termination_reason", reinterpret_cast<getter>(AppBroadcastState_get_TerminationReason), nullptr, nullptr, nullptr },
        { "termination_reason_plug_in_specific", reinterpret_cast<getter>(AppBroadcastState_get_TerminationReasonPlugInSpecific), nullptr, nullptr, nullptr },
        { "viewer_count", reinterpret_cast<getter>(AppBroadcastState_get_ViewerCount), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastState[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastState) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastState) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastState) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastState) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastState =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastState",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastState),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastState
    };

    // ----- AppBroadcastStreamAudioFrame class --------------------
    static constexpr const char* const type_name_AppBroadcastStreamAudioFrame = "AppBroadcastStreamAudioFrame";

    static PyObject* _new_AppBroadcastStreamAudioFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastStreamAudioFrame);
        return nullptr;
    }

    static void _dealloc_AppBroadcastStreamAudioFrame(py::wrapper::Windows::Media::Capture::AppBroadcastStreamAudioFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastStreamAudioFrame_get_AudioBuffer(py::wrapper::Windows::Media::Capture::AppBroadcastStreamAudioFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamAudioFrame", L"AudioBuffer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioBuffer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamAudioFrame_get_AudioHeader(py::wrapper::Windows::Media::Capture::AppBroadcastStreamAudioFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamAudioFrame", L"AudioHeader"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioHeader());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastStreamAudioFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastStreamAudioFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastStreamAudioFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastStreamAudioFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastStreamAudioFrame[] = {
        { "_assign_array_", _assign_array_AppBroadcastStreamAudioFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastStreamAudioFrame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastStreamAudioFrame[] = {
        { "audio_buffer", reinterpret_cast<getter>(AppBroadcastStreamAudioFrame_get_AudioBuffer), nullptr, nullptr, nullptr },
        { "audio_header", reinterpret_cast<getter>(AppBroadcastStreamAudioFrame_get_AudioHeader), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastStreamAudioFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastStreamAudioFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastStreamAudioFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastStreamAudioFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastStreamAudioFrame) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastStreamAudioFrame =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastStreamAudioFrame",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastStreamAudioFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastStreamAudioFrame
    };

    // ----- AppBroadcastStreamAudioHeader class --------------------
    static constexpr const char* const type_name_AppBroadcastStreamAudioHeader = "AppBroadcastStreamAudioHeader";

    static PyObject* _new_AppBroadcastStreamAudioHeader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastStreamAudioHeader);
        return nullptr;
    }

    static void _dealloc_AppBroadcastStreamAudioHeader(py::wrapper::Windows::Media::Capture::AppBroadcastStreamAudioHeader* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastStreamAudioHeader_get_AbsoluteTimestamp(py::wrapper::Windows::Media::Capture::AppBroadcastStreamAudioHeader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamAudioHeader", L"AbsoluteTimestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AbsoluteTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamAudioHeader_get_Duration(py::wrapper::Windows::Media::Capture::AppBroadcastStreamAudioHeader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamAudioHeader", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamAudioHeader_get_FrameId(py::wrapper::Windows::Media::Capture::AppBroadcastStreamAudioHeader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamAudioHeader", L"FrameId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamAudioHeader_get_HasDiscontinuity(py::wrapper::Windows::Media::Capture::AppBroadcastStreamAudioHeader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamAudioHeader", L"HasDiscontinuity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasDiscontinuity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamAudioHeader_get_RelativeTimestamp(py::wrapper::Windows::Media::Capture::AppBroadcastStreamAudioHeader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamAudioHeader", L"RelativeTimestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RelativeTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastStreamAudioHeader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastStreamAudioHeader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastStreamAudioHeader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastStreamAudioHeader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastStreamAudioHeader[] = {
        { "_assign_array_", _assign_array_AppBroadcastStreamAudioHeader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastStreamAudioHeader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastStreamAudioHeader[] = {
        { "absolute_timestamp", reinterpret_cast<getter>(AppBroadcastStreamAudioHeader_get_AbsoluteTimestamp), nullptr, nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(AppBroadcastStreamAudioHeader_get_Duration), nullptr, nullptr, nullptr },
        { "frame_id", reinterpret_cast<getter>(AppBroadcastStreamAudioHeader_get_FrameId), nullptr, nullptr, nullptr },
        { "has_discontinuity", reinterpret_cast<getter>(AppBroadcastStreamAudioHeader_get_HasDiscontinuity), nullptr, nullptr, nullptr },
        { "relative_timestamp", reinterpret_cast<getter>(AppBroadcastStreamAudioHeader_get_RelativeTimestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastStreamAudioHeader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastStreamAudioHeader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastStreamAudioHeader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastStreamAudioHeader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastStreamAudioHeader) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastStreamAudioHeader =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastStreamAudioHeader",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastStreamAudioHeader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastStreamAudioHeader
    };

    // ----- AppBroadcastStreamReader class --------------------
    static constexpr const char* const type_name_AppBroadcastStreamReader = "AppBroadcastStreamReader";

    static PyObject* _new_AppBroadcastStreamReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastStreamReader);
        return nullptr;
    }

    static void _dealloc_AppBroadcastStreamReader(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastStreamReader_TryGetNextAudioFrame(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastStreamReader", L"TryGetNextAudioFrame", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryGetNextAudioFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamReader_TryGetNextVideoFrame(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastStreamReader", L"TryGetNextVideoFrame", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryGetNextVideoFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamReader_get_AudioAacSequence(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamReader", L"AudioAacSequence"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioAacSequence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamReader_get_AudioBitrate(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamReader", L"AudioBitrate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamReader_get_AudioChannels(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamReader", L"AudioChannels"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioChannels());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamReader_get_AudioSampleRate(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamReader", L"AudioSampleRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioSampleRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamReader_get_VideoBitrate(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamReader", L"VideoBitrate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamReader_get_VideoHeight(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamReader", L"VideoHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamReader_get_VideoWidth(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamReader", L"VideoWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamReader_add_AudioFrameArrived(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastStreamReader", L"AudioFrameArrived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastStreamReader, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AudioFrameArrived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamReader_remove_AudioFrameArrived(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastStreamReader", L"AudioFrameArrived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AudioFrameArrived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamReader_add_VideoFrameArrived(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastStreamReader", L"VideoFrameArrived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastStreamReader, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VideoFrameArrived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamReader_remove_VideoFrameArrived(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastStreamReader", L"VideoFrameArrived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VideoFrameArrived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastStreamReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastStreamReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastStreamReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastStreamReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastStreamReader[] = {
        { "try_get_next_audio_frame", reinterpret_cast<PyCFunction>(AppBroadcastStreamReader_TryGetNextAudioFrame), METH_VARARGS, nullptr },
        { "try_get_next_video_frame", reinterpret_cast<PyCFunction>(AppBroadcastStreamReader_TryGetNextVideoFrame), METH_VARARGS, nullptr },
        { "add_audio_frame_arrived", reinterpret_cast<PyCFunction>(AppBroadcastStreamReader_add_AudioFrameArrived), METH_O, nullptr },
        { "remove_audio_frame_arrived", reinterpret_cast<PyCFunction>(AppBroadcastStreamReader_remove_AudioFrameArrived), METH_O, nullptr },
        { "add_video_frame_arrived", reinterpret_cast<PyCFunction>(AppBroadcastStreamReader_add_VideoFrameArrived), METH_O, nullptr },
        { "remove_video_frame_arrived", reinterpret_cast<PyCFunction>(AppBroadcastStreamReader_remove_VideoFrameArrived), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppBroadcastStreamReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastStreamReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastStreamReader[] = {
        { "audio_aac_sequence", reinterpret_cast<getter>(AppBroadcastStreamReader_get_AudioAacSequence), nullptr, nullptr, nullptr },
        { "audio_bitrate", reinterpret_cast<getter>(AppBroadcastStreamReader_get_AudioBitrate), nullptr, nullptr, nullptr },
        { "audio_channels", reinterpret_cast<getter>(AppBroadcastStreamReader_get_AudioChannels), nullptr, nullptr, nullptr },
        { "audio_sample_rate", reinterpret_cast<getter>(AppBroadcastStreamReader_get_AudioSampleRate), nullptr, nullptr, nullptr },
        { "video_bitrate", reinterpret_cast<getter>(AppBroadcastStreamReader_get_VideoBitrate), nullptr, nullptr, nullptr },
        { "video_height", reinterpret_cast<getter>(AppBroadcastStreamReader_get_VideoHeight), nullptr, nullptr, nullptr },
        { "video_width", reinterpret_cast<getter>(AppBroadcastStreamReader_get_VideoWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastStreamReader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastStreamReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastStreamReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastStreamReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastStreamReader) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastStreamReader =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastStreamReader",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastStreamReader
    };

    // ----- AppBroadcastStreamStateChangedEventArgs class --------------------
    static constexpr const char* const type_name_AppBroadcastStreamStateChangedEventArgs = "AppBroadcastStreamStateChangedEventArgs";

    static PyObject* _new_AppBroadcastStreamStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastStreamStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_AppBroadcastStreamStateChangedEventArgs(py::wrapper::Windows::Media::Capture::AppBroadcastStreamStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastStreamStateChangedEventArgs_get_StreamState(py::wrapper::Windows::Media::Capture::AppBroadcastStreamStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamStateChangedEventArgs", L"StreamState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StreamState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastStreamStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastStreamStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastStreamStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastStreamStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastStreamStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AppBroadcastStreamStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastStreamStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastStreamStateChangedEventArgs[] = {
        { "stream_state", reinterpret_cast<getter>(AppBroadcastStreamStateChangedEventArgs_get_StreamState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastStreamStateChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastStreamStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastStreamStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastStreamStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastStreamStateChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastStreamStateChangedEventArgs =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastStreamStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastStreamStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastStreamStateChangedEventArgs
    };

    // ----- AppBroadcastStreamVideoFrame class --------------------
    static constexpr const char* const type_name_AppBroadcastStreamVideoFrame = "AppBroadcastStreamVideoFrame";

    static PyObject* _new_AppBroadcastStreamVideoFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastStreamVideoFrame);
        return nullptr;
    }

    static void _dealloc_AppBroadcastStreamVideoFrame(py::wrapper::Windows::Media::Capture::AppBroadcastStreamVideoFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastStreamVideoFrame_get_VideoBuffer(py::wrapper::Windows::Media::Capture::AppBroadcastStreamVideoFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamVideoFrame", L"VideoBuffer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoBuffer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamVideoFrame_get_VideoHeader(py::wrapper::Windows::Media::Capture::AppBroadcastStreamVideoFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamVideoFrame", L"VideoHeader"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoHeader());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastStreamVideoFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastStreamVideoFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastStreamVideoFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastStreamVideoFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastStreamVideoFrame[] = {
        { "_assign_array_", _assign_array_AppBroadcastStreamVideoFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastStreamVideoFrame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastStreamVideoFrame[] = {
        { "video_buffer", reinterpret_cast<getter>(AppBroadcastStreamVideoFrame_get_VideoBuffer), nullptr, nullptr, nullptr },
        { "video_header", reinterpret_cast<getter>(AppBroadcastStreamVideoFrame_get_VideoHeader), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastStreamVideoFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastStreamVideoFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastStreamVideoFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastStreamVideoFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastStreamVideoFrame) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastStreamVideoFrame =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastStreamVideoFrame",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastStreamVideoFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastStreamVideoFrame
    };

    // ----- AppBroadcastStreamVideoHeader class --------------------
    static constexpr const char* const type_name_AppBroadcastStreamVideoHeader = "AppBroadcastStreamVideoHeader";

    static PyObject* _new_AppBroadcastStreamVideoHeader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastStreamVideoHeader);
        return nullptr;
    }

    static void _dealloc_AppBroadcastStreamVideoHeader(py::wrapper::Windows::Media::Capture::AppBroadcastStreamVideoHeader* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastStreamVideoHeader_get_AbsoluteTimestamp(py::wrapper::Windows::Media::Capture::AppBroadcastStreamVideoHeader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamVideoHeader", L"AbsoluteTimestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AbsoluteTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamVideoHeader_get_Duration(py::wrapper::Windows::Media::Capture::AppBroadcastStreamVideoHeader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamVideoHeader", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamVideoHeader_get_FrameId(py::wrapper::Windows::Media::Capture::AppBroadcastStreamVideoHeader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamVideoHeader", L"FrameId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamVideoHeader_get_HasDiscontinuity(py::wrapper::Windows::Media::Capture::AppBroadcastStreamVideoHeader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamVideoHeader", L"HasDiscontinuity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasDiscontinuity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamVideoHeader_get_IsKeyFrame(py::wrapper::Windows::Media::Capture::AppBroadcastStreamVideoHeader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamVideoHeader", L"IsKeyFrame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsKeyFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamVideoHeader_get_RelativeTimestamp(py::wrapper::Windows::Media::Capture::AppBroadcastStreamVideoHeader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamVideoHeader", L"RelativeTimestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RelativeTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastStreamVideoHeader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastStreamVideoHeader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastStreamVideoHeader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastStreamVideoHeader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastStreamVideoHeader[] = {
        { "_assign_array_", _assign_array_AppBroadcastStreamVideoHeader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastStreamVideoHeader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastStreamVideoHeader[] = {
        { "absolute_timestamp", reinterpret_cast<getter>(AppBroadcastStreamVideoHeader_get_AbsoluteTimestamp), nullptr, nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(AppBroadcastStreamVideoHeader_get_Duration), nullptr, nullptr, nullptr },
        { "frame_id", reinterpret_cast<getter>(AppBroadcastStreamVideoHeader_get_FrameId), nullptr, nullptr, nullptr },
        { "has_discontinuity", reinterpret_cast<getter>(AppBroadcastStreamVideoHeader_get_HasDiscontinuity), nullptr, nullptr, nullptr },
        { "is_key_frame", reinterpret_cast<getter>(AppBroadcastStreamVideoHeader_get_IsKeyFrame), nullptr, nullptr, nullptr },
        { "relative_timestamp", reinterpret_cast<getter>(AppBroadcastStreamVideoHeader_get_RelativeTimestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastStreamVideoHeader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastStreamVideoHeader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastStreamVideoHeader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastStreamVideoHeader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastStreamVideoHeader) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastStreamVideoHeader =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastStreamVideoHeader",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastStreamVideoHeader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastStreamVideoHeader
    };

    // ----- AppBroadcastTriggerDetails class --------------------
    static constexpr const char* const type_name_AppBroadcastTriggerDetails = "AppBroadcastTriggerDetails";

    static PyObject* _new_AppBroadcastTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastTriggerDetails);
        return nullptr;
    }

    static void _dealloc_AppBroadcastTriggerDetails(py::wrapper::Windows::Media::Capture::AppBroadcastTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastTriggerDetails_get_BackgroundService(py::wrapper::Windows::Media::Capture::AppBroadcastTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastTriggerDetails", L"BackgroundService"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BackgroundService());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastTriggerDetails[] = {
        { "_assign_array_", _assign_array_AppBroadcastTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastTriggerDetails[] = {
        { "background_service", reinterpret_cast<getter>(AppBroadcastTriggerDetails_get_BackgroundService), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastTriggerDetails =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastTriggerDetails",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastTriggerDetails
    };

    // ----- AppBroadcastViewerCountChangedEventArgs class --------------------
    static constexpr const char* const type_name_AppBroadcastViewerCountChangedEventArgs = "AppBroadcastViewerCountChangedEventArgs";

    static PyObject* _new_AppBroadcastViewerCountChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppBroadcastViewerCountChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_AppBroadcastViewerCountChangedEventArgs(py::wrapper::Windows::Media::Capture::AppBroadcastViewerCountChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastViewerCountChangedEventArgs_get_ViewerCount(py::wrapper::Windows::Media::Capture::AppBroadcastViewerCountChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastViewerCountChangedEventArgs", L"ViewerCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ViewerCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastViewerCountChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastViewerCountChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastViewerCountChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastViewerCountChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastViewerCountChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AppBroadcastViewerCountChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastViewerCountChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastViewerCountChangedEventArgs[] = {
        { "viewer_count", reinterpret_cast<getter>(AppBroadcastViewerCountChangedEventArgs_get_ViewerCount), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastViewerCountChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastViewerCountChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastViewerCountChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastViewerCountChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastViewerCountChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastViewerCountChangedEventArgs =
    {
        "_winsdk_Windows_Media_Capture.AppBroadcastViewerCountChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastViewerCountChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastViewerCountChangedEventArgs
    };

    // ----- AppCapture class --------------------
    static constexpr const char* const type_name_AppCapture = "AppCapture";

    static PyObject* _new_AppCapture(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppCapture);
        return nullptr;
    }

    static void _dealloc_AppCapture(py::wrapper::Windows::Media::Capture::AppCapture* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppCapture_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCapture", L"GetForCurrentView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::Capture::AppCapture::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCapture_SetAllowedAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCapture", L"SetAllowedAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(winrt::Windows::Media::Capture::AppCapture::SetAllowedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCapture_get_IsCapturingAudio(py::wrapper::Windows::Media::Capture::AppCapture* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCapture", L"IsCapturingAudio"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCapturingAudio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCapture_get_IsCapturingVideo(py::wrapper::Windows::Media::Capture::AppCapture* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCapture", L"IsCapturingVideo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCapturingVideo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCapture_add_CapturingChanged(py::wrapper::Windows::Media::Capture::AppCapture* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCapture", L"CapturingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppCapture, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CapturingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCapture_remove_CapturingChanged(py::wrapper::Windows::Media::Capture::AppCapture* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCapture", L"CapturingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CapturingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppCapture>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppCapture>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppCapture[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(AppCapture_GetForCurrentView), METH_VARARGS | METH_STATIC, nullptr },
        { "set_allowed_async", reinterpret_cast<PyCFunction>(AppCapture_SetAllowedAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "add_capturing_changed", reinterpret_cast<PyCFunction>(AppCapture_add_CapturingChanged), METH_O, nullptr },
        { "remove_capturing_changed", reinterpret_cast<PyCFunction>(AppCapture_remove_CapturingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppCapture, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppCapture), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppCapture[] = {
        { "is_capturing_audio", reinterpret_cast<getter>(AppCapture_get_IsCapturingAudio), nullptr, nullptr, nullptr },
        { "is_capturing_video", reinterpret_cast<getter>(AppCapture_get_IsCapturingVideo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppCapture[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppCapture) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppCapture) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppCapture) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppCapture) },
        { },
    };

    static PyType_Spec type_spec_AppCapture =
    {
        "_winsdk_Windows_Media_Capture.AppCapture",
        sizeof(py::wrapper::Windows::Media::Capture::AppCapture),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppCapture
    };

    // ----- AppCaptureAlternateShortcutKeys class --------------------
    static constexpr const char* const type_name_AppCaptureAlternateShortcutKeys = "AppCaptureAlternateShortcutKeys";

    static PyObject* _new_AppCaptureAlternateShortcutKeys(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppCaptureAlternateShortcutKeys);
        return nullptr;
    }

    static void _dealloc_AppCaptureAlternateShortcutKeys(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_ToggleRecordingKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleRecordingKeyModifiers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ToggleRecordingKeyModifiers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_ToggleRecordingKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleRecordingKeyModifiers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::VirtualKeyModifiers>(arg);

            self->obj.ToggleRecordingKeyModifiers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_ToggleRecordingKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleRecordingKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ToggleRecordingKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_ToggleRecordingKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleRecordingKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(arg);

            self->obj.ToggleRecordingKey(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_ToggleRecordingIndicatorKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleRecordingIndicatorKeyModifiers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ToggleRecordingIndicatorKeyModifiers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_ToggleRecordingIndicatorKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleRecordingIndicatorKeyModifiers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::VirtualKeyModifiers>(arg);

            self->obj.ToggleRecordingIndicatorKeyModifiers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_ToggleRecordingIndicatorKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleRecordingIndicatorKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ToggleRecordingIndicatorKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_ToggleRecordingIndicatorKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleRecordingIndicatorKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(arg);

            self->obj.ToggleRecordingIndicatorKey(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_ToggleGameBarKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleGameBarKeyModifiers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ToggleGameBarKeyModifiers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_ToggleGameBarKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleGameBarKeyModifiers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::VirtualKeyModifiers>(arg);

            self->obj.ToggleGameBarKeyModifiers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_ToggleGameBarKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleGameBarKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ToggleGameBarKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_ToggleGameBarKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleGameBarKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(arg);

            self->obj.ToggleGameBarKey(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_TakeScreenshotKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"TakeScreenshotKeyModifiers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TakeScreenshotKeyModifiers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_TakeScreenshotKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"TakeScreenshotKeyModifiers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::VirtualKeyModifiers>(arg);

            self->obj.TakeScreenshotKeyModifiers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_TakeScreenshotKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"TakeScreenshotKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TakeScreenshotKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_TakeScreenshotKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"TakeScreenshotKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(arg);

            self->obj.TakeScreenshotKey(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_SaveHistoricalVideoKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"SaveHistoricalVideoKeyModifiers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SaveHistoricalVideoKeyModifiers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_SaveHistoricalVideoKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"SaveHistoricalVideoKeyModifiers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::VirtualKeyModifiers>(arg);

            self->obj.SaveHistoricalVideoKeyModifiers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_SaveHistoricalVideoKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"SaveHistoricalVideoKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SaveHistoricalVideoKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_SaveHistoricalVideoKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"SaveHistoricalVideoKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(arg);

            self->obj.SaveHistoricalVideoKey(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_ToggleMicrophoneCaptureKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleMicrophoneCaptureKeyModifiers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ToggleMicrophoneCaptureKeyModifiers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_ToggleMicrophoneCaptureKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleMicrophoneCaptureKeyModifiers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::VirtualKeyModifiers>(arg);

            self->obj.ToggleMicrophoneCaptureKeyModifiers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_ToggleMicrophoneCaptureKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleMicrophoneCaptureKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ToggleMicrophoneCaptureKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_ToggleMicrophoneCaptureKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleMicrophoneCaptureKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(arg);

            self->obj.ToggleMicrophoneCaptureKey(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_ToggleCameraCaptureKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleCameraCaptureKeyModifiers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ToggleCameraCaptureKeyModifiers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_ToggleCameraCaptureKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleCameraCaptureKeyModifiers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::VirtualKeyModifiers>(arg);

            self->obj.ToggleCameraCaptureKeyModifiers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_ToggleCameraCaptureKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleCameraCaptureKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ToggleCameraCaptureKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_ToggleCameraCaptureKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleCameraCaptureKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(arg);

            self->obj.ToggleCameraCaptureKey(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_ToggleBroadcastKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleBroadcastKeyModifiers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ToggleBroadcastKeyModifiers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_ToggleBroadcastKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleBroadcastKeyModifiers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::VirtualKeyModifiers>(arg);

            self->obj.ToggleBroadcastKeyModifiers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_ToggleBroadcastKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleBroadcastKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ToggleBroadcastKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_ToggleBroadcastKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleBroadcastKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(arg);

            self->obj.ToggleBroadcastKey(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AppCaptureAlternateShortcutKeys(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppCaptureAlternateShortcutKeys>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppCaptureAlternateShortcutKeys(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppCaptureAlternateShortcutKeys>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppCaptureAlternateShortcutKeys[] = {
        { "_assign_array_", _assign_array_AppCaptureAlternateShortcutKeys, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppCaptureAlternateShortcutKeys), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppCaptureAlternateShortcutKeys[] = {
        { "toggle_recording_key_modifiers", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_ToggleRecordingKeyModifiers), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_ToggleRecordingKeyModifiers), nullptr, nullptr },
        { "toggle_recording_key", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_ToggleRecordingKey), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_ToggleRecordingKey), nullptr, nullptr },
        { "toggle_recording_indicator_key_modifiers", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_ToggleRecordingIndicatorKeyModifiers), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_ToggleRecordingIndicatorKeyModifiers), nullptr, nullptr },
        { "toggle_recording_indicator_key", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_ToggleRecordingIndicatorKey), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_ToggleRecordingIndicatorKey), nullptr, nullptr },
        { "toggle_game_bar_key_modifiers", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_ToggleGameBarKeyModifiers), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_ToggleGameBarKeyModifiers), nullptr, nullptr },
        { "toggle_game_bar_key", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_ToggleGameBarKey), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_ToggleGameBarKey), nullptr, nullptr },
        { "take_screenshot_key_modifiers", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_TakeScreenshotKeyModifiers), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_TakeScreenshotKeyModifiers), nullptr, nullptr },
        { "take_screenshot_key", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_TakeScreenshotKey), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_TakeScreenshotKey), nullptr, nullptr },
        { "save_historical_video_key_modifiers", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_SaveHistoricalVideoKeyModifiers), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_SaveHistoricalVideoKeyModifiers), nullptr, nullptr },
        { "save_historical_video_key", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_SaveHistoricalVideoKey), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_SaveHistoricalVideoKey), nullptr, nullptr },
        { "toggle_microphone_capture_key_modifiers", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_ToggleMicrophoneCaptureKeyModifiers), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_ToggleMicrophoneCaptureKeyModifiers), nullptr, nullptr },
        { "toggle_microphone_capture_key", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_ToggleMicrophoneCaptureKey), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_ToggleMicrophoneCaptureKey), nullptr, nullptr },
        { "toggle_camera_capture_key_modifiers", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_ToggleCameraCaptureKeyModifiers), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_ToggleCameraCaptureKeyModifiers), nullptr, nullptr },
        { "toggle_camera_capture_key", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_ToggleCameraCaptureKey), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_ToggleCameraCaptureKey), nullptr, nullptr },
        { "toggle_broadcast_key_modifiers", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_ToggleBroadcastKeyModifiers), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_ToggleBroadcastKeyModifiers), nullptr, nullptr },
        { "toggle_broadcast_key", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_ToggleBroadcastKey), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_ToggleBroadcastKey), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppCaptureAlternateShortcutKeys[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppCaptureAlternateShortcutKeys) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppCaptureAlternateShortcutKeys) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppCaptureAlternateShortcutKeys) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppCaptureAlternateShortcutKeys) },
        { },
    };

    static PyType_Spec type_spec_AppCaptureAlternateShortcutKeys =
    {
        "_winsdk_Windows_Media_Capture.AppCaptureAlternateShortcutKeys",
        sizeof(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppCaptureAlternateShortcutKeys
    };

    // ----- AppCaptureDurationGeneratedEventArgs class --------------------
    static constexpr const char* const type_name_AppCaptureDurationGeneratedEventArgs = "AppCaptureDurationGeneratedEventArgs";

    static PyObject* _new_AppCaptureDurationGeneratedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppCaptureDurationGeneratedEventArgs);
        return nullptr;
    }

    static void _dealloc_AppCaptureDurationGeneratedEventArgs(py::wrapper::Windows::Media::Capture::AppCaptureDurationGeneratedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppCaptureDurationGeneratedEventArgs_get_Duration(py::wrapper::Windows::Media::Capture::AppCaptureDurationGeneratedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureDurationGeneratedEventArgs", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppCaptureDurationGeneratedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppCaptureDurationGeneratedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppCaptureDurationGeneratedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppCaptureDurationGeneratedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppCaptureDurationGeneratedEventArgs[] = {
        { "_assign_array_", _assign_array_AppCaptureDurationGeneratedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppCaptureDurationGeneratedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppCaptureDurationGeneratedEventArgs[] = {
        { "duration", reinterpret_cast<getter>(AppCaptureDurationGeneratedEventArgs_get_Duration), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppCaptureDurationGeneratedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppCaptureDurationGeneratedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppCaptureDurationGeneratedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppCaptureDurationGeneratedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppCaptureDurationGeneratedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AppCaptureDurationGeneratedEventArgs =
    {
        "_winsdk_Windows_Media_Capture.AppCaptureDurationGeneratedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::AppCaptureDurationGeneratedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppCaptureDurationGeneratedEventArgs
    };

    // ----- AppCaptureFileGeneratedEventArgs class --------------------
    static constexpr const char* const type_name_AppCaptureFileGeneratedEventArgs = "AppCaptureFileGeneratedEventArgs";

    static PyObject* _new_AppCaptureFileGeneratedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppCaptureFileGeneratedEventArgs);
        return nullptr;
    }

    static void _dealloc_AppCaptureFileGeneratedEventArgs(py::wrapper::Windows::Media::Capture::AppCaptureFileGeneratedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppCaptureFileGeneratedEventArgs_get_File(py::wrapper::Windows::Media::Capture::AppCaptureFileGeneratedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureFileGeneratedEventArgs", L"File"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.File());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppCaptureFileGeneratedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppCaptureFileGeneratedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppCaptureFileGeneratedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppCaptureFileGeneratedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppCaptureFileGeneratedEventArgs[] = {
        { "_assign_array_", _assign_array_AppCaptureFileGeneratedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppCaptureFileGeneratedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppCaptureFileGeneratedEventArgs[] = {
        { "file", reinterpret_cast<getter>(AppCaptureFileGeneratedEventArgs_get_File), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppCaptureFileGeneratedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppCaptureFileGeneratedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppCaptureFileGeneratedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppCaptureFileGeneratedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppCaptureFileGeneratedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AppCaptureFileGeneratedEventArgs =
    {
        "_winsdk_Windows_Media_Capture.AppCaptureFileGeneratedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::AppCaptureFileGeneratedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppCaptureFileGeneratedEventArgs
    };

    // ----- AppCaptureManager class --------------------
    static constexpr const char* const type_name_AppCaptureManager = "AppCaptureManager";

    static PyObject* _new_AppCaptureManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppCaptureManager);
        return nullptr;
    }

    static PyObject* AppCaptureManager_ApplySettings(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureManager", L"ApplySettings", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppCaptureSettings>(args, 0);

                winrt::Windows::Media::Capture::AppCaptureManager::ApplySettings(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureManager_GetCurrentSettings(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureManager", L"GetCurrentSettings", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::Capture::AppCaptureManager::GetCurrentSettings());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppCaptureManager[] = {
        { "apply_settings", reinterpret_cast<PyCFunction>(AppCaptureManager_ApplySettings), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_settings", reinterpret_cast<PyCFunction>(AppCaptureManager_GetCurrentSettings), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppCaptureManager[] = {
        { }
    };

    static PyType_Slot _type_slots_AppCaptureManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppCaptureManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppCaptureManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppCaptureManager) },
        { },
    };

    static PyType_Spec type_spec_AppCaptureManager =
    {
        "_winsdk_Windows_Media_Capture.AppCaptureManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppCaptureManager
    };

    // ----- AppCaptureMetadataWriter class --------------------
    static constexpr const char* const type_name_AppCaptureMetadataWriter = "AppCaptureMetadataWriter";

    static PyObject* _new_AppCaptureMetadataWriter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Capture::AppCaptureMetadataWriter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppCaptureMetadataWriter(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppCaptureMetadataWriter_AddDoubleEvent(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureMetadataWriter", L"AddDoubleEvent", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Capture::AppCaptureMetadataPriority>(args, 2);

                self->obj.AddDoubleEvent(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureMetadataWriter_AddInt32Event(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureMetadataWriter", L"AddInt32Event", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Capture::AppCaptureMetadataPriority>(args, 2);

                self->obj.AddInt32Event(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureMetadataWriter_AddStringEvent(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureMetadataWriter", L"AddStringEvent", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Capture::AppCaptureMetadataPriority>(args, 2);

                self->obj.AddStringEvent(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureMetadataWriter_Close(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureMetadataWriter", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureMetadataWriter_StartDoubleState(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureMetadataWriter", L"StartDoubleState", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Capture::AppCaptureMetadataPriority>(args, 2);

                self->obj.StartDoubleState(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureMetadataWriter_StartInt32State(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureMetadataWriter", L"StartInt32State", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Capture::AppCaptureMetadataPriority>(args, 2);

                self->obj.StartInt32State(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureMetadataWriter_StartStringState(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureMetadataWriter", L"StartStringState", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Capture::AppCaptureMetadataPriority>(args, 2);

                self->obj.StartStringState(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureMetadataWriter_StopAllStates(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureMetadataWriter", L"StopAllStates", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.StopAllStates();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureMetadataWriter_StopState(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureMetadataWriter", L"StopState", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.StopState(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureMetadataWriter_get_RemainingStorageBytesAvailable(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureMetadataWriter", L"RemainingStorageBytesAvailable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemainingStorageBytesAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureMetadataWriter_add_MetadataPurged(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCaptureMetadataWriter", L"MetadataPurged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppCaptureMetadataWriter, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.MetadataPurged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureMetadataWriter_remove_MetadataPurged(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCaptureMetadataWriter", L"MetadataPurged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MetadataPurged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppCaptureMetadataWriter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppCaptureMetadataWriter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppCaptureMetadataWriter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppCaptureMetadataWriter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AppCaptureMetadataWriter(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_AppCaptureMetadataWriter(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppCaptureMetadataWriter[] = {
        { "add_double_event", reinterpret_cast<PyCFunction>(AppCaptureMetadataWriter_AddDoubleEvent), METH_VARARGS, nullptr },
        { "add_int32_event", reinterpret_cast<PyCFunction>(AppCaptureMetadataWriter_AddInt32Event), METH_VARARGS, nullptr },
        { "add_string_event", reinterpret_cast<PyCFunction>(AppCaptureMetadataWriter_AddStringEvent), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(AppCaptureMetadataWriter_Close), METH_VARARGS, nullptr },
        { "start_double_state", reinterpret_cast<PyCFunction>(AppCaptureMetadataWriter_StartDoubleState), METH_VARARGS, nullptr },
        { "start_int32_state", reinterpret_cast<PyCFunction>(AppCaptureMetadataWriter_StartInt32State), METH_VARARGS, nullptr },
        { "start_string_state", reinterpret_cast<PyCFunction>(AppCaptureMetadataWriter_StartStringState), METH_VARARGS, nullptr },
        { "stop_all_states", reinterpret_cast<PyCFunction>(AppCaptureMetadataWriter_StopAllStates), METH_VARARGS, nullptr },
        { "stop_state", reinterpret_cast<PyCFunction>(AppCaptureMetadataWriter_StopState), METH_VARARGS, nullptr },
        { "add_metadata_purged", reinterpret_cast<PyCFunction>(AppCaptureMetadataWriter_add_MetadataPurged), METH_O, nullptr },
        { "remove_metadata_purged", reinterpret_cast<PyCFunction>(AppCaptureMetadataWriter_remove_MetadataPurged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppCaptureMetadataWriter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppCaptureMetadataWriter), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AppCaptureMetadataWriter), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AppCaptureMetadataWriter), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppCaptureMetadataWriter[] = {
        { "remaining_storage_bytes_available", reinterpret_cast<getter>(AppCaptureMetadataWriter_get_RemainingStorageBytesAvailable), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppCaptureMetadataWriter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppCaptureMetadataWriter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppCaptureMetadataWriter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppCaptureMetadataWriter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppCaptureMetadataWriter) },
        { },
    };

    static PyType_Spec type_spec_AppCaptureMetadataWriter =
    {
        "_winsdk_Windows_Media_Capture.AppCaptureMetadataWriter",
        sizeof(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppCaptureMetadataWriter
    };

    // ----- AppCaptureMicrophoneCaptureStateChangedEventArgs class --------------------
    static constexpr const char* const type_name_AppCaptureMicrophoneCaptureStateChangedEventArgs = "AppCaptureMicrophoneCaptureStateChangedEventArgs";

    static PyObject* _new_AppCaptureMicrophoneCaptureStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppCaptureMicrophoneCaptureStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_AppCaptureMicrophoneCaptureStateChangedEventArgs(py::wrapper::Windows::Media::Capture::AppCaptureMicrophoneCaptureStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppCaptureMicrophoneCaptureStateChangedEventArgs_get_ErrorCode(py::wrapper::Windows::Media::Capture::AppCaptureMicrophoneCaptureStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureMicrophoneCaptureStateChangedEventArgs", L"ErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureMicrophoneCaptureStateChangedEventArgs_get_State(py::wrapper::Windows::Media::Capture::AppCaptureMicrophoneCaptureStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureMicrophoneCaptureStateChangedEventArgs", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppCaptureMicrophoneCaptureStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppCaptureMicrophoneCaptureStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppCaptureMicrophoneCaptureStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppCaptureMicrophoneCaptureStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppCaptureMicrophoneCaptureStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AppCaptureMicrophoneCaptureStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppCaptureMicrophoneCaptureStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppCaptureMicrophoneCaptureStateChangedEventArgs[] = {
        { "error_code", reinterpret_cast<getter>(AppCaptureMicrophoneCaptureStateChangedEventArgs_get_ErrorCode), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(AppCaptureMicrophoneCaptureStateChangedEventArgs_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppCaptureMicrophoneCaptureStateChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppCaptureMicrophoneCaptureStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppCaptureMicrophoneCaptureStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppCaptureMicrophoneCaptureStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppCaptureMicrophoneCaptureStateChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AppCaptureMicrophoneCaptureStateChangedEventArgs =
    {
        "_winsdk_Windows_Media_Capture.AppCaptureMicrophoneCaptureStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::AppCaptureMicrophoneCaptureStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppCaptureMicrophoneCaptureStateChangedEventArgs
    };

    // ----- AppCaptureRecordOperation class --------------------
    static constexpr const char* const type_name_AppCaptureRecordOperation = "AppCaptureRecordOperation";

    static PyObject* _new_AppCaptureRecordOperation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppCaptureRecordOperation);
        return nullptr;
    }

    static void _dealloc_AppCaptureRecordOperation(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppCaptureRecordOperation_StopRecording(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureRecordOperation", L"StopRecording", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.StopRecording();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureRecordOperation_get_Duration(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureRecordOperation", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureRecordOperation_get_ErrorCode(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureRecordOperation", L"ErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureRecordOperation_get_File(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureRecordOperation", L"File"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.File());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureRecordOperation_get_IsFileTruncated(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureRecordOperation", L"IsFileTruncated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsFileTruncated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureRecordOperation_get_State(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureRecordOperation", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureRecordOperation_add_DurationGenerated(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCaptureRecordOperation", L"DurationGenerated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppCaptureRecordOperation, winrt::Windows::Media::Capture::AppCaptureDurationGeneratedEventArgs>>(arg);

            return py::convert(self->obj.DurationGenerated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureRecordOperation_remove_DurationGenerated(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCaptureRecordOperation", L"DurationGenerated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DurationGenerated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureRecordOperation_add_FileGenerated(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCaptureRecordOperation", L"FileGenerated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppCaptureRecordOperation, winrt::Windows::Media::Capture::AppCaptureFileGeneratedEventArgs>>(arg);

            return py::convert(self->obj.FileGenerated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureRecordOperation_remove_FileGenerated(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCaptureRecordOperation", L"FileGenerated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FileGenerated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureRecordOperation_add_StateChanged(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCaptureRecordOperation", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppCaptureRecordOperation, winrt::Windows::Media::Capture::AppCaptureRecordingStateChangedEventArgs>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureRecordOperation_remove_StateChanged(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCaptureRecordOperation", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppCaptureRecordOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppCaptureRecordOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppCaptureRecordOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppCaptureRecordOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppCaptureRecordOperation[] = {
        { "stop_recording", reinterpret_cast<PyCFunction>(AppCaptureRecordOperation_StopRecording), METH_VARARGS, nullptr },
        { "add_duration_generated", reinterpret_cast<PyCFunction>(AppCaptureRecordOperation_add_DurationGenerated), METH_O, nullptr },
        { "remove_duration_generated", reinterpret_cast<PyCFunction>(AppCaptureRecordOperation_remove_DurationGenerated), METH_O, nullptr },
        { "add_file_generated", reinterpret_cast<PyCFunction>(AppCaptureRecordOperation_add_FileGenerated), METH_O, nullptr },
        { "remove_file_generated", reinterpret_cast<PyCFunction>(AppCaptureRecordOperation_remove_FileGenerated), METH_O, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(AppCaptureRecordOperation_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(AppCaptureRecordOperation_remove_StateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppCaptureRecordOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppCaptureRecordOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppCaptureRecordOperation[] = {
        { "duration", reinterpret_cast<getter>(AppCaptureRecordOperation_get_Duration), nullptr, nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(AppCaptureRecordOperation_get_ErrorCode), nullptr, nullptr, nullptr },
        { "file", reinterpret_cast<getter>(AppCaptureRecordOperation_get_File), nullptr, nullptr, nullptr },
        { "is_file_truncated", reinterpret_cast<getter>(AppCaptureRecordOperation_get_IsFileTruncated), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(AppCaptureRecordOperation_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppCaptureRecordOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppCaptureRecordOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppCaptureRecordOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppCaptureRecordOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppCaptureRecordOperation) },
        { },
    };

    static PyType_Spec type_spec_AppCaptureRecordOperation =
    {
        "_winsdk_Windows_Media_Capture.AppCaptureRecordOperation",
        sizeof(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppCaptureRecordOperation
    };

    // ----- AppCaptureRecordingStateChangedEventArgs class --------------------
    static constexpr const char* const type_name_AppCaptureRecordingStateChangedEventArgs = "AppCaptureRecordingStateChangedEventArgs";

    static PyObject* _new_AppCaptureRecordingStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppCaptureRecordingStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_AppCaptureRecordingStateChangedEventArgs(py::wrapper::Windows::Media::Capture::AppCaptureRecordingStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppCaptureRecordingStateChangedEventArgs_get_ErrorCode(py::wrapper::Windows::Media::Capture::AppCaptureRecordingStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureRecordingStateChangedEventArgs", L"ErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureRecordingStateChangedEventArgs_get_State(py::wrapper::Windows::Media::Capture::AppCaptureRecordingStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureRecordingStateChangedEventArgs", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppCaptureRecordingStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppCaptureRecordingStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppCaptureRecordingStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppCaptureRecordingStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppCaptureRecordingStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AppCaptureRecordingStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppCaptureRecordingStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppCaptureRecordingStateChangedEventArgs[] = {
        { "error_code", reinterpret_cast<getter>(AppCaptureRecordingStateChangedEventArgs_get_ErrorCode), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(AppCaptureRecordingStateChangedEventArgs_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppCaptureRecordingStateChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppCaptureRecordingStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppCaptureRecordingStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppCaptureRecordingStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppCaptureRecordingStateChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AppCaptureRecordingStateChangedEventArgs =
    {
        "_winsdk_Windows_Media_Capture.AppCaptureRecordingStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::AppCaptureRecordingStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppCaptureRecordingStateChangedEventArgs
    };

    // ----- AppCaptureServices class --------------------
    static constexpr const char* const type_name_AppCaptureServices = "AppCaptureServices";

    static PyObject* _new_AppCaptureServices(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppCaptureServices);
        return nullptr;
    }

    static void _dealloc_AppCaptureServices(py::wrapper::Windows::Media::Capture::AppCaptureServices* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppCaptureServices_Record(py::wrapper::Windows::Media::Capture::AppCaptureServices* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureServices", L"Record", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Record());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureServices_RecordTimeSpan(py::wrapper::Windows::Media::Capture::AppCaptureServices* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureServices", L"RecordTimeSpan", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(self->obj.RecordTimeSpan(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureServices_get_CanCapture(py::wrapper::Windows::Media::Capture::AppCaptureServices* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureServices", L"CanCapture"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanCapture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureServices_get_State(py::wrapper::Windows::Media::Capture::AppCaptureServices* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureServices", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppCaptureServices(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppCaptureServices>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppCaptureServices(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppCaptureServices>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppCaptureServices[] = {
        { "record", reinterpret_cast<PyCFunction>(AppCaptureServices_Record), METH_VARARGS, nullptr },
        { "record_time_span", reinterpret_cast<PyCFunction>(AppCaptureServices_RecordTimeSpan), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppCaptureServices, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppCaptureServices), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppCaptureServices[] = {
        { "can_capture", reinterpret_cast<getter>(AppCaptureServices_get_CanCapture), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(AppCaptureServices_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppCaptureServices[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppCaptureServices) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppCaptureServices) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppCaptureServices) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppCaptureServices) },
        { },
    };

    static PyType_Spec type_spec_AppCaptureServices =
    {
        "_winsdk_Windows_Media_Capture.AppCaptureServices",
        sizeof(py::wrapper::Windows::Media::Capture::AppCaptureServices),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppCaptureServices
    };

    // ----- AppCaptureSettings class --------------------
    static constexpr const char* const type_name_AppCaptureSettings = "AppCaptureSettings";

    static PyObject* _new_AppCaptureSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppCaptureSettings);
        return nullptr;
    }

    static void _dealloc_AppCaptureSettings(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppCaptureSettings_get_IsHistoricalCaptureOnWirelessDisplayAllowed(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsHistoricalCaptureOnWirelessDisplayAllowed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsHistoricalCaptureOnWirelessDisplayAllowed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_IsHistoricalCaptureOnWirelessDisplayAllowed(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsHistoricalCaptureOnWirelessDisplayAllowed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsHistoricalCaptureOnWirelessDisplayAllowed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_VideoEncodingBitrateMode(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"VideoEncodingBitrateMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoEncodingBitrateMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_VideoEncodingBitrateMode(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"VideoEncodingBitrateMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppCaptureVideoEncodingBitrateMode>(arg);

            self->obj.VideoEncodingBitrateMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_IsHistoricalCaptureOnBatteryAllowed(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsHistoricalCaptureOnBatteryAllowed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsHistoricalCaptureOnBatteryAllowed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_IsHistoricalCaptureOnBatteryAllowed(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsHistoricalCaptureOnBatteryAllowed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsHistoricalCaptureOnBatteryAllowed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_IsAudioCaptureEnabled(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsAudioCaptureEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsAudioCaptureEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_IsAudioCaptureEnabled(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsAudioCaptureEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAudioCaptureEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_IsAppCaptureEnabled(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsAppCaptureEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsAppCaptureEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_IsAppCaptureEnabled(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsAppCaptureEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAppCaptureEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_AppCaptureDestinationFolder(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"AppCaptureDestinationFolder"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppCaptureDestinationFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_AppCaptureDestinationFolder(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"AppCaptureDestinationFolder"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageFolder>(arg);

            self->obj.AppCaptureDestinationFolder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_HistoricalBufferLength(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"HistoricalBufferLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HistoricalBufferLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_HistoricalBufferLength(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"HistoricalBufferLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.HistoricalBufferLength(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_IsHistoricalCaptureEnabled(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsHistoricalCaptureEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsHistoricalCaptureEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_IsHistoricalCaptureEnabled(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsHistoricalCaptureEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsHistoricalCaptureEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_CustomVideoEncodingWidth(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"CustomVideoEncodingWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CustomVideoEncodingWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_CustomVideoEncodingWidth(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"CustomVideoEncodingWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CustomVideoEncodingWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_CustomVideoEncodingHeight(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"CustomVideoEncodingHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CustomVideoEncodingHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_CustomVideoEncodingHeight(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"CustomVideoEncodingHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CustomVideoEncodingHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_CustomVideoEncodingBitrate(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"CustomVideoEncodingBitrate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CustomVideoEncodingBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_CustomVideoEncodingBitrate(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"CustomVideoEncodingBitrate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CustomVideoEncodingBitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_AudioEncodingBitrate(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"AudioEncodingBitrate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioEncodingBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_AudioEncodingBitrate(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"AudioEncodingBitrate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.AudioEncodingBitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_HistoricalBufferLengthUnit(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"HistoricalBufferLengthUnit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HistoricalBufferLengthUnit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_HistoricalBufferLengthUnit(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"HistoricalBufferLengthUnit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppCaptureHistoricalBufferLengthUnit>(arg);

            self->obj.HistoricalBufferLengthUnit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_VideoEncodingResolutionMode(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"VideoEncodingResolutionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoEncodingResolutionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_VideoEncodingResolutionMode(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"VideoEncodingResolutionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppCaptureVideoEncodingResolutionMode>(arg);

            self->obj.VideoEncodingResolutionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_ScreenshotDestinationFolder(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"ScreenshotDestinationFolder"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScreenshotDestinationFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_ScreenshotDestinationFolder(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"ScreenshotDestinationFolder"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageFolder>(arg);

            self->obj.ScreenshotDestinationFolder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_MaximumRecordLength(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"MaximumRecordLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaximumRecordLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_MaximumRecordLength(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"MaximumRecordLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.MaximumRecordLength(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_HasHardwareEncoder(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"HasHardwareEncoder"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasHardwareEncoder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureSettings_get_IsCpuConstrained(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsCpuConstrained"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCpuConstrained());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureSettings_get_IsMemoryConstrained(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsMemoryConstrained"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsMemoryConstrained());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureSettings_get_IsDisabledByPolicy(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsDisabledByPolicy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDisabledByPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureSettings_get_AlternateShortcutKeys(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"AlternateShortcutKeys"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AlternateShortcutKeys());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureSettings_get_IsGpuConstrained(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsGpuConstrained"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsGpuConstrained());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureSettings_get_IsMicrophoneCaptureEnabled(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsMicrophoneCaptureEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsMicrophoneCaptureEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_IsMicrophoneCaptureEnabled(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsMicrophoneCaptureEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsMicrophoneCaptureEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_VideoEncodingFrameRateMode(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"VideoEncodingFrameRateMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoEncodingFrameRateMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_VideoEncodingFrameRateMode(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"VideoEncodingFrameRateMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppCaptureVideoEncodingFrameRateMode>(arg);

            self->obj.VideoEncodingFrameRateMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_SystemAudioGain(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"SystemAudioGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SystemAudioGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_SystemAudioGain(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"SystemAudioGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.SystemAudioGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_MicrophoneGain(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"MicrophoneGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MicrophoneGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_MicrophoneGain(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"MicrophoneGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.MicrophoneGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_IsMicrophoneCaptureEnabledByDefault(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsMicrophoneCaptureEnabledByDefault"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsMicrophoneCaptureEnabledByDefault());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_IsMicrophoneCaptureEnabledByDefault(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsMicrophoneCaptureEnabledByDefault"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsMicrophoneCaptureEnabledByDefault(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_IsEchoCancellationEnabled(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsEchoCancellationEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEchoCancellationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_IsEchoCancellationEnabled(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsEchoCancellationEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEchoCancellationEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_IsCursorImageCaptureEnabled(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsCursorImageCaptureEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCursorImageCaptureEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_IsCursorImageCaptureEnabled(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsCursorImageCaptureEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCursorImageCaptureEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AppCaptureSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppCaptureSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppCaptureSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppCaptureSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppCaptureSettings[] = {
        { "_assign_array_", _assign_array_AppCaptureSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppCaptureSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppCaptureSettings[] = {
        { "is_historical_capture_on_wireless_display_allowed", reinterpret_cast<getter>(AppCaptureSettings_get_IsHistoricalCaptureOnWirelessDisplayAllowed), reinterpret_cast<setter>(AppCaptureSettings_put_IsHistoricalCaptureOnWirelessDisplayAllowed), nullptr, nullptr },
        { "video_encoding_bitrate_mode", reinterpret_cast<getter>(AppCaptureSettings_get_VideoEncodingBitrateMode), reinterpret_cast<setter>(AppCaptureSettings_put_VideoEncodingBitrateMode), nullptr, nullptr },
        { "is_historical_capture_on_battery_allowed", reinterpret_cast<getter>(AppCaptureSettings_get_IsHistoricalCaptureOnBatteryAllowed), reinterpret_cast<setter>(AppCaptureSettings_put_IsHistoricalCaptureOnBatteryAllowed), nullptr, nullptr },
        { "is_audio_capture_enabled", reinterpret_cast<getter>(AppCaptureSettings_get_IsAudioCaptureEnabled), reinterpret_cast<setter>(AppCaptureSettings_put_IsAudioCaptureEnabled), nullptr, nullptr },
        { "is_app_capture_enabled", reinterpret_cast<getter>(AppCaptureSettings_get_IsAppCaptureEnabled), reinterpret_cast<setter>(AppCaptureSettings_put_IsAppCaptureEnabled), nullptr, nullptr },
        { "app_capture_destination_folder", reinterpret_cast<getter>(AppCaptureSettings_get_AppCaptureDestinationFolder), reinterpret_cast<setter>(AppCaptureSettings_put_AppCaptureDestinationFolder), nullptr, nullptr },
        { "historical_buffer_length", reinterpret_cast<getter>(AppCaptureSettings_get_HistoricalBufferLength), reinterpret_cast<setter>(AppCaptureSettings_put_HistoricalBufferLength), nullptr, nullptr },
        { "is_historical_capture_enabled", reinterpret_cast<getter>(AppCaptureSettings_get_IsHistoricalCaptureEnabled), reinterpret_cast<setter>(AppCaptureSettings_put_IsHistoricalCaptureEnabled), nullptr, nullptr },
        { "custom_video_encoding_width", reinterpret_cast<getter>(AppCaptureSettings_get_CustomVideoEncodingWidth), reinterpret_cast<setter>(AppCaptureSettings_put_CustomVideoEncodingWidth), nullptr, nullptr },
        { "custom_video_encoding_height", reinterpret_cast<getter>(AppCaptureSettings_get_CustomVideoEncodingHeight), reinterpret_cast<setter>(AppCaptureSettings_put_CustomVideoEncodingHeight), nullptr, nullptr },
        { "custom_video_encoding_bitrate", reinterpret_cast<getter>(AppCaptureSettings_get_CustomVideoEncodingBitrate), reinterpret_cast<setter>(AppCaptureSettings_put_CustomVideoEncodingBitrate), nullptr, nullptr },
        { "audio_encoding_bitrate", reinterpret_cast<getter>(AppCaptureSettings_get_AudioEncodingBitrate), reinterpret_cast<setter>(AppCaptureSettings_put_AudioEncodingBitrate), nullptr, nullptr },
        { "historical_buffer_length_unit", reinterpret_cast<getter>(AppCaptureSettings_get_HistoricalBufferLengthUnit), reinterpret_cast<setter>(AppCaptureSettings_put_HistoricalBufferLengthUnit), nullptr, nullptr },
        { "video_encoding_resolution_mode", reinterpret_cast<getter>(AppCaptureSettings_get_VideoEncodingResolutionMode), reinterpret_cast<setter>(AppCaptureSettings_put_VideoEncodingResolutionMode), nullptr, nullptr },
        { "screenshot_destination_folder", reinterpret_cast<getter>(AppCaptureSettings_get_ScreenshotDestinationFolder), reinterpret_cast<setter>(AppCaptureSettings_put_ScreenshotDestinationFolder), nullptr, nullptr },
        { "maximum_record_length", reinterpret_cast<getter>(AppCaptureSettings_get_MaximumRecordLength), reinterpret_cast<setter>(AppCaptureSettings_put_MaximumRecordLength), nullptr, nullptr },
        { "has_hardware_encoder", reinterpret_cast<getter>(AppCaptureSettings_get_HasHardwareEncoder), nullptr, nullptr, nullptr },
        { "is_cpu_constrained", reinterpret_cast<getter>(AppCaptureSettings_get_IsCpuConstrained), nullptr, nullptr, nullptr },
        { "is_memory_constrained", reinterpret_cast<getter>(AppCaptureSettings_get_IsMemoryConstrained), nullptr, nullptr, nullptr },
        { "is_disabled_by_policy", reinterpret_cast<getter>(AppCaptureSettings_get_IsDisabledByPolicy), nullptr, nullptr, nullptr },
        { "alternate_shortcut_keys", reinterpret_cast<getter>(AppCaptureSettings_get_AlternateShortcutKeys), nullptr, nullptr, nullptr },
        { "is_gpu_constrained", reinterpret_cast<getter>(AppCaptureSettings_get_IsGpuConstrained), nullptr, nullptr, nullptr },
        { "is_microphone_capture_enabled", reinterpret_cast<getter>(AppCaptureSettings_get_IsMicrophoneCaptureEnabled), reinterpret_cast<setter>(AppCaptureSettings_put_IsMicrophoneCaptureEnabled), nullptr, nullptr },
        { "video_encoding_frame_rate_mode", reinterpret_cast<getter>(AppCaptureSettings_get_VideoEncodingFrameRateMode), reinterpret_cast<setter>(AppCaptureSettings_put_VideoEncodingFrameRateMode), nullptr, nullptr },
        { "system_audio_gain", reinterpret_cast<getter>(AppCaptureSettings_get_SystemAudioGain), reinterpret_cast<setter>(AppCaptureSettings_put_SystemAudioGain), nullptr, nullptr },
        { "microphone_gain", reinterpret_cast<getter>(AppCaptureSettings_get_MicrophoneGain), reinterpret_cast<setter>(AppCaptureSettings_put_MicrophoneGain), nullptr, nullptr },
        { "is_microphone_capture_enabled_by_default", reinterpret_cast<getter>(AppCaptureSettings_get_IsMicrophoneCaptureEnabledByDefault), reinterpret_cast<setter>(AppCaptureSettings_put_IsMicrophoneCaptureEnabledByDefault), nullptr, nullptr },
        { "is_echo_cancellation_enabled", reinterpret_cast<getter>(AppCaptureSettings_get_IsEchoCancellationEnabled), reinterpret_cast<setter>(AppCaptureSettings_put_IsEchoCancellationEnabled), nullptr, nullptr },
        { "is_cursor_image_capture_enabled", reinterpret_cast<getter>(AppCaptureSettings_get_IsCursorImageCaptureEnabled), reinterpret_cast<setter>(AppCaptureSettings_put_IsCursorImageCaptureEnabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppCaptureSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppCaptureSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppCaptureSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppCaptureSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppCaptureSettings) },
        { },
    };

    static PyType_Spec type_spec_AppCaptureSettings =
    {
        "_winsdk_Windows_Media_Capture.AppCaptureSettings",
        sizeof(py::wrapper::Windows::Media::Capture::AppCaptureSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppCaptureSettings
    };

    // ----- AppCaptureState class --------------------
    static constexpr const char* const type_name_AppCaptureState = "AppCaptureState";

    static PyObject* _new_AppCaptureState(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppCaptureState);
        return nullptr;
    }

    static void _dealloc_AppCaptureState(py::wrapper::Windows::Media::Capture::AppCaptureState* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppCaptureState_RestartMicrophoneCapture(py::wrapper::Windows::Media::Capture::AppCaptureState* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureState", L"RestartMicrophoneCapture", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RestartMicrophoneCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureState_get_ShouldCaptureMicrophone(py::wrapper::Windows::Media::Capture::AppCaptureState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureState", L"ShouldCaptureMicrophone"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShouldCaptureMicrophone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureState_put_ShouldCaptureMicrophone(py::wrapper::Windows::Media::Capture::AppCaptureState* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureState", L"ShouldCaptureMicrophone"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShouldCaptureMicrophone(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureState_get_IsHistoricalCaptureEnabled(py::wrapper::Windows::Media::Capture::AppCaptureState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureState", L"IsHistoricalCaptureEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsHistoricalCaptureEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureState_get_IsTargetRunning(py::wrapper::Windows::Media::Capture::AppCaptureState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureState", L"IsTargetRunning"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTargetRunning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureState_get_MicrophoneCaptureError(py::wrapper::Windows::Media::Capture::AppCaptureState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureState", L"MicrophoneCaptureError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MicrophoneCaptureError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureState_get_MicrophoneCaptureState(py::wrapper::Windows::Media::Capture::AppCaptureState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureState", L"MicrophoneCaptureState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MicrophoneCaptureState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureState_add_CaptureTargetClosed(py::wrapper::Windows::Media::Capture::AppCaptureState* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCaptureState", L"CaptureTargetClosed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppCaptureState, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CaptureTargetClosed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureState_remove_CaptureTargetClosed(py::wrapper::Windows::Media::Capture::AppCaptureState* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCaptureState", L"CaptureTargetClosed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CaptureTargetClosed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureState_add_MicrophoneCaptureStateChanged(py::wrapper::Windows::Media::Capture::AppCaptureState* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCaptureState", L"MicrophoneCaptureStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppCaptureState, winrt::Windows::Media::Capture::AppCaptureMicrophoneCaptureStateChangedEventArgs>>(arg);

            return py::convert(self->obj.MicrophoneCaptureStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureState_remove_MicrophoneCaptureStateChanged(py::wrapper::Windows::Media::Capture::AppCaptureState* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCaptureState", L"MicrophoneCaptureStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MicrophoneCaptureStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppCaptureState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppCaptureState>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppCaptureState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppCaptureState>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppCaptureState[] = {
        { "restart_microphone_capture", reinterpret_cast<PyCFunction>(AppCaptureState_RestartMicrophoneCapture), METH_VARARGS, nullptr },
        { "add_capture_target_closed", reinterpret_cast<PyCFunction>(AppCaptureState_add_CaptureTargetClosed), METH_O, nullptr },
        { "remove_capture_target_closed", reinterpret_cast<PyCFunction>(AppCaptureState_remove_CaptureTargetClosed), METH_O, nullptr },
        { "add_microphone_capture_state_changed", reinterpret_cast<PyCFunction>(AppCaptureState_add_MicrophoneCaptureStateChanged), METH_O, nullptr },
        { "remove_microphone_capture_state_changed", reinterpret_cast<PyCFunction>(AppCaptureState_remove_MicrophoneCaptureStateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppCaptureState, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppCaptureState), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppCaptureState[] = {
        { "should_capture_microphone", reinterpret_cast<getter>(AppCaptureState_get_ShouldCaptureMicrophone), reinterpret_cast<setter>(AppCaptureState_put_ShouldCaptureMicrophone), nullptr, nullptr },
        { "is_historical_capture_enabled", reinterpret_cast<getter>(AppCaptureState_get_IsHistoricalCaptureEnabled), nullptr, nullptr, nullptr },
        { "is_target_running", reinterpret_cast<getter>(AppCaptureState_get_IsTargetRunning), nullptr, nullptr, nullptr },
        { "microphone_capture_error", reinterpret_cast<getter>(AppCaptureState_get_MicrophoneCaptureError), nullptr, nullptr, nullptr },
        { "microphone_capture_state", reinterpret_cast<getter>(AppCaptureState_get_MicrophoneCaptureState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppCaptureState[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppCaptureState) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppCaptureState) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppCaptureState) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppCaptureState) },
        { },
    };

    static PyType_Spec type_spec_AppCaptureState =
    {
        "_winsdk_Windows_Media_Capture.AppCaptureState",
        sizeof(py::wrapper::Windows::Media::Capture::AppCaptureState),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppCaptureState
    };

    // ----- CameraCaptureUI class --------------------
    static constexpr const char* const type_name_CameraCaptureUI = "CameraCaptureUI";

    static PyObject* _new_CameraCaptureUI(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Capture::CameraCaptureUI instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CameraCaptureUI(py::wrapper::Windows::Media::Capture::CameraCaptureUI* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CameraCaptureUI_CaptureFileAsync(py::wrapper::Windows::Media::Capture::CameraCaptureUI* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.CameraCaptureUI", L"CaptureFileAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::CameraCaptureUIMode>(args, 0);

                return py::convert(self->obj.CaptureFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraCaptureUI_get_PhotoSettings(py::wrapper::Windows::Media::Capture::CameraCaptureUI* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUI", L"PhotoSettings"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhotoSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraCaptureUI_get_VideoSettings(py::wrapper::Windows::Media::Capture::CameraCaptureUI* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUI", L"VideoSettings"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CameraCaptureUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::CameraCaptureUI>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CameraCaptureUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::CameraCaptureUI>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraCaptureUI[] = {
        { "capture_file_async", reinterpret_cast<PyCFunction>(CameraCaptureUI_CaptureFileAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CameraCaptureUI, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CameraCaptureUI), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CameraCaptureUI[] = {
        { "photo_settings", reinterpret_cast<getter>(CameraCaptureUI_get_PhotoSettings), nullptr, nullptr, nullptr },
        { "video_settings", reinterpret_cast<getter>(CameraCaptureUI_get_VideoSettings), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CameraCaptureUI[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CameraCaptureUI) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CameraCaptureUI) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CameraCaptureUI) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CameraCaptureUI) },
        { },
    };

    static PyType_Spec type_spec_CameraCaptureUI =
    {
        "_winsdk_Windows_Media_Capture.CameraCaptureUI",
        sizeof(py::wrapper::Windows::Media::Capture::CameraCaptureUI),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraCaptureUI
    };

    // ----- CameraCaptureUIPhotoCaptureSettings class --------------------
    static constexpr const char* const type_name_CameraCaptureUIPhotoCaptureSettings = "CameraCaptureUIPhotoCaptureSettings";

    static PyObject* _new_CameraCaptureUIPhotoCaptureSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CameraCaptureUIPhotoCaptureSettings);
        return nullptr;
    }

    static void _dealloc_CameraCaptureUIPhotoCaptureSettings(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CameraCaptureUIPhotoCaptureSettings_get_MaxResolution(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings", L"MaxResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIPhotoCaptureSettings_put_MaxResolution(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings", L"MaxResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::CameraCaptureUIMaxPhotoResolution>(arg);

            self->obj.MaxResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIPhotoCaptureSettings_get_Format(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIPhotoCaptureSettings_put_Format(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::CameraCaptureUIPhotoFormat>(arg);

            self->obj.Format(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIPhotoCaptureSettings_get_CroppedSizeInPixels(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings", L"CroppedSizeInPixels"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CroppedSizeInPixels());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIPhotoCaptureSettings_put_CroppedSizeInPixels(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings", L"CroppedSizeInPixels"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(arg);

            self->obj.CroppedSizeInPixels(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIPhotoCaptureSettings_get_CroppedAspectRatio(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings", L"CroppedAspectRatio"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CroppedAspectRatio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIPhotoCaptureSettings_put_CroppedAspectRatio(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings", L"CroppedAspectRatio"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(arg);

            self->obj.CroppedAspectRatio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIPhotoCaptureSettings_get_AllowCropping(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings", L"AllowCropping"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowCropping());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIPhotoCaptureSettings_put_AllowCropping(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings", L"AllowCropping"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowCropping(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CameraCaptureUIPhotoCaptureSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CameraCaptureUIPhotoCaptureSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraCaptureUIPhotoCaptureSettings[] = {
        { "_assign_array_", _assign_array_CameraCaptureUIPhotoCaptureSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CameraCaptureUIPhotoCaptureSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CameraCaptureUIPhotoCaptureSettings[] = {
        { "max_resolution", reinterpret_cast<getter>(CameraCaptureUIPhotoCaptureSettings_get_MaxResolution), reinterpret_cast<setter>(CameraCaptureUIPhotoCaptureSettings_put_MaxResolution), nullptr, nullptr },
        { "format", reinterpret_cast<getter>(CameraCaptureUIPhotoCaptureSettings_get_Format), reinterpret_cast<setter>(CameraCaptureUIPhotoCaptureSettings_put_Format), nullptr, nullptr },
        { "cropped_size_in_pixels", reinterpret_cast<getter>(CameraCaptureUIPhotoCaptureSettings_get_CroppedSizeInPixels), reinterpret_cast<setter>(CameraCaptureUIPhotoCaptureSettings_put_CroppedSizeInPixels), nullptr, nullptr },
        { "cropped_aspect_ratio", reinterpret_cast<getter>(CameraCaptureUIPhotoCaptureSettings_get_CroppedAspectRatio), reinterpret_cast<setter>(CameraCaptureUIPhotoCaptureSettings_put_CroppedAspectRatio), nullptr, nullptr },
        { "allow_cropping", reinterpret_cast<getter>(CameraCaptureUIPhotoCaptureSettings_get_AllowCropping), reinterpret_cast<setter>(CameraCaptureUIPhotoCaptureSettings_put_AllowCropping), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CameraCaptureUIPhotoCaptureSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CameraCaptureUIPhotoCaptureSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CameraCaptureUIPhotoCaptureSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CameraCaptureUIPhotoCaptureSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CameraCaptureUIPhotoCaptureSettings) },
        { },
    };

    static PyType_Spec type_spec_CameraCaptureUIPhotoCaptureSettings =
    {
        "_winsdk_Windows_Media_Capture.CameraCaptureUIPhotoCaptureSettings",
        sizeof(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraCaptureUIPhotoCaptureSettings
    };

    // ----- CameraCaptureUIVideoCaptureSettings class --------------------
    static constexpr const char* const type_name_CameraCaptureUIVideoCaptureSettings = "CameraCaptureUIVideoCaptureSettings";

    static PyObject* _new_CameraCaptureUIVideoCaptureSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CameraCaptureUIVideoCaptureSettings);
        return nullptr;
    }

    static void _dealloc_CameraCaptureUIVideoCaptureSettings(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CameraCaptureUIVideoCaptureSettings_get_MaxResolution(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIVideoCaptureSettings", L"MaxResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIVideoCaptureSettings_put_MaxResolution(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIVideoCaptureSettings", L"MaxResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::CameraCaptureUIMaxVideoResolution>(arg);

            self->obj.MaxResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIVideoCaptureSettings_get_MaxDurationInSeconds(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIVideoCaptureSettings", L"MaxDurationInSeconds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxDurationInSeconds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIVideoCaptureSettings_put_MaxDurationInSeconds(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIVideoCaptureSettings", L"MaxDurationInSeconds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.MaxDurationInSeconds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIVideoCaptureSettings_get_Format(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIVideoCaptureSettings", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIVideoCaptureSettings_put_Format(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIVideoCaptureSettings", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::CameraCaptureUIVideoFormat>(arg);

            self->obj.Format(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIVideoCaptureSettings_get_AllowTrimming(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIVideoCaptureSettings", L"AllowTrimming"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowTrimming());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIVideoCaptureSettings_put_AllowTrimming(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIVideoCaptureSettings", L"AllowTrimming"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowTrimming(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CameraCaptureUIVideoCaptureSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CameraCaptureUIVideoCaptureSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraCaptureUIVideoCaptureSettings[] = {
        { "_assign_array_", _assign_array_CameraCaptureUIVideoCaptureSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CameraCaptureUIVideoCaptureSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CameraCaptureUIVideoCaptureSettings[] = {
        { "max_resolution", reinterpret_cast<getter>(CameraCaptureUIVideoCaptureSettings_get_MaxResolution), reinterpret_cast<setter>(CameraCaptureUIVideoCaptureSettings_put_MaxResolution), nullptr, nullptr },
        { "max_duration_in_seconds", reinterpret_cast<getter>(CameraCaptureUIVideoCaptureSettings_get_MaxDurationInSeconds), reinterpret_cast<setter>(CameraCaptureUIVideoCaptureSettings_put_MaxDurationInSeconds), nullptr, nullptr },
        { "format", reinterpret_cast<getter>(CameraCaptureUIVideoCaptureSettings_get_Format), reinterpret_cast<setter>(CameraCaptureUIVideoCaptureSettings_put_Format), nullptr, nullptr },
        { "allow_trimming", reinterpret_cast<getter>(CameraCaptureUIVideoCaptureSettings_get_AllowTrimming), reinterpret_cast<setter>(CameraCaptureUIVideoCaptureSettings_put_AllowTrimming), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CameraCaptureUIVideoCaptureSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CameraCaptureUIVideoCaptureSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CameraCaptureUIVideoCaptureSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CameraCaptureUIVideoCaptureSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CameraCaptureUIVideoCaptureSettings) },
        { },
    };

    static PyType_Spec type_spec_CameraCaptureUIVideoCaptureSettings =
    {
        "_winsdk_Windows_Media_Capture.CameraCaptureUIVideoCaptureSettings",
        sizeof(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraCaptureUIVideoCaptureSettings
    };

    // ----- CameraOptionsUI class --------------------
    static constexpr const char* const type_name_CameraOptionsUI = "CameraOptionsUI";

    static PyObject* _new_CameraOptionsUI(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CameraOptionsUI);
        return nullptr;
    }

    static PyObject* CameraOptionsUI_Show(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.CameraOptionsUI", L"Show", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCapture>(args, 0);

                winrt::Windows::Media::Capture::CameraOptionsUI::Show(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraOptionsUI[] = {
        { "show", reinterpret_cast<PyCFunction>(CameraOptionsUI_Show), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CameraOptionsUI[] = {
        { }
    };

    static PyType_Slot _type_slots_CameraOptionsUI[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CameraOptionsUI) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CameraOptionsUI) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CameraOptionsUI) },
        { },
    };

    static PyType_Spec type_spec_CameraOptionsUI =
    {
        "_winsdk_Windows_Media_Capture.CameraOptionsUI",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraOptionsUI
    };

    // ----- CapturedFrame class --------------------
    static constexpr const char* const type_name_CapturedFrame = "CapturedFrame";

    static PyObject* _new_CapturedFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CapturedFrame);
        return nullptr;
    }

    static void _dealloc_CapturedFrame(py::wrapper::Windows::Media::Capture::CapturedFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CapturedFrame_CloneStream(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.CapturedFrame", L"CloneStream", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CloneStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_Close(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.CapturedFrame", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_FlushAsync(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.CapturedFrame", L"FlushAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_GetInputStreamAt(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.CapturedFrame", L"GetInputStreamAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetInputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_GetOutputStreamAt(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.CapturedFrame", L"GetOutputStreamAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetOutputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_ReadAsync(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.CapturedFrame", L"ReadAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

                return py::convert(self->obj.ReadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_Seek(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.CapturedFrame", L"Seek", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_WriteAsync(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.CapturedFrame", L"WriteAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_Height(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrame", L"Height"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_Width(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrame", L"Width"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_BitmapProperties(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrame", L"BitmapProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BitmapProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_ControlValues(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrame", L"ControlValues"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ControlValues());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_SoftwareBitmap(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrame", L"SoftwareBitmap"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SoftwareBitmap());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_ContentType(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrame", L"ContentType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_Size(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrame", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CapturedFrame_put_Size(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrame", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CapturedFrame_get_CanRead(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrame", L"CanRead"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_CanWrite(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrame", L"CanWrite"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanWrite());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_Position(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrame", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CapturedFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::CapturedFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CapturedFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::CapturedFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_CapturedFrame(py::wrapper::Windows::Media::Capture::CapturedFrame* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_CapturedFrame(py::wrapper::Windows::Media::Capture::CapturedFrame* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CapturedFrame[] = {
        { "clone_stream", reinterpret_cast<PyCFunction>(CapturedFrame_CloneStream), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(CapturedFrame_Close), METH_VARARGS, nullptr },
        { "flush_async", reinterpret_cast<PyCFunction>(CapturedFrame_FlushAsync), METH_VARARGS, nullptr },
        { "get_input_stream_at", reinterpret_cast<PyCFunction>(CapturedFrame_GetInputStreamAt), METH_VARARGS, nullptr },
        { "get_output_stream_at", reinterpret_cast<PyCFunction>(CapturedFrame_GetOutputStreamAt), METH_VARARGS, nullptr },
        { "read_async", reinterpret_cast<PyCFunction>(CapturedFrame_ReadAsync), METH_VARARGS, nullptr },
        { "seek", reinterpret_cast<PyCFunction>(CapturedFrame_Seek), METH_VARARGS, nullptr },
        { "write_async", reinterpret_cast<PyCFunction>(CapturedFrame_WriteAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CapturedFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CapturedFrame), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_CapturedFrame), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_CapturedFrame), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_CapturedFrame[] = {
        { "height", reinterpret_cast<getter>(CapturedFrame_get_Height), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(CapturedFrame_get_Width), nullptr, nullptr, nullptr },
        { "bitmap_properties", reinterpret_cast<getter>(CapturedFrame_get_BitmapProperties), nullptr, nullptr, nullptr },
        { "control_values", reinterpret_cast<getter>(CapturedFrame_get_ControlValues), nullptr, nullptr, nullptr },
        { "software_bitmap", reinterpret_cast<getter>(CapturedFrame_get_SoftwareBitmap), nullptr, nullptr, nullptr },
        { "content_type", reinterpret_cast<getter>(CapturedFrame_get_ContentType), nullptr, nullptr, nullptr },
        { "size", reinterpret_cast<getter>(CapturedFrame_get_Size), reinterpret_cast<setter>(CapturedFrame_put_Size), nullptr, nullptr },
        { "can_read", reinterpret_cast<getter>(CapturedFrame_get_CanRead), nullptr, nullptr, nullptr },
        { "can_write", reinterpret_cast<getter>(CapturedFrame_get_CanWrite), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(CapturedFrame_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CapturedFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CapturedFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CapturedFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CapturedFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CapturedFrame) },
        { },
    };

    static PyType_Spec type_spec_CapturedFrame =
    {
        "_winsdk_Windows_Media_Capture.CapturedFrame",
        sizeof(py::wrapper::Windows::Media::Capture::CapturedFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CapturedFrame
    };

    // ----- CapturedFrameControlValues class --------------------
    static constexpr const char* const type_name_CapturedFrameControlValues = "CapturedFrameControlValues";

    static PyObject* _new_CapturedFrameControlValues(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CapturedFrameControlValues);
        return nullptr;
    }

    static void _dealloc_CapturedFrameControlValues(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CapturedFrameControlValues_get_Exposure(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"Exposure"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Exposure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_ExposureCompensation(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"ExposureCompensation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExposureCompensation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_FlashPowerPercent(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"FlashPowerPercent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FlashPowerPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_Flashed(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"Flashed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Flashed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_Focus(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"Focus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Focus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_IsoSpeed(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"IsoSpeed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsoSpeed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_SceneMode(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"SceneMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SceneMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_WhiteBalance(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"WhiteBalance"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WhiteBalance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_ZoomFactor(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"ZoomFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZoomFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_FocusState(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"FocusState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FocusState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_IsoAnalogGain(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"IsoAnalogGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsoAnalogGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_IsoDigitalGain(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"IsoDigitalGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsoDigitalGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_SensorFrameRate(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"SensorFrameRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SensorFrameRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_WhiteBalanceGain(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"WhiteBalanceGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WhiteBalanceGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CapturedFrameControlValues(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::CapturedFrameControlValues>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CapturedFrameControlValues(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::CapturedFrameControlValues>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CapturedFrameControlValues[] = {
        { "_assign_array_", _assign_array_CapturedFrameControlValues, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CapturedFrameControlValues), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CapturedFrameControlValues[] = {
        { "exposure", reinterpret_cast<getter>(CapturedFrameControlValues_get_Exposure), nullptr, nullptr, nullptr },
        { "exposure_compensation", reinterpret_cast<getter>(CapturedFrameControlValues_get_ExposureCompensation), nullptr, nullptr, nullptr },
        { "flash_power_percent", reinterpret_cast<getter>(CapturedFrameControlValues_get_FlashPowerPercent), nullptr, nullptr, nullptr },
        { "flashed", reinterpret_cast<getter>(CapturedFrameControlValues_get_Flashed), nullptr, nullptr, nullptr },
        { "focus", reinterpret_cast<getter>(CapturedFrameControlValues_get_Focus), nullptr, nullptr, nullptr },
        { "iso_speed", reinterpret_cast<getter>(CapturedFrameControlValues_get_IsoSpeed), nullptr, nullptr, nullptr },
        { "scene_mode", reinterpret_cast<getter>(CapturedFrameControlValues_get_SceneMode), nullptr, nullptr, nullptr },
        { "white_balance", reinterpret_cast<getter>(CapturedFrameControlValues_get_WhiteBalance), nullptr, nullptr, nullptr },
        { "zoom_factor", reinterpret_cast<getter>(CapturedFrameControlValues_get_ZoomFactor), nullptr, nullptr, nullptr },
        { "focus_state", reinterpret_cast<getter>(CapturedFrameControlValues_get_FocusState), nullptr, nullptr, nullptr },
        { "iso_analog_gain", reinterpret_cast<getter>(CapturedFrameControlValues_get_IsoAnalogGain), nullptr, nullptr, nullptr },
        { "iso_digital_gain", reinterpret_cast<getter>(CapturedFrameControlValues_get_IsoDigitalGain), nullptr, nullptr, nullptr },
        { "sensor_frame_rate", reinterpret_cast<getter>(CapturedFrameControlValues_get_SensorFrameRate), nullptr, nullptr, nullptr },
        { "white_balance_gain", reinterpret_cast<getter>(CapturedFrameControlValues_get_WhiteBalanceGain), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CapturedFrameControlValues[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CapturedFrameControlValues) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CapturedFrameControlValues) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CapturedFrameControlValues) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CapturedFrameControlValues) },
        { },
    };

    static PyType_Spec type_spec_CapturedFrameControlValues =
    {
        "_winsdk_Windows_Media_Capture.CapturedFrameControlValues",
        sizeof(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CapturedFrameControlValues
    };

    // ----- CapturedPhoto class --------------------
    static constexpr const char* const type_name_CapturedPhoto = "CapturedPhoto";

    static PyObject* _new_CapturedPhoto(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CapturedPhoto);
        return nullptr;
    }

    static void _dealloc_CapturedPhoto(py::wrapper::Windows::Media::Capture::CapturedPhoto* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CapturedPhoto_get_Frame(py::wrapper::Windows::Media::Capture::CapturedPhoto* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedPhoto", L"Frame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedPhoto_get_Thumbnail(py::wrapper::Windows::Media::Capture::CapturedPhoto* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedPhoto", L"Thumbnail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CapturedPhoto(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::CapturedPhoto>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CapturedPhoto(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::CapturedPhoto>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CapturedPhoto[] = {
        { "_assign_array_", _assign_array_CapturedPhoto, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CapturedPhoto), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CapturedPhoto[] = {
        { "frame", reinterpret_cast<getter>(CapturedPhoto_get_Frame), nullptr, nullptr, nullptr },
        { "thumbnail", reinterpret_cast<getter>(CapturedPhoto_get_Thumbnail), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CapturedPhoto[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CapturedPhoto) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CapturedPhoto) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CapturedPhoto) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CapturedPhoto) },
        { },
    };

    static PyType_Spec type_spec_CapturedPhoto =
    {
        "_winsdk_Windows_Media_Capture.CapturedPhoto",
        sizeof(py::wrapper::Windows::Media::Capture::CapturedPhoto),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CapturedPhoto
    };

    // ----- GameBarServices class --------------------
    static constexpr const char* const type_name_GameBarServices = "GameBarServices";

    static PyObject* _new_GameBarServices(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_GameBarServices);
        return nullptr;
    }

    static void _dealloc_GameBarServices(py::wrapper::Windows::Media::Capture::GameBarServices* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GameBarServices_DisableCapture(py::wrapper::Windows::Media::Capture::GameBarServices* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.GameBarServices", L"DisableCapture", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.DisableCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GameBarServices_EnableCapture(py::wrapper::Windows::Media::Capture::GameBarServices* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.GameBarServices", L"EnableCapture", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.EnableCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GameBarServices_get_AppBroadcastServices(py::wrapper::Windows::Media::Capture::GameBarServices* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.GameBarServices", L"AppBroadcastServices"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppBroadcastServices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GameBarServices_get_AppCaptureServices(py::wrapper::Windows::Media::Capture::GameBarServices* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.GameBarServices", L"AppCaptureServices"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppCaptureServices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GameBarServices_get_SessionId(py::wrapper::Windows::Media::Capture::GameBarServices* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.GameBarServices", L"SessionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SessionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GameBarServices_get_TargetCapturePolicy(py::wrapper::Windows::Media::Capture::GameBarServices* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.GameBarServices", L"TargetCapturePolicy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetCapturePolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GameBarServices_get_TargetInfo(py::wrapper::Windows::Media::Capture::GameBarServices* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.GameBarServices", L"TargetInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GameBarServices_add_CommandReceived(py::wrapper::Windows::Media::Capture::GameBarServices* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.GameBarServices", L"CommandReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::GameBarServices, winrt::Windows::Media::Capture::GameBarServicesCommandEventArgs>>(arg);

            return py::convert(self->obj.CommandReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GameBarServices_remove_CommandReceived(py::wrapper::Windows::Media::Capture::GameBarServices* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.GameBarServices", L"CommandReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CommandReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GameBarServices(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::GameBarServices>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GameBarServices(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::GameBarServices>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GameBarServices[] = {
        { "disable_capture", reinterpret_cast<PyCFunction>(GameBarServices_DisableCapture), METH_VARARGS, nullptr },
        { "enable_capture", reinterpret_cast<PyCFunction>(GameBarServices_EnableCapture), METH_VARARGS, nullptr },
        { "add_command_received", reinterpret_cast<PyCFunction>(GameBarServices_add_CommandReceived), METH_O, nullptr },
        { "remove_command_received", reinterpret_cast<PyCFunction>(GameBarServices_remove_CommandReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_GameBarServices, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GameBarServices), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GameBarServices[] = {
        { "app_broadcast_services", reinterpret_cast<getter>(GameBarServices_get_AppBroadcastServices), nullptr, nullptr, nullptr },
        { "app_capture_services", reinterpret_cast<getter>(GameBarServices_get_AppCaptureServices), nullptr, nullptr, nullptr },
        { "session_id", reinterpret_cast<getter>(GameBarServices_get_SessionId), nullptr, nullptr, nullptr },
        { "target_capture_policy", reinterpret_cast<getter>(GameBarServices_get_TargetCapturePolicy), nullptr, nullptr, nullptr },
        { "target_info", reinterpret_cast<getter>(GameBarServices_get_TargetInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GameBarServices[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GameBarServices) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GameBarServices) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GameBarServices) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GameBarServices) },
        { },
    };

    static PyType_Spec type_spec_GameBarServices =
    {
        "_winsdk_Windows_Media_Capture.GameBarServices",
        sizeof(py::wrapper::Windows::Media::Capture::GameBarServices),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GameBarServices
    };

    // ----- GameBarServicesCommandEventArgs class --------------------
    static constexpr const char* const type_name_GameBarServicesCommandEventArgs = "GameBarServicesCommandEventArgs";

    static PyObject* _new_GameBarServicesCommandEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_GameBarServicesCommandEventArgs);
        return nullptr;
    }

    static void _dealloc_GameBarServicesCommandEventArgs(py::wrapper::Windows::Media::Capture::GameBarServicesCommandEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GameBarServicesCommandEventArgs_get_Command(py::wrapper::Windows::Media::Capture::GameBarServicesCommandEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.GameBarServicesCommandEventArgs", L"Command"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Command());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GameBarServicesCommandEventArgs_get_Origin(py::wrapper::Windows::Media::Capture::GameBarServicesCommandEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.GameBarServicesCommandEventArgs", L"Origin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Origin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GameBarServicesCommandEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::GameBarServicesCommandEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GameBarServicesCommandEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::GameBarServicesCommandEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GameBarServicesCommandEventArgs[] = {
        { "_assign_array_", _assign_array_GameBarServicesCommandEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GameBarServicesCommandEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GameBarServicesCommandEventArgs[] = {
        { "command", reinterpret_cast<getter>(GameBarServicesCommandEventArgs_get_Command), nullptr, nullptr, nullptr },
        { "origin", reinterpret_cast<getter>(GameBarServicesCommandEventArgs_get_Origin), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GameBarServicesCommandEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GameBarServicesCommandEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GameBarServicesCommandEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GameBarServicesCommandEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GameBarServicesCommandEventArgs) },
        { },
    };

    static PyType_Spec type_spec_GameBarServicesCommandEventArgs =
    {
        "_winsdk_Windows_Media_Capture.GameBarServicesCommandEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::GameBarServicesCommandEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GameBarServicesCommandEventArgs
    };

    // ----- GameBarServicesManager class --------------------
    static constexpr const char* const type_name_GameBarServicesManager = "GameBarServicesManager";

    static PyObject* _new_GameBarServicesManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_GameBarServicesManager);
        return nullptr;
    }

    static void _dealloc_GameBarServicesManager(py::wrapper::Windows::Media::Capture::GameBarServicesManager* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GameBarServicesManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.GameBarServicesManager", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::Capture::GameBarServicesManager::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GameBarServicesManager_add_GameBarServicesCreated(py::wrapper::Windows::Media::Capture::GameBarServicesManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.GameBarServicesManager", L"GameBarServicesCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::GameBarServicesManager, winrt::Windows::Media::Capture::GameBarServicesManagerGameBarServicesCreatedEventArgs>>(arg);

            return py::convert(self->obj.GameBarServicesCreated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GameBarServicesManager_remove_GameBarServicesCreated(py::wrapper::Windows::Media::Capture::GameBarServicesManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.GameBarServicesManager", L"GameBarServicesCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.GameBarServicesCreated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GameBarServicesManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::GameBarServicesManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GameBarServicesManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::GameBarServicesManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GameBarServicesManager[] = {
        { "get_default", reinterpret_cast<PyCFunction>(GameBarServicesManager_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "add_game_bar_services_created", reinterpret_cast<PyCFunction>(GameBarServicesManager_add_GameBarServicesCreated), METH_O, nullptr },
        { "remove_game_bar_services_created", reinterpret_cast<PyCFunction>(GameBarServicesManager_remove_GameBarServicesCreated), METH_O, nullptr },
        { "_assign_array_", _assign_array_GameBarServicesManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GameBarServicesManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GameBarServicesManager[] = {
        { }
    };

    static PyType_Slot _type_slots_GameBarServicesManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GameBarServicesManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GameBarServicesManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GameBarServicesManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GameBarServicesManager) },
        { },
    };

    static PyType_Spec type_spec_GameBarServicesManager =
    {
        "_winsdk_Windows_Media_Capture.GameBarServicesManager",
        sizeof(py::wrapper::Windows::Media::Capture::GameBarServicesManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GameBarServicesManager
    };

    // ----- GameBarServicesManagerGameBarServicesCreatedEventArgs class --------------------
    static constexpr const char* const type_name_GameBarServicesManagerGameBarServicesCreatedEventArgs = "GameBarServicesManagerGameBarServicesCreatedEventArgs";

    static PyObject* _new_GameBarServicesManagerGameBarServicesCreatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_GameBarServicesManagerGameBarServicesCreatedEventArgs);
        return nullptr;
    }

    static void _dealloc_GameBarServicesManagerGameBarServicesCreatedEventArgs(py::wrapper::Windows::Media::Capture::GameBarServicesManagerGameBarServicesCreatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GameBarServicesManagerGameBarServicesCreatedEventArgs_get_GameBarServices(py::wrapper::Windows::Media::Capture::GameBarServicesManagerGameBarServicesCreatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.GameBarServicesManagerGameBarServicesCreatedEventArgs", L"GameBarServices"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.GameBarServices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GameBarServicesManagerGameBarServicesCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::GameBarServicesManagerGameBarServicesCreatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GameBarServicesManagerGameBarServicesCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::GameBarServicesManagerGameBarServicesCreatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GameBarServicesManagerGameBarServicesCreatedEventArgs[] = {
        { "_assign_array_", _assign_array_GameBarServicesManagerGameBarServicesCreatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GameBarServicesManagerGameBarServicesCreatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GameBarServicesManagerGameBarServicesCreatedEventArgs[] = {
        { "game_bar_services", reinterpret_cast<getter>(GameBarServicesManagerGameBarServicesCreatedEventArgs_get_GameBarServices), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GameBarServicesManagerGameBarServicesCreatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GameBarServicesManagerGameBarServicesCreatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GameBarServicesManagerGameBarServicesCreatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GameBarServicesManagerGameBarServicesCreatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GameBarServicesManagerGameBarServicesCreatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_GameBarServicesManagerGameBarServicesCreatedEventArgs =
    {
        "_winsdk_Windows_Media_Capture.GameBarServicesManagerGameBarServicesCreatedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::GameBarServicesManagerGameBarServicesCreatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GameBarServicesManagerGameBarServicesCreatedEventArgs
    };

    // ----- GameBarServicesTargetInfo class --------------------
    static constexpr const char* const type_name_GameBarServicesTargetInfo = "GameBarServicesTargetInfo";

    static PyObject* _new_GameBarServicesTargetInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_GameBarServicesTargetInfo);
        return nullptr;
    }

    static void _dealloc_GameBarServicesTargetInfo(py::wrapper::Windows::Media::Capture::GameBarServicesTargetInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GameBarServicesTargetInfo_get_AppId(py::wrapper::Windows::Media::Capture::GameBarServicesTargetInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.GameBarServicesTargetInfo", L"AppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GameBarServicesTargetInfo_get_DisplayMode(py::wrapper::Windows::Media::Capture::GameBarServicesTargetInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.GameBarServicesTargetInfo", L"DisplayMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GameBarServicesTargetInfo_get_DisplayName(py::wrapper::Windows::Media::Capture::GameBarServicesTargetInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.GameBarServicesTargetInfo", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GameBarServicesTargetInfo_get_TitleId(py::wrapper::Windows::Media::Capture::GameBarServicesTargetInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.GameBarServicesTargetInfo", L"TitleId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TitleId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GameBarServicesTargetInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::GameBarServicesTargetInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GameBarServicesTargetInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::GameBarServicesTargetInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GameBarServicesTargetInfo[] = {
        { "_assign_array_", _assign_array_GameBarServicesTargetInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GameBarServicesTargetInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GameBarServicesTargetInfo[] = {
        { "app_id", reinterpret_cast<getter>(GameBarServicesTargetInfo_get_AppId), nullptr, nullptr, nullptr },
        { "display_mode", reinterpret_cast<getter>(GameBarServicesTargetInfo_get_DisplayMode), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(GameBarServicesTargetInfo_get_DisplayName), nullptr, nullptr, nullptr },
        { "title_id", reinterpret_cast<getter>(GameBarServicesTargetInfo_get_TitleId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GameBarServicesTargetInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GameBarServicesTargetInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GameBarServicesTargetInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GameBarServicesTargetInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GameBarServicesTargetInfo) },
        { },
    };

    static PyType_Spec type_spec_GameBarServicesTargetInfo =
    {
        "_winsdk_Windows_Media_Capture.GameBarServicesTargetInfo",
        sizeof(py::wrapper::Windows::Media::Capture::GameBarServicesTargetInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GameBarServicesTargetInfo
    };

    // ----- LowLagMediaRecording class --------------------
    static constexpr const char* const type_name_LowLagMediaRecording = "LowLagMediaRecording";

    static PyObject* _new_LowLagMediaRecording(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LowLagMediaRecording);
        return nullptr;
    }

    static void _dealloc_LowLagMediaRecording(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LowLagMediaRecording_FinishAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.LowLagMediaRecording", L"FinishAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FinishAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagMediaRecording_PauseAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.LowLagMediaRecording", L"PauseAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::MediaCapturePauseBehavior>(args, 0);

                return py::convert(self->obj.PauseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagMediaRecording_PauseWithResultAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.LowLagMediaRecording", L"PauseWithResultAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::MediaCapturePauseBehavior>(args, 0);

                return py::convert(self->obj.PauseWithResultAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagMediaRecording_ResumeAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.LowLagMediaRecording", L"ResumeAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ResumeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagMediaRecording_StartAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.LowLagMediaRecording", L"StartAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagMediaRecording_StopAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.LowLagMediaRecording", L"StopAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StopAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagMediaRecording_StopWithResultAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.LowLagMediaRecording", L"StopWithResultAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StopWithResultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_LowLagMediaRecording(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::LowLagMediaRecording>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LowLagMediaRecording(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::LowLagMediaRecording>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLagMediaRecording[] = {
        { "finish_async", reinterpret_cast<PyCFunction>(LowLagMediaRecording_FinishAsync), METH_VARARGS, nullptr },
        { "pause_async", reinterpret_cast<PyCFunction>(LowLagMediaRecording_PauseAsync), METH_VARARGS, nullptr },
        { "pause_with_result_async", reinterpret_cast<PyCFunction>(LowLagMediaRecording_PauseWithResultAsync), METH_VARARGS, nullptr },
        { "resume_async", reinterpret_cast<PyCFunction>(LowLagMediaRecording_ResumeAsync), METH_VARARGS, nullptr },
        { "start_async", reinterpret_cast<PyCFunction>(LowLagMediaRecording_StartAsync), METH_VARARGS, nullptr },
        { "stop_async", reinterpret_cast<PyCFunction>(LowLagMediaRecording_StopAsync), METH_VARARGS, nullptr },
        { "stop_with_result_async", reinterpret_cast<PyCFunction>(LowLagMediaRecording_StopWithResultAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LowLagMediaRecording, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LowLagMediaRecording), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LowLagMediaRecording[] = {
        { }
    };

    static PyType_Slot _type_slots_LowLagMediaRecording[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LowLagMediaRecording) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LowLagMediaRecording) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LowLagMediaRecording) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LowLagMediaRecording) },
        { },
    };

    static PyType_Spec type_spec_LowLagMediaRecording =
    {
        "_winsdk_Windows_Media_Capture.LowLagMediaRecording",
        sizeof(py::wrapper::Windows::Media::Capture::LowLagMediaRecording),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLagMediaRecording
    };

    // ----- LowLagPhotoCapture class --------------------
    static constexpr const char* const type_name_LowLagPhotoCapture = "LowLagPhotoCapture";

    static PyObject* _new_LowLagPhotoCapture(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LowLagPhotoCapture);
        return nullptr;
    }

    static void _dealloc_LowLagPhotoCapture(py::wrapper::Windows::Media::Capture::LowLagPhotoCapture* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LowLagPhotoCapture_CaptureAsync(py::wrapper::Windows::Media::Capture::LowLagPhotoCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.LowLagPhotoCapture", L"CaptureAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CaptureAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoCapture_FinishAsync(py::wrapper::Windows::Media::Capture::LowLagPhotoCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.LowLagPhotoCapture", L"FinishAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FinishAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_LowLagPhotoCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::LowLagPhotoCapture>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LowLagPhotoCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::LowLagPhotoCapture>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLagPhotoCapture[] = {
        { "capture_async", reinterpret_cast<PyCFunction>(LowLagPhotoCapture_CaptureAsync), METH_VARARGS, nullptr },
        { "finish_async", reinterpret_cast<PyCFunction>(LowLagPhotoCapture_FinishAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LowLagPhotoCapture, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LowLagPhotoCapture), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LowLagPhotoCapture[] = {
        { }
    };

    static PyType_Slot _type_slots_LowLagPhotoCapture[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LowLagPhotoCapture) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LowLagPhotoCapture) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LowLagPhotoCapture) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LowLagPhotoCapture) },
        { },
    };

    static PyType_Spec type_spec_LowLagPhotoCapture =
    {
        "_winsdk_Windows_Media_Capture.LowLagPhotoCapture",
        sizeof(py::wrapper::Windows::Media::Capture::LowLagPhotoCapture),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLagPhotoCapture
    };

    // ----- LowLagPhotoSequenceCapture class --------------------
    static constexpr const char* const type_name_LowLagPhotoSequenceCapture = "LowLagPhotoSequenceCapture";

    static PyObject* _new_LowLagPhotoSequenceCapture(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LowLagPhotoSequenceCapture);
        return nullptr;
    }

    static void _dealloc_LowLagPhotoSequenceCapture(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LowLagPhotoSequenceCapture_FinishAsync(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.LowLagPhotoSequenceCapture", L"FinishAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FinishAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceCapture_StartAsync(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.LowLagPhotoSequenceCapture", L"StartAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceCapture_StopAsync(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.LowLagPhotoSequenceCapture", L"StopAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StopAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceCapture_add_PhotoCaptured(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.LowLagPhotoSequenceCapture", L"PhotoCaptured"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::LowLagPhotoSequenceCapture, winrt::Windows::Media::Capture::PhotoCapturedEventArgs>>(arg);

            return py::convert(self->obj.PhotoCaptured(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceCapture_remove_PhotoCaptured(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.LowLagPhotoSequenceCapture", L"PhotoCaptured"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PhotoCaptured(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LowLagPhotoSequenceCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::LowLagPhotoSequenceCapture>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LowLagPhotoSequenceCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::LowLagPhotoSequenceCapture>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLagPhotoSequenceCapture[] = {
        { "finish_async", reinterpret_cast<PyCFunction>(LowLagPhotoSequenceCapture_FinishAsync), METH_VARARGS, nullptr },
        { "start_async", reinterpret_cast<PyCFunction>(LowLagPhotoSequenceCapture_StartAsync), METH_VARARGS, nullptr },
        { "stop_async", reinterpret_cast<PyCFunction>(LowLagPhotoSequenceCapture_StopAsync), METH_VARARGS, nullptr },
        { "add_photo_captured", reinterpret_cast<PyCFunction>(LowLagPhotoSequenceCapture_add_PhotoCaptured), METH_O, nullptr },
        { "remove_photo_captured", reinterpret_cast<PyCFunction>(LowLagPhotoSequenceCapture_remove_PhotoCaptured), METH_O, nullptr },
        { "_assign_array_", _assign_array_LowLagPhotoSequenceCapture, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LowLagPhotoSequenceCapture), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LowLagPhotoSequenceCapture[] = {
        { }
    };

    static PyType_Slot _type_slots_LowLagPhotoSequenceCapture[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LowLagPhotoSequenceCapture) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LowLagPhotoSequenceCapture) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LowLagPhotoSequenceCapture) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LowLagPhotoSequenceCapture) },
        { },
    };

    static PyType_Spec type_spec_LowLagPhotoSequenceCapture =
    {
        "_winsdk_Windows_Media_Capture.LowLagPhotoSequenceCapture",
        sizeof(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLagPhotoSequenceCapture
    };

    // ----- MediaCapture class --------------------
    static constexpr const char* const type_name_MediaCapture = "MediaCapture";

    static PyObject* _new_MediaCapture(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Capture::MediaCapture instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaCapture(py::wrapper::Windows::Media::Capture::MediaCapture* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaCapture_AddAudioEffectAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"AddAudioEffectAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                return py::convert(self->obj.AddAudioEffectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_AddEffectAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"AddEffectAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);

                return py::convert(self->obj.AddEffectAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_AddVideoEffectAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"AddVideoEffectAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IVideoEffectDefinition>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 1);

                return py::convert(self->obj.AddVideoEffectAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_CapturePhotoToStorageFileAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"CapturePhotoToStorageFileAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);

                return py::convert(self->obj.CapturePhotoToStorageFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_CapturePhotoToStreamAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"CapturePhotoToStreamAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                return py::convert(self->obj.CapturePhotoToStreamAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_ClearEffectsAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"ClearEffectsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);

                return py::convert(self->obj.ClearEffectsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_Close(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_CreateFrameReaderAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"CreateFrameReaderAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::Frames::MediaFrameSource>(args, 0);

                return py::convert(self->obj.CreateFrameReaderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"CreateFrameReaderAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::Frames::MediaFrameSource>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CreateFrameReaderAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"CreateFrameReaderAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::Frames::MediaFrameSource>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapSize>(args, 2);

                return py::convert(self->obj.CreateFrameReaderAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_CreateMultiSourceFrameReaderAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"CreateMultiSourceFrameReaderAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Media::Capture::Frames::MediaFrameSource>>(args, 0);

                return py::convert(self->obj.CreateMultiSourceFrameReaderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_CreateRelativePanelWatcher(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"CreateRelativePanelWatcher", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::StreamingCaptureMode>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::WindowManagement::DisplayRegion>(args, 1);

                return py::convert(self->obj.CreateRelativePanelWatcher(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_FindAllVideoProfiles(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"FindAllVideoProfiles", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Capture::MediaCapture::FindAllVideoProfiles(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_FindConcurrentProfiles(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"FindConcurrentProfiles", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Capture::MediaCapture::FindConcurrentProfiles(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_FindKnownVideoProfiles(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"FindKnownVideoProfiles", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Capture::KnownVideoProfile>(args, 1);

                return py::convert(winrt::Windows::Media::Capture::MediaCapture::FindKnownVideoProfiles(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_GetEncoderProperty(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"GetEncoderProperty", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);

                return py::convert(self->obj.GetEncoderProperty(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_GetPreviewFrameAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"GetPreviewFrameAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetPreviewFrameAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"GetPreviewFrameAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::VideoFrame>(args, 0);

                return py::convert(self->obj.GetPreviewFrameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_GetPreviewMirroring(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"GetPreviewMirroring", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetPreviewMirroring());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_GetPreviewRotation(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"GetPreviewRotation", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetPreviewRotation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_GetRecordRotation(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"GetRecordRotation", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetRecordRotation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_InitializeAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"InitializeAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.InitializeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"InitializeAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureInitializationSettings>(args, 0);

                return py::convert(self->obj.InitializeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_IsVideoProfileSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"IsVideoProfileSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Capture::MediaCapture::IsVideoProfileSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PauseRecordAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"PauseRecordAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::MediaCapturePauseBehavior>(args, 0);

                return py::convert(self->obj.PauseRecordAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PauseRecordWithResultAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"PauseRecordWithResultAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::MediaCapturePauseBehavior>(args, 0);

                return py::convert(self->obj.PauseRecordWithResultAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareAdvancedPhotoCaptureAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"PrepareAdvancedPhotoCaptureAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>(args, 0);

                return py::convert(self->obj.PrepareAdvancedPhotoCaptureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareLowLagPhotoCaptureAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"PrepareLowLagPhotoCaptureAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>(args, 0);

                return py::convert(self->obj.PrepareLowLagPhotoCaptureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareLowLagPhotoSequenceCaptureAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"PrepareLowLagPhotoSequenceCaptureAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>(args, 0);

                return py::convert(self->obj.PrepareLowLagPhotoSequenceCaptureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareLowLagRecordToCustomSinkAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"PrepareLowLagRecordToCustomSinkAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::IMediaExtension>(args, 1);

                return py::convert(self->obj.PrepareLowLagRecordToCustomSinkAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"PrepareLowLagRecordToCustomSinkAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);

                return py::convert(self->obj.PrepareLowLagRecordToCustomSinkAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareLowLagRecordToStorageFileAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"PrepareLowLagRecordToStorageFileAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);

                return py::convert(self->obj.PrepareLowLagRecordToStorageFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareLowLagRecordToStreamAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"PrepareLowLagRecordToStreamAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                return py::convert(self->obj.PrepareLowLagRecordToStreamAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareVariablePhotoSequenceCaptureAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"PrepareVariablePhotoSequenceCaptureAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>(args, 0);

                return py::convert(self->obj.PrepareVariablePhotoSequenceCaptureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_RemoveEffectAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"RemoveEffectAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::IMediaExtension>(args, 0);

                return py::convert(self->obj.RemoveEffectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_ResumeRecordAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"ResumeRecordAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ResumeRecordAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_SetEncoderProperty(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"SetEncoderProperty", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);

                self->obj.SetEncoderProperty(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_SetEncodingPropertiesAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"SetEncodingPropertiesAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaPropertySet>(args, 2);

                return py::convert(self->obj.SetEncodingPropertiesAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_SetPreviewMirroring(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"SetPreviewMirroring", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.SetPreviewMirroring(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_SetPreviewRotation(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"SetPreviewRotation", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::VideoRotation>(args, 0);

                self->obj.SetPreviewRotation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_SetRecordRotation(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"SetRecordRotation", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::VideoRotation>(args, 0);

                self->obj.SetRecordRotation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StartPreviewAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"StartPreviewAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StartPreviewAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StartPreviewToCustomSinkAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"StartPreviewToCustomSinkAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::IMediaExtension>(args, 1);

                return py::convert(self->obj.StartPreviewToCustomSinkAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"StartPreviewToCustomSinkAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);

                return py::convert(self->obj.StartPreviewToCustomSinkAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StartRecordToCustomSinkAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"StartRecordToCustomSinkAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::IMediaExtension>(args, 1);

                return py::convert(self->obj.StartRecordToCustomSinkAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"StartRecordToCustomSinkAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);

                return py::convert(self->obj.StartRecordToCustomSinkAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StartRecordToStorageFileAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"StartRecordToStorageFileAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);

                return py::convert(self->obj.StartRecordToStorageFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StartRecordToStreamAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"StartRecordToStreamAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                return py::convert(self->obj.StartRecordToStreamAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StopPreviewAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"StopPreviewAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StopPreviewAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StopRecordAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"StopRecordAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StopRecordAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StopRecordWithResultAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"StopRecordWithResultAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StopRecordWithResultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_get_AudioDeviceController(py::wrapper::Windows::Media::Capture::MediaCapture* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCapture", L"AudioDeviceController"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioDeviceController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_get_MediaCaptureSettings(py::wrapper::Windows::Media::Capture::MediaCapture* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCapture", L"MediaCaptureSettings"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MediaCaptureSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_get_VideoDeviceController(py::wrapper::Windows::Media::Capture::MediaCapture* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCapture", L"VideoDeviceController"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoDeviceController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_get_CameraStreamState(py::wrapper::Windows::Media::Capture::MediaCapture* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCapture", L"CameraStreamState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CameraStreamState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_get_ThermalStatus(py::wrapper::Windows::Media::Capture::MediaCapture* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCapture", L"ThermalStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ThermalStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_get_FrameSources(py::wrapper::Windows::Media::Capture::MediaCapture* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCapture", L"FrameSources"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameSources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_Failed(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"Failed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureFailedEventHandler>(arg);

            return py::convert(self->obj.Failed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_Failed(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"Failed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Failed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_RecordLimitationExceeded(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"RecordLimitationExceeded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::RecordLimitationExceededEventHandler>(arg);

            return py::convert(self->obj.RecordLimitationExceeded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_RecordLimitationExceeded(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"RecordLimitationExceeded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RecordLimitationExceeded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_FocusChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"FocusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::MediaCapture, winrt::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs>>(arg);

            return py::convert(self->obj.FocusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_FocusChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"FocusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FocusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_PhotoConfirmationCaptured(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"PhotoConfirmationCaptured"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::MediaCapture, winrt::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs>>(arg);

            return py::convert(self->obj.PhotoConfirmationCaptured(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_PhotoConfirmationCaptured(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"PhotoConfirmationCaptured"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PhotoConfirmationCaptured(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_CameraStreamStateChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"CameraStreamStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::MediaCapture, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CameraStreamStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_CameraStreamStateChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"CameraStreamStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CameraStreamStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_ThermalStatusChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"ThermalStatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::MediaCapture, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ThermalStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_ThermalStatusChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"ThermalStatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ThermalStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_CaptureDeviceExclusiveControlStatusChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"CaptureDeviceExclusiveControlStatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::MediaCapture, winrt::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs>>(arg);

            return py::convert(self->obj.CaptureDeviceExclusiveControlStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_CaptureDeviceExclusiveControlStatusChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"CaptureDeviceExclusiveControlStatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CaptureDeviceExclusiveControlStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::MediaCapture>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCapture>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaCapture(py::wrapper::Windows::Media::Capture::MediaCapture* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_MediaCapture(py::wrapper::Windows::Media::Capture::MediaCapture* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCapture[] = {
        { "add_audio_effect_async", reinterpret_cast<PyCFunction>(MediaCapture_AddAudioEffectAsync), METH_VARARGS, nullptr },
        { "add_effect_async", reinterpret_cast<PyCFunction>(MediaCapture_AddEffectAsync), METH_VARARGS, nullptr },
        { "add_video_effect_async", reinterpret_cast<PyCFunction>(MediaCapture_AddVideoEffectAsync), METH_VARARGS, nullptr },
        { "capture_photo_to_storage_file_async", reinterpret_cast<PyCFunction>(MediaCapture_CapturePhotoToStorageFileAsync), METH_VARARGS, nullptr },
        { "capture_photo_to_stream_async", reinterpret_cast<PyCFunction>(MediaCapture_CapturePhotoToStreamAsync), METH_VARARGS, nullptr },
        { "clear_effects_async", reinterpret_cast<PyCFunction>(MediaCapture_ClearEffectsAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(MediaCapture_Close), METH_VARARGS, nullptr },
        { "create_frame_reader_async", reinterpret_cast<PyCFunction>(MediaCapture_CreateFrameReaderAsync), METH_VARARGS, nullptr },
        { "create_multi_source_frame_reader_async", reinterpret_cast<PyCFunction>(MediaCapture_CreateMultiSourceFrameReaderAsync), METH_VARARGS, nullptr },
        { "create_relative_panel_watcher", reinterpret_cast<PyCFunction>(MediaCapture_CreateRelativePanelWatcher), METH_VARARGS, nullptr },
        { "find_all_video_profiles", reinterpret_cast<PyCFunction>(MediaCapture_FindAllVideoProfiles), METH_VARARGS | METH_STATIC, nullptr },
        { "find_concurrent_profiles", reinterpret_cast<PyCFunction>(MediaCapture_FindConcurrentProfiles), METH_VARARGS | METH_STATIC, nullptr },
        { "find_known_video_profiles", reinterpret_cast<PyCFunction>(MediaCapture_FindKnownVideoProfiles), METH_VARARGS | METH_STATIC, nullptr },
        { "get_encoder_property", reinterpret_cast<PyCFunction>(MediaCapture_GetEncoderProperty), METH_VARARGS, nullptr },
        { "get_preview_frame_async", reinterpret_cast<PyCFunction>(MediaCapture_GetPreviewFrameAsync), METH_VARARGS, nullptr },
        { "get_preview_mirroring", reinterpret_cast<PyCFunction>(MediaCapture_GetPreviewMirroring), METH_VARARGS, nullptr },
        { "get_preview_rotation", reinterpret_cast<PyCFunction>(MediaCapture_GetPreviewRotation), METH_VARARGS, nullptr },
        { "get_record_rotation", reinterpret_cast<PyCFunction>(MediaCapture_GetRecordRotation), METH_VARARGS, nullptr },
        { "initialize_async", reinterpret_cast<PyCFunction>(MediaCapture_InitializeAsync), METH_VARARGS, nullptr },
        { "is_video_profile_supported", reinterpret_cast<PyCFunction>(MediaCapture_IsVideoProfileSupported), METH_VARARGS | METH_STATIC, nullptr },
        { "pause_record_async", reinterpret_cast<PyCFunction>(MediaCapture_PauseRecordAsync), METH_VARARGS, nullptr },
        { "pause_record_with_result_async", reinterpret_cast<PyCFunction>(MediaCapture_PauseRecordWithResultAsync), METH_VARARGS, nullptr },
        { "prepare_advanced_photo_capture_async", reinterpret_cast<PyCFunction>(MediaCapture_PrepareAdvancedPhotoCaptureAsync), METH_VARARGS, nullptr },
        { "prepare_low_lag_photo_capture_async", reinterpret_cast<PyCFunction>(MediaCapture_PrepareLowLagPhotoCaptureAsync), METH_VARARGS, nullptr },
        { "prepare_low_lag_photo_sequence_capture_async", reinterpret_cast<PyCFunction>(MediaCapture_PrepareLowLagPhotoSequenceCaptureAsync), METH_VARARGS, nullptr },
        { "prepare_low_lag_record_to_custom_sink_async", reinterpret_cast<PyCFunction>(MediaCapture_PrepareLowLagRecordToCustomSinkAsync), METH_VARARGS, nullptr },
        { "prepare_low_lag_record_to_storage_file_async", reinterpret_cast<PyCFunction>(MediaCapture_PrepareLowLagRecordToStorageFileAsync), METH_VARARGS, nullptr },
        { "prepare_low_lag_record_to_stream_async", reinterpret_cast<PyCFunction>(MediaCapture_PrepareLowLagRecordToStreamAsync), METH_VARARGS, nullptr },
        { "prepare_variable_photo_sequence_capture_async", reinterpret_cast<PyCFunction>(MediaCapture_PrepareVariablePhotoSequenceCaptureAsync), METH_VARARGS, nullptr },
        { "remove_effect_async", reinterpret_cast<PyCFunction>(MediaCapture_RemoveEffectAsync), METH_VARARGS, nullptr },
        { "resume_record_async", reinterpret_cast<PyCFunction>(MediaCapture_ResumeRecordAsync), METH_VARARGS, nullptr },
        { "set_encoder_property", reinterpret_cast<PyCFunction>(MediaCapture_SetEncoderProperty), METH_VARARGS, nullptr },
        { "set_encoding_properties_async", reinterpret_cast<PyCFunction>(MediaCapture_SetEncodingPropertiesAsync), METH_VARARGS, nullptr },
        { "set_preview_mirroring", reinterpret_cast<PyCFunction>(MediaCapture_SetPreviewMirroring), METH_VARARGS, nullptr },
        { "set_preview_rotation", reinterpret_cast<PyCFunction>(MediaCapture_SetPreviewRotation), METH_VARARGS, nullptr },
        { "set_record_rotation", reinterpret_cast<PyCFunction>(MediaCapture_SetRecordRotation), METH_VARARGS, nullptr },
        { "start_preview_async", reinterpret_cast<PyCFunction>(MediaCapture_StartPreviewAsync), METH_VARARGS, nullptr },
        { "start_preview_to_custom_sink_async", reinterpret_cast<PyCFunction>(MediaCapture_StartPreviewToCustomSinkAsync), METH_VARARGS, nullptr },
        { "start_record_to_custom_sink_async", reinterpret_cast<PyCFunction>(MediaCapture_StartRecordToCustomSinkAsync), METH_VARARGS, nullptr },
        { "start_record_to_storage_file_async", reinterpret_cast<PyCFunction>(MediaCapture_StartRecordToStorageFileAsync), METH_VARARGS, nullptr },
        { "start_record_to_stream_async", reinterpret_cast<PyCFunction>(MediaCapture_StartRecordToStreamAsync), METH_VARARGS, nullptr },
        { "stop_preview_async", reinterpret_cast<PyCFunction>(MediaCapture_StopPreviewAsync), METH_VARARGS, nullptr },
        { "stop_record_async", reinterpret_cast<PyCFunction>(MediaCapture_StopRecordAsync), METH_VARARGS, nullptr },
        { "stop_record_with_result_async", reinterpret_cast<PyCFunction>(MediaCapture_StopRecordWithResultAsync), METH_VARARGS, nullptr },
        { "add_failed", reinterpret_cast<PyCFunction>(MediaCapture_add_Failed), METH_O, nullptr },
        { "remove_failed", reinterpret_cast<PyCFunction>(MediaCapture_remove_Failed), METH_O, nullptr },
        { "add_record_limitation_exceeded", reinterpret_cast<PyCFunction>(MediaCapture_add_RecordLimitationExceeded), METH_O, nullptr },
        { "remove_record_limitation_exceeded", reinterpret_cast<PyCFunction>(MediaCapture_remove_RecordLimitationExceeded), METH_O, nullptr },
        { "add_focus_changed", reinterpret_cast<PyCFunction>(MediaCapture_add_FocusChanged), METH_O, nullptr },
        { "remove_focus_changed", reinterpret_cast<PyCFunction>(MediaCapture_remove_FocusChanged), METH_O, nullptr },
        { "add_photo_confirmation_captured", reinterpret_cast<PyCFunction>(MediaCapture_add_PhotoConfirmationCaptured), METH_O, nullptr },
        { "remove_photo_confirmation_captured", reinterpret_cast<PyCFunction>(MediaCapture_remove_PhotoConfirmationCaptured), METH_O, nullptr },
        { "add_camera_stream_state_changed", reinterpret_cast<PyCFunction>(MediaCapture_add_CameraStreamStateChanged), METH_O, nullptr },
        { "remove_camera_stream_state_changed", reinterpret_cast<PyCFunction>(MediaCapture_remove_CameraStreamStateChanged), METH_O, nullptr },
        { "add_thermal_status_changed", reinterpret_cast<PyCFunction>(MediaCapture_add_ThermalStatusChanged), METH_O, nullptr },
        { "remove_thermal_status_changed", reinterpret_cast<PyCFunction>(MediaCapture_remove_ThermalStatusChanged), METH_O, nullptr },
        { "add_capture_device_exclusive_control_status_changed", reinterpret_cast<PyCFunction>(MediaCapture_add_CaptureDeviceExclusiveControlStatusChanged), METH_O, nullptr },
        { "remove_capture_device_exclusive_control_status_changed", reinterpret_cast<PyCFunction>(MediaCapture_remove_CaptureDeviceExclusiveControlStatusChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaCapture, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCapture), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MediaCapture), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MediaCapture), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCapture[] = {
        { "audio_device_controller", reinterpret_cast<getter>(MediaCapture_get_AudioDeviceController), nullptr, nullptr, nullptr },
        { "media_capture_settings", reinterpret_cast<getter>(MediaCapture_get_MediaCaptureSettings), nullptr, nullptr, nullptr },
        { "video_device_controller", reinterpret_cast<getter>(MediaCapture_get_VideoDeviceController), nullptr, nullptr, nullptr },
        { "camera_stream_state", reinterpret_cast<getter>(MediaCapture_get_CameraStreamState), nullptr, nullptr, nullptr },
        { "thermal_status", reinterpret_cast<getter>(MediaCapture_get_ThermalStatus), nullptr, nullptr, nullptr },
        { "frame_sources", reinterpret_cast<getter>(MediaCapture_get_FrameSources), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCapture[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaCapture) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaCapture) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaCapture) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaCapture) },
        { },
    };

    static PyType_Spec type_spec_MediaCapture =
    {
        "_winsdk_Windows_Media_Capture.MediaCapture",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCapture),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCapture
    };

    // ----- MediaCaptureDeviceExclusiveControlStatusChangedEventArgs class --------------------
    static constexpr const char* const type_name_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs = "MediaCaptureDeviceExclusiveControlStatusChangedEventArgs";

    static PyObject* _new_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs(py::wrapper::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaCaptureDeviceExclusiveControlStatusChangedEventArgs_get_DeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureDeviceExclusiveControlStatusChangedEventArgs", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureDeviceExclusiveControlStatusChangedEventArgs_get_Status(py::wrapper::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureDeviceExclusiveControlStatusChangedEventArgs", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs[] = {
        { "device_id", reinterpret_cast<getter>(MediaCaptureDeviceExclusiveControlStatusChangedEventArgs_get_DeviceId), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(MediaCaptureDeviceExclusiveControlStatusChangedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs =
    {
        "_winsdk_Windows_Media_Capture.MediaCaptureDeviceExclusiveControlStatusChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs
    };

    // ----- MediaCaptureFailedEventArgs class --------------------
    static constexpr const char* const type_name_MediaCaptureFailedEventArgs = "MediaCaptureFailedEventArgs";

    static PyObject* _new_MediaCaptureFailedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaCaptureFailedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaCaptureFailedEventArgs(py::wrapper::Windows::Media::Capture::MediaCaptureFailedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaCaptureFailedEventArgs_get_Code(py::wrapper::Windows::Media::Capture::MediaCaptureFailedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureFailedEventArgs", L"Code"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Code());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureFailedEventArgs_get_Message(py::wrapper::Windows::Media::Capture::MediaCaptureFailedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureFailedEventArgs", L"Message"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaCaptureFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::MediaCaptureFailedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaCaptureFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureFailedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaCaptureFailedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCaptureFailedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCaptureFailedEventArgs[] = {
        { "code", reinterpret_cast<getter>(MediaCaptureFailedEventArgs_get_Code), nullptr, nullptr, nullptr },
        { "message", reinterpret_cast<getter>(MediaCaptureFailedEventArgs_get_Message), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCaptureFailedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaCaptureFailedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaCaptureFailedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaCaptureFailedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaCaptureFailedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaCaptureFailedEventArgs =
    {
        "_winsdk_Windows_Media_Capture.MediaCaptureFailedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureFailedEventArgs
    };

    // ----- MediaCaptureFocusChangedEventArgs class --------------------
    static constexpr const char* const type_name_MediaCaptureFocusChangedEventArgs = "MediaCaptureFocusChangedEventArgs";

    static PyObject* _new_MediaCaptureFocusChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaCaptureFocusChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaCaptureFocusChangedEventArgs(py::wrapper::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaCaptureFocusChangedEventArgs_get_FocusState(py::wrapper::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureFocusChangedEventArgs", L"FocusState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FocusState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaCaptureFocusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaCaptureFocusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureFocusChangedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaCaptureFocusChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCaptureFocusChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCaptureFocusChangedEventArgs[] = {
        { "focus_state", reinterpret_cast<getter>(MediaCaptureFocusChangedEventArgs_get_FocusState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCaptureFocusChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaCaptureFocusChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaCaptureFocusChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaCaptureFocusChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaCaptureFocusChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaCaptureFocusChangedEventArgs =
    {
        "_winsdk_Windows_Media_Capture.MediaCaptureFocusChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureFocusChangedEventArgs
    };

    // ----- MediaCaptureInitializationSettings class --------------------
    static constexpr const char* const type_name_MediaCaptureInitializationSettings = "MediaCaptureInitializationSettings";

    static PyObject* _new_MediaCaptureInitializationSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Capture::MediaCaptureInitializationSettings instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaCaptureInitializationSettings(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaCaptureInitializationSettings_get_VideoDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"VideoDeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_VideoDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"VideoDeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.VideoDeviceId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_StreamingCaptureMode(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"StreamingCaptureMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StreamingCaptureMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_StreamingCaptureMode(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"StreamingCaptureMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::StreamingCaptureMode>(arg);

            self->obj.StreamingCaptureMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_PhotoCaptureSource(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"PhotoCaptureSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhotoCaptureSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_PhotoCaptureSource(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"PhotoCaptureSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::PhotoCaptureSource>(arg);

            self->obj.PhotoCaptureSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_AudioDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"AudioDeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_AudioDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"AudioDeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AudioDeviceId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_MediaCategory(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"MediaCategory"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MediaCategory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_MediaCategory(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"MediaCategory"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(arg);

            self->obj.MediaCategory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_AudioProcessing(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"AudioProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_AudioProcessing(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"AudioProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::AudioProcessing>(arg);

            self->obj.AudioProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_VideoSource(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"VideoSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_VideoSource(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"VideoSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaSource>(arg);

            self->obj.VideoSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_AudioSource(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"AudioSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_AudioSource(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"AudioSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaSource>(arg);

            self->obj.AudioSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_VideoProfile(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"VideoProfile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_VideoProfile(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"VideoProfile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureVideoProfile>(arg);

            self->obj.VideoProfile(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_RecordMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"RecordMediaDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RecordMediaDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_RecordMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"RecordMediaDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription>(arg);

            self->obj.RecordMediaDescription(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_PreviewMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"PreviewMediaDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviewMediaDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_PreviewMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"PreviewMediaDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription>(arg);

            self->obj.PreviewMediaDescription(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_PhotoMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"PhotoMediaDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhotoMediaDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_PhotoMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"PhotoMediaDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription>(arg);

            self->obj.PhotoMediaDescription(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_SourceGroup(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"SourceGroup"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_SourceGroup(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"SourceGroup"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::Frames::MediaFrameSourceGroup>(arg);

            self->obj.SourceGroup(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_SharingMode(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"SharingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SharingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_SharingMode(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"SharingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureSharingMode>(arg);

            self->obj.SharingMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_MemoryPreference(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"MemoryPreference"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MemoryPreference());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_MemoryPreference(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"MemoryPreference"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureMemoryPreference>(arg);

            self->obj.MemoryPreference(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_AlwaysPlaySystemShutterSound(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"AlwaysPlaySystemShutterSound"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AlwaysPlaySystemShutterSound());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_AlwaysPlaySystemShutterSound(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"AlwaysPlaySystemShutterSound"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AlwaysPlaySystemShutterSound(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_DeviceUriPasswordCredential(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"DeviceUriPasswordCredential"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceUriPasswordCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_DeviceUriPasswordCredential(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"DeviceUriPasswordCredential"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.DeviceUriPasswordCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_DeviceUri(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"DeviceUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_DeviceUri(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"DeviceUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.DeviceUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MediaCaptureInitializationSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::MediaCaptureInitializationSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaCaptureInitializationSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureInitializationSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureInitializationSettings[] = {
        { "_assign_array_", _assign_array_MediaCaptureInitializationSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCaptureInitializationSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCaptureInitializationSettings[] = {
        { "video_device_id", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_VideoDeviceId), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_VideoDeviceId), nullptr, nullptr },
        { "streaming_capture_mode", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_StreamingCaptureMode), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_StreamingCaptureMode), nullptr, nullptr },
        { "photo_capture_source", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_PhotoCaptureSource), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_PhotoCaptureSource), nullptr, nullptr },
        { "audio_device_id", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_AudioDeviceId), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_AudioDeviceId), nullptr, nullptr },
        { "media_category", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_MediaCategory), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_MediaCategory), nullptr, nullptr },
        { "audio_processing", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_AudioProcessing), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_AudioProcessing), nullptr, nullptr },
        { "video_source", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_VideoSource), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_VideoSource), nullptr, nullptr },
        { "audio_source", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_AudioSource), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_AudioSource), nullptr, nullptr },
        { "video_profile", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_VideoProfile), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_VideoProfile), nullptr, nullptr },
        { "record_media_description", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_RecordMediaDescription), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_RecordMediaDescription), nullptr, nullptr },
        { "preview_media_description", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_PreviewMediaDescription), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_PreviewMediaDescription), nullptr, nullptr },
        { "photo_media_description", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_PhotoMediaDescription), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_PhotoMediaDescription), nullptr, nullptr },
        { "source_group", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_SourceGroup), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_SourceGroup), nullptr, nullptr },
        { "sharing_mode", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_SharingMode), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_SharingMode), nullptr, nullptr },
        { "memory_preference", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_MemoryPreference), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_MemoryPreference), nullptr, nullptr },
        { "always_play_system_shutter_sound", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_AlwaysPlaySystemShutterSound), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_AlwaysPlaySystemShutterSound), nullptr, nullptr },
        { "device_uri_password_credential", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_DeviceUriPasswordCredential), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_DeviceUriPasswordCredential), nullptr, nullptr },
        { "device_uri", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_DeviceUri), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_DeviceUri), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCaptureInitializationSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaCaptureInitializationSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaCaptureInitializationSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaCaptureInitializationSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaCaptureInitializationSettings) },
        { },
    };

    static PyType_Spec type_spec_MediaCaptureInitializationSettings =
    {
        "_winsdk_Windows_Media_Capture.MediaCaptureInitializationSettings",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureInitializationSettings
    };

    // ----- MediaCapturePauseResult class --------------------
    static constexpr const char* const type_name_MediaCapturePauseResult = "MediaCapturePauseResult";

    static PyObject* _new_MediaCapturePauseResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaCapturePauseResult);
        return nullptr;
    }

    static void _dealloc_MediaCapturePauseResult(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaCapturePauseResult_Close(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapturePauseResult", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapturePauseResult_get_LastFrame(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCapturePauseResult", L"LastFrame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LastFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapturePauseResult_get_RecordDuration(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCapturePauseResult", L"RecordDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RecordDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaCapturePauseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::MediaCapturePauseResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaCapturePauseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCapturePauseResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaCapturePauseResult(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_MediaCapturePauseResult(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCapturePauseResult[] = {
        { "close", reinterpret_cast<PyCFunction>(MediaCapturePauseResult_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaCapturePauseResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCapturePauseResult), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MediaCapturePauseResult), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MediaCapturePauseResult), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCapturePauseResult[] = {
        { "last_frame", reinterpret_cast<getter>(MediaCapturePauseResult_get_LastFrame), nullptr, nullptr, nullptr },
        { "record_duration", reinterpret_cast<getter>(MediaCapturePauseResult_get_RecordDuration), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCapturePauseResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaCapturePauseResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaCapturePauseResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaCapturePauseResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaCapturePauseResult) },
        { },
    };

    static PyType_Spec type_spec_MediaCapturePauseResult =
    {
        "_winsdk_Windows_Media_Capture.MediaCapturePauseResult",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCapturePauseResult
    };

    // ----- MediaCaptureRelativePanelWatcher class --------------------
    static constexpr const char* const type_name_MediaCaptureRelativePanelWatcher = "MediaCaptureRelativePanelWatcher";

    static PyObject* _new_MediaCaptureRelativePanelWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaCaptureRelativePanelWatcher);
        return nullptr;
    }

    static void _dealloc_MediaCaptureRelativePanelWatcher(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaCaptureRelativePanelWatcher_Close(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCaptureRelativePanelWatcher", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCaptureRelativePanelWatcher_Start(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCaptureRelativePanelWatcher", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCaptureRelativePanelWatcher_Stop(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCaptureRelativePanelWatcher", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCaptureRelativePanelWatcher_get_RelativePanel(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureRelativePanelWatcher", L"RelativePanel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RelativePanel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureRelativePanelWatcher_add_Changed(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCaptureRelativePanelWatcher", L"Changed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::MediaCaptureRelativePanelWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Changed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureRelativePanelWatcher_remove_Changed(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCaptureRelativePanelWatcher", L"Changed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Changed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaCaptureRelativePanelWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::MediaCaptureRelativePanelWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaCaptureRelativePanelWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureRelativePanelWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaCaptureRelativePanelWatcher(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_MediaCaptureRelativePanelWatcher(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureRelativePanelWatcher[] = {
        { "close", reinterpret_cast<PyCFunction>(MediaCaptureRelativePanelWatcher_Close), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(MediaCaptureRelativePanelWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(MediaCaptureRelativePanelWatcher_Stop), METH_VARARGS, nullptr },
        { "add_changed", reinterpret_cast<PyCFunction>(MediaCaptureRelativePanelWatcher_add_Changed), METH_O, nullptr },
        { "remove_changed", reinterpret_cast<PyCFunction>(MediaCaptureRelativePanelWatcher_remove_Changed), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaCaptureRelativePanelWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCaptureRelativePanelWatcher), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MediaCaptureRelativePanelWatcher), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MediaCaptureRelativePanelWatcher), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCaptureRelativePanelWatcher[] = {
        { "relative_panel", reinterpret_cast<getter>(MediaCaptureRelativePanelWatcher_get_RelativePanel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCaptureRelativePanelWatcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaCaptureRelativePanelWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaCaptureRelativePanelWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaCaptureRelativePanelWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaCaptureRelativePanelWatcher) },
        { },
    };

    static PyType_Spec type_spec_MediaCaptureRelativePanelWatcher =
    {
        "_winsdk_Windows_Media_Capture.MediaCaptureRelativePanelWatcher",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureRelativePanelWatcher
    };

    // ----- MediaCaptureSettings class --------------------
    static constexpr const char* const type_name_MediaCaptureSettings = "MediaCaptureSettings";

    static PyObject* _new_MediaCaptureSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaCaptureSettings);
        return nullptr;
    }

    static void _dealloc_MediaCaptureSettings(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaCaptureSettings_get_AudioDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"AudioDeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_PhotoCaptureSource(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"PhotoCaptureSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhotoCaptureSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_StreamingCaptureMode(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"StreamingCaptureMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StreamingCaptureMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_VideoDeviceCharacteristic(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"VideoDeviceCharacteristic"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoDeviceCharacteristic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_VideoDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"VideoDeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_AudioProcessing(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"AudioProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_CameraSoundRequiredForRegion(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"CameraSoundRequiredForRegion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CameraSoundRequiredForRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_ConcurrentRecordAndPhotoSequenceSupported(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"ConcurrentRecordAndPhotoSequenceSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConcurrentRecordAndPhotoSequenceSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_ConcurrentRecordAndPhotoSupported(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"ConcurrentRecordAndPhotoSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConcurrentRecordAndPhotoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_Horizontal35mmEquivalentFocalLength(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"Horizontal35mmEquivalentFocalLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Horizontal35mmEquivalentFocalLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_MediaCategory(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"MediaCategory"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MediaCategory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_PitchOffsetDegrees(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"PitchOffsetDegrees"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PitchOffsetDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_Vertical35mmEquivalentFocalLength(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"Vertical35mmEquivalentFocalLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Vertical35mmEquivalentFocalLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_Direct3D11Device(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"Direct3D11Device"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Direct3D11Device());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaCaptureSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::MediaCaptureSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaCaptureSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureSettings[] = {
        { "_assign_array_", _assign_array_MediaCaptureSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCaptureSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCaptureSettings[] = {
        { "audio_device_id", reinterpret_cast<getter>(MediaCaptureSettings_get_AudioDeviceId), nullptr, nullptr, nullptr },
        { "photo_capture_source", reinterpret_cast<getter>(MediaCaptureSettings_get_PhotoCaptureSource), nullptr, nullptr, nullptr },
        { "streaming_capture_mode", reinterpret_cast<getter>(MediaCaptureSettings_get_StreamingCaptureMode), nullptr, nullptr, nullptr },
        { "video_device_characteristic", reinterpret_cast<getter>(MediaCaptureSettings_get_VideoDeviceCharacteristic), nullptr, nullptr, nullptr },
        { "video_device_id", reinterpret_cast<getter>(MediaCaptureSettings_get_VideoDeviceId), nullptr, nullptr, nullptr },
        { "audio_processing", reinterpret_cast<getter>(MediaCaptureSettings_get_AudioProcessing), nullptr, nullptr, nullptr },
        { "camera_sound_required_for_region", reinterpret_cast<getter>(MediaCaptureSettings_get_CameraSoundRequiredForRegion), nullptr, nullptr, nullptr },
        { "concurrent_record_and_photo_sequence_supported", reinterpret_cast<getter>(MediaCaptureSettings_get_ConcurrentRecordAndPhotoSequenceSupported), nullptr, nullptr, nullptr },
        { "concurrent_record_and_photo_supported", reinterpret_cast<getter>(MediaCaptureSettings_get_ConcurrentRecordAndPhotoSupported), nullptr, nullptr, nullptr },
        { "horizontal35mm_equivalent_focal_length", reinterpret_cast<getter>(MediaCaptureSettings_get_Horizontal35mmEquivalentFocalLength), nullptr, nullptr, nullptr },
        { "media_category", reinterpret_cast<getter>(MediaCaptureSettings_get_MediaCategory), nullptr, nullptr, nullptr },
        { "pitch_offset_degrees", reinterpret_cast<getter>(MediaCaptureSettings_get_PitchOffsetDegrees), nullptr, nullptr, nullptr },
        { "vertical35mm_equivalent_focal_length", reinterpret_cast<getter>(MediaCaptureSettings_get_Vertical35mmEquivalentFocalLength), nullptr, nullptr, nullptr },
        { "direct3_d11_device", reinterpret_cast<getter>(MediaCaptureSettings_get_Direct3D11Device), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCaptureSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaCaptureSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaCaptureSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaCaptureSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaCaptureSettings) },
        { },
    };

    static PyType_Spec type_spec_MediaCaptureSettings =
    {
        "_winsdk_Windows_Media_Capture.MediaCaptureSettings",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureSettings
    };

    // ----- MediaCaptureStopResult class --------------------
    static constexpr const char* const type_name_MediaCaptureStopResult = "MediaCaptureStopResult";

    static PyObject* _new_MediaCaptureStopResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaCaptureStopResult);
        return nullptr;
    }

    static void _dealloc_MediaCaptureStopResult(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaCaptureStopResult_Close(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCaptureStopResult", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCaptureStopResult_get_LastFrame(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureStopResult", L"LastFrame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LastFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureStopResult_get_RecordDuration(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureStopResult", L"RecordDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RecordDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaCaptureStopResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::MediaCaptureStopResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaCaptureStopResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureStopResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaCaptureStopResult(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_MediaCaptureStopResult(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureStopResult[] = {
        { "close", reinterpret_cast<PyCFunction>(MediaCaptureStopResult_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaCaptureStopResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCaptureStopResult), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MediaCaptureStopResult), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MediaCaptureStopResult), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCaptureStopResult[] = {
        { "last_frame", reinterpret_cast<getter>(MediaCaptureStopResult_get_LastFrame), nullptr, nullptr, nullptr },
        { "record_duration", reinterpret_cast<getter>(MediaCaptureStopResult_get_RecordDuration), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCaptureStopResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaCaptureStopResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaCaptureStopResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaCaptureStopResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaCaptureStopResult) },
        { },
    };

    static PyType_Spec type_spec_MediaCaptureStopResult =
    {
        "_winsdk_Windows_Media_Capture.MediaCaptureStopResult",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureStopResult
    };

    // ----- MediaCaptureVideoProfile class --------------------
    static constexpr const char* const type_name_MediaCaptureVideoProfile = "MediaCaptureVideoProfile";

    static PyObject* _new_MediaCaptureVideoProfile(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaCaptureVideoProfile);
        return nullptr;
    }

    static void _dealloc_MediaCaptureVideoProfile(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaCaptureVideoProfile_GetConcurrency(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCaptureVideoProfile", L"GetConcurrency", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetConcurrency());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_Id(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfile", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_SupportedPhotoMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfile", L"SupportedPhotoMediaDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedPhotoMediaDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_SupportedPreviewMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfile", L"SupportedPreviewMediaDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedPreviewMediaDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_SupportedRecordMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfile", L"SupportedRecordMediaDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedRecordMediaDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_VideoDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfile", L"VideoDeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_FrameSourceInfos(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfile", L"FrameSourceInfos"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameSourceInfos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_Properties(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfile", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaCaptureVideoProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::MediaCaptureVideoProfile>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaCaptureVideoProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureVideoProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureVideoProfile[] = {
        { "get_concurrency", reinterpret_cast<PyCFunction>(MediaCaptureVideoProfile_GetConcurrency), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaCaptureVideoProfile, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCaptureVideoProfile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCaptureVideoProfile[] = {
        { "id", reinterpret_cast<getter>(MediaCaptureVideoProfile_get_Id), nullptr, nullptr, nullptr },
        { "supported_photo_media_description", reinterpret_cast<getter>(MediaCaptureVideoProfile_get_SupportedPhotoMediaDescription), nullptr, nullptr, nullptr },
        { "supported_preview_media_description", reinterpret_cast<getter>(MediaCaptureVideoProfile_get_SupportedPreviewMediaDescription), nullptr, nullptr, nullptr },
        { "supported_record_media_description", reinterpret_cast<getter>(MediaCaptureVideoProfile_get_SupportedRecordMediaDescription), nullptr, nullptr, nullptr },
        { "video_device_id", reinterpret_cast<getter>(MediaCaptureVideoProfile_get_VideoDeviceId), nullptr, nullptr, nullptr },
        { "frame_source_infos", reinterpret_cast<getter>(MediaCaptureVideoProfile_get_FrameSourceInfos), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(MediaCaptureVideoProfile_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCaptureVideoProfile[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaCaptureVideoProfile) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaCaptureVideoProfile) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaCaptureVideoProfile) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaCaptureVideoProfile) },
        { },
    };

    static PyType_Spec type_spec_MediaCaptureVideoProfile =
    {
        "_winsdk_Windows_Media_Capture.MediaCaptureVideoProfile",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureVideoProfile
    };

    // ----- MediaCaptureVideoProfileMediaDescription class --------------------
    static constexpr const char* const type_name_MediaCaptureVideoProfileMediaDescription = "MediaCaptureVideoProfileMediaDescription";

    static PyObject* _new_MediaCaptureVideoProfileMediaDescription(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaCaptureVideoProfileMediaDescription);
        return nullptr;
    }

    static void _dealloc_MediaCaptureVideoProfileMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_FrameRate(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription", L"FrameRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_Height(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription", L"Height"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_IsHdrVideoSupported(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription", L"IsHdrVideoSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsHdrVideoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_IsVariablePhotoSequenceSupported(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription", L"IsVariablePhotoSequenceSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsVariablePhotoSequenceSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_Width(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription", L"Width"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_Properties(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_Subtype(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription", L"Subtype"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaCaptureVideoProfileMediaDescription(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaCaptureVideoProfileMediaDescription(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureVideoProfileMediaDescription[] = {
        { "_assign_array_", _assign_array_MediaCaptureVideoProfileMediaDescription, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCaptureVideoProfileMediaDescription), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCaptureVideoProfileMediaDescription[] = {
        { "frame_rate", reinterpret_cast<getter>(MediaCaptureVideoProfileMediaDescription_get_FrameRate), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(MediaCaptureVideoProfileMediaDescription_get_Height), nullptr, nullptr, nullptr },
        { "is_hdr_video_supported", reinterpret_cast<getter>(MediaCaptureVideoProfileMediaDescription_get_IsHdrVideoSupported), nullptr, nullptr, nullptr },
        { "is_variable_photo_sequence_supported", reinterpret_cast<getter>(MediaCaptureVideoProfileMediaDescription_get_IsVariablePhotoSequenceSupported), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(MediaCaptureVideoProfileMediaDescription_get_Width), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(MediaCaptureVideoProfileMediaDescription_get_Properties), nullptr, nullptr, nullptr },
        { "subtype", reinterpret_cast<getter>(MediaCaptureVideoProfileMediaDescription_get_Subtype), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCaptureVideoProfileMediaDescription[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaCaptureVideoProfileMediaDescription) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaCaptureVideoProfileMediaDescription) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaCaptureVideoProfileMediaDescription) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaCaptureVideoProfileMediaDescription) },
        { },
    };

    static PyType_Spec type_spec_MediaCaptureVideoProfileMediaDescription =
    {
        "_winsdk_Windows_Media_Capture.MediaCaptureVideoProfileMediaDescription",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureVideoProfileMediaDescription
    };

    // ----- OptionalReferencePhotoCapturedEventArgs class --------------------
    static constexpr const char* const type_name_OptionalReferencePhotoCapturedEventArgs = "OptionalReferencePhotoCapturedEventArgs";

    static PyObject* _new_OptionalReferencePhotoCapturedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_OptionalReferencePhotoCapturedEventArgs);
        return nullptr;
    }

    static void _dealloc_OptionalReferencePhotoCapturedEventArgs(py::wrapper::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* OptionalReferencePhotoCapturedEventArgs_get_Context(py::wrapper::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.OptionalReferencePhotoCapturedEventArgs", L"Context"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Context());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OptionalReferencePhotoCapturedEventArgs_get_Frame(py::wrapper::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.OptionalReferencePhotoCapturedEventArgs", L"Frame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_OptionalReferencePhotoCapturedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_OptionalReferencePhotoCapturedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_OptionalReferencePhotoCapturedEventArgs[] = {
        { "_assign_array_", _assign_array_OptionalReferencePhotoCapturedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_OptionalReferencePhotoCapturedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_OptionalReferencePhotoCapturedEventArgs[] = {
        { "context", reinterpret_cast<getter>(OptionalReferencePhotoCapturedEventArgs_get_Context), nullptr, nullptr, nullptr },
        { "frame", reinterpret_cast<getter>(OptionalReferencePhotoCapturedEventArgs_get_Frame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_OptionalReferencePhotoCapturedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_OptionalReferencePhotoCapturedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_OptionalReferencePhotoCapturedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_OptionalReferencePhotoCapturedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_OptionalReferencePhotoCapturedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_OptionalReferencePhotoCapturedEventArgs =
    {
        "_winsdk_Windows_Media_Capture.OptionalReferencePhotoCapturedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_OptionalReferencePhotoCapturedEventArgs
    };

    // ----- PhotoCapturedEventArgs class --------------------
    static constexpr const char* const type_name_PhotoCapturedEventArgs = "PhotoCapturedEventArgs";

    static PyObject* _new_PhotoCapturedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PhotoCapturedEventArgs);
        return nullptr;
    }

    static void _dealloc_PhotoCapturedEventArgs(py::wrapper::Windows::Media::Capture::PhotoCapturedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoCapturedEventArgs_get_CaptureTimeOffset(py::wrapper::Windows::Media::Capture::PhotoCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.PhotoCapturedEventArgs", L"CaptureTimeOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CaptureTimeOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoCapturedEventArgs_get_Frame(py::wrapper::Windows::Media::Capture::PhotoCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.PhotoCapturedEventArgs", L"Frame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoCapturedEventArgs_get_Thumbnail(py::wrapper::Windows::Media::Capture::PhotoCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.PhotoCapturedEventArgs", L"Thumbnail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoCapturedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::PhotoCapturedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoCapturedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::PhotoCapturedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoCapturedEventArgs[] = {
        { "_assign_array_", _assign_array_PhotoCapturedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoCapturedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhotoCapturedEventArgs[] = {
        { "capture_time_offset", reinterpret_cast<getter>(PhotoCapturedEventArgs_get_CaptureTimeOffset), nullptr, nullptr, nullptr },
        { "frame", reinterpret_cast<getter>(PhotoCapturedEventArgs_get_Frame), nullptr, nullptr, nullptr },
        { "thumbnail", reinterpret_cast<getter>(PhotoCapturedEventArgs_get_Thumbnail), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhotoCapturedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoCapturedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoCapturedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoCapturedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoCapturedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PhotoCapturedEventArgs =
    {
        "_winsdk_Windows_Media_Capture.PhotoCapturedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::PhotoCapturedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoCapturedEventArgs
    };

    // ----- PhotoConfirmationCapturedEventArgs class --------------------
    static constexpr const char* const type_name_PhotoConfirmationCapturedEventArgs = "PhotoConfirmationCapturedEventArgs";

    static PyObject* _new_PhotoConfirmationCapturedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PhotoConfirmationCapturedEventArgs);
        return nullptr;
    }

    static void _dealloc_PhotoConfirmationCapturedEventArgs(py::wrapper::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoConfirmationCapturedEventArgs_get_CaptureTimeOffset(py::wrapper::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.PhotoConfirmationCapturedEventArgs", L"CaptureTimeOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CaptureTimeOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoConfirmationCapturedEventArgs_get_Frame(py::wrapper::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.PhotoConfirmationCapturedEventArgs", L"Frame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoConfirmationCapturedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoConfirmationCapturedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoConfirmationCapturedEventArgs[] = {
        { "_assign_array_", _assign_array_PhotoConfirmationCapturedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoConfirmationCapturedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhotoConfirmationCapturedEventArgs[] = {
        { "capture_time_offset", reinterpret_cast<getter>(PhotoConfirmationCapturedEventArgs_get_CaptureTimeOffset), nullptr, nullptr, nullptr },
        { "frame", reinterpret_cast<getter>(PhotoConfirmationCapturedEventArgs_get_Frame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhotoConfirmationCapturedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoConfirmationCapturedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoConfirmationCapturedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoConfirmationCapturedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoConfirmationCapturedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PhotoConfirmationCapturedEventArgs =
    {
        "_winsdk_Windows_Media_Capture.PhotoConfirmationCapturedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoConfirmationCapturedEventArgs
    };

    // ----- ScreenCapture class --------------------
    static constexpr const char* const type_name_ScreenCapture = "ScreenCapture";

    static PyObject* _new_ScreenCapture(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ScreenCapture);
        return nullptr;
    }

    static void _dealloc_ScreenCapture(py::wrapper::Windows::Media::Capture::ScreenCapture* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScreenCapture_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.ScreenCapture", L"GetForCurrentView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::Capture::ScreenCapture::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScreenCapture_get_AudioSource(py::wrapper::Windows::Media::Capture::ScreenCapture* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.ScreenCapture", L"AudioSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScreenCapture_get_IsAudioSuspended(py::wrapper::Windows::Media::Capture::ScreenCapture* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.ScreenCapture", L"IsAudioSuspended"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsAudioSuspended());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScreenCapture_get_IsVideoSuspended(py::wrapper::Windows::Media::Capture::ScreenCapture* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.ScreenCapture", L"IsVideoSuspended"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsVideoSuspended());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScreenCapture_get_VideoSource(py::wrapper::Windows::Media::Capture::ScreenCapture* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.ScreenCapture", L"VideoSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScreenCapture_add_SourceSuspensionChanged(py::wrapper::Windows::Media::Capture::ScreenCapture* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.ScreenCapture", L"SourceSuspensionChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::ScreenCapture, winrt::Windows::Media::Capture::SourceSuspensionChangedEventArgs>>(arg);

            return py::convert(self->obj.SourceSuspensionChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScreenCapture_remove_SourceSuspensionChanged(py::wrapper::Windows::Media::Capture::ScreenCapture* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.ScreenCapture", L"SourceSuspensionChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceSuspensionChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScreenCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::ScreenCapture>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScreenCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::ScreenCapture>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScreenCapture[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(ScreenCapture_GetForCurrentView), METH_VARARGS | METH_STATIC, nullptr },
        { "add_source_suspension_changed", reinterpret_cast<PyCFunction>(ScreenCapture_add_SourceSuspensionChanged), METH_O, nullptr },
        { "remove_source_suspension_changed", reinterpret_cast<PyCFunction>(ScreenCapture_remove_SourceSuspensionChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ScreenCapture, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScreenCapture), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScreenCapture[] = {
        { "audio_source", reinterpret_cast<getter>(ScreenCapture_get_AudioSource), nullptr, nullptr, nullptr },
        { "is_audio_suspended", reinterpret_cast<getter>(ScreenCapture_get_IsAudioSuspended), nullptr, nullptr, nullptr },
        { "is_video_suspended", reinterpret_cast<getter>(ScreenCapture_get_IsVideoSuspended), nullptr, nullptr, nullptr },
        { "video_source", reinterpret_cast<getter>(ScreenCapture_get_VideoSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScreenCapture[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScreenCapture) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScreenCapture) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScreenCapture) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScreenCapture) },
        { },
    };

    static PyType_Spec type_spec_ScreenCapture =
    {
        "_winsdk_Windows_Media_Capture.ScreenCapture",
        sizeof(py::wrapper::Windows::Media::Capture::ScreenCapture),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScreenCapture
    };

    // ----- SourceSuspensionChangedEventArgs class --------------------
    static constexpr const char* const type_name_SourceSuspensionChangedEventArgs = "SourceSuspensionChangedEventArgs";

    static PyObject* _new_SourceSuspensionChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SourceSuspensionChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_SourceSuspensionChangedEventArgs(py::wrapper::Windows::Media::Capture::SourceSuspensionChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SourceSuspensionChangedEventArgs_get_IsAudioSuspended(py::wrapper::Windows::Media::Capture::SourceSuspensionChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.SourceSuspensionChangedEventArgs", L"IsAudioSuspended"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsAudioSuspended());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SourceSuspensionChangedEventArgs_get_IsVideoSuspended(py::wrapper::Windows::Media::Capture::SourceSuspensionChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.SourceSuspensionChangedEventArgs", L"IsVideoSuspended"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsVideoSuspended());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SourceSuspensionChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::SourceSuspensionChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SourceSuspensionChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::SourceSuspensionChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SourceSuspensionChangedEventArgs[] = {
        { "_assign_array_", _assign_array_SourceSuspensionChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SourceSuspensionChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SourceSuspensionChangedEventArgs[] = {
        { "is_audio_suspended", reinterpret_cast<getter>(SourceSuspensionChangedEventArgs_get_IsAudioSuspended), nullptr, nullptr, nullptr },
        { "is_video_suspended", reinterpret_cast<getter>(SourceSuspensionChangedEventArgs_get_IsVideoSuspended), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SourceSuspensionChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SourceSuspensionChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SourceSuspensionChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SourceSuspensionChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SourceSuspensionChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SourceSuspensionChangedEventArgs =
    {
        "_winsdk_Windows_Media_Capture.SourceSuspensionChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::SourceSuspensionChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SourceSuspensionChangedEventArgs
    };

    // ----- VideoStreamConfiguration class --------------------
    static constexpr const char* const type_name_VideoStreamConfiguration = "VideoStreamConfiguration";

    static PyObject* _new_VideoStreamConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_VideoStreamConfiguration);
        return nullptr;
    }

    static void _dealloc_VideoStreamConfiguration(py::wrapper::Windows::Media::Capture::VideoStreamConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoStreamConfiguration_get_InputProperties(py::wrapper::Windows::Media::Capture::VideoStreamConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.VideoStreamConfiguration", L"InputProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoStreamConfiguration_get_OutputProperties(py::wrapper::Windows::Media::Capture::VideoStreamConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.VideoStreamConfiguration", L"OutputProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutputProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoStreamConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::VideoStreamConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoStreamConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::VideoStreamConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoStreamConfiguration[] = {
        { "_assign_array_", _assign_array_VideoStreamConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoStreamConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoStreamConfiguration[] = {
        { "input_properties", reinterpret_cast<getter>(VideoStreamConfiguration_get_InputProperties), nullptr, nullptr, nullptr },
        { "output_properties", reinterpret_cast<getter>(VideoStreamConfiguration_get_OutputProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoStreamConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoStreamConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoStreamConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoStreamConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoStreamConfiguration) },
        { },
    };

    static PyType_Spec type_spec_VideoStreamConfiguration =
    {
        "_winsdk_Windows_Media_Capture.VideoStreamConfiguration",
        sizeof(py::wrapper::Windows::Media::Capture::VideoStreamConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoStreamConfiguration
    };

    // ----- WhiteBalanceGain struct --------------------
    static constexpr const char* const type_name_WhiteBalanceGain = "WhiteBalanceGain";

    PyObject* _new_WhiteBalanceGain(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Media::Capture::WhiteBalanceGain return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        double _R{};
        double _G{};
        double _B{};

        static const char* kwlist[] = {"r", "g", "b", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ddd", const_cast<char**>(kwlist), &_R, &_G, &_B))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Media::Capture::WhiteBalanceGain return_value{ _R, _G, _B };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_WhiteBalanceGain(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self) noexcept
    {
    }

    static PyObject* WhiteBalanceGain_get_R(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.R);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WhiteBalanceGain_set_R(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.R = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WhiteBalanceGain_get_G(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.G);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WhiteBalanceGain_set_G(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.G = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WhiteBalanceGain_get_B(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.B);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WhiteBalanceGain_set_B(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.B = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_WhiteBalanceGain[] = {
        { "r", reinterpret_cast<getter>(WhiteBalanceGain_get_R), reinterpret_cast<setter>(WhiteBalanceGain_set_R), nullptr, nullptr },
        { "g", reinterpret_cast<getter>(WhiteBalanceGain_get_G), reinterpret_cast<setter>(WhiteBalanceGain_set_G), nullptr, nullptr },
        { "b", reinterpret_cast<getter>(WhiteBalanceGain_get_B), reinterpret_cast<setter>(WhiteBalanceGain_set_B), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WhiteBalanceGain[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WhiteBalanceGain) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WhiteBalanceGain) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WhiteBalanceGain) },
        { },
    };

    static PyType_Spec type_spec_WhiteBalanceGain =
    {
        "_winsdk_Windows_Media_Capture.WhiteBalanceGain",
        sizeof(py::wrapper::Windows::Media::Capture::WhiteBalanceGain),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WhiteBalanceGain
    };

    // ----- Windows.Media.Capture Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Media::Capture");

    static PyMethodDef module_methods[] = {
        {"_register_AppBroadcastCameraCaptureState", register_AppBroadcastCameraCaptureState, METH_O, "registers type"},
        {"_register_AppBroadcastCameraOverlayLocation", register_AppBroadcastCameraOverlayLocation, METH_O, "registers type"},
        {"_register_AppBroadcastCameraOverlaySize", register_AppBroadcastCameraOverlaySize, METH_O, "registers type"},
        {"_register_AppBroadcastCaptureTargetType", register_AppBroadcastCaptureTargetType, METH_O, "registers type"},
        {"_register_AppBroadcastExitBroadcastModeReason", register_AppBroadcastExitBroadcastModeReason, METH_O, "registers type"},
        {"_register_AppBroadcastMicrophoneCaptureState", register_AppBroadcastMicrophoneCaptureState, METH_O, "registers type"},
        {"_register_AppBroadcastPlugInState", register_AppBroadcastPlugInState, METH_O, "registers type"},
        {"_register_AppBroadcastPreviewState", register_AppBroadcastPreviewState, METH_O, "registers type"},
        {"_register_AppBroadcastSignInResult", register_AppBroadcastSignInResult, METH_O, "registers type"},
        {"_register_AppBroadcastSignInState", register_AppBroadcastSignInState, METH_O, "registers type"},
        {"_register_AppBroadcastStreamState", register_AppBroadcastStreamState, METH_O, "registers type"},
        {"_register_AppBroadcastTerminationReason", register_AppBroadcastTerminationReason, METH_O, "registers type"},
        {"_register_AppBroadcastVideoEncodingBitrateMode", register_AppBroadcastVideoEncodingBitrateMode, METH_O, "registers type"},
        {"_register_AppBroadcastVideoEncodingResolutionMode", register_AppBroadcastVideoEncodingResolutionMode, METH_O, "registers type"},
        {"_register_AppCaptureHistoricalBufferLengthUnit", register_AppCaptureHistoricalBufferLengthUnit, METH_O, "registers type"},
        {"_register_AppCaptureMetadataPriority", register_AppCaptureMetadataPriority, METH_O, "registers type"},
        {"_register_AppCaptureMicrophoneCaptureState", register_AppCaptureMicrophoneCaptureState, METH_O, "registers type"},
        {"_register_AppCaptureRecordingState", register_AppCaptureRecordingState, METH_O, "registers type"},
        {"_register_AppCaptureVideoEncodingBitrateMode", register_AppCaptureVideoEncodingBitrateMode, METH_O, "registers type"},
        {"_register_AppCaptureVideoEncodingFrameRateMode", register_AppCaptureVideoEncodingFrameRateMode, METH_O, "registers type"},
        {"_register_AppCaptureVideoEncodingResolutionMode", register_AppCaptureVideoEncodingResolutionMode, METH_O, "registers type"},
        {"_register_CameraCaptureUIMaxPhotoResolution", register_CameraCaptureUIMaxPhotoResolution, METH_O, "registers type"},
        {"_register_CameraCaptureUIMaxVideoResolution", register_CameraCaptureUIMaxVideoResolution, METH_O, "registers type"},
        {"_register_CameraCaptureUIMode", register_CameraCaptureUIMode, METH_O, "registers type"},
        {"_register_CameraCaptureUIPhotoFormat", register_CameraCaptureUIPhotoFormat, METH_O, "registers type"},
        {"_register_CameraCaptureUIVideoFormat", register_CameraCaptureUIVideoFormat, METH_O, "registers type"},
        {"_register_ForegroundActivationArgument", register_ForegroundActivationArgument, METH_O, "registers type"},
        {"_register_GameBarCommand", register_GameBarCommand, METH_O, "registers type"},
        {"_register_GameBarCommandOrigin", register_GameBarCommandOrigin, METH_O, "registers type"},
        {"_register_GameBarServicesDisplayMode", register_GameBarServicesDisplayMode, METH_O, "registers type"},
        {"_register_GameBarTargetCapturePolicy", register_GameBarTargetCapturePolicy, METH_O, "registers type"},
        {"_register_KnownVideoProfile", register_KnownVideoProfile, METH_O, "registers type"},
        {"_register_MediaCaptureDeviceExclusiveControlReleaseMode", register_MediaCaptureDeviceExclusiveControlReleaseMode, METH_O, "registers type"},
        {"_register_MediaCaptureDeviceExclusiveControlStatus", register_MediaCaptureDeviceExclusiveControlStatus, METH_O, "registers type"},
        {"_register_MediaCaptureMemoryPreference", register_MediaCaptureMemoryPreference, METH_O, "registers type"},
        {"_register_MediaCaptureSharingMode", register_MediaCaptureSharingMode, METH_O, "registers type"},
        {"_register_MediaCaptureThermalStatus", register_MediaCaptureThermalStatus, METH_O, "registers type"},
        {"_register_MediaCategory", register_MediaCategory, METH_O, "registers type"},
        {"_register_MediaStreamType", register_MediaStreamType, METH_O, "registers type"},
        {"_register_PhotoCaptureSource", register_PhotoCaptureSource, METH_O, "registers type"},
        {"_register_PowerlineFrequency", register_PowerlineFrequency, METH_O, "registers type"},
        {"_register_StreamingCaptureMode", register_StreamingCaptureMode, METH_O, "registers type"},
        {"_register_VideoDeviceCharacteristic", register_VideoDeviceCharacteristic, METH_O, "registers type"},
        {"_register_VideoRotation", register_VideoRotation, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_AppBroadcastCameraCaptureState);
        Py_VISIT(state->type_AppBroadcastCameraOverlayLocation);
        Py_VISIT(state->type_AppBroadcastCameraOverlaySize);
        Py_VISIT(state->type_AppBroadcastCaptureTargetType);
        Py_VISIT(state->type_AppBroadcastExitBroadcastModeReason);
        Py_VISIT(state->type_AppBroadcastMicrophoneCaptureState);
        Py_VISIT(state->type_AppBroadcastPlugInState);
        Py_VISIT(state->type_AppBroadcastPreviewState);
        Py_VISIT(state->type_AppBroadcastSignInResult);
        Py_VISIT(state->type_AppBroadcastSignInState);
        Py_VISIT(state->type_AppBroadcastStreamState);
        Py_VISIT(state->type_AppBroadcastTerminationReason);
        Py_VISIT(state->type_AppBroadcastVideoEncodingBitrateMode);
        Py_VISIT(state->type_AppBroadcastVideoEncodingResolutionMode);
        Py_VISIT(state->type_AppCaptureHistoricalBufferLengthUnit);
        Py_VISIT(state->type_AppCaptureMetadataPriority);
        Py_VISIT(state->type_AppCaptureMicrophoneCaptureState);
        Py_VISIT(state->type_AppCaptureRecordingState);
        Py_VISIT(state->type_AppCaptureVideoEncodingBitrateMode);
        Py_VISIT(state->type_AppCaptureVideoEncodingFrameRateMode);
        Py_VISIT(state->type_AppCaptureVideoEncodingResolutionMode);
        Py_VISIT(state->type_CameraCaptureUIMaxPhotoResolution);
        Py_VISIT(state->type_CameraCaptureUIMaxVideoResolution);
        Py_VISIT(state->type_CameraCaptureUIMode);
        Py_VISIT(state->type_CameraCaptureUIPhotoFormat);
        Py_VISIT(state->type_CameraCaptureUIVideoFormat);
        Py_VISIT(state->type_ForegroundActivationArgument);
        Py_VISIT(state->type_GameBarCommand);
        Py_VISIT(state->type_GameBarCommandOrigin);
        Py_VISIT(state->type_GameBarServicesDisplayMode);
        Py_VISIT(state->type_GameBarTargetCapturePolicy);
        Py_VISIT(state->type_KnownVideoProfile);
        Py_VISIT(state->type_MediaCaptureDeviceExclusiveControlReleaseMode);
        Py_VISIT(state->type_MediaCaptureDeviceExclusiveControlStatus);
        Py_VISIT(state->type_MediaCaptureMemoryPreference);
        Py_VISIT(state->type_MediaCaptureSharingMode);
        Py_VISIT(state->type_MediaCaptureThermalStatus);
        Py_VISIT(state->type_MediaCategory);
        Py_VISIT(state->type_MediaStreamType);
        Py_VISIT(state->type_PhotoCaptureSource);
        Py_VISIT(state->type_PowerlineFrequency);
        Py_VISIT(state->type_StreamingCaptureMode);
        Py_VISIT(state->type_VideoDeviceCharacteristic);
        Py_VISIT(state->type_VideoRotation);
        Py_VISIT(state->type_AdvancedCapturedPhoto);
        Py_VISIT(state->type_AdvancedPhotoCapture);
        Py_VISIT(state->type_AppBroadcastBackgroundService);
        Py_VISIT(state->type_AppBroadcastBackgroundServiceSignInInfo);
        Py_VISIT(state->type_AppBroadcastBackgroundServiceStreamInfo);
        Py_VISIT(state->type_AppBroadcastCameraCaptureStateChangedEventArgs);
        Py_VISIT(state->type_AppBroadcastGlobalSettings);
        Py_VISIT(state->type_AppBroadcastHeartbeatRequestedEventArgs);
        Py_VISIT(state->type_AppBroadcastManager);
        Py_VISIT(state->type_AppBroadcastMicrophoneCaptureStateChangedEventArgs);
        Py_VISIT(state->type_AppBroadcastPlugIn);
        Py_VISIT(state->type_AppBroadcastPlugInManager);
        Py_VISIT(state->type_AppBroadcastPlugInStateChangedEventArgs);
        Py_VISIT(state->type_AppBroadcastPreview);
        Py_VISIT(state->type_AppBroadcastPreviewStateChangedEventArgs);
        Py_VISIT(state->type_AppBroadcastPreviewStreamReader);
        Py_VISIT(state->type_AppBroadcastPreviewStreamVideoFrame);
        Py_VISIT(state->type_AppBroadcastPreviewStreamVideoHeader);
        Py_VISIT(state->type_AppBroadcastProviderSettings);
        Py_VISIT(state->type_AppBroadcastServices);
        Py_VISIT(state->type_AppBroadcastSignInStateChangedEventArgs);
        Py_VISIT(state->type_AppBroadcastState);
        Py_VISIT(state->type_AppBroadcastStreamAudioFrame);
        Py_VISIT(state->type_AppBroadcastStreamAudioHeader);
        Py_VISIT(state->type_AppBroadcastStreamReader);
        Py_VISIT(state->type_AppBroadcastStreamStateChangedEventArgs);
        Py_VISIT(state->type_AppBroadcastStreamVideoFrame);
        Py_VISIT(state->type_AppBroadcastStreamVideoHeader);
        Py_VISIT(state->type_AppBroadcastTriggerDetails);
        Py_VISIT(state->type_AppBroadcastViewerCountChangedEventArgs);
        Py_VISIT(state->type_AppCapture);
        Py_VISIT(state->type_AppCaptureAlternateShortcutKeys);
        Py_VISIT(state->type_AppCaptureDurationGeneratedEventArgs);
        Py_VISIT(state->type_AppCaptureFileGeneratedEventArgs);
        Py_VISIT(state->type_AppCaptureManager);
        Py_VISIT(state->type_AppCaptureMetadataWriter);
        Py_VISIT(state->type_AppCaptureMicrophoneCaptureStateChangedEventArgs);
        Py_VISIT(state->type_AppCaptureRecordOperation);
        Py_VISIT(state->type_AppCaptureRecordingStateChangedEventArgs);
        Py_VISIT(state->type_AppCaptureServices);
        Py_VISIT(state->type_AppCaptureSettings);
        Py_VISIT(state->type_AppCaptureState);
        Py_VISIT(state->type_CameraCaptureUI);
        Py_VISIT(state->type_CameraCaptureUIPhotoCaptureSettings);
        Py_VISIT(state->type_CameraCaptureUIVideoCaptureSettings);
        Py_VISIT(state->type_CameraOptionsUI);
        Py_VISIT(state->type_CapturedFrame);
        Py_VISIT(state->type_CapturedFrameControlValues);
        Py_VISIT(state->type_CapturedPhoto);
        Py_VISIT(state->type_GameBarServices);
        Py_VISIT(state->type_GameBarServicesCommandEventArgs);
        Py_VISIT(state->type_GameBarServicesManager);
        Py_VISIT(state->type_GameBarServicesManagerGameBarServicesCreatedEventArgs);
        Py_VISIT(state->type_GameBarServicesTargetInfo);
        Py_VISIT(state->type_LowLagMediaRecording);
        Py_VISIT(state->type_LowLagPhotoCapture);
        Py_VISIT(state->type_LowLagPhotoSequenceCapture);
        Py_VISIT(state->type_MediaCapture);
        Py_VISIT(state->type_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs);
        Py_VISIT(state->type_MediaCaptureFailedEventArgs);
        Py_VISIT(state->type_MediaCaptureFocusChangedEventArgs);
        Py_VISIT(state->type_MediaCaptureInitializationSettings);
        Py_VISIT(state->type_MediaCapturePauseResult);
        Py_VISIT(state->type_MediaCaptureRelativePanelWatcher);
        Py_VISIT(state->type_MediaCaptureSettings);
        Py_VISIT(state->type_MediaCaptureStopResult);
        Py_VISIT(state->type_MediaCaptureVideoProfile);
        Py_VISIT(state->type_MediaCaptureVideoProfileMediaDescription);
        Py_VISIT(state->type_OptionalReferencePhotoCapturedEventArgs);
        Py_VISIT(state->type_PhotoCapturedEventArgs);
        Py_VISIT(state->type_PhotoConfirmationCapturedEventArgs);
        Py_VISIT(state->type_ScreenCapture);
        Py_VISIT(state->type_SourceSuspensionChangedEventArgs);
        Py_VISIT(state->type_VideoStreamConfiguration);
        Py_VISIT(state->type_WhiteBalanceGain);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_AppBroadcastCameraCaptureState);
        Py_CLEAR(state->type_AppBroadcastCameraOverlayLocation);
        Py_CLEAR(state->type_AppBroadcastCameraOverlaySize);
        Py_CLEAR(state->type_AppBroadcastCaptureTargetType);
        Py_CLEAR(state->type_AppBroadcastExitBroadcastModeReason);
        Py_CLEAR(state->type_AppBroadcastMicrophoneCaptureState);
        Py_CLEAR(state->type_AppBroadcastPlugInState);
        Py_CLEAR(state->type_AppBroadcastPreviewState);
        Py_CLEAR(state->type_AppBroadcastSignInResult);
        Py_CLEAR(state->type_AppBroadcastSignInState);
        Py_CLEAR(state->type_AppBroadcastStreamState);
        Py_CLEAR(state->type_AppBroadcastTerminationReason);
        Py_CLEAR(state->type_AppBroadcastVideoEncodingBitrateMode);
        Py_CLEAR(state->type_AppBroadcastVideoEncodingResolutionMode);
        Py_CLEAR(state->type_AppCaptureHistoricalBufferLengthUnit);
        Py_CLEAR(state->type_AppCaptureMetadataPriority);
        Py_CLEAR(state->type_AppCaptureMicrophoneCaptureState);
        Py_CLEAR(state->type_AppCaptureRecordingState);
        Py_CLEAR(state->type_AppCaptureVideoEncodingBitrateMode);
        Py_CLEAR(state->type_AppCaptureVideoEncodingFrameRateMode);
        Py_CLEAR(state->type_AppCaptureVideoEncodingResolutionMode);
        Py_CLEAR(state->type_CameraCaptureUIMaxPhotoResolution);
        Py_CLEAR(state->type_CameraCaptureUIMaxVideoResolution);
        Py_CLEAR(state->type_CameraCaptureUIMode);
        Py_CLEAR(state->type_CameraCaptureUIPhotoFormat);
        Py_CLEAR(state->type_CameraCaptureUIVideoFormat);
        Py_CLEAR(state->type_ForegroundActivationArgument);
        Py_CLEAR(state->type_GameBarCommand);
        Py_CLEAR(state->type_GameBarCommandOrigin);
        Py_CLEAR(state->type_GameBarServicesDisplayMode);
        Py_CLEAR(state->type_GameBarTargetCapturePolicy);
        Py_CLEAR(state->type_KnownVideoProfile);
        Py_CLEAR(state->type_MediaCaptureDeviceExclusiveControlReleaseMode);
        Py_CLEAR(state->type_MediaCaptureDeviceExclusiveControlStatus);
        Py_CLEAR(state->type_MediaCaptureMemoryPreference);
        Py_CLEAR(state->type_MediaCaptureSharingMode);
        Py_CLEAR(state->type_MediaCaptureThermalStatus);
        Py_CLEAR(state->type_MediaCategory);
        Py_CLEAR(state->type_MediaStreamType);
        Py_CLEAR(state->type_PhotoCaptureSource);
        Py_CLEAR(state->type_PowerlineFrequency);
        Py_CLEAR(state->type_StreamingCaptureMode);
        Py_CLEAR(state->type_VideoDeviceCharacteristic);
        Py_CLEAR(state->type_VideoRotation);
        Py_CLEAR(state->type_AdvancedCapturedPhoto);
        Py_CLEAR(state->type_AdvancedPhotoCapture);
        Py_CLEAR(state->type_AppBroadcastBackgroundService);
        Py_CLEAR(state->type_AppBroadcastBackgroundServiceSignInInfo);
        Py_CLEAR(state->type_AppBroadcastBackgroundServiceStreamInfo);
        Py_CLEAR(state->type_AppBroadcastCameraCaptureStateChangedEventArgs);
        Py_CLEAR(state->type_AppBroadcastGlobalSettings);
        Py_CLEAR(state->type_AppBroadcastHeartbeatRequestedEventArgs);
        Py_CLEAR(state->type_AppBroadcastManager);
        Py_CLEAR(state->type_AppBroadcastMicrophoneCaptureStateChangedEventArgs);
        Py_CLEAR(state->type_AppBroadcastPlugIn);
        Py_CLEAR(state->type_AppBroadcastPlugInManager);
        Py_CLEAR(state->type_AppBroadcastPlugInStateChangedEventArgs);
        Py_CLEAR(state->type_AppBroadcastPreview);
        Py_CLEAR(state->type_AppBroadcastPreviewStateChangedEventArgs);
        Py_CLEAR(state->type_AppBroadcastPreviewStreamReader);
        Py_CLEAR(state->type_AppBroadcastPreviewStreamVideoFrame);
        Py_CLEAR(state->type_AppBroadcastPreviewStreamVideoHeader);
        Py_CLEAR(state->type_AppBroadcastProviderSettings);
        Py_CLEAR(state->type_AppBroadcastServices);
        Py_CLEAR(state->type_AppBroadcastSignInStateChangedEventArgs);
        Py_CLEAR(state->type_AppBroadcastState);
        Py_CLEAR(state->type_AppBroadcastStreamAudioFrame);
        Py_CLEAR(state->type_AppBroadcastStreamAudioHeader);
        Py_CLEAR(state->type_AppBroadcastStreamReader);
        Py_CLEAR(state->type_AppBroadcastStreamStateChangedEventArgs);
        Py_CLEAR(state->type_AppBroadcastStreamVideoFrame);
        Py_CLEAR(state->type_AppBroadcastStreamVideoHeader);
        Py_CLEAR(state->type_AppBroadcastTriggerDetails);
        Py_CLEAR(state->type_AppBroadcastViewerCountChangedEventArgs);
        Py_CLEAR(state->type_AppCapture);
        Py_CLEAR(state->type_AppCaptureAlternateShortcutKeys);
        Py_CLEAR(state->type_AppCaptureDurationGeneratedEventArgs);
        Py_CLEAR(state->type_AppCaptureFileGeneratedEventArgs);
        Py_CLEAR(state->type_AppCaptureManager);
        Py_CLEAR(state->type_AppCaptureMetadataWriter);
        Py_CLEAR(state->type_AppCaptureMicrophoneCaptureStateChangedEventArgs);
        Py_CLEAR(state->type_AppCaptureRecordOperation);
        Py_CLEAR(state->type_AppCaptureRecordingStateChangedEventArgs);
        Py_CLEAR(state->type_AppCaptureServices);
        Py_CLEAR(state->type_AppCaptureSettings);
        Py_CLEAR(state->type_AppCaptureState);
        Py_CLEAR(state->type_CameraCaptureUI);
        Py_CLEAR(state->type_CameraCaptureUIPhotoCaptureSettings);
        Py_CLEAR(state->type_CameraCaptureUIVideoCaptureSettings);
        Py_CLEAR(state->type_CameraOptionsUI);
        Py_CLEAR(state->type_CapturedFrame);
        Py_CLEAR(state->type_CapturedFrameControlValues);
        Py_CLEAR(state->type_CapturedPhoto);
        Py_CLEAR(state->type_GameBarServices);
        Py_CLEAR(state->type_GameBarServicesCommandEventArgs);
        Py_CLEAR(state->type_GameBarServicesManager);
        Py_CLEAR(state->type_GameBarServicesManagerGameBarServicesCreatedEventArgs);
        Py_CLEAR(state->type_GameBarServicesTargetInfo);
        Py_CLEAR(state->type_LowLagMediaRecording);
        Py_CLEAR(state->type_LowLagPhotoCapture);
        Py_CLEAR(state->type_LowLagPhotoSequenceCapture);
        Py_CLEAR(state->type_MediaCapture);
        Py_CLEAR(state->type_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs);
        Py_CLEAR(state->type_MediaCaptureFailedEventArgs);
        Py_CLEAR(state->type_MediaCaptureFocusChangedEventArgs);
        Py_CLEAR(state->type_MediaCaptureInitializationSettings);
        Py_CLEAR(state->type_MediaCapturePauseResult);
        Py_CLEAR(state->type_MediaCaptureRelativePanelWatcher);
        Py_CLEAR(state->type_MediaCaptureSettings);
        Py_CLEAR(state->type_MediaCaptureStopResult);
        Py_CLEAR(state->type_MediaCaptureVideoProfile);
        Py_CLEAR(state->type_MediaCaptureVideoProfileMediaDescription);
        Py_CLEAR(state->type_OptionalReferencePhotoCapturedEventArgs);
        Py_CLEAR(state->type_PhotoCapturedEventArgs);
        Py_CLEAR(state->type_PhotoConfirmationCapturedEventArgs);
        Py_CLEAR(state->type_ScreenCapture);
        Py_CLEAR(state->type_SourceSuspensionChangedEventArgs);
        Py_CLEAR(state->type_VideoStreamConfiguration);
        Py_CLEAR(state->type_WhiteBalanceGain);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Media_Capture",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Media::Capture

PyMODINIT_FUNC PyInit__winsdk_Windows_Media_Capture(void) noexcept
{
    using namespace py::cpp::Windows::Media::Capture;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_AdvancedCapturedPhoto = py::register_python_type(module.get(), type_name_AdvancedCapturedPhoto, &type_spec_AdvancedCapturedPhoto, bases.get(), nullptr);
    if (!state->type_AdvancedCapturedPhoto)
    {
        return nullptr;
    }

    state->type_AdvancedPhotoCapture = py::register_python_type(module.get(), type_name_AdvancedPhotoCapture, &type_spec_AdvancedPhotoCapture, bases.get(), nullptr);
    if (!state->type_AdvancedPhotoCapture)
    {
        return nullptr;
    }

    state->type_AppBroadcastBackgroundService = py::register_python_type(module.get(), type_name_AppBroadcastBackgroundService, &type_spec_AppBroadcastBackgroundService, bases.get(), nullptr);
    if (!state->type_AppBroadcastBackgroundService)
    {
        return nullptr;
    }

    state->type_AppBroadcastBackgroundServiceSignInInfo = py::register_python_type(module.get(), type_name_AppBroadcastBackgroundServiceSignInInfo, &type_spec_AppBroadcastBackgroundServiceSignInInfo, bases.get(), nullptr);
    if (!state->type_AppBroadcastBackgroundServiceSignInInfo)
    {
        return nullptr;
    }

    state->type_AppBroadcastBackgroundServiceStreamInfo = py::register_python_type(module.get(), type_name_AppBroadcastBackgroundServiceStreamInfo, &type_spec_AppBroadcastBackgroundServiceStreamInfo, bases.get(), nullptr);
    if (!state->type_AppBroadcastBackgroundServiceStreamInfo)
    {
        return nullptr;
    }

    state->type_AppBroadcastCameraCaptureStateChangedEventArgs = py::register_python_type(module.get(), type_name_AppBroadcastCameraCaptureStateChangedEventArgs, &type_spec_AppBroadcastCameraCaptureStateChangedEventArgs, bases.get(), nullptr);
    if (!state->type_AppBroadcastCameraCaptureStateChangedEventArgs)
    {
        return nullptr;
    }

    state->type_AppBroadcastGlobalSettings = py::register_python_type(module.get(), type_name_AppBroadcastGlobalSettings, &type_spec_AppBroadcastGlobalSettings, bases.get(), nullptr);
    if (!state->type_AppBroadcastGlobalSettings)
    {
        return nullptr;
    }

    state->type_AppBroadcastHeartbeatRequestedEventArgs = py::register_python_type(module.get(), type_name_AppBroadcastHeartbeatRequestedEventArgs, &type_spec_AppBroadcastHeartbeatRequestedEventArgs, bases.get(), nullptr);
    if (!state->type_AppBroadcastHeartbeatRequestedEventArgs)
    {
        return nullptr;
    }

    state->type_AppBroadcastManager = py::register_python_type(module.get(), type_name_AppBroadcastManager, &type_spec_AppBroadcastManager, nullptr, nullptr);
    if (!state->type_AppBroadcastManager)
    {
        return nullptr;
    }

    state->type_AppBroadcastMicrophoneCaptureStateChangedEventArgs = py::register_python_type(module.get(), type_name_AppBroadcastMicrophoneCaptureStateChangedEventArgs, &type_spec_AppBroadcastMicrophoneCaptureStateChangedEventArgs, bases.get(), nullptr);
    if (!state->type_AppBroadcastMicrophoneCaptureStateChangedEventArgs)
    {
        return nullptr;
    }

    state->type_AppBroadcastPlugIn = py::register_python_type(module.get(), type_name_AppBroadcastPlugIn, &type_spec_AppBroadcastPlugIn, bases.get(), nullptr);
    if (!state->type_AppBroadcastPlugIn)
    {
        return nullptr;
    }

    state->type_AppBroadcastPlugInManager = py::register_python_type(module.get(), type_name_AppBroadcastPlugInManager, &type_spec_AppBroadcastPlugInManager, bases.get(), nullptr);
    if (!state->type_AppBroadcastPlugInManager)
    {
        return nullptr;
    }

    state->type_AppBroadcastPlugInStateChangedEventArgs = py::register_python_type(module.get(), type_name_AppBroadcastPlugInStateChangedEventArgs, &type_spec_AppBroadcastPlugInStateChangedEventArgs, bases.get(), nullptr);
    if (!state->type_AppBroadcastPlugInStateChangedEventArgs)
    {
        return nullptr;
    }

    state->type_AppBroadcastPreview = py::register_python_type(module.get(), type_name_AppBroadcastPreview, &type_spec_AppBroadcastPreview, bases.get(), nullptr);
    if (!state->type_AppBroadcastPreview)
    {
        return nullptr;
    }

    state->type_AppBroadcastPreviewStateChangedEventArgs = py::register_python_type(module.get(), type_name_AppBroadcastPreviewStateChangedEventArgs, &type_spec_AppBroadcastPreviewStateChangedEventArgs, bases.get(), nullptr);
    if (!state->type_AppBroadcastPreviewStateChangedEventArgs)
    {
        return nullptr;
    }

    state->type_AppBroadcastPreviewStreamReader = py::register_python_type(module.get(), type_name_AppBroadcastPreviewStreamReader, &type_spec_AppBroadcastPreviewStreamReader, bases.get(), nullptr);
    if (!state->type_AppBroadcastPreviewStreamReader)
    {
        return nullptr;
    }

    state->type_AppBroadcastPreviewStreamVideoFrame = py::register_python_type(module.get(), type_name_AppBroadcastPreviewStreamVideoFrame, &type_spec_AppBroadcastPreviewStreamVideoFrame, bases.get(), nullptr);
    if (!state->type_AppBroadcastPreviewStreamVideoFrame)
    {
        return nullptr;
    }

    state->type_AppBroadcastPreviewStreamVideoHeader = py::register_python_type(module.get(), type_name_AppBroadcastPreviewStreamVideoHeader, &type_spec_AppBroadcastPreviewStreamVideoHeader, bases.get(), nullptr);
    if (!state->type_AppBroadcastPreviewStreamVideoHeader)
    {
        return nullptr;
    }

    state->type_AppBroadcastProviderSettings = py::register_python_type(module.get(), type_name_AppBroadcastProviderSettings, &type_spec_AppBroadcastProviderSettings, bases.get(), nullptr);
    if (!state->type_AppBroadcastProviderSettings)
    {
        return nullptr;
    }

    state->type_AppBroadcastServices = py::register_python_type(module.get(), type_name_AppBroadcastServices, &type_spec_AppBroadcastServices, bases.get(), nullptr);
    if (!state->type_AppBroadcastServices)
    {
        return nullptr;
    }

    state->type_AppBroadcastSignInStateChangedEventArgs = py::register_python_type(module.get(), type_name_AppBroadcastSignInStateChangedEventArgs, &type_spec_AppBroadcastSignInStateChangedEventArgs, bases.get(), nullptr);
    if (!state->type_AppBroadcastSignInStateChangedEventArgs)
    {
        return nullptr;
    }

    state->type_AppBroadcastState = py::register_python_type(module.get(), type_name_AppBroadcastState, &type_spec_AppBroadcastState, bases.get(), nullptr);
    if (!state->type_AppBroadcastState)
    {
        return nullptr;
    }

    state->type_AppBroadcastStreamAudioFrame = py::register_python_type(module.get(), type_name_AppBroadcastStreamAudioFrame, &type_spec_AppBroadcastStreamAudioFrame, bases.get(), nullptr);
    if (!state->type_AppBroadcastStreamAudioFrame)
    {
        return nullptr;
    }

    state->type_AppBroadcastStreamAudioHeader = py::register_python_type(module.get(), type_name_AppBroadcastStreamAudioHeader, &type_spec_AppBroadcastStreamAudioHeader, bases.get(), nullptr);
    if (!state->type_AppBroadcastStreamAudioHeader)
    {
        return nullptr;
    }

    state->type_AppBroadcastStreamReader = py::register_python_type(module.get(), type_name_AppBroadcastStreamReader, &type_spec_AppBroadcastStreamReader, bases.get(), nullptr);
    if (!state->type_AppBroadcastStreamReader)
    {
        return nullptr;
    }

    state->type_AppBroadcastStreamStateChangedEventArgs = py::register_python_type(module.get(), type_name_AppBroadcastStreamStateChangedEventArgs, &type_spec_AppBroadcastStreamStateChangedEventArgs, bases.get(), nullptr);
    if (!state->type_AppBroadcastStreamStateChangedEventArgs)
    {
        return nullptr;
    }

    state->type_AppBroadcastStreamVideoFrame = py::register_python_type(module.get(), type_name_AppBroadcastStreamVideoFrame, &type_spec_AppBroadcastStreamVideoFrame, bases.get(), nullptr);
    if (!state->type_AppBroadcastStreamVideoFrame)
    {
        return nullptr;
    }

    state->type_AppBroadcastStreamVideoHeader = py::register_python_type(module.get(), type_name_AppBroadcastStreamVideoHeader, &type_spec_AppBroadcastStreamVideoHeader, bases.get(), nullptr);
    if (!state->type_AppBroadcastStreamVideoHeader)
    {
        return nullptr;
    }

    state->type_AppBroadcastTriggerDetails = py::register_python_type(module.get(), type_name_AppBroadcastTriggerDetails, &type_spec_AppBroadcastTriggerDetails, bases.get(), nullptr);
    if (!state->type_AppBroadcastTriggerDetails)
    {
        return nullptr;
    }

    state->type_AppBroadcastViewerCountChangedEventArgs = py::register_python_type(module.get(), type_name_AppBroadcastViewerCountChangedEventArgs, &type_spec_AppBroadcastViewerCountChangedEventArgs, bases.get(), nullptr);
    if (!state->type_AppBroadcastViewerCountChangedEventArgs)
    {
        return nullptr;
    }

    state->type_AppCapture = py::register_python_type(module.get(), type_name_AppCapture, &type_spec_AppCapture, bases.get(), nullptr);
    if (!state->type_AppCapture)
    {
        return nullptr;
    }

    state->type_AppCaptureAlternateShortcutKeys = py::register_python_type(module.get(), type_name_AppCaptureAlternateShortcutKeys, &type_spec_AppCaptureAlternateShortcutKeys, bases.get(), nullptr);
    if (!state->type_AppCaptureAlternateShortcutKeys)
    {
        return nullptr;
    }

    state->type_AppCaptureDurationGeneratedEventArgs = py::register_python_type(module.get(), type_name_AppCaptureDurationGeneratedEventArgs, &type_spec_AppCaptureDurationGeneratedEventArgs, bases.get(), nullptr);
    if (!state->type_AppCaptureDurationGeneratedEventArgs)
    {
        return nullptr;
    }

    state->type_AppCaptureFileGeneratedEventArgs = py::register_python_type(module.get(), type_name_AppCaptureFileGeneratedEventArgs, &type_spec_AppCaptureFileGeneratedEventArgs, bases.get(), nullptr);
    if (!state->type_AppCaptureFileGeneratedEventArgs)
    {
        return nullptr;
    }

    state->type_AppCaptureManager = py::register_python_type(module.get(), type_name_AppCaptureManager, &type_spec_AppCaptureManager, nullptr, nullptr);
    if (!state->type_AppCaptureManager)
    {
        return nullptr;
    }

    state->type_AppCaptureMetadataWriter = py::register_python_type(module.get(), type_name_AppCaptureMetadataWriter, &type_spec_AppCaptureMetadataWriter, bases.get(), nullptr);
    if (!state->type_AppCaptureMetadataWriter)
    {
        return nullptr;
    }

    state->type_AppCaptureMicrophoneCaptureStateChangedEventArgs = py::register_python_type(module.get(), type_name_AppCaptureMicrophoneCaptureStateChangedEventArgs, &type_spec_AppCaptureMicrophoneCaptureStateChangedEventArgs, bases.get(), nullptr);
    if (!state->type_AppCaptureMicrophoneCaptureStateChangedEventArgs)
    {
        return nullptr;
    }

    state->type_AppCaptureRecordOperation = py::register_python_type(module.get(), type_name_AppCaptureRecordOperation, &type_spec_AppCaptureRecordOperation, bases.get(), nullptr);
    if (!state->type_AppCaptureRecordOperation)
    {
        return nullptr;
    }

    state->type_AppCaptureRecordingStateChangedEventArgs = py::register_python_type(module.get(), type_name_AppCaptureRecordingStateChangedEventArgs, &type_spec_AppCaptureRecordingStateChangedEventArgs, bases.get(), nullptr);
    if (!state->type_AppCaptureRecordingStateChangedEventArgs)
    {
        return nullptr;
    }

    state->type_AppCaptureServices = py::register_python_type(module.get(), type_name_AppCaptureServices, &type_spec_AppCaptureServices, bases.get(), nullptr);
    if (!state->type_AppCaptureServices)
    {
        return nullptr;
    }

    state->type_AppCaptureSettings = py::register_python_type(module.get(), type_name_AppCaptureSettings, &type_spec_AppCaptureSettings, bases.get(), nullptr);
    if (!state->type_AppCaptureSettings)
    {
        return nullptr;
    }

    state->type_AppCaptureState = py::register_python_type(module.get(), type_name_AppCaptureState, &type_spec_AppCaptureState, bases.get(), nullptr);
    if (!state->type_AppCaptureState)
    {
        return nullptr;
    }

    state->type_CameraCaptureUI = py::register_python_type(module.get(), type_name_CameraCaptureUI, &type_spec_CameraCaptureUI, bases.get(), nullptr);
    if (!state->type_CameraCaptureUI)
    {
        return nullptr;
    }

    state->type_CameraCaptureUIPhotoCaptureSettings = py::register_python_type(module.get(), type_name_CameraCaptureUIPhotoCaptureSettings, &type_spec_CameraCaptureUIPhotoCaptureSettings, bases.get(), nullptr);
    if (!state->type_CameraCaptureUIPhotoCaptureSettings)
    {
        return nullptr;
    }

    state->type_CameraCaptureUIVideoCaptureSettings = py::register_python_type(module.get(), type_name_CameraCaptureUIVideoCaptureSettings, &type_spec_CameraCaptureUIVideoCaptureSettings, bases.get(), nullptr);
    if (!state->type_CameraCaptureUIVideoCaptureSettings)
    {
        return nullptr;
    }

    state->type_CameraOptionsUI = py::register_python_type(module.get(), type_name_CameraOptionsUI, &type_spec_CameraOptionsUI, nullptr, nullptr);
    if (!state->type_CameraOptionsUI)
    {
        return nullptr;
    }

    state->type_CapturedFrame = py::register_python_type(module.get(), type_name_CapturedFrame, &type_spec_CapturedFrame, bases.get(), nullptr);
    if (!state->type_CapturedFrame)
    {
        return nullptr;
    }

    state->type_CapturedFrameControlValues = py::register_python_type(module.get(), type_name_CapturedFrameControlValues, &type_spec_CapturedFrameControlValues, bases.get(), nullptr);
    if (!state->type_CapturedFrameControlValues)
    {
        return nullptr;
    }

    state->type_CapturedPhoto = py::register_python_type(module.get(), type_name_CapturedPhoto, &type_spec_CapturedPhoto, bases.get(), nullptr);
    if (!state->type_CapturedPhoto)
    {
        return nullptr;
    }

    state->type_GameBarServices = py::register_python_type(module.get(), type_name_GameBarServices, &type_spec_GameBarServices, bases.get(), nullptr);
    if (!state->type_GameBarServices)
    {
        return nullptr;
    }

    state->type_GameBarServicesCommandEventArgs = py::register_python_type(module.get(), type_name_GameBarServicesCommandEventArgs, &type_spec_GameBarServicesCommandEventArgs, bases.get(), nullptr);
    if (!state->type_GameBarServicesCommandEventArgs)
    {
        return nullptr;
    }

    state->type_GameBarServicesManager = py::register_python_type(module.get(), type_name_GameBarServicesManager, &type_spec_GameBarServicesManager, bases.get(), nullptr);
    if (!state->type_GameBarServicesManager)
    {
        return nullptr;
    }

    state->type_GameBarServicesManagerGameBarServicesCreatedEventArgs = py::register_python_type(module.get(), type_name_GameBarServicesManagerGameBarServicesCreatedEventArgs, &type_spec_GameBarServicesManagerGameBarServicesCreatedEventArgs, bases.get(), nullptr);
    if (!state->type_GameBarServicesManagerGameBarServicesCreatedEventArgs)
    {
        return nullptr;
    }

    state->type_GameBarServicesTargetInfo = py::register_python_type(module.get(), type_name_GameBarServicesTargetInfo, &type_spec_GameBarServicesTargetInfo, bases.get(), nullptr);
    if (!state->type_GameBarServicesTargetInfo)
    {
        return nullptr;
    }

    state->type_LowLagMediaRecording = py::register_python_type(module.get(), type_name_LowLagMediaRecording, &type_spec_LowLagMediaRecording, bases.get(), nullptr);
    if (!state->type_LowLagMediaRecording)
    {
        return nullptr;
    }

    state->type_LowLagPhotoCapture = py::register_python_type(module.get(), type_name_LowLagPhotoCapture, &type_spec_LowLagPhotoCapture, bases.get(), nullptr);
    if (!state->type_LowLagPhotoCapture)
    {
        return nullptr;
    }

    state->type_LowLagPhotoSequenceCapture = py::register_python_type(module.get(), type_name_LowLagPhotoSequenceCapture, &type_spec_LowLagPhotoSequenceCapture, bases.get(), nullptr);
    if (!state->type_LowLagPhotoSequenceCapture)
    {
        return nullptr;
    }

    state->type_MediaCapture = py::register_python_type(module.get(), type_name_MediaCapture, &type_spec_MediaCapture, bases.get(), nullptr);
    if (!state->type_MediaCapture)
    {
        return nullptr;
    }

    state->type_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs = py::register_python_type(module.get(), type_name_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs, &type_spec_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs, bases.get(), nullptr);
    if (!state->type_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs)
    {
        return nullptr;
    }

    state->type_MediaCaptureFailedEventArgs = py::register_python_type(module.get(), type_name_MediaCaptureFailedEventArgs, &type_spec_MediaCaptureFailedEventArgs, bases.get(), nullptr);
    if (!state->type_MediaCaptureFailedEventArgs)
    {
        return nullptr;
    }

    state->type_MediaCaptureFocusChangedEventArgs = py::register_python_type(module.get(), type_name_MediaCaptureFocusChangedEventArgs, &type_spec_MediaCaptureFocusChangedEventArgs, bases.get(), nullptr);
    if (!state->type_MediaCaptureFocusChangedEventArgs)
    {
        return nullptr;
    }

    state->type_MediaCaptureInitializationSettings = py::register_python_type(module.get(), type_name_MediaCaptureInitializationSettings, &type_spec_MediaCaptureInitializationSettings, bases.get(), nullptr);
    if (!state->type_MediaCaptureInitializationSettings)
    {
        return nullptr;
    }

    state->type_MediaCapturePauseResult = py::register_python_type(module.get(), type_name_MediaCapturePauseResult, &type_spec_MediaCapturePauseResult, bases.get(), nullptr);
    if (!state->type_MediaCapturePauseResult)
    {
        return nullptr;
    }

    state->type_MediaCaptureRelativePanelWatcher = py::register_python_type(module.get(), type_name_MediaCaptureRelativePanelWatcher, &type_spec_MediaCaptureRelativePanelWatcher, bases.get(), nullptr);
    if (!state->type_MediaCaptureRelativePanelWatcher)
    {
        return nullptr;
    }

    state->type_MediaCaptureSettings = py::register_python_type(module.get(), type_name_MediaCaptureSettings, &type_spec_MediaCaptureSettings, bases.get(), nullptr);
    if (!state->type_MediaCaptureSettings)
    {
        return nullptr;
    }

    state->type_MediaCaptureStopResult = py::register_python_type(module.get(), type_name_MediaCaptureStopResult, &type_spec_MediaCaptureStopResult, bases.get(), nullptr);
    if (!state->type_MediaCaptureStopResult)
    {
        return nullptr;
    }

    state->type_MediaCaptureVideoProfile = py::register_python_type(module.get(), type_name_MediaCaptureVideoProfile, &type_spec_MediaCaptureVideoProfile, bases.get(), nullptr);
    if (!state->type_MediaCaptureVideoProfile)
    {
        return nullptr;
    }

    state->type_MediaCaptureVideoProfileMediaDescription = py::register_python_type(module.get(), type_name_MediaCaptureVideoProfileMediaDescription, &type_spec_MediaCaptureVideoProfileMediaDescription, bases.get(), nullptr);
    if (!state->type_MediaCaptureVideoProfileMediaDescription)
    {
        return nullptr;
    }

    state->type_OptionalReferencePhotoCapturedEventArgs = py::register_python_type(module.get(), type_name_OptionalReferencePhotoCapturedEventArgs, &type_spec_OptionalReferencePhotoCapturedEventArgs, bases.get(), nullptr);
    if (!state->type_OptionalReferencePhotoCapturedEventArgs)
    {
        return nullptr;
    }

    state->type_PhotoCapturedEventArgs = py::register_python_type(module.get(), type_name_PhotoCapturedEventArgs, &type_spec_PhotoCapturedEventArgs, bases.get(), nullptr);
    if (!state->type_PhotoCapturedEventArgs)
    {
        return nullptr;
    }

    state->type_PhotoConfirmationCapturedEventArgs = py::register_python_type(module.get(), type_name_PhotoConfirmationCapturedEventArgs, &type_spec_PhotoConfirmationCapturedEventArgs, bases.get(), nullptr);
    if (!state->type_PhotoConfirmationCapturedEventArgs)
    {
        return nullptr;
    }

    state->type_ScreenCapture = py::register_python_type(module.get(), type_name_ScreenCapture, &type_spec_ScreenCapture, bases.get(), nullptr);
    if (!state->type_ScreenCapture)
    {
        return nullptr;
    }

    state->type_SourceSuspensionChangedEventArgs = py::register_python_type(module.get(), type_name_SourceSuspensionChangedEventArgs, &type_spec_SourceSuspensionChangedEventArgs, bases.get(), nullptr);
    if (!state->type_SourceSuspensionChangedEventArgs)
    {
        return nullptr;
    }

    state->type_VideoStreamConfiguration = py::register_python_type(module.get(), type_name_VideoStreamConfiguration, &type_spec_VideoStreamConfiguration, bases.get(), nullptr);
    if (!state->type_VideoStreamConfiguration)
    {
        return nullptr;
    }

    state->type_WhiteBalanceGain = py::register_python_type(module.get(), type_name_WhiteBalanceGain, &type_spec_WhiteBalanceGain, bases.get(), nullptr);
    if (!state->type_WhiteBalanceGain)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Media::Capture::AppBroadcastCameraCaptureState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastCameraCaptureState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastCameraCaptureState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::AppBroadcastCameraOverlayLocation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastCameraOverlayLocation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastCameraOverlayLocation is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::AppBroadcastCameraOverlaySize>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastCameraOverlaySize;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastCameraOverlaySize is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::AppBroadcastCaptureTargetType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastCaptureTargetType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastCaptureTargetType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::AppBroadcastExitBroadcastModeReason>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastExitBroadcastModeReason;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastExitBroadcastModeReason is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::AppBroadcastMicrophoneCaptureState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastMicrophoneCaptureState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastMicrophoneCaptureState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::AppBroadcastPlugInState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastPlugInState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastPlugInState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::AppBroadcastPreviewState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastPreviewState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastPreviewState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::AppBroadcastSignInResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastSignInResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastSignInResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::AppBroadcastSignInState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastSignInState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastSignInState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::AppBroadcastStreamState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastStreamState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastStreamState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::AppBroadcastTerminationReason>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastTerminationReason;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastTerminationReason is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::AppBroadcastVideoEncodingBitrateMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastVideoEncodingBitrateMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastVideoEncodingBitrateMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::AppBroadcastVideoEncodingResolutionMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastVideoEncodingResolutionMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastVideoEncodingResolutionMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::AppCaptureHistoricalBufferLengthUnit>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppCaptureHistoricalBufferLengthUnit;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppCaptureHistoricalBufferLengthUnit is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::AppCaptureMetadataPriority>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppCaptureMetadataPriority;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppCaptureMetadataPriority is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::AppCaptureMicrophoneCaptureState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppCaptureMicrophoneCaptureState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppCaptureMicrophoneCaptureState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::AppCaptureRecordingState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppCaptureRecordingState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppCaptureRecordingState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::AppCaptureVideoEncodingBitrateMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppCaptureVideoEncodingBitrateMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppCaptureVideoEncodingBitrateMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::AppCaptureVideoEncodingFrameRateMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppCaptureVideoEncodingFrameRateMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppCaptureVideoEncodingFrameRateMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::AppCaptureVideoEncodingResolutionMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppCaptureVideoEncodingResolutionMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppCaptureVideoEncodingResolutionMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::CameraCaptureUIMaxPhotoResolution>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CameraCaptureUIMaxPhotoResolution;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::CameraCaptureUIMaxPhotoResolution is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::CameraCaptureUIMaxVideoResolution>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CameraCaptureUIMaxVideoResolution;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::CameraCaptureUIMaxVideoResolution is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::CameraCaptureUIMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CameraCaptureUIMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::CameraCaptureUIMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::CameraCaptureUIPhotoFormat>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CameraCaptureUIPhotoFormat;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::CameraCaptureUIPhotoFormat is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::CameraCaptureUIVideoFormat>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CameraCaptureUIVideoFormat;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::CameraCaptureUIVideoFormat is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::ForegroundActivationArgument>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ForegroundActivationArgument;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::ForegroundActivationArgument is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::GameBarCommand>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GameBarCommand;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::GameBarCommand is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::GameBarCommandOrigin>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GameBarCommandOrigin;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::GameBarCommandOrigin is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::GameBarServicesDisplayMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GameBarServicesDisplayMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::GameBarServicesDisplayMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::GameBarTargetCapturePolicy>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GameBarTargetCapturePolicy;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::GameBarTargetCapturePolicy is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::KnownVideoProfile>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownVideoProfile;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::KnownVideoProfile is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlReleaseMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaCaptureDeviceExclusiveControlReleaseMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlReleaseMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaCaptureDeviceExclusiveControlStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::MediaCaptureMemoryPreference>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaCaptureMemoryPreference;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::MediaCaptureMemoryPreference is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::MediaCaptureSharingMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaCaptureSharingMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::MediaCaptureSharingMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::MediaCaptureThermalStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaCaptureThermalStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::MediaCaptureThermalStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::MediaCategory>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaCategory;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::MediaCategory is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::MediaStreamType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaStreamType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::MediaStreamType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::PhotoCaptureSource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhotoCaptureSource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::PhotoCaptureSource is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::PowerlineFrequency>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PowerlineFrequency;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::PowerlineFrequency is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::StreamingCaptureMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StreamingCaptureMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::StreamingCaptureMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::VideoDeviceCharacteristic>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VideoDeviceCharacteristic;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::VideoDeviceCharacteristic is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Capture::VideoRotation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VideoRotation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::VideoRotation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AdvancedCapturedPhoto>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AdvancedCapturedPhoto;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AdvancedCapturedPhoto is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AdvancedPhotoCapture>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AdvancedPhotoCapture;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AdvancedPhotoCapture is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastBackgroundService>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastBackgroundService;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastBackgroundService is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastBackgroundServiceSignInInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastBackgroundServiceStreamInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastCameraCaptureStateChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastCameraCaptureStateChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastCameraCaptureStateChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastGlobalSettings>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastGlobalSettings;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastGlobalSettings is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastHeartbeatRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastHeartbeatRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastHeartbeatRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastMicrophoneCaptureStateChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastMicrophoneCaptureStateChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastMicrophoneCaptureStateChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastPlugIn>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastPlugIn;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastPlugIn is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastPlugInManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastPlugInManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastPlugInManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastPlugInStateChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastPlugInStateChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastPlugInStateChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastPreview>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastPreview;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastPreview is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastPreviewStateChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastPreviewStateChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastPreviewStateChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastPreviewStreamReader>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastPreviewStreamReader;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastPreviewStreamReader is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastPreviewStreamVideoFrame>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastPreviewStreamVideoFrame;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastPreviewStreamVideoFrame is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastPreviewStreamVideoHeader>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastPreviewStreamVideoHeader;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastPreviewStreamVideoHeader is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastProviderSettings>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastProviderSettings;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastProviderSettings is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastServices>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastServices;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastServices is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastSignInStateChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastSignInStateChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastSignInStateChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastState is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastStreamAudioFrame>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastStreamAudioFrame;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastStreamAudioFrame is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastStreamAudioHeader>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastStreamAudioHeader;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastStreamAudioHeader is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastStreamReader>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastStreamReader;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastStreamReader is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastStreamStateChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastStreamStateChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastStreamStateChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastStreamVideoFrame>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastStreamVideoFrame;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastStreamVideoFrame is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastStreamVideoHeader>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastStreamVideoHeader;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastStreamVideoHeader is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppBroadcastViewerCountChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppBroadcastViewerCountChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppBroadcastViewerCountChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppCapture>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppCapture;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppCapture is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppCaptureAlternateShortcutKeys>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppCaptureAlternateShortcutKeys;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppCaptureAlternateShortcutKeys is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppCaptureDurationGeneratedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppCaptureDurationGeneratedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppCaptureDurationGeneratedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppCaptureFileGeneratedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppCaptureFileGeneratedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppCaptureFileGeneratedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppCaptureManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppCaptureManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppCaptureManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppCaptureMetadataWriter>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppCaptureMetadataWriter;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppCaptureMetadataWriter is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppCaptureMicrophoneCaptureStateChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppCaptureMicrophoneCaptureStateChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppCaptureMicrophoneCaptureStateChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppCaptureRecordOperation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppCaptureRecordOperation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppCaptureRecordOperation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppCaptureRecordingStateChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppCaptureRecordingStateChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppCaptureRecordingStateChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppCaptureServices>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppCaptureServices;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppCaptureServices is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppCaptureSettings>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppCaptureSettings;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppCaptureSettings is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppCaptureState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppCaptureState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::AppCaptureState is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::CameraCaptureUI>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CameraCaptureUI;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::CameraCaptureUI is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CameraCaptureUIPhotoCaptureSettings;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CameraCaptureUIVideoCaptureSettings;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::CameraOptionsUI>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CameraOptionsUI;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::CameraOptionsUI is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::CapturedFrame>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CapturedFrame;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::CapturedFrame is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::CapturedFrameControlValues>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CapturedFrameControlValues;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::CapturedFrameControlValues is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::CapturedPhoto>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CapturedPhoto;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::CapturedPhoto is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::GameBarServices>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GameBarServices;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::GameBarServices is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::GameBarServicesCommandEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GameBarServicesCommandEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::GameBarServicesCommandEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::GameBarServicesManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GameBarServicesManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::GameBarServicesManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::GameBarServicesManagerGameBarServicesCreatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GameBarServicesManagerGameBarServicesCreatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::GameBarServicesManagerGameBarServicesCreatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::GameBarServicesTargetInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GameBarServicesTargetInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::GameBarServicesTargetInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::LowLagMediaRecording>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LowLagMediaRecording;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::LowLagMediaRecording is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::LowLagPhotoCapture>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LowLagPhotoCapture;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::LowLagPhotoCapture is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::LowLagPhotoSequenceCapture>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LowLagPhotoSequenceCapture;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::LowLagPhotoSequenceCapture is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCapture>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaCapture;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::MediaCapture is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureFailedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaCaptureFailedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::MediaCaptureFailedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaCaptureFocusChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureInitializationSettings>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaCaptureInitializationSettings;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::MediaCaptureInitializationSettings is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCapturePauseResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaCapturePauseResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::MediaCapturePauseResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureRelativePanelWatcher>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaCaptureRelativePanelWatcher;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::MediaCaptureRelativePanelWatcher is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureSettings>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaCaptureSettings;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::MediaCaptureSettings is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureStopResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaCaptureStopResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::MediaCaptureStopResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureVideoProfile>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaCaptureVideoProfile;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::MediaCaptureVideoProfile is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaCaptureVideoProfileMediaDescription;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_OptionalReferencePhotoCapturedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::PhotoCapturedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhotoCapturedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::PhotoCapturedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhotoConfirmationCapturedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::ScreenCapture>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ScreenCapture;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::ScreenCapture is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::SourceSuspensionChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SourceSuspensionChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::SourceSuspensionChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::VideoStreamConfiguration>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VideoStreamConfiguration;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::VideoStreamConfiguration is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::WhiteBalanceGain>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Capture;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Capture");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WhiteBalanceGain;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Capture::WhiteBalanceGain is not registered");
        return nullptr;
    }

    return python_type;
}
