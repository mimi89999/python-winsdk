// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.UI.WebUI.h"


namespace py::cpp::Windows::UI::WebUI
{
    struct module_state
    {
        PyObject* type_PrintContent;
        PyTypeObject* type_ActivatedDeferral;
        PyTypeObject* type_ActivatedOperation;
        PyTypeObject* type_BackgroundActivatedEventArgs;
        PyTypeObject* type_EnteredBackgroundEventArgs;
        PyTypeObject* type_HtmlPrintDocumentSource;
        PyTypeObject* type_LeavingBackgroundEventArgs;
        PyTypeObject* type_NewWebUIViewCreatedEventArgs;
        PyTypeObject* type_SuspendingDeferral;
        PyTypeObject* type_SuspendingEventArgs;
        PyTypeObject* type_SuspendingOperation;
        PyTypeObject* type_WebUIApplication;
        PyTypeObject* type_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs;
        PyTypeObject* type_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs;
        PyTypeObject* type_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs;
        PyTypeObject* type_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs;
        PyTypeObject* type_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs;
        PyTypeObject* type_WebUIBackgroundTaskInstance;
        PyTypeObject* type_WebUIBackgroundTaskInstanceRuntimeClass;
        PyTypeObject* type_WebUIBarcodeScannerPreviewActivatedEventArgs;
        PyTypeObject* type_WebUICachedFileUpdaterActivatedEventArgs;
        PyTypeObject* type_WebUICameraSettingsActivatedEventArgs;
        PyTypeObject* type_WebUICommandLineActivatedEventArgs;
        PyTypeObject* type_WebUIContactCallActivatedEventArgs;
        PyTypeObject* type_WebUIContactMapActivatedEventArgs;
        PyTypeObject* type_WebUIContactMessageActivatedEventArgs;
        PyTypeObject* type_WebUIContactPanelActivatedEventArgs;
        PyTypeObject* type_WebUIContactPickerActivatedEventArgs;
        PyTypeObject* type_WebUIContactPostActivatedEventArgs;
        PyTypeObject* type_WebUIContactVideoCallActivatedEventArgs;
        PyTypeObject* type_WebUIDeviceActivatedEventArgs;
        PyTypeObject* type_WebUIDevicePairingActivatedEventArgs;
        PyTypeObject* type_WebUIDialReceiverActivatedEventArgs;
        PyTypeObject* type_WebUIFileActivatedEventArgs;
        PyTypeObject* type_WebUIFileOpenPickerActivatedEventArgs;
        PyTypeObject* type_WebUIFileOpenPickerContinuationEventArgs;
        PyTypeObject* type_WebUIFileSavePickerActivatedEventArgs;
        PyTypeObject* type_WebUIFileSavePickerContinuationEventArgs;
        PyTypeObject* type_WebUIFolderPickerContinuationEventArgs;
        PyTypeObject* type_WebUILaunchActivatedEventArgs;
        PyTypeObject* type_WebUILockScreenActivatedEventArgs;
        PyTypeObject* type_WebUILockScreenCallActivatedEventArgs;
        PyTypeObject* type_WebUILockScreenComponentActivatedEventArgs;
        PyTypeObject* type_WebUINavigatedDeferral;
        PyTypeObject* type_WebUINavigatedEventArgs;
        PyTypeObject* type_WebUINavigatedOperation;
        PyTypeObject* type_WebUIPhoneCallActivatedEventArgs;
        PyTypeObject* type_WebUIPrint3DWorkflowActivatedEventArgs;
        PyTypeObject* type_WebUIPrintTaskSettingsActivatedEventArgs;
        PyTypeObject* type_WebUIPrintWorkflowForegroundTaskActivatedEventArgs;
        PyTypeObject* type_WebUIProtocolActivatedEventArgs;
        PyTypeObject* type_WebUIProtocolForResultsActivatedEventArgs;
        PyTypeObject* type_WebUIRestrictedLaunchActivatedEventArgs;
        PyTypeObject* type_WebUISearchActivatedEventArgs;
        PyTypeObject* type_WebUIShareTargetActivatedEventArgs;
        PyTypeObject* type_WebUIStartupTaskActivatedEventArgs;
        PyTypeObject* type_WebUIToastNotificationActivatedEventArgs;
        PyTypeObject* type_WebUIUserDataAccountProviderActivatedEventArgs;
        PyTypeObject* type_WebUIView;
        PyTypeObject* type_WebUIVoiceCommandActivatedEventArgs;
        PyTypeObject* type_WebUIWalletActionActivatedEventArgs;
        PyTypeObject* type_WebUIWebAccountProviderActivatedEventArgs;
        PyTypeObject* type_WebUIWebAuthenticationBrokerContinuationEventArgs;
        PyTypeObject* type_IActivatedEventArgsDeferral;
        PyTypeObject* type_IWebUIBackgroundTaskInstance;
        PyTypeObject* type_IWebUINavigatedEventArgs;
    };

    static PyObject* register_PrintContent(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PrintContent)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PrintContent = type;
        Py_INCREF(state->type_PrintContent);


        Py_RETURN_NONE;
    }

    // ----- ActivatedDeferral class --------------------
    static constexpr const char* const type_name_ActivatedDeferral = "ActivatedDeferral";

    static PyObject* _new_ActivatedDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ActivatedDeferral);
        return nullptr;
    }

    static void _dealloc_ActivatedDeferral(py::wrapper::Windows::UI::WebUI::ActivatedDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActivatedDeferral_Complete(py::wrapper::Windows::UI::WebUI::ActivatedDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.ActivatedDeferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ActivatedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::ActivatedDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ActivatedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::ActivatedDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivatedDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(ActivatedDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ActivatedDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActivatedDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ActivatedDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_ActivatedDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ActivatedDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ActivatedDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ActivatedDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ActivatedDeferral) },
        { },
    };

    static PyType_Spec type_spec_ActivatedDeferral =
    {
        "_winsdk_Windows_UI_WebUI.ActivatedDeferral",
        sizeof(py::wrapper::Windows::UI::WebUI::ActivatedDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivatedDeferral
    };

    // ----- ActivatedOperation class --------------------
    static constexpr const char* const type_name_ActivatedOperation = "ActivatedOperation";

    static PyObject* _new_ActivatedOperation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ActivatedOperation);
        return nullptr;
    }

    static void _dealloc_ActivatedOperation(py::wrapper::Windows::UI::WebUI::ActivatedOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActivatedOperation_GetDeferral(py::wrapper::Windows::UI::WebUI::ActivatedOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.ActivatedOperation", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ActivatedOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::ActivatedOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ActivatedOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::ActivatedOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivatedOperation[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(ActivatedOperation_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ActivatedOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActivatedOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ActivatedOperation[] = {
        { }
    };

    static PyType_Slot _type_slots_ActivatedOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ActivatedOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ActivatedOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ActivatedOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ActivatedOperation) },
        { },
    };

    static PyType_Spec type_spec_ActivatedOperation =
    {
        "_winsdk_Windows_UI_WebUI.ActivatedOperation",
        sizeof(py::wrapper::Windows::UI::WebUI::ActivatedOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivatedOperation
    };

    // ----- BackgroundActivatedEventArgs class --------------------
    static constexpr const char* const type_name_BackgroundActivatedEventArgs = "BackgroundActivatedEventArgs";

    static PyObject* _new_BackgroundActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BackgroundActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_BackgroundActivatedEventArgs(py::wrapper::Windows::UI::WebUI::BackgroundActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundActivatedEventArgs_get_TaskInstance(py::wrapper::Windows::UI::WebUI::BackgroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.BackgroundActivatedEventArgs", L"TaskInstance"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TaskInstance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackgroundActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::BackgroundActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::BackgroundActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_BackgroundActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundActivatedEventArgs[] = {
        { "task_instance", reinterpret_cast<getter>(BackgroundActivatedEventArgs_get_TaskInstance), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_BackgroundActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.BackgroundActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::BackgroundActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundActivatedEventArgs
    };

    // ----- EnteredBackgroundEventArgs class --------------------
    static constexpr const char* const type_name_EnteredBackgroundEventArgs = "EnteredBackgroundEventArgs";

    static PyObject* _new_EnteredBackgroundEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EnteredBackgroundEventArgs);
        return nullptr;
    }

    static void _dealloc_EnteredBackgroundEventArgs(py::wrapper::Windows::UI::WebUI::EnteredBackgroundEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EnteredBackgroundEventArgs_GetDeferral(py::wrapper::Windows::UI::WebUI::EnteredBackgroundEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.EnteredBackgroundEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_EnteredBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::EnteredBackgroundEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EnteredBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::EnteredBackgroundEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EnteredBackgroundEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EnteredBackgroundEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EnteredBackgroundEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EnteredBackgroundEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EnteredBackgroundEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_EnteredBackgroundEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EnteredBackgroundEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EnteredBackgroundEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EnteredBackgroundEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EnteredBackgroundEventArgs) },
        { },
    };

    static PyType_Spec type_spec_EnteredBackgroundEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.EnteredBackgroundEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::EnteredBackgroundEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EnteredBackgroundEventArgs
    };

    // ----- HtmlPrintDocumentSource class --------------------
    static constexpr const char* const type_name_HtmlPrintDocumentSource = "HtmlPrintDocumentSource";

    static PyObject* _new_HtmlPrintDocumentSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HtmlPrintDocumentSource);
        return nullptr;
    }

    static void _dealloc_HtmlPrintDocumentSource(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HtmlPrintDocumentSource_Close(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HtmlPrintDocumentSource_TrySetPageRange(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"TrySetPageRange", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TrySetPageRange(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HtmlPrintDocumentSource_get_TopMargin(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"TopMargin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TopMargin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HtmlPrintDocumentSource_put_TopMargin(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"TopMargin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.TopMargin(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HtmlPrintDocumentSource_get_ShrinkToFit(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"ShrinkToFit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShrinkToFit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HtmlPrintDocumentSource_put_ShrinkToFit(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"ShrinkToFit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShrinkToFit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HtmlPrintDocumentSource_get_RightMargin(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"RightMargin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RightMargin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HtmlPrintDocumentSource_put_RightMargin(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"RightMargin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.RightMargin(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HtmlPrintDocumentSource_get_PercentScale(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"PercentScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PercentScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HtmlPrintDocumentSource_put_PercentScale(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"PercentScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.PercentScale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HtmlPrintDocumentSource_get_LeftMargin(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"LeftMargin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LeftMargin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HtmlPrintDocumentSource_put_LeftMargin(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"LeftMargin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.LeftMargin(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HtmlPrintDocumentSource_get_EnableHeaderFooter(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"EnableHeaderFooter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EnableHeaderFooter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HtmlPrintDocumentSource_put_EnableHeaderFooter(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"EnableHeaderFooter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.EnableHeaderFooter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HtmlPrintDocumentSource_get_Content(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"Content"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HtmlPrintDocumentSource_put_Content(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"Content"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::WebUI::PrintContent>(arg);

            self->obj.Content(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HtmlPrintDocumentSource_get_BottomMargin(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"BottomMargin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BottomMargin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HtmlPrintDocumentSource_put_BottomMargin(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"BottomMargin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.BottomMargin(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HtmlPrintDocumentSource_get_PageRange(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"PageRange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PageRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HtmlPrintDocumentSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::HtmlPrintDocumentSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HtmlPrintDocumentSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::HtmlPrintDocumentSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HtmlPrintDocumentSource(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_HtmlPrintDocumentSource(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HtmlPrintDocumentSource[] = {
        { "close", reinterpret_cast<PyCFunction>(HtmlPrintDocumentSource_Close), METH_VARARGS, nullptr },
        { "try_set_page_range", reinterpret_cast<PyCFunction>(HtmlPrintDocumentSource_TrySetPageRange), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HtmlPrintDocumentSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HtmlPrintDocumentSource), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_HtmlPrintDocumentSource), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_HtmlPrintDocumentSource), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_HtmlPrintDocumentSource[] = {
        { "top_margin", reinterpret_cast<getter>(HtmlPrintDocumentSource_get_TopMargin), reinterpret_cast<setter>(HtmlPrintDocumentSource_put_TopMargin), nullptr, nullptr },
        { "shrink_to_fit", reinterpret_cast<getter>(HtmlPrintDocumentSource_get_ShrinkToFit), reinterpret_cast<setter>(HtmlPrintDocumentSource_put_ShrinkToFit), nullptr, nullptr },
        { "right_margin", reinterpret_cast<getter>(HtmlPrintDocumentSource_get_RightMargin), reinterpret_cast<setter>(HtmlPrintDocumentSource_put_RightMargin), nullptr, nullptr },
        { "percent_scale", reinterpret_cast<getter>(HtmlPrintDocumentSource_get_PercentScale), reinterpret_cast<setter>(HtmlPrintDocumentSource_put_PercentScale), nullptr, nullptr },
        { "left_margin", reinterpret_cast<getter>(HtmlPrintDocumentSource_get_LeftMargin), reinterpret_cast<setter>(HtmlPrintDocumentSource_put_LeftMargin), nullptr, nullptr },
        { "enable_header_footer", reinterpret_cast<getter>(HtmlPrintDocumentSource_get_EnableHeaderFooter), reinterpret_cast<setter>(HtmlPrintDocumentSource_put_EnableHeaderFooter), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(HtmlPrintDocumentSource_get_Content), reinterpret_cast<setter>(HtmlPrintDocumentSource_put_Content), nullptr, nullptr },
        { "bottom_margin", reinterpret_cast<getter>(HtmlPrintDocumentSource_get_BottomMargin), reinterpret_cast<setter>(HtmlPrintDocumentSource_put_BottomMargin), nullptr, nullptr },
        { "page_range", reinterpret_cast<getter>(HtmlPrintDocumentSource_get_PageRange), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HtmlPrintDocumentSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HtmlPrintDocumentSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HtmlPrintDocumentSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HtmlPrintDocumentSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HtmlPrintDocumentSource) },
        { },
    };

    static PyType_Spec type_spec_HtmlPrintDocumentSource =
    {
        "_winsdk_Windows_UI_WebUI.HtmlPrintDocumentSource",
        sizeof(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HtmlPrintDocumentSource
    };

    // ----- LeavingBackgroundEventArgs class --------------------
    static constexpr const char* const type_name_LeavingBackgroundEventArgs = "LeavingBackgroundEventArgs";

    static PyObject* _new_LeavingBackgroundEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LeavingBackgroundEventArgs);
        return nullptr;
    }

    static void _dealloc_LeavingBackgroundEventArgs(py::wrapper::Windows::UI::WebUI::LeavingBackgroundEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LeavingBackgroundEventArgs_GetDeferral(py::wrapper::Windows::UI::WebUI::LeavingBackgroundEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.LeavingBackgroundEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_LeavingBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::LeavingBackgroundEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LeavingBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::LeavingBackgroundEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LeavingBackgroundEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(LeavingBackgroundEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LeavingBackgroundEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LeavingBackgroundEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LeavingBackgroundEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_LeavingBackgroundEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LeavingBackgroundEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LeavingBackgroundEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LeavingBackgroundEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LeavingBackgroundEventArgs) },
        { },
    };

    static PyType_Spec type_spec_LeavingBackgroundEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.LeavingBackgroundEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::LeavingBackgroundEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LeavingBackgroundEventArgs
    };

    // ----- NewWebUIViewCreatedEventArgs class --------------------
    static constexpr const char* const type_name_NewWebUIViewCreatedEventArgs = "NewWebUIViewCreatedEventArgs";

    static PyObject* _new_NewWebUIViewCreatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_NewWebUIViewCreatedEventArgs);
        return nullptr;
    }

    static void _dealloc_NewWebUIViewCreatedEventArgs(py::wrapper::Windows::UI::WebUI::NewWebUIViewCreatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NewWebUIViewCreatedEventArgs_GetDeferral(py::wrapper::Windows::UI::WebUI::NewWebUIViewCreatedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.NewWebUIViewCreatedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NewWebUIViewCreatedEventArgs_get_ActivatedEventArgs(py::wrapper::Windows::UI::WebUI::NewWebUIViewCreatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.NewWebUIViewCreatedEventArgs", L"ActivatedEventArgs"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedEventArgs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NewWebUIViewCreatedEventArgs_get_HasPendingNavigate(py::wrapper::Windows::UI::WebUI::NewWebUIViewCreatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.NewWebUIViewCreatedEventArgs", L"HasPendingNavigate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasPendingNavigate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NewWebUIViewCreatedEventArgs_get_WebUIView(py::wrapper::Windows::UI::WebUI::NewWebUIViewCreatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.NewWebUIViewCreatedEventArgs", L"WebUIView"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WebUIView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NewWebUIViewCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::NewWebUIViewCreatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NewWebUIViewCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::NewWebUIViewCreatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NewWebUIViewCreatedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(NewWebUIViewCreatedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NewWebUIViewCreatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NewWebUIViewCreatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NewWebUIViewCreatedEventArgs[] = {
        { "activated_event_args", reinterpret_cast<getter>(NewWebUIViewCreatedEventArgs_get_ActivatedEventArgs), nullptr, nullptr, nullptr },
        { "has_pending_navigate", reinterpret_cast<getter>(NewWebUIViewCreatedEventArgs_get_HasPendingNavigate), nullptr, nullptr, nullptr },
        { "web_u_i_view", reinterpret_cast<getter>(NewWebUIViewCreatedEventArgs_get_WebUIView), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NewWebUIViewCreatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NewWebUIViewCreatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NewWebUIViewCreatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NewWebUIViewCreatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NewWebUIViewCreatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_NewWebUIViewCreatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.NewWebUIViewCreatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::NewWebUIViewCreatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NewWebUIViewCreatedEventArgs
    };

    // ----- SuspendingDeferral class --------------------
    static constexpr const char* const type_name_SuspendingDeferral = "SuspendingDeferral";

    static PyObject* _new_SuspendingDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SuspendingDeferral);
        return nullptr;
    }

    static void _dealloc_SuspendingDeferral(py::wrapper::Windows::UI::WebUI::SuspendingDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SuspendingDeferral_Complete(py::wrapper::Windows::UI::WebUI::SuspendingDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.SuspendingDeferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SuspendingDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::SuspendingDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SuspendingDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::SuspendingDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SuspendingDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(SuspendingDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SuspendingDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SuspendingDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SuspendingDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_SuspendingDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SuspendingDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SuspendingDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SuspendingDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SuspendingDeferral) },
        { },
    };

    static PyType_Spec type_spec_SuspendingDeferral =
    {
        "_winsdk_Windows_UI_WebUI.SuspendingDeferral",
        sizeof(py::wrapper::Windows::UI::WebUI::SuspendingDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SuspendingDeferral
    };

    // ----- SuspendingEventArgs class --------------------
    static constexpr const char* const type_name_SuspendingEventArgs = "SuspendingEventArgs";

    static PyObject* _new_SuspendingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SuspendingEventArgs);
        return nullptr;
    }

    static void _dealloc_SuspendingEventArgs(py::wrapper::Windows::UI::WebUI::SuspendingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SuspendingEventArgs_get_SuspendingOperation(py::wrapper::Windows::UI::WebUI::SuspendingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.SuspendingEventArgs", L"SuspendingOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SuspendingOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SuspendingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::SuspendingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SuspendingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::SuspendingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SuspendingEventArgs[] = {
        { "_assign_array_", _assign_array_SuspendingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SuspendingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SuspendingEventArgs[] = {
        { "suspending_operation", reinterpret_cast<getter>(SuspendingEventArgs_get_SuspendingOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SuspendingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SuspendingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SuspendingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SuspendingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SuspendingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SuspendingEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.SuspendingEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::SuspendingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SuspendingEventArgs
    };

    // ----- SuspendingOperation class --------------------
    static constexpr const char* const type_name_SuspendingOperation = "SuspendingOperation";

    static PyObject* _new_SuspendingOperation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SuspendingOperation);
        return nullptr;
    }

    static void _dealloc_SuspendingOperation(py::wrapper::Windows::UI::WebUI::SuspendingOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SuspendingOperation_GetDeferral(py::wrapper::Windows::UI::WebUI::SuspendingOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.SuspendingOperation", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SuspendingOperation_get_Deadline(py::wrapper::Windows::UI::WebUI::SuspendingOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.SuspendingOperation", L"Deadline"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Deadline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SuspendingOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::SuspendingOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SuspendingOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::SuspendingOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SuspendingOperation[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(SuspendingOperation_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SuspendingOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SuspendingOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SuspendingOperation[] = {
        { "deadline", reinterpret_cast<getter>(SuspendingOperation_get_Deadline), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SuspendingOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SuspendingOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SuspendingOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SuspendingOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SuspendingOperation) },
        { },
    };

    static PyType_Spec type_spec_SuspendingOperation =
    {
        "_winsdk_Windows_UI_WebUI.SuspendingOperation",
        sizeof(py::wrapper::Windows::UI::WebUI::SuspendingOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SuspendingOperation
    };

    // ----- WebUIApplication class --------------------
    static constexpr const char* const type_name_WebUIApplication = "WebUIApplication";

    static PyObject* _new_WebUIApplication(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIApplication);
        return nullptr;
    }

    static PyObject* WebUIApplication_EnablePrelaunch(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIApplication", L"EnablePrelaunch", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                winrt::Windows::UI::WebUI::WebUIApplication::EnablePrelaunch(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_RequestRestartAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIApplication", L"RequestRestartAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::UI::WebUI::WebUIApplication::RequestRestartAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_RequestRestartForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIApplication", L"RequestRestartForUserAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::UI::WebUI::WebUIApplication::RequestRestartForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_add_BackgroundActivated(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"BackgroundActivated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::WebUI::BackgroundActivatedEventHandler>(arg);

            return py::convert(winrt::Windows::UI::WebUI::WebUIApplication::BackgroundActivated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_remove_BackgroundActivated(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"BackgroundActivated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::UI::WebUI::WebUIApplication::BackgroundActivated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_add_NewWebUIViewCreated(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"NewWebUIViewCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::UI::WebUI::NewWebUIViewCreatedEventArgs>>(arg);

            return py::convert(winrt::Windows::UI::WebUI::WebUIApplication::NewWebUIViewCreated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_remove_NewWebUIViewCreated(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"NewWebUIViewCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::UI::WebUI::WebUIApplication::NewWebUIViewCreated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_add_EnteredBackground(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"EnteredBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::WebUI::EnteredBackgroundEventHandler>(arg);

            return py::convert(winrt::Windows::UI::WebUI::WebUIApplication::EnteredBackground(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_remove_EnteredBackground(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"EnteredBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::UI::WebUI::WebUIApplication::EnteredBackground(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_add_LeavingBackground(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"LeavingBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::WebUI::LeavingBackgroundEventHandler>(arg);

            return py::convert(winrt::Windows::UI::WebUI::WebUIApplication::LeavingBackground(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_remove_LeavingBackground(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"LeavingBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::UI::WebUI::WebUIApplication::LeavingBackground(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_add_Activated(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"Activated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::WebUI::ActivatedEventHandler>(arg);

            return py::convert(winrt::Windows::UI::WebUI::WebUIApplication::Activated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_remove_Activated(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"Activated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::UI::WebUI::WebUIApplication::Activated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_add_Navigated(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"Navigated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::WebUI::NavigatedEventHandler>(arg);

            return py::convert(winrt::Windows::UI::WebUI::WebUIApplication::Navigated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_remove_Navigated(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"Navigated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::UI::WebUI::WebUIApplication::Navigated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_add_Resuming(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"Resuming"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::WebUI::ResumingEventHandler>(arg);

            return py::convert(winrt::Windows::UI::WebUI::WebUIApplication::Resuming(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_remove_Resuming(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"Resuming"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::UI::WebUI::WebUIApplication::Resuming(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_add_Suspending(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"Suspending"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::WebUI::SuspendingEventHandler>(arg);

            return py::convert(winrt::Windows::UI::WebUI::WebUIApplication::Suspending(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_remove_Suspending(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"Suspending"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::UI::WebUI::WebUIApplication::Suspending(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIApplication[] = {
        { "enable_prelaunch", reinterpret_cast<PyCFunction>(WebUIApplication_EnablePrelaunch), METH_VARARGS | METH_STATIC, nullptr },
        { "request_restart_async", reinterpret_cast<PyCFunction>(WebUIApplication_RequestRestartAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "request_restart_for_user_async", reinterpret_cast<PyCFunction>(WebUIApplication_RequestRestartForUserAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "add_background_activated", reinterpret_cast<PyCFunction>(WebUIApplication_add_BackgroundActivated), METH_O | METH_STATIC, nullptr },
        { "remove_background_activated", reinterpret_cast<PyCFunction>(WebUIApplication_remove_BackgroundActivated), METH_O | METH_STATIC, nullptr },
        { "add_new_web_u_i_view_created", reinterpret_cast<PyCFunction>(WebUIApplication_add_NewWebUIViewCreated), METH_O | METH_STATIC, nullptr },
        { "remove_new_web_u_i_view_created", reinterpret_cast<PyCFunction>(WebUIApplication_remove_NewWebUIViewCreated), METH_O | METH_STATIC, nullptr },
        { "add_entered_background", reinterpret_cast<PyCFunction>(WebUIApplication_add_EnteredBackground), METH_O | METH_STATIC, nullptr },
        { "remove_entered_background", reinterpret_cast<PyCFunction>(WebUIApplication_remove_EnteredBackground), METH_O | METH_STATIC, nullptr },
        { "add_leaving_background", reinterpret_cast<PyCFunction>(WebUIApplication_add_LeavingBackground), METH_O | METH_STATIC, nullptr },
        { "remove_leaving_background", reinterpret_cast<PyCFunction>(WebUIApplication_remove_LeavingBackground), METH_O | METH_STATIC, nullptr },
        { "add_activated", reinterpret_cast<PyCFunction>(WebUIApplication_add_Activated), METH_O | METH_STATIC, nullptr },
        { "remove_activated", reinterpret_cast<PyCFunction>(WebUIApplication_remove_Activated), METH_O | METH_STATIC, nullptr },
        { "add_navigated", reinterpret_cast<PyCFunction>(WebUIApplication_add_Navigated), METH_O | METH_STATIC, nullptr },
        { "remove_navigated", reinterpret_cast<PyCFunction>(WebUIApplication_remove_Navigated), METH_O | METH_STATIC, nullptr },
        { "add_resuming", reinterpret_cast<PyCFunction>(WebUIApplication_add_Resuming), METH_O | METH_STATIC, nullptr },
        { "remove_resuming", reinterpret_cast<PyCFunction>(WebUIApplication_remove_Resuming), METH_O | METH_STATIC, nullptr },
        { "add_suspending", reinterpret_cast<PyCFunction>(WebUIApplication_add_Suspending), METH_O | METH_STATIC, nullptr },
        { "remove_suspending", reinterpret_cast<PyCFunction>(WebUIApplication_remove_Suspending), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIApplication[] = {
        { }
    };

    static PyType_Slot _type_slots_WebUIApplication[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIApplication) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIApplication) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIApplication) },
        { },
    };

    static PyType_Spec type_spec_WebUIApplication =
    {
        "_winsdk_Windows_UI_WebUI.WebUIApplication",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIApplication
    };

    // ----- WebUIAppointmentsProviderAddAppointmentActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs = "WebUIAppointmentsProviderAddAppointmentActivatedEventArgs";

    static PyObject* _new_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderAddAppointmentActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderAddAppointmentActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderAddAppointmentActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderAddAppointmentActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderAddAppointmentActivatedEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_Verb(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderAddAppointmentActivatedEventArgs", L"Verb"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_AddAppointmentOperation(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderAddAppointmentActivatedEventArgs", L"AddAppointmentOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AddAppointmentOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderAddAppointmentActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderAddAppointmentActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderAddAppointmentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "add_appointment_operation", reinterpret_cast<getter>(WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_AddAppointmentOperation), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIAppointmentsProviderAddAppointmentActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderAddAppointmentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs
    };

    // ----- WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs = "WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs";

    static PyObject* _new_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Verb(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs", L"Verb"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_RemoveAppointmentOperation(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs", L"RemoveAppointmentOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoveAppointmentOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "remove_appointment_operation", reinterpret_cast<getter>(WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_RemoveAppointmentOperation), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs
    };

    // ----- WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs = "WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs";

    static PyObject* _new_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Verb(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs", L"Verb"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_ReplaceAppointmentOperation(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs", L"ReplaceAppointmentOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReplaceAppointmentOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "replace_appointment_operation", reinterpret_cast<getter>(WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_ReplaceAppointmentOperation), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs
    };

    // ----- WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs = "WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs";

    static PyObject* _new_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Verb(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"Verb"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_InstanceStartDate(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"InstanceStartDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstanceStartDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_LocalId(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"LocalId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocalId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_RoamingId(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"RoamingId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RoamingId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "instance_start_date", reinterpret_cast<getter>(WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_InstanceStartDate), nullptr, nullptr, nullptr },
        { "local_id", reinterpret_cast<getter>(WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_LocalId), nullptr, nullptr, nullptr },
        { "roaming_id", reinterpret_cast<getter>(WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_RoamingId), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs
    };

    // ----- WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs = "WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs";

    static PyObject* _new_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Verb(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs", L"Verb"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Duration(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_TimeToShow(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs", L"TimeToShow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeToShow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Duration), nullptr, nullptr, nullptr },
        { "time_to_show", reinterpret_cast<getter>(WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_TimeToShow), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs
    };

    // ----- WebUIBackgroundTaskInstance class --------------------
    static constexpr const char* const type_name_WebUIBackgroundTaskInstance = "WebUIBackgroundTaskInstance";

    static PyObject* _new_WebUIBackgroundTaskInstance(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIBackgroundTaskInstance);
        return nullptr;
    }

    static PyObject* WebUIBackgroundTaskInstance_get_Current(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBackgroundTaskInstance", L"Current"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::WebUI::WebUIBackgroundTaskInstance::Current());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIBackgroundTaskInstance[] = {
        { }
    };

    static PyGetSetDef _getset_WebUIBackgroundTaskInstance[] = {
        { }
    };

    static PyType_Slot _type_slots_WebUIBackgroundTaskInstance[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIBackgroundTaskInstance) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIBackgroundTaskInstance) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIBackgroundTaskInstance) },
        { },
    };

    static PyType_Spec type_spec_WebUIBackgroundTaskInstance =
    {
        "_winsdk_Windows_UI_WebUI.WebUIBackgroundTaskInstance",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIBackgroundTaskInstance
    };

    static PyGetSetDef getset_WebUIBackgroundTaskInstance_Meta[] = {
        { "current", reinterpret_cast<getter>(WebUIBackgroundTaskInstance_get_Current), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_WebUIBackgroundTaskInstance_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_WebUIBackgroundTaskInstance_Meta) },
        { }
    };

    static PyType_Spec type_spec_WebUIBackgroundTaskInstance_Meta =
    {
        "_winsdk_Windows_UI_WebUI.WebUIBackgroundTaskInstance_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_WebUIBackgroundTaskInstance_Meta
    };

    // ----- WebUIBackgroundTaskInstanceRuntimeClass class --------------------
    static constexpr const char* const type_name_WebUIBackgroundTaskInstanceRuntimeClass = "WebUIBackgroundTaskInstanceRuntimeClass";

    static PyObject* _new_WebUIBackgroundTaskInstanceRuntimeClass(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIBackgroundTaskInstanceRuntimeClass);
        return nullptr;
    }

    static void _dealloc_WebUIBackgroundTaskInstanceRuntimeClass(py::wrapper::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIBackgroundTaskInstanceRuntimeClass_GetDeferral(py::wrapper::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIBackgroundTaskInstanceRuntimeClass_get_Progress(py::wrapper::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebUIBackgroundTaskInstanceRuntimeClass_put_Progress(py::wrapper::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Progress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WebUIBackgroundTaskInstanceRuntimeClass_get_InstanceId(py::wrapper::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass", L"InstanceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIBackgroundTaskInstanceRuntimeClass_get_SuspendedCount(py::wrapper::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass", L"SuspendedCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SuspendedCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIBackgroundTaskInstanceRuntimeClass_get_Task(py::wrapper::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass", L"Task"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Task());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIBackgroundTaskInstanceRuntimeClass_get_TriggerDetails(py::wrapper::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass", L"TriggerDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TriggerDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIBackgroundTaskInstanceRuntimeClass_get_Succeeded(py::wrapper::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass", L"Succeeded"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Succeeded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebUIBackgroundTaskInstanceRuntimeClass_put_Succeeded(py::wrapper::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass", L"Succeeded"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Succeeded(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WebUIBackgroundTaskInstanceRuntimeClass_add_Canceled(py::wrapper::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass", L"Canceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskCanceledEventHandler>(arg);

            return py::convert(self->obj.Canceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIBackgroundTaskInstanceRuntimeClass_remove_Canceled(py::wrapper::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass", L"Canceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Canceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIBackgroundTaskInstanceRuntimeClass(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIBackgroundTaskInstanceRuntimeClass(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIBackgroundTaskInstanceRuntimeClass[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(WebUIBackgroundTaskInstanceRuntimeClass_GetDeferral), METH_VARARGS, nullptr },
        { "add_canceled", reinterpret_cast<PyCFunction>(WebUIBackgroundTaskInstanceRuntimeClass_add_Canceled), METH_O, nullptr },
        { "remove_canceled", reinterpret_cast<PyCFunction>(WebUIBackgroundTaskInstanceRuntimeClass_remove_Canceled), METH_O, nullptr },
        { "_assign_array_", _assign_array_WebUIBackgroundTaskInstanceRuntimeClass, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIBackgroundTaskInstanceRuntimeClass), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIBackgroundTaskInstanceRuntimeClass[] = {
        { "progress", reinterpret_cast<getter>(WebUIBackgroundTaskInstanceRuntimeClass_get_Progress), reinterpret_cast<setter>(WebUIBackgroundTaskInstanceRuntimeClass_put_Progress), nullptr, nullptr },
        { "instance_id", reinterpret_cast<getter>(WebUIBackgroundTaskInstanceRuntimeClass_get_InstanceId), nullptr, nullptr, nullptr },
        { "suspended_count", reinterpret_cast<getter>(WebUIBackgroundTaskInstanceRuntimeClass_get_SuspendedCount), nullptr, nullptr, nullptr },
        { "task", reinterpret_cast<getter>(WebUIBackgroundTaskInstanceRuntimeClass_get_Task), nullptr, nullptr, nullptr },
        { "trigger_details", reinterpret_cast<getter>(WebUIBackgroundTaskInstanceRuntimeClass_get_TriggerDetails), nullptr, nullptr, nullptr },
        { "succeeded", reinterpret_cast<getter>(WebUIBackgroundTaskInstanceRuntimeClass_get_Succeeded), reinterpret_cast<setter>(WebUIBackgroundTaskInstanceRuntimeClass_put_Succeeded), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIBackgroundTaskInstanceRuntimeClass[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIBackgroundTaskInstanceRuntimeClass) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIBackgroundTaskInstanceRuntimeClass) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIBackgroundTaskInstanceRuntimeClass) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIBackgroundTaskInstanceRuntimeClass) },
        { },
    };

    static PyType_Spec type_spec_WebUIBackgroundTaskInstanceRuntimeClass =
    {
        "_winsdk_Windows_UI_WebUI.WebUIBackgroundTaskInstanceRuntimeClass",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIBackgroundTaskInstanceRuntimeClass
    };

    // ----- WebUIBarcodeScannerPreviewActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIBarcodeScannerPreviewActivatedEventArgs = "WebUIBarcodeScannerPreviewActivatedEventArgs";

    static PyObject* _new_WebUIBarcodeScannerPreviewActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIBarcodeScannerPreviewActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIBarcodeScannerPreviewActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIBarcodeScannerPreviewActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIBarcodeScannerPreviewActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIBarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBarcodeScannerPreviewActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIBarcodeScannerPreviewActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIBarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBarcodeScannerPreviewActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIBarcodeScannerPreviewActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIBarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBarcodeScannerPreviewActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIBarcodeScannerPreviewActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIBarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBarcodeScannerPreviewActivatedEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIBarcodeScannerPreviewActivatedEventArgs_get_ConnectionId(py::wrapper::Windows::UI::WebUI::WebUIBarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBarcodeScannerPreviewActivatedEventArgs", L"ConnectionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConnectionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIBarcodeScannerPreviewActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIBarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBarcodeScannerPreviewActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIBarcodeScannerPreviewActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIBarcodeScannerPreviewActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIBarcodeScannerPreviewActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIBarcodeScannerPreviewActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIBarcodeScannerPreviewActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIBarcodeScannerPreviewActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIBarcodeScannerPreviewActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIBarcodeScannerPreviewActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIBarcodeScannerPreviewActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIBarcodeScannerPreviewActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIBarcodeScannerPreviewActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIBarcodeScannerPreviewActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "connection_id", reinterpret_cast<getter>(WebUIBarcodeScannerPreviewActivatedEventArgs_get_ConnectionId), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIBarcodeScannerPreviewActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIBarcodeScannerPreviewActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIBarcodeScannerPreviewActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIBarcodeScannerPreviewActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIBarcodeScannerPreviewActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIBarcodeScannerPreviewActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIBarcodeScannerPreviewActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIBarcodeScannerPreviewActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIBarcodeScannerPreviewActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIBarcodeScannerPreviewActivatedEventArgs
    };

    // ----- WebUICachedFileUpdaterActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUICachedFileUpdaterActivatedEventArgs = "WebUICachedFileUpdaterActivatedEventArgs";

    static PyObject* _new_WebUICachedFileUpdaterActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUICachedFileUpdaterActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUICachedFileUpdaterActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUICachedFileUpdaterActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUICachedFileUpdaterActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUICachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICachedFileUpdaterActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICachedFileUpdaterActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUICachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICachedFileUpdaterActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICachedFileUpdaterActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUICachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICachedFileUpdaterActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICachedFileUpdaterActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUICachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICachedFileUpdaterActivatedEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICachedFileUpdaterActivatedEventArgs_get_CachedFileUpdaterUI(py::wrapper::Windows::UI::WebUI::WebUICachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICachedFileUpdaterActivatedEventArgs", L"CachedFileUpdaterUI"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CachedFileUpdaterUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICachedFileUpdaterActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUICachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICachedFileUpdaterActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUICachedFileUpdaterActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUICachedFileUpdaterActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUICachedFileUpdaterActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUICachedFileUpdaterActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUICachedFileUpdaterActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUICachedFileUpdaterActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUICachedFileUpdaterActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUICachedFileUpdaterActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUICachedFileUpdaterActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUICachedFileUpdaterActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUICachedFileUpdaterActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUICachedFileUpdaterActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "cached_file_updater_u_i", reinterpret_cast<getter>(WebUICachedFileUpdaterActivatedEventArgs_get_CachedFileUpdaterUI), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUICachedFileUpdaterActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUICachedFileUpdaterActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUICachedFileUpdaterActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUICachedFileUpdaterActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUICachedFileUpdaterActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUICachedFileUpdaterActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUICachedFileUpdaterActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUICachedFileUpdaterActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUICachedFileUpdaterActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUICachedFileUpdaterActivatedEventArgs
    };

    // ----- WebUICameraSettingsActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUICameraSettingsActivatedEventArgs = "WebUICameraSettingsActivatedEventArgs";

    static PyObject* _new_WebUICameraSettingsActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUICameraSettingsActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUICameraSettingsActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUICameraSettingsActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUICameraSettingsActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUICameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICameraSettingsActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICameraSettingsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUICameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICameraSettingsActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICameraSettingsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUICameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICameraSettingsActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICameraSettingsActivatedEventArgs_get_VideoDeviceController(py::wrapper::Windows::UI::WebUI::WebUICameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICameraSettingsActivatedEventArgs", L"VideoDeviceController"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoDeviceController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICameraSettingsActivatedEventArgs_get_VideoDeviceExtension(py::wrapper::Windows::UI::WebUI::WebUICameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICameraSettingsActivatedEventArgs", L"VideoDeviceExtension"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoDeviceExtension());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICameraSettingsActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUICameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICameraSettingsActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUICameraSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUICameraSettingsActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUICameraSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUICameraSettingsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUICameraSettingsActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUICameraSettingsActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUICameraSettingsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUICameraSettingsActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUICameraSettingsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUICameraSettingsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUICameraSettingsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "video_device_controller", reinterpret_cast<getter>(WebUICameraSettingsActivatedEventArgs_get_VideoDeviceController), nullptr, nullptr, nullptr },
        { "video_device_extension", reinterpret_cast<getter>(WebUICameraSettingsActivatedEventArgs_get_VideoDeviceExtension), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUICameraSettingsActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUICameraSettingsActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUICameraSettingsActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUICameraSettingsActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUICameraSettingsActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUICameraSettingsActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUICameraSettingsActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUICameraSettingsActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUICameraSettingsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUICameraSettingsActivatedEventArgs
    };

    // ----- WebUICommandLineActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUICommandLineActivatedEventArgs = "WebUICommandLineActivatedEventArgs";

    static PyObject* _new_WebUICommandLineActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUICommandLineActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUICommandLineActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUICommandLineActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUICommandLineActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUICommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICommandLineActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICommandLineActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUICommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICommandLineActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICommandLineActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUICommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICommandLineActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICommandLineActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUICommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICommandLineActivatedEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICommandLineActivatedEventArgs_get_Operation(py::wrapper::Windows::UI::WebUI::WebUICommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICommandLineActivatedEventArgs", L"Operation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Operation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICommandLineActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUICommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICommandLineActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUICommandLineActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUICommandLineActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUICommandLineActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUICommandLineActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUICommandLineActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUICommandLineActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUICommandLineActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUICommandLineActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUICommandLineActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUICommandLineActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUICommandLineActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUICommandLineActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "operation", reinterpret_cast<getter>(WebUICommandLineActivatedEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUICommandLineActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUICommandLineActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUICommandLineActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUICommandLineActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUICommandLineActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUICommandLineActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUICommandLineActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUICommandLineActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUICommandLineActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUICommandLineActivatedEventArgs
    };

    // ----- WebUIContactCallActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIContactCallActivatedEventArgs = "WebUIContactCallActivatedEventArgs";

    static PyObject* _new_WebUIContactCallActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIContactCallActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIContactCallActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIContactCallActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactCallActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactCallActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactCallActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactCallActivatedEventArgs_get_Verb(py::wrapper::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactCallActivatedEventArgs", L"Verb"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactCallActivatedEventArgs_get_Contact(py::wrapper::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactCallActivatedEventArgs", L"Contact"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactCallActivatedEventArgs_get_ServiceId(py::wrapper::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactCallActivatedEventArgs", L"ServiceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactCallActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactCallActivatedEventArgs", L"ServiceUserId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServiceUserId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactCallActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactCallActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIContactCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIContactCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIContactCallActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIContactCallActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIContactCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIContactCallActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIContactCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIContactCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIContactCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(WebUIContactCallActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(WebUIContactCallActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(WebUIContactCallActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(WebUIContactCallActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIContactCallActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIContactCallActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIContactCallActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIContactCallActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIContactCallActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIContactCallActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIContactCallActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIContactCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIContactCallActivatedEventArgs
    };

    // ----- WebUIContactMapActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIContactMapActivatedEventArgs = "WebUIContactMapActivatedEventArgs";

    static PyObject* _new_WebUIContactMapActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIContactMapActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIContactMapActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIContactMapActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIContactMapActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMapActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactMapActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMapActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactMapActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMapActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactMapActivatedEventArgs_get_Verb(py::wrapper::Windows::UI::WebUI::WebUIContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMapActivatedEventArgs", L"Verb"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactMapActivatedEventArgs_get_Address(py::wrapper::Windows::UI::WebUI::WebUIContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMapActivatedEventArgs", L"Address"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactMapActivatedEventArgs_get_Contact(py::wrapper::Windows::UI::WebUI::WebUIContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMapActivatedEventArgs", L"Contact"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactMapActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMapActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIContactMapActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIContactMapActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIContactMapActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIContactMapActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIContactMapActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIContactMapActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIContactMapActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIContactMapActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIContactMapActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIContactMapActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIContactMapActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(WebUIContactMapActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "address", reinterpret_cast<getter>(WebUIContactMapActivatedEventArgs_get_Address), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(WebUIContactMapActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIContactMapActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIContactMapActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIContactMapActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIContactMapActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIContactMapActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIContactMapActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIContactMapActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIContactMapActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIContactMapActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIContactMapActivatedEventArgs
    };

    // ----- WebUIContactMessageActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIContactMessageActivatedEventArgs = "WebUIContactMessageActivatedEventArgs";

    static PyObject* _new_WebUIContactMessageActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIContactMessageActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIContactMessageActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIContactMessageActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMessageActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactMessageActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMessageActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactMessageActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMessageActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactMessageActivatedEventArgs_get_Verb(py::wrapper::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMessageActivatedEventArgs", L"Verb"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactMessageActivatedEventArgs_get_Contact(py::wrapper::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMessageActivatedEventArgs", L"Contact"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactMessageActivatedEventArgs_get_ServiceId(py::wrapper::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMessageActivatedEventArgs", L"ServiceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactMessageActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMessageActivatedEventArgs", L"ServiceUserId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServiceUserId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactMessageActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMessageActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIContactMessageActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIContactMessageActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIContactMessageActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIContactMessageActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIContactMessageActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIContactMessageActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIContactMessageActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIContactMessageActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIContactMessageActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(WebUIContactMessageActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(WebUIContactMessageActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(WebUIContactMessageActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(WebUIContactMessageActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIContactMessageActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIContactMessageActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIContactMessageActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIContactMessageActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIContactMessageActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIContactMessageActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIContactMessageActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIContactMessageActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIContactMessageActivatedEventArgs
    };

    // ----- WebUIContactPanelActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIContactPanelActivatedEventArgs = "WebUIContactPanelActivatedEventArgs";

    static PyObject* _new_WebUIContactPanelActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIContactPanelActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIContactPanelActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIContactPanelActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIContactPanelActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPanelActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPanelActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPanelActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPanelActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPanelActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPanelActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPanelActivatedEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPanelActivatedEventArgs_get_Contact(py::wrapper::Windows::UI::WebUI::WebUIContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPanelActivatedEventArgs", L"Contact"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPanelActivatedEventArgs_get_ContactPanel(py::wrapper::Windows::UI::WebUI::WebUIContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPanelActivatedEventArgs", L"ContactPanel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactPanel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPanelActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPanelActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIContactPanelActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIContactPanelActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIContactPanelActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIContactPanelActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIContactPanelActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIContactPanelActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIContactPanelActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIContactPanelActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIContactPanelActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIContactPanelActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIContactPanelActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIContactPanelActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(WebUIContactPanelActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "contact_panel", reinterpret_cast<getter>(WebUIContactPanelActivatedEventArgs_get_ContactPanel), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIContactPanelActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIContactPanelActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIContactPanelActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIContactPanelActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIContactPanelActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIContactPanelActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIContactPanelActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIContactPanelActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIContactPanelActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIContactPanelActivatedEventArgs
    };

    // ----- WebUIContactPickerActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIContactPickerActivatedEventArgs = "WebUIContactPickerActivatedEventArgs";

    static PyObject* _new_WebUIContactPickerActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIContactPickerActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIContactPickerActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIContactPickerActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIContactPickerActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPickerActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPickerActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPickerActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPickerActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPickerActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPickerActivatedEventArgs_get_ContactPickerUI(py::wrapper::Windows::UI::WebUI::WebUIContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPickerActivatedEventArgs", L"ContactPickerUI"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactPickerUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPickerActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPickerActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIContactPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIContactPickerActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIContactPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIContactPickerActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIContactPickerActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIContactPickerActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIContactPickerActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIContactPickerActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIContactPickerActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIContactPickerActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIContactPickerActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "contact_picker_u_i", reinterpret_cast<getter>(WebUIContactPickerActivatedEventArgs_get_ContactPickerUI), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIContactPickerActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIContactPickerActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIContactPickerActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIContactPickerActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIContactPickerActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIContactPickerActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIContactPickerActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIContactPickerActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIContactPickerActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIContactPickerActivatedEventArgs
    };

    // ----- WebUIContactPostActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIContactPostActivatedEventArgs = "WebUIContactPostActivatedEventArgs";

    static PyObject* _new_WebUIContactPostActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIContactPostActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIContactPostActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIContactPostActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPostActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPostActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPostActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPostActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPostActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPostActivatedEventArgs_get_Verb(py::wrapper::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPostActivatedEventArgs", L"Verb"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPostActivatedEventArgs_get_Contact(py::wrapper::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPostActivatedEventArgs", L"Contact"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPostActivatedEventArgs_get_ServiceId(py::wrapper::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPostActivatedEventArgs", L"ServiceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPostActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPostActivatedEventArgs", L"ServiceUserId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServiceUserId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPostActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPostActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIContactPostActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIContactPostActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIContactPostActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIContactPostActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIContactPostActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIContactPostActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIContactPostActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIContactPostActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIContactPostActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(WebUIContactPostActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(WebUIContactPostActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(WebUIContactPostActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(WebUIContactPostActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIContactPostActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIContactPostActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIContactPostActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIContactPostActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIContactPostActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIContactPostActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIContactPostActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIContactPostActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIContactPostActivatedEventArgs
    };

    // ----- WebUIContactVideoCallActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIContactVideoCallActivatedEventArgs = "WebUIContactVideoCallActivatedEventArgs";

    static PyObject* _new_WebUIContactVideoCallActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIContactVideoCallActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIContactVideoCallActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIContactVideoCallActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactVideoCallActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactVideoCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactVideoCallActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactVideoCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactVideoCallActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactVideoCallActivatedEventArgs_get_Verb(py::wrapper::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactVideoCallActivatedEventArgs", L"Verb"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactVideoCallActivatedEventArgs_get_Contact(py::wrapper::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactVideoCallActivatedEventArgs", L"Contact"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactVideoCallActivatedEventArgs_get_ServiceId(py::wrapper::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactVideoCallActivatedEventArgs", L"ServiceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactVideoCallActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactVideoCallActivatedEventArgs", L"ServiceUserId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServiceUserId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactVideoCallActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactVideoCallActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIContactVideoCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIContactVideoCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIContactVideoCallActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIContactVideoCallActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIContactVideoCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIContactVideoCallActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIContactVideoCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIContactVideoCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIContactVideoCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(WebUIContactVideoCallActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(WebUIContactVideoCallActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(WebUIContactVideoCallActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(WebUIContactVideoCallActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIContactVideoCallActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIContactVideoCallActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIContactVideoCallActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIContactVideoCallActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIContactVideoCallActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIContactVideoCallActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIContactVideoCallActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIContactVideoCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIContactVideoCallActivatedEventArgs
    };

    // ----- WebUIDeviceActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIDeviceActivatedEventArgs = "WebUIDeviceActivatedEventArgs";

    static PyObject* _new_WebUIDeviceActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIDeviceActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIDeviceActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIDeviceActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDeviceActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDeviceActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDeviceActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDeviceActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDeviceActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDeviceActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDeviceActivatedEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDeviceActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDeviceActivatedEventArgs", L"CurrentlyShownApplicationViewId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDeviceActivatedEventArgs_get_DeviceInformationId(py::wrapper::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDeviceActivatedEventArgs", L"DeviceInformationId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceInformationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDeviceActivatedEventArgs_get_Verb(py::wrapper::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDeviceActivatedEventArgs", L"Verb"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDeviceActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDeviceActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIDeviceActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIDeviceActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIDeviceActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIDeviceActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIDeviceActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIDeviceActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIDeviceActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIDeviceActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIDeviceActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIDeviceActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(WebUIDeviceActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "device_information_id", reinterpret_cast<getter>(WebUIDeviceActivatedEventArgs_get_DeviceInformationId), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(WebUIDeviceActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIDeviceActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIDeviceActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIDeviceActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIDeviceActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIDeviceActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIDeviceActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIDeviceActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIDeviceActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIDeviceActivatedEventArgs
    };

    // ----- WebUIDevicePairingActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIDevicePairingActivatedEventArgs = "WebUIDevicePairingActivatedEventArgs";

    static PyObject* _new_WebUIDevicePairingActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIDevicePairingActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIDevicePairingActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIDevicePairingActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIDevicePairingActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIDevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDevicePairingActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDevicePairingActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIDevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDevicePairingActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDevicePairingActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIDevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDevicePairingActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDevicePairingActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIDevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDevicePairingActivatedEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDevicePairingActivatedEventArgs_get_DeviceInformation(py::wrapper::Windows::UI::WebUI::WebUIDevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDevicePairingActivatedEventArgs", L"DeviceInformation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDevicePairingActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIDevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDevicePairingActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIDevicePairingActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIDevicePairingActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIDevicePairingActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIDevicePairingActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIDevicePairingActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIDevicePairingActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIDevicePairingActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIDevicePairingActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIDevicePairingActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIDevicePairingActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIDevicePairingActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIDevicePairingActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "device_information", reinterpret_cast<getter>(WebUIDevicePairingActivatedEventArgs_get_DeviceInformation), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIDevicePairingActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIDevicePairingActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIDevicePairingActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIDevicePairingActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIDevicePairingActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIDevicePairingActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIDevicePairingActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIDevicePairingActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIDevicePairingActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIDevicePairingActivatedEventArgs
    };

    // ----- WebUIDialReceiverActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIDialReceiverActivatedEventArgs = "WebUIDialReceiverActivatedEventArgs";

    static PyObject* _new_WebUIDialReceiverActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIDialReceiverActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIDialReceiverActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIDialReceiverActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDialReceiverActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDialReceiverActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDialReceiverActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDialReceiverActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDialReceiverActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDialReceiverActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDialReceiverActivatedEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDialReceiverActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDialReceiverActivatedEventArgs", L"CurrentlyShownApplicationViewId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDialReceiverActivatedEventArgs_get_AppName(py::wrapper::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDialReceiverActivatedEventArgs", L"AppName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDialReceiverActivatedEventArgs_get_Arguments(py::wrapper::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDialReceiverActivatedEventArgs", L"Arguments"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDialReceiverActivatedEventArgs_get_TileId(py::wrapper::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDialReceiverActivatedEventArgs", L"TileId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TileId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDialReceiverActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDialReceiverActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIDialReceiverActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIDialReceiverActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIDialReceiverActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIDialReceiverActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIDialReceiverActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIDialReceiverActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIDialReceiverActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIDialReceiverActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIDialReceiverActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIDialReceiverActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(WebUIDialReceiverActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "app_name", reinterpret_cast<getter>(WebUIDialReceiverActivatedEventArgs_get_AppName), nullptr, nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(WebUIDialReceiverActivatedEventArgs_get_Arguments), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(WebUIDialReceiverActivatedEventArgs_get_TileId), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIDialReceiverActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIDialReceiverActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIDialReceiverActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIDialReceiverActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIDialReceiverActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIDialReceiverActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIDialReceiverActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIDialReceiverActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIDialReceiverActivatedEventArgs
    };

    // ----- WebUIFileActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIFileActivatedEventArgs = "WebUIFileActivatedEventArgs";

    static PyObject* _new_WebUIFileActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIFileActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIFileActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIFileActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIFileActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileActivatedEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::UI::WebUI::WebUIFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileActivatedEventArgs", L"CurrentlyShownApplicationViewId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileActivatedEventArgs_get_Files(py::wrapper::Windows::UI::WebUI::WebUIFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileActivatedEventArgs", L"Files"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Files());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileActivatedEventArgs_get_Verb(py::wrapper::Windows::UI::WebUI::WebUIFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileActivatedEventArgs", L"Verb"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileActivatedEventArgs_get_NeighboringFilesQuery(py::wrapper::Windows::UI::WebUI::WebUIFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileActivatedEventArgs", L"NeighboringFilesQuery"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NeighboringFilesQuery());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIFileActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIFileActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIFileActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIFileActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIFileActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIFileActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIFileActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIFileActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIFileActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIFileActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIFileActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIFileActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(WebUIFileActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "files", reinterpret_cast<getter>(WebUIFileActivatedEventArgs_get_Files), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(WebUIFileActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "neighboring_files_query", reinterpret_cast<getter>(WebUIFileActivatedEventArgs_get_NeighboringFilesQuery), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIFileActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIFileActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIFileActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIFileActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIFileActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIFileActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIFileActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIFileActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIFileActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIFileActivatedEventArgs
    };

    // ----- WebUIFileOpenPickerActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIFileOpenPickerActivatedEventArgs = "WebUIFileOpenPickerActivatedEventArgs";

    static PyObject* _new_WebUIFileOpenPickerActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIFileOpenPickerActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIFileOpenPickerActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIFileOpenPickerActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileOpenPickerActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileOpenPickerActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileOpenPickerActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerActivatedEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileOpenPickerActivatedEventArgs_get_FileOpenPickerUI(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerActivatedEventArgs", L"FileOpenPickerUI"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FileOpenPickerUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileOpenPickerActivatedEventArgs_get_CallerPackageFamilyName(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerActivatedEventArgs", L"CallerPackageFamilyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CallerPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileOpenPickerActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIFileOpenPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIFileOpenPickerActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIFileOpenPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIFileOpenPickerActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIFileOpenPickerActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIFileOpenPickerActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIFileOpenPickerActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIFileOpenPickerActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIFileOpenPickerActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIFileOpenPickerActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIFileOpenPickerActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIFileOpenPickerActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "file_open_picker_u_i", reinterpret_cast<getter>(WebUIFileOpenPickerActivatedEventArgs_get_FileOpenPickerUI), nullptr, nullptr, nullptr },
        { "caller_package_family_name", reinterpret_cast<getter>(WebUIFileOpenPickerActivatedEventArgs_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIFileOpenPickerActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIFileOpenPickerActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIFileOpenPickerActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIFileOpenPickerActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIFileOpenPickerActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIFileOpenPickerActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIFileOpenPickerActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIFileOpenPickerActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIFileOpenPickerActivatedEventArgs
    };

    // ----- WebUIFileOpenPickerContinuationEventArgs class --------------------
    static constexpr const char* const type_name_WebUIFileOpenPickerContinuationEventArgs = "WebUIFileOpenPickerContinuationEventArgs";

    static PyObject* _new_WebUIFileOpenPickerContinuationEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIFileOpenPickerContinuationEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIFileOpenPickerContinuationEventArgs(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerContinuationEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIFileOpenPickerContinuationEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerContinuationEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileOpenPickerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerContinuationEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileOpenPickerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerContinuationEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileOpenPickerContinuationEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerContinuationEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileOpenPickerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerContinuationEventArgs", L"ContinuationData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContinuationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileOpenPickerContinuationEventArgs_get_Files(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerContinuationEventArgs", L"Files"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Files());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileOpenPickerContinuationEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerContinuationEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIFileOpenPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIFileOpenPickerContinuationEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIFileOpenPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIFileOpenPickerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIFileOpenPickerContinuationEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIFileOpenPickerContinuationEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIFileOpenPickerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIFileOpenPickerContinuationEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIFileOpenPickerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIFileOpenPickerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIFileOpenPickerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIFileOpenPickerContinuationEventArgs_get_User), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(WebUIFileOpenPickerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "files", reinterpret_cast<getter>(WebUIFileOpenPickerContinuationEventArgs_get_Files), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIFileOpenPickerContinuationEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIFileOpenPickerContinuationEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIFileOpenPickerContinuationEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIFileOpenPickerContinuationEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIFileOpenPickerContinuationEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIFileOpenPickerContinuationEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIFileOpenPickerContinuationEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIFileOpenPickerContinuationEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIFileOpenPickerContinuationEventArgs
    };

    // ----- WebUIFileSavePickerActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIFileSavePickerActivatedEventArgs = "WebUIFileSavePickerActivatedEventArgs";

    static PyObject* _new_WebUIFileSavePickerActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIFileSavePickerActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIFileSavePickerActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIFileSavePickerActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileSavePickerActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileSavePickerActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileSavePickerActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerActivatedEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileSavePickerActivatedEventArgs_get_FileSavePickerUI(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerActivatedEventArgs", L"FileSavePickerUI"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FileSavePickerUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileSavePickerActivatedEventArgs_get_CallerPackageFamilyName(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerActivatedEventArgs", L"CallerPackageFamilyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CallerPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileSavePickerActivatedEventArgs_get_EnterpriseId(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerActivatedEventArgs", L"EnterpriseId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EnterpriseId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileSavePickerActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIFileSavePickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIFileSavePickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIFileSavePickerActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIFileSavePickerActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIFileSavePickerActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIFileSavePickerActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIFileSavePickerActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIFileSavePickerActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIFileSavePickerActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIFileSavePickerActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "file_save_picker_u_i", reinterpret_cast<getter>(WebUIFileSavePickerActivatedEventArgs_get_FileSavePickerUI), nullptr, nullptr, nullptr },
        { "caller_package_family_name", reinterpret_cast<getter>(WebUIFileSavePickerActivatedEventArgs_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "enterprise_id", reinterpret_cast<getter>(WebUIFileSavePickerActivatedEventArgs_get_EnterpriseId), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIFileSavePickerActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIFileSavePickerActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIFileSavePickerActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIFileSavePickerActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIFileSavePickerActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIFileSavePickerActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIFileSavePickerActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIFileSavePickerActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIFileSavePickerActivatedEventArgs
    };

    // ----- WebUIFileSavePickerContinuationEventArgs class --------------------
    static constexpr const char* const type_name_WebUIFileSavePickerContinuationEventArgs = "WebUIFileSavePickerContinuationEventArgs";

    static PyObject* _new_WebUIFileSavePickerContinuationEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIFileSavePickerContinuationEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIFileSavePickerContinuationEventArgs(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerContinuationEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIFileSavePickerContinuationEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerContinuationEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileSavePickerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerContinuationEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileSavePickerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerContinuationEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileSavePickerContinuationEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerContinuationEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileSavePickerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerContinuationEventArgs", L"ContinuationData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContinuationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileSavePickerContinuationEventArgs_get_File(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerContinuationEventArgs", L"File"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.File());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileSavePickerContinuationEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerContinuationEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIFileSavePickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIFileSavePickerContinuationEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIFileSavePickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIFileSavePickerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIFileSavePickerContinuationEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIFileSavePickerContinuationEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIFileSavePickerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIFileSavePickerContinuationEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIFileSavePickerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIFileSavePickerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIFileSavePickerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIFileSavePickerContinuationEventArgs_get_User), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(WebUIFileSavePickerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "file", reinterpret_cast<getter>(WebUIFileSavePickerContinuationEventArgs_get_File), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIFileSavePickerContinuationEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIFileSavePickerContinuationEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIFileSavePickerContinuationEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIFileSavePickerContinuationEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIFileSavePickerContinuationEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIFileSavePickerContinuationEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIFileSavePickerContinuationEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIFileSavePickerContinuationEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIFileSavePickerContinuationEventArgs
    };

    // ----- WebUIFolderPickerContinuationEventArgs class --------------------
    static constexpr const char* const type_name_WebUIFolderPickerContinuationEventArgs = "WebUIFolderPickerContinuationEventArgs";

    static PyObject* _new_WebUIFolderPickerContinuationEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIFolderPickerContinuationEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIFolderPickerContinuationEventArgs(py::wrapper::Windows::UI::WebUI::WebUIFolderPickerContinuationEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIFolderPickerContinuationEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFolderPickerContinuationEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFolderPickerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFolderPickerContinuationEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFolderPickerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFolderPickerContinuationEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFolderPickerContinuationEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFolderPickerContinuationEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFolderPickerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::UI::WebUI::WebUIFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFolderPickerContinuationEventArgs", L"ContinuationData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContinuationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFolderPickerContinuationEventArgs_get_Folder(py::wrapper::Windows::UI::WebUI::WebUIFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFolderPickerContinuationEventArgs", L"Folder"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Folder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFolderPickerContinuationEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFolderPickerContinuationEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIFolderPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIFolderPickerContinuationEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIFolderPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIFolderPickerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIFolderPickerContinuationEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIFolderPickerContinuationEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIFolderPickerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIFolderPickerContinuationEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIFolderPickerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIFolderPickerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIFolderPickerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIFolderPickerContinuationEventArgs_get_User), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(WebUIFolderPickerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "folder", reinterpret_cast<getter>(WebUIFolderPickerContinuationEventArgs_get_Folder), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIFolderPickerContinuationEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIFolderPickerContinuationEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIFolderPickerContinuationEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIFolderPickerContinuationEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIFolderPickerContinuationEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIFolderPickerContinuationEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIFolderPickerContinuationEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIFolderPickerContinuationEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIFolderPickerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIFolderPickerContinuationEventArgs
    };

    // ----- WebUILaunchActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUILaunchActivatedEventArgs = "WebUILaunchActivatedEventArgs";

    static PyObject* _new_WebUILaunchActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUILaunchActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUILaunchActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUILaunchActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUILaunchActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILaunchActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILaunchActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILaunchActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILaunchActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILaunchActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILaunchActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILaunchActivatedEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILaunchActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::UI::WebUI::WebUILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILaunchActivatedEventArgs", L"CurrentlyShownApplicationViewId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILaunchActivatedEventArgs_get_Arguments(py::wrapper::Windows::UI::WebUI::WebUILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILaunchActivatedEventArgs", L"Arguments"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILaunchActivatedEventArgs_get_TileId(py::wrapper::Windows::UI::WebUI::WebUILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILaunchActivatedEventArgs", L"TileId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TileId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILaunchActivatedEventArgs_get_TileActivatedInfo(py::wrapper::Windows::UI::WebUI::WebUILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILaunchActivatedEventArgs", L"TileActivatedInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TileActivatedInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILaunchActivatedEventArgs_get_PrelaunchActivated(py::wrapper::Windows::UI::WebUI::WebUILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILaunchActivatedEventArgs", L"PrelaunchActivated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PrelaunchActivated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILaunchActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILaunchActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUILaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUILaunchActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUILaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUILaunchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUILaunchActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUILaunchActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUILaunchActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUILaunchActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUILaunchActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUILaunchActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUILaunchActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUILaunchActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(WebUILaunchActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(WebUILaunchActivatedEventArgs_get_Arguments), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(WebUILaunchActivatedEventArgs_get_TileId), nullptr, nullptr, nullptr },
        { "tile_activated_info", reinterpret_cast<getter>(WebUILaunchActivatedEventArgs_get_TileActivatedInfo), nullptr, nullptr, nullptr },
        { "prelaunch_activated", reinterpret_cast<getter>(WebUILaunchActivatedEventArgs_get_PrelaunchActivated), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUILaunchActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUILaunchActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUILaunchActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUILaunchActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUILaunchActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUILaunchActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUILaunchActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUILaunchActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUILaunchActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUILaunchActivatedEventArgs
    };

    // ----- WebUILockScreenActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUILockScreenActivatedEventArgs = "WebUILockScreenActivatedEventArgs";

    static PyObject* _new_WebUILockScreenActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUILockScreenActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUILockScreenActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUILockScreenActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUILockScreenActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUILockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUILockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUILockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUILockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenActivatedEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::UI::WebUI::WebUILockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenActivatedEventArgs", L"CurrentlyShownApplicationViewId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenActivatedEventArgs_get_Info(py::wrapper::Windows::UI::WebUI::WebUILockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenActivatedEventArgs", L"Info"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Info());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUILockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUILockScreenActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUILockScreenActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUILockScreenActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUILockScreenActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUILockScreenActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUILockScreenActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUILockScreenActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUILockScreenActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUILockScreenActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUILockScreenActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUILockScreenActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUILockScreenActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(WebUILockScreenActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "info", reinterpret_cast<getter>(WebUILockScreenActivatedEventArgs_get_Info), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUILockScreenActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUILockScreenActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUILockScreenActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUILockScreenActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUILockScreenActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUILockScreenActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUILockScreenActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUILockScreenActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUILockScreenActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUILockScreenActivatedEventArgs
    };

    // ----- WebUILockScreenCallActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUILockScreenCallActivatedEventArgs = "WebUILockScreenCallActivatedEventArgs";

    static PyObject* _new_WebUILockScreenCallActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUILockScreenCallActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUILockScreenCallActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUILockScreenCallActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenCallActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenCallActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenCallActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenCallActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenCallActivatedEventArgs", L"CurrentlyShownApplicationViewId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenCallActivatedEventArgs_get_Arguments(py::wrapper::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenCallActivatedEventArgs", L"Arguments"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenCallActivatedEventArgs_get_TileId(py::wrapper::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenCallActivatedEventArgs", L"TileId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TileId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenCallActivatedEventArgs_get_CallUI(py::wrapper::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenCallActivatedEventArgs", L"CallUI"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CallUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenCallActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenCallActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUILockScreenCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUILockScreenCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUILockScreenCallActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUILockScreenCallActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUILockScreenCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUILockScreenCallActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUILockScreenCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUILockScreenCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUILockScreenCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(WebUILockScreenCallActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(WebUILockScreenCallActivatedEventArgs_get_Arguments), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(WebUILockScreenCallActivatedEventArgs_get_TileId), nullptr, nullptr, nullptr },
        { "call_u_i", reinterpret_cast<getter>(WebUILockScreenCallActivatedEventArgs_get_CallUI), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUILockScreenCallActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUILockScreenCallActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUILockScreenCallActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUILockScreenCallActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUILockScreenCallActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUILockScreenCallActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUILockScreenCallActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUILockScreenCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUILockScreenCallActivatedEventArgs
    };

    // ----- WebUILockScreenComponentActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUILockScreenComponentActivatedEventArgs = "WebUILockScreenComponentActivatedEventArgs";

    static PyObject* _new_WebUILockScreenComponentActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUILockScreenComponentActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUILockScreenComponentActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUILockScreenComponentActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUILockScreenComponentActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUILockScreenComponentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenComponentActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenComponentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUILockScreenComponentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenComponentActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenComponentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUILockScreenComponentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenComponentActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenComponentActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUILockScreenComponentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenComponentActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUILockScreenComponentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUILockScreenComponentActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUILockScreenComponentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUILockScreenComponentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUILockScreenComponentActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUILockScreenComponentActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUILockScreenComponentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUILockScreenComponentActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUILockScreenComponentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUILockScreenComponentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUILockScreenComponentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUILockScreenComponentActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUILockScreenComponentActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUILockScreenComponentActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUILockScreenComponentActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUILockScreenComponentActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUILockScreenComponentActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUILockScreenComponentActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUILockScreenComponentActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUILockScreenComponentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUILockScreenComponentActivatedEventArgs
    };

    // ----- WebUINavigatedDeferral class --------------------
    static constexpr const char* const type_name_WebUINavigatedDeferral = "WebUINavigatedDeferral";

    static PyObject* _new_WebUINavigatedDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUINavigatedDeferral);
        return nullptr;
    }

    static void _dealloc_WebUINavigatedDeferral(py::wrapper::Windows::UI::WebUI::WebUINavigatedDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUINavigatedDeferral_Complete(py::wrapper::Windows::UI::WebUI::WebUINavigatedDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUINavigatedDeferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUINavigatedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUINavigatedDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUINavigatedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUINavigatedDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUINavigatedDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(WebUINavigatedDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WebUINavigatedDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUINavigatedDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUINavigatedDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_WebUINavigatedDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUINavigatedDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUINavigatedDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUINavigatedDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUINavigatedDeferral) },
        { },
    };

    static PyType_Spec type_spec_WebUINavigatedDeferral =
    {
        "_winsdk_Windows_UI_WebUI.WebUINavigatedDeferral",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUINavigatedDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUINavigatedDeferral
    };

    // ----- WebUINavigatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUINavigatedEventArgs = "WebUINavigatedEventArgs";

    static PyObject* _new_WebUINavigatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUINavigatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUINavigatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUINavigatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUINavigatedEventArgs_get_NavigatedOperation(py::wrapper::Windows::UI::WebUI::WebUINavigatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUINavigatedEventArgs", L"NavigatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NavigatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUINavigatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUINavigatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUINavigatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUINavigatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUINavigatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUINavigatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUINavigatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUINavigatedEventArgs[] = {
        { "navigated_operation", reinterpret_cast<getter>(WebUINavigatedEventArgs_get_NavigatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUINavigatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUINavigatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUINavigatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUINavigatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUINavigatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUINavigatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUINavigatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUINavigatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUINavigatedEventArgs
    };

    // ----- WebUINavigatedOperation class --------------------
    static constexpr const char* const type_name_WebUINavigatedOperation = "WebUINavigatedOperation";

    static PyObject* _new_WebUINavigatedOperation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUINavigatedOperation);
        return nullptr;
    }

    static void _dealloc_WebUINavigatedOperation(py::wrapper::Windows::UI::WebUI::WebUINavigatedOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUINavigatedOperation_GetDeferral(py::wrapper::Windows::UI::WebUI::WebUINavigatedOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUINavigatedOperation", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUINavigatedOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUINavigatedOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUINavigatedOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUINavigatedOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUINavigatedOperation[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(WebUINavigatedOperation_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WebUINavigatedOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUINavigatedOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUINavigatedOperation[] = {
        { }
    };

    static PyType_Slot _type_slots_WebUINavigatedOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUINavigatedOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUINavigatedOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUINavigatedOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUINavigatedOperation) },
        { },
    };

    static PyType_Spec type_spec_WebUINavigatedOperation =
    {
        "_winsdk_Windows_UI_WebUI.WebUINavigatedOperation",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUINavigatedOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUINavigatedOperation
    };

    // ----- WebUIPhoneCallActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIPhoneCallActivatedEventArgs = "WebUIPhoneCallActivatedEventArgs";

    static PyObject* _new_WebUIPhoneCallActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIPhoneCallActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIPhoneCallActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIPhoneCallActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIPhoneCallActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIPhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPhoneCallActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPhoneCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIPhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPhoneCallActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPhoneCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIPhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPhoneCallActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPhoneCallActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIPhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPhoneCallActivatedEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPhoneCallActivatedEventArgs_get_LineId(py::wrapper::Windows::UI::WebUI::WebUIPhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPhoneCallActivatedEventArgs", L"LineId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPhoneCallActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIPhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPhoneCallActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIPhoneCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIPhoneCallActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIPhoneCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIPhoneCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIPhoneCallActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIPhoneCallActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIPhoneCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIPhoneCallActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIPhoneCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIPhoneCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIPhoneCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIPhoneCallActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "line_id", reinterpret_cast<getter>(WebUIPhoneCallActivatedEventArgs_get_LineId), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIPhoneCallActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIPhoneCallActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIPhoneCallActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIPhoneCallActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIPhoneCallActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIPhoneCallActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIPhoneCallActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIPhoneCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIPhoneCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIPhoneCallActivatedEventArgs
    };

    // ----- WebUIPrint3DWorkflowActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIPrint3DWorkflowActivatedEventArgs = "WebUIPrint3DWorkflowActivatedEventArgs";

    static PyObject* _new_WebUIPrint3DWorkflowActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIPrint3DWorkflowActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIPrint3DWorkflowActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIPrint3DWorkflowActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIPrint3DWorkflowActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIPrint3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrint3DWorkflowActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPrint3DWorkflowActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIPrint3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrint3DWorkflowActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPrint3DWorkflowActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIPrint3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrint3DWorkflowActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPrint3DWorkflowActivatedEventArgs_get_Workflow(py::wrapper::Windows::UI::WebUI::WebUIPrint3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrint3DWorkflowActivatedEventArgs", L"Workflow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Workflow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPrint3DWorkflowActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIPrint3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrint3DWorkflowActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIPrint3DWorkflowActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIPrint3DWorkflowActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIPrint3DWorkflowActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIPrint3DWorkflowActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIPrint3DWorkflowActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIPrint3DWorkflowActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIPrint3DWorkflowActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIPrint3DWorkflowActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIPrint3DWorkflowActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIPrint3DWorkflowActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIPrint3DWorkflowActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "workflow", reinterpret_cast<getter>(WebUIPrint3DWorkflowActivatedEventArgs_get_Workflow), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIPrint3DWorkflowActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIPrint3DWorkflowActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIPrint3DWorkflowActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIPrint3DWorkflowActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIPrint3DWorkflowActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIPrint3DWorkflowActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIPrint3DWorkflowActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIPrint3DWorkflowActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIPrint3DWorkflowActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIPrint3DWorkflowActivatedEventArgs
    };

    // ----- WebUIPrintTaskSettingsActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIPrintTaskSettingsActivatedEventArgs = "WebUIPrintTaskSettingsActivatedEventArgs";

    static PyObject* _new_WebUIPrintTaskSettingsActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIPrintTaskSettingsActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIPrintTaskSettingsActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIPrintTaskSettingsActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIPrintTaskSettingsActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIPrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrintTaskSettingsActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPrintTaskSettingsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIPrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrintTaskSettingsActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPrintTaskSettingsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIPrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrintTaskSettingsActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPrintTaskSettingsActivatedEventArgs_get_Configuration(py::wrapper::Windows::UI::WebUI::WebUIPrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrintTaskSettingsActivatedEventArgs", L"Configuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Configuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPrintTaskSettingsActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIPrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrintTaskSettingsActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIPrintTaskSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIPrintTaskSettingsActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIPrintTaskSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIPrintTaskSettingsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIPrintTaskSettingsActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIPrintTaskSettingsActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIPrintTaskSettingsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIPrintTaskSettingsActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIPrintTaskSettingsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIPrintTaskSettingsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIPrintTaskSettingsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "configuration", reinterpret_cast<getter>(WebUIPrintTaskSettingsActivatedEventArgs_get_Configuration), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIPrintTaskSettingsActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIPrintTaskSettingsActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIPrintTaskSettingsActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIPrintTaskSettingsActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIPrintTaskSettingsActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIPrintTaskSettingsActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIPrintTaskSettingsActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIPrintTaskSettingsActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIPrintTaskSettingsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIPrintTaskSettingsActivatedEventArgs
    };

    // ----- WebUIPrintWorkflowForegroundTaskActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIPrintWorkflowForegroundTaskActivatedEventArgs = "WebUIPrintWorkflowForegroundTaskActivatedEventArgs";

    static PyObject* _new_WebUIPrintWorkflowForegroundTaskActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIPrintWorkflowForegroundTaskActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIPrintWorkflowForegroundTaskActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIPrintWorkflowForegroundTaskActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIPrintWorkflowForegroundTaskActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIPrintWorkflowForegroundTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrintWorkflowForegroundTaskActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPrintWorkflowForegroundTaskActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIPrintWorkflowForegroundTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrintWorkflowForegroundTaskActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPrintWorkflowForegroundTaskActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIPrintWorkflowForegroundTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrintWorkflowForegroundTaskActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPrintWorkflowForegroundTaskActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIPrintWorkflowForegroundTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrintWorkflowForegroundTaskActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIPrintWorkflowForegroundTaskActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIPrintWorkflowForegroundTaskActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIPrintWorkflowForegroundTaskActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIPrintWorkflowForegroundTaskActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIPrintWorkflowForegroundTaskActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIPrintWorkflowForegroundTaskActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIPrintWorkflowForegroundTaskActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIPrintWorkflowForegroundTaskActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIPrintWorkflowForegroundTaskActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIPrintWorkflowForegroundTaskActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIPrintWorkflowForegroundTaskActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIPrintWorkflowForegroundTaskActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIPrintWorkflowForegroundTaskActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIPrintWorkflowForegroundTaskActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIPrintWorkflowForegroundTaskActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIPrintWorkflowForegroundTaskActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIPrintWorkflowForegroundTaskActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIPrintWorkflowForegroundTaskActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIPrintWorkflowForegroundTaskActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIPrintWorkflowForegroundTaskActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIPrintWorkflowForegroundTaskActivatedEventArgs
    };

    // ----- WebUIProtocolActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIProtocolActivatedEventArgs = "WebUIProtocolActivatedEventArgs";

    static PyObject* _new_WebUIProtocolActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIProtocolActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIProtocolActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIProtocolActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolActivatedEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolActivatedEventArgs", L"CurrentlyShownApplicationViewId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolActivatedEventArgs_get_Uri(py::wrapper::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolActivatedEventArgs", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolActivatedEventArgs_get_CallerPackageFamilyName(py::wrapper::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolActivatedEventArgs", L"CallerPackageFamilyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CallerPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolActivatedEventArgs_get_Data(py::wrapper::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolActivatedEventArgs", L"Data"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIProtocolActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIProtocolActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIProtocolActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIProtocolActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIProtocolActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIProtocolActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIProtocolActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIProtocolActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIProtocolActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIProtocolActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(WebUIProtocolActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(WebUIProtocolActivatedEventArgs_get_Uri), nullptr, nullptr, nullptr },
        { "caller_package_family_name", reinterpret_cast<getter>(WebUIProtocolActivatedEventArgs_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "data", reinterpret_cast<getter>(WebUIProtocolActivatedEventArgs_get_Data), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIProtocolActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIProtocolActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIProtocolActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIProtocolActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIProtocolActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIProtocolActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIProtocolActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIProtocolActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIProtocolActivatedEventArgs
    };

    // ----- WebUIProtocolForResultsActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIProtocolForResultsActivatedEventArgs = "WebUIProtocolForResultsActivatedEventArgs";

    static PyObject* _new_WebUIProtocolForResultsActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIProtocolForResultsActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIProtocolForResultsActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIProtocolForResultsActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolForResultsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolForResultsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolForResultsActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolForResultsActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs", L"CurrentlyShownApplicationViewId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolForResultsActivatedEventArgs_get_Uri(py::wrapper::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolForResultsActivatedEventArgs_get_CallerPackageFamilyName(py::wrapper::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs", L"CallerPackageFamilyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CallerPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolForResultsActivatedEventArgs_get_Data(py::wrapper::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs", L"Data"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolForResultsActivatedEventArgs_get_ProtocolForResultsOperation(py::wrapper::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs", L"ProtocolForResultsOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProtocolForResultsOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolForResultsActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIProtocolForResultsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIProtocolForResultsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIProtocolForResultsActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIProtocolForResultsActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIProtocolForResultsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIProtocolForResultsActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIProtocolForResultsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIProtocolForResultsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIProtocolForResultsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIProtocolForResultsActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(WebUIProtocolForResultsActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(WebUIProtocolForResultsActivatedEventArgs_get_Uri), nullptr, nullptr, nullptr },
        { "caller_package_family_name", reinterpret_cast<getter>(WebUIProtocolForResultsActivatedEventArgs_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "data", reinterpret_cast<getter>(WebUIProtocolForResultsActivatedEventArgs_get_Data), nullptr, nullptr, nullptr },
        { "protocol_for_results_operation", reinterpret_cast<getter>(WebUIProtocolForResultsActivatedEventArgs_get_ProtocolForResultsOperation), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIProtocolForResultsActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIProtocolForResultsActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIProtocolForResultsActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIProtocolForResultsActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIProtocolForResultsActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIProtocolForResultsActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIProtocolForResultsActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIProtocolForResultsActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIProtocolForResultsActivatedEventArgs
    };

    // ----- WebUIRestrictedLaunchActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIRestrictedLaunchActivatedEventArgs = "WebUIRestrictedLaunchActivatedEventArgs";

    static PyObject* _new_WebUIRestrictedLaunchActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIRestrictedLaunchActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIRestrictedLaunchActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIRestrictedLaunchActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIRestrictedLaunchActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIRestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIRestrictedLaunchActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIRestrictedLaunchActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIRestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIRestrictedLaunchActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIRestrictedLaunchActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIRestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIRestrictedLaunchActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIRestrictedLaunchActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIRestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIRestrictedLaunchActivatedEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIRestrictedLaunchActivatedEventArgs_get_SharedContext(py::wrapper::Windows::UI::WebUI::WebUIRestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIRestrictedLaunchActivatedEventArgs", L"SharedContext"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SharedContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIRestrictedLaunchActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIRestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIRestrictedLaunchActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIRestrictedLaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIRestrictedLaunchActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIRestrictedLaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIRestrictedLaunchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIRestrictedLaunchActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIRestrictedLaunchActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIRestrictedLaunchActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIRestrictedLaunchActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIRestrictedLaunchActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIRestrictedLaunchActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIRestrictedLaunchActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIRestrictedLaunchActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "shared_context", reinterpret_cast<getter>(WebUIRestrictedLaunchActivatedEventArgs_get_SharedContext), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIRestrictedLaunchActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIRestrictedLaunchActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIRestrictedLaunchActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIRestrictedLaunchActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIRestrictedLaunchActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIRestrictedLaunchActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIRestrictedLaunchActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIRestrictedLaunchActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIRestrictedLaunchActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIRestrictedLaunchActivatedEventArgs
    };

    // ----- WebUISearchActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUISearchActivatedEventArgs = "WebUISearchActivatedEventArgs";

    static PyObject* _new_WebUISearchActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUISearchActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUISearchActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUISearchActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUISearchActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUISearchActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUISearchActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUISearchActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUISearchActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUISearchActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUISearchActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::UI::WebUI::WebUISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUISearchActivatedEventArgs", L"CurrentlyShownApplicationViewId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUISearchActivatedEventArgs_get_Language(py::wrapper::Windows::UI::WebUI::WebUISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUISearchActivatedEventArgs", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUISearchActivatedEventArgs_get_QueryText(py::wrapper::Windows::UI::WebUI::WebUISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUISearchActivatedEventArgs", L"QueryText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QueryText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUISearchActivatedEventArgs_get_LinguisticDetails(py::wrapper::Windows::UI::WebUI::WebUISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUISearchActivatedEventArgs", L"LinguisticDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LinguisticDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUISearchActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUISearchActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUISearchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUISearchActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUISearchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUISearchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUISearchActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUISearchActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUISearchActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUISearchActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUISearchActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUISearchActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUISearchActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(WebUISearchActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(WebUISearchActivatedEventArgs_get_Language), nullptr, nullptr, nullptr },
        { "query_text", reinterpret_cast<getter>(WebUISearchActivatedEventArgs_get_QueryText), nullptr, nullptr, nullptr },
        { "linguistic_details", reinterpret_cast<getter>(WebUISearchActivatedEventArgs_get_LinguisticDetails), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUISearchActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUISearchActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUISearchActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUISearchActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUISearchActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUISearchActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUISearchActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUISearchActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUISearchActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUISearchActivatedEventArgs
    };

    // ----- WebUIShareTargetActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIShareTargetActivatedEventArgs = "WebUIShareTargetActivatedEventArgs";

    static PyObject* _new_WebUIShareTargetActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIShareTargetActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIShareTargetActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIShareTargetActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIShareTargetActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIShareTargetActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIShareTargetActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIShareTargetActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIShareTargetActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIShareTargetActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIShareTargetActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIShareTargetActivatedEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIShareTargetActivatedEventArgs_get_ShareOperation(py::wrapper::Windows::UI::WebUI::WebUIShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIShareTargetActivatedEventArgs", L"ShareOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShareOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIShareTargetActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIShareTargetActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIShareTargetActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIShareTargetActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIShareTargetActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIShareTargetActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIShareTargetActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIShareTargetActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIShareTargetActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIShareTargetActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIShareTargetActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIShareTargetActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIShareTargetActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIShareTargetActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "share_operation", reinterpret_cast<getter>(WebUIShareTargetActivatedEventArgs_get_ShareOperation), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIShareTargetActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIShareTargetActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIShareTargetActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIShareTargetActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIShareTargetActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIShareTargetActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIShareTargetActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIShareTargetActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIShareTargetActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIShareTargetActivatedEventArgs
    };

    // ----- WebUIStartupTaskActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIStartupTaskActivatedEventArgs = "WebUIStartupTaskActivatedEventArgs";

    static PyObject* _new_WebUIStartupTaskActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIStartupTaskActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIStartupTaskActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIStartupTaskActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIStartupTaskActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIStartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIStartupTaskActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIStartupTaskActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIStartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIStartupTaskActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIStartupTaskActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIStartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIStartupTaskActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIStartupTaskActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIStartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIStartupTaskActivatedEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIStartupTaskActivatedEventArgs_get_TaskId(py::wrapper::Windows::UI::WebUI::WebUIStartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIStartupTaskActivatedEventArgs", L"TaskId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIStartupTaskActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIStartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIStartupTaskActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIStartupTaskActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIStartupTaskActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIStartupTaskActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIStartupTaskActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIStartupTaskActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIStartupTaskActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIStartupTaskActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIStartupTaskActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIStartupTaskActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIStartupTaskActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIStartupTaskActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIStartupTaskActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "task_id", reinterpret_cast<getter>(WebUIStartupTaskActivatedEventArgs_get_TaskId), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIStartupTaskActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIStartupTaskActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIStartupTaskActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIStartupTaskActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIStartupTaskActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIStartupTaskActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIStartupTaskActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIStartupTaskActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIStartupTaskActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIStartupTaskActivatedEventArgs
    };

    // ----- WebUIToastNotificationActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIToastNotificationActivatedEventArgs = "WebUIToastNotificationActivatedEventArgs";

    static PyObject* _new_WebUIToastNotificationActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIToastNotificationActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIToastNotificationActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIToastNotificationActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIToastNotificationActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIToastNotificationActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIToastNotificationActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIToastNotificationActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIToastNotificationActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIToastNotificationActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIToastNotificationActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIToastNotificationActivatedEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIToastNotificationActivatedEventArgs_get_Argument(py::wrapper::Windows::UI::WebUI::WebUIToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIToastNotificationActivatedEventArgs", L"Argument"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Argument());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIToastNotificationActivatedEventArgs_get_UserInput(py::wrapper::Windows::UI::WebUI::WebUIToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIToastNotificationActivatedEventArgs", L"UserInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UserInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIToastNotificationActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIToastNotificationActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIToastNotificationActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIToastNotificationActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIToastNotificationActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIToastNotificationActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIToastNotificationActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIToastNotificationActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIToastNotificationActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIToastNotificationActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIToastNotificationActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIToastNotificationActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIToastNotificationActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIToastNotificationActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "argument", reinterpret_cast<getter>(WebUIToastNotificationActivatedEventArgs_get_Argument), nullptr, nullptr, nullptr },
        { "user_input", reinterpret_cast<getter>(WebUIToastNotificationActivatedEventArgs_get_UserInput), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIToastNotificationActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIToastNotificationActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIToastNotificationActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIToastNotificationActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIToastNotificationActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIToastNotificationActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIToastNotificationActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIToastNotificationActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIToastNotificationActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIToastNotificationActivatedEventArgs
    };

    // ----- WebUIUserDataAccountProviderActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIUserDataAccountProviderActivatedEventArgs = "WebUIUserDataAccountProviderActivatedEventArgs";

    static PyObject* _new_WebUIUserDataAccountProviderActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIUserDataAccountProviderActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIUserDataAccountProviderActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIUserDataAccountProviderActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIUserDataAccountProviderActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIUserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIUserDataAccountProviderActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIUserDataAccountProviderActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIUserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIUserDataAccountProviderActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIUserDataAccountProviderActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIUserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIUserDataAccountProviderActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIUserDataAccountProviderActivatedEventArgs_get_Operation(py::wrapper::Windows::UI::WebUI::WebUIUserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIUserDataAccountProviderActivatedEventArgs", L"Operation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Operation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIUserDataAccountProviderActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIUserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIUserDataAccountProviderActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIUserDataAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIUserDataAccountProviderActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIUserDataAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIUserDataAccountProviderActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIUserDataAccountProviderActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIUserDataAccountProviderActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIUserDataAccountProviderActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIUserDataAccountProviderActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIUserDataAccountProviderActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIUserDataAccountProviderActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIUserDataAccountProviderActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "operation", reinterpret_cast<getter>(WebUIUserDataAccountProviderActivatedEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIUserDataAccountProviderActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIUserDataAccountProviderActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIUserDataAccountProviderActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIUserDataAccountProviderActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIUserDataAccountProviderActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIUserDataAccountProviderActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIUserDataAccountProviderActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIUserDataAccountProviderActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIUserDataAccountProviderActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIUserDataAccountProviderActivatedEventArgs
    };

    // ----- WebUIView class --------------------
    static constexpr const char* const type_name_WebUIView = "WebUIView";

    static PyObject* _new_WebUIView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIView);
        return nullptr;
    }

    static void _dealloc_WebUIView(py::wrapper::Windows::UI::WebUI::WebUIView* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIView_AddInitializeScript(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"AddInitializeScript", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.AddInitializeScript(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_BuildLocalStreamUri(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"BuildLocalStreamUri", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.BuildLocalStreamUri(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_CapturePreviewToStreamAsync(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"CapturePreviewToStreamAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert(self->obj.CapturePreviewToStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_CaptureSelectedContentToDataPackageAsync(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"CaptureSelectedContentToDataPackageAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CaptureSelectedContentToDataPackageAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_CreateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"CreateAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::WebUI::WebUIView::CreateAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"CreateAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::UI::WebUI::WebUIView::CreateAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_GetDeferredPermissionRequestById(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"GetDeferredPermissionRequestById", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                winrt::Windows::Web::UI::WebViewControlDeferredPermissionRequest param1 { nullptr };

                self->obj.GetDeferredPermissionRequestById(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_GoBack(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"GoBack", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.GoBack();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_GoForward(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"GoForward", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.GoForward();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_InvokeScriptAsync(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"InvokeScriptAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(self->obj.InvokeScriptAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_Navigate(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"Navigate", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                self->obj.Navigate(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_NavigateToLocalStreamUri(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"NavigateToLocalStreamUri", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::IUriToStreamResolver>(args, 1);

                self->obj.NavigateToLocalStreamUri(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_NavigateToString(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"NavigateToString", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.NavigateToString(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_NavigateWithHttpRequestMessage(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"NavigateWithHttpRequestMessage", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpRequestMessage>(args, 0);

                self->obj.NavigateWithHttpRequestMessage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_Refresh(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"Refresh", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Refresh();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_Stop(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_get_IgnoreApplicationContentUriRulesNavigationRestrictions(py::wrapper::Windows::UI::WebUI::WebUIView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIView", L"IgnoreApplicationContentUriRulesNavigationRestrictions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IgnoreApplicationContentUriRulesNavigationRestrictions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebUIView_put_IgnoreApplicationContentUriRulesNavigationRestrictions(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIView", L"IgnoreApplicationContentUriRulesNavigationRestrictions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IgnoreApplicationContentUriRulesNavigationRestrictions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WebUIView_get_ApplicationViewId(py::wrapper::Windows::UI::WebUI::WebUIView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIView", L"ApplicationViewId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_get_Source(py::wrapper::Windows::UI::WebUI::WebUIView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIView", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebUIView_put_Source(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIView", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Source(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WebUIView_get_DefaultBackgroundColor(py::wrapper::Windows::UI::WebUI::WebUIView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIView", L"DefaultBackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultBackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebUIView_put_DefaultBackgroundColor(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIView", L"DefaultBackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.DefaultBackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WebUIView_get_CanGoBack(py::wrapper::Windows::UI::WebUI::WebUIView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIView", L"CanGoBack"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanGoBack());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_get_CanGoForward(py::wrapper::Windows::UI::WebUI::WebUIView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIView", L"CanGoForward"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanGoForward());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_get_ContainsFullScreenElement(py::wrapper::Windows::UI::WebUI::WebUIView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIView", L"ContainsFullScreenElement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContainsFullScreenElement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_get_DeferredPermissionRequests(py::wrapper::Windows::UI::WebUI::WebUIView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIView", L"DeferredPermissionRequests"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeferredPermissionRequests());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_get_DocumentTitle(py::wrapper::Windows::UI::WebUI::WebUIView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIView", L"DocumentTitle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DocumentTitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_get_Settings(py::wrapper::Windows::UI::WebUI::WebUIView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIView", L"Settings"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Settings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_Activated(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"Activated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::WebUI::WebUIView, winrt::Windows::ApplicationModel::Activation::IActivatedEventArgs>>(arg);

            return py::convert(self->obj.Activated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_Activated(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"Activated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Activated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_Closed(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::WebUI::WebUIView, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_Closed(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_ContainsFullScreenElementChanged(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"ContainsFullScreenElementChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ContainsFullScreenElementChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_ContainsFullScreenElementChanged(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"ContainsFullScreenElementChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ContainsFullScreenElementChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_ContentLoading(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"ContentLoading"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlContentLoadingEventArgs>>(arg);

            return py::convert(self->obj.ContentLoading(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_ContentLoading(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"ContentLoading"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ContentLoading(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_DOMContentLoaded(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"DOMContentLoaded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlDOMContentLoadedEventArgs>>(arg);

            return py::convert(self->obj.DOMContentLoaded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_DOMContentLoaded(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"DOMContentLoaded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DOMContentLoaded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_FrameContentLoading(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"FrameContentLoading"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlContentLoadingEventArgs>>(arg);

            return py::convert(self->obj.FrameContentLoading(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_FrameContentLoading(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"FrameContentLoading"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FrameContentLoading(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_FrameDOMContentLoaded(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"FrameDOMContentLoaded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlDOMContentLoadedEventArgs>>(arg);

            return py::convert(self->obj.FrameDOMContentLoaded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_FrameDOMContentLoaded(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"FrameDOMContentLoaded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FrameDOMContentLoaded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_FrameNavigationCompleted(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"FrameNavigationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlNavigationCompletedEventArgs>>(arg);

            return py::convert(self->obj.FrameNavigationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_FrameNavigationCompleted(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"FrameNavigationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FrameNavigationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_FrameNavigationStarting(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"FrameNavigationStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlNavigationStartingEventArgs>>(arg);

            return py::convert(self->obj.FrameNavigationStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_FrameNavigationStarting(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"FrameNavigationStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FrameNavigationStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_LongRunningScriptDetected(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"LongRunningScriptDetected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlLongRunningScriptDetectedEventArgs>>(arg);

            return py::convert(self->obj.LongRunningScriptDetected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_LongRunningScriptDetected(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"LongRunningScriptDetected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LongRunningScriptDetected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_NavigationCompleted(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"NavigationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlNavigationCompletedEventArgs>>(arg);

            return py::convert(self->obj.NavigationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_NavigationCompleted(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"NavigationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NavigationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_NavigationStarting(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"NavigationStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlNavigationStartingEventArgs>>(arg);

            return py::convert(self->obj.NavigationStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_NavigationStarting(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"NavigationStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NavigationStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_NewWindowRequested(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"NewWindowRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlNewWindowRequestedEventArgs>>(arg);

            return py::convert(self->obj.NewWindowRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_NewWindowRequested(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"NewWindowRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NewWindowRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_PermissionRequested(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"PermissionRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlPermissionRequestedEventArgs>>(arg);

            return py::convert(self->obj.PermissionRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_PermissionRequested(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"PermissionRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PermissionRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_ScriptNotify(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"ScriptNotify"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlScriptNotifyEventArgs>>(arg);

            return py::convert(self->obj.ScriptNotify(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_ScriptNotify(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"ScriptNotify"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ScriptNotify(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_UnsafeContentWarningDisplaying(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"UnsafeContentWarningDisplaying"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.UnsafeContentWarningDisplaying(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_UnsafeContentWarningDisplaying(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"UnsafeContentWarningDisplaying"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UnsafeContentWarningDisplaying(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_UnsupportedUriSchemeIdentified(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"UnsupportedUriSchemeIdentified"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlUnsupportedUriSchemeIdentifiedEventArgs>>(arg);

            return py::convert(self->obj.UnsupportedUriSchemeIdentified(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_UnsupportedUriSchemeIdentified(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"UnsupportedUriSchemeIdentified"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UnsupportedUriSchemeIdentified(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_UnviewableContentIdentified(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"UnviewableContentIdentified"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlUnviewableContentIdentifiedEventArgs>>(arg);

            return py::convert(self->obj.UnviewableContentIdentified(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_UnviewableContentIdentified(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"UnviewableContentIdentified"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UnviewableContentIdentified(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_WebResourceRequested(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"WebResourceRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlWebResourceRequestedEventArgs>>(arg);

            return py::convert(self->obj.WebResourceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_WebResourceRequested(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"WebResourceRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.WebResourceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIView[] = {
        { "add_initialize_script", reinterpret_cast<PyCFunction>(WebUIView_AddInitializeScript), METH_VARARGS, nullptr },
        { "build_local_stream_uri", reinterpret_cast<PyCFunction>(WebUIView_BuildLocalStreamUri), METH_VARARGS, nullptr },
        { "capture_preview_to_stream_async", reinterpret_cast<PyCFunction>(WebUIView_CapturePreviewToStreamAsync), METH_VARARGS, nullptr },
        { "capture_selected_content_to_data_package_async", reinterpret_cast<PyCFunction>(WebUIView_CaptureSelectedContentToDataPackageAsync), METH_VARARGS, nullptr },
        { "create_async", reinterpret_cast<PyCFunction>(WebUIView_CreateAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_deferred_permission_request_by_id", reinterpret_cast<PyCFunction>(WebUIView_GetDeferredPermissionRequestById), METH_VARARGS, nullptr },
        { "go_back", reinterpret_cast<PyCFunction>(WebUIView_GoBack), METH_VARARGS, nullptr },
        { "go_forward", reinterpret_cast<PyCFunction>(WebUIView_GoForward), METH_VARARGS, nullptr },
        { "invoke_script_async", reinterpret_cast<PyCFunction>(WebUIView_InvokeScriptAsync), METH_VARARGS, nullptr },
        { "navigate", reinterpret_cast<PyCFunction>(WebUIView_Navigate), METH_VARARGS, nullptr },
        { "navigate_to_local_stream_uri", reinterpret_cast<PyCFunction>(WebUIView_NavigateToLocalStreamUri), METH_VARARGS, nullptr },
        { "navigate_to_string", reinterpret_cast<PyCFunction>(WebUIView_NavigateToString), METH_VARARGS, nullptr },
        { "navigate_with_http_request_message", reinterpret_cast<PyCFunction>(WebUIView_NavigateWithHttpRequestMessage), METH_VARARGS, nullptr },
        { "refresh", reinterpret_cast<PyCFunction>(WebUIView_Refresh), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(WebUIView_Stop), METH_VARARGS, nullptr },
        { "add_activated", reinterpret_cast<PyCFunction>(WebUIView_add_Activated), METH_O, nullptr },
        { "remove_activated", reinterpret_cast<PyCFunction>(WebUIView_remove_Activated), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(WebUIView_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(WebUIView_remove_Closed), METH_O, nullptr },
        { "add_contains_full_screen_element_changed", reinterpret_cast<PyCFunction>(WebUIView_add_ContainsFullScreenElementChanged), METH_O, nullptr },
        { "remove_contains_full_screen_element_changed", reinterpret_cast<PyCFunction>(WebUIView_remove_ContainsFullScreenElementChanged), METH_O, nullptr },
        { "add_content_loading", reinterpret_cast<PyCFunction>(WebUIView_add_ContentLoading), METH_O, nullptr },
        { "remove_content_loading", reinterpret_cast<PyCFunction>(WebUIView_remove_ContentLoading), METH_O, nullptr },
        { "add_d_o_m_content_loaded", reinterpret_cast<PyCFunction>(WebUIView_add_DOMContentLoaded), METH_O, nullptr },
        { "remove_d_o_m_content_loaded", reinterpret_cast<PyCFunction>(WebUIView_remove_DOMContentLoaded), METH_O, nullptr },
        { "add_frame_content_loading", reinterpret_cast<PyCFunction>(WebUIView_add_FrameContentLoading), METH_O, nullptr },
        { "remove_frame_content_loading", reinterpret_cast<PyCFunction>(WebUIView_remove_FrameContentLoading), METH_O, nullptr },
        { "add_frame_d_o_m_content_loaded", reinterpret_cast<PyCFunction>(WebUIView_add_FrameDOMContentLoaded), METH_O, nullptr },
        { "remove_frame_d_o_m_content_loaded", reinterpret_cast<PyCFunction>(WebUIView_remove_FrameDOMContentLoaded), METH_O, nullptr },
        { "add_frame_navigation_completed", reinterpret_cast<PyCFunction>(WebUIView_add_FrameNavigationCompleted), METH_O, nullptr },
        { "remove_frame_navigation_completed", reinterpret_cast<PyCFunction>(WebUIView_remove_FrameNavigationCompleted), METH_O, nullptr },
        { "add_frame_navigation_starting", reinterpret_cast<PyCFunction>(WebUIView_add_FrameNavigationStarting), METH_O, nullptr },
        { "remove_frame_navigation_starting", reinterpret_cast<PyCFunction>(WebUIView_remove_FrameNavigationStarting), METH_O, nullptr },
        { "add_long_running_script_detected", reinterpret_cast<PyCFunction>(WebUIView_add_LongRunningScriptDetected), METH_O, nullptr },
        { "remove_long_running_script_detected", reinterpret_cast<PyCFunction>(WebUIView_remove_LongRunningScriptDetected), METH_O, nullptr },
        { "add_navigation_completed", reinterpret_cast<PyCFunction>(WebUIView_add_NavigationCompleted), METH_O, nullptr },
        { "remove_navigation_completed", reinterpret_cast<PyCFunction>(WebUIView_remove_NavigationCompleted), METH_O, nullptr },
        { "add_navigation_starting", reinterpret_cast<PyCFunction>(WebUIView_add_NavigationStarting), METH_O, nullptr },
        { "remove_navigation_starting", reinterpret_cast<PyCFunction>(WebUIView_remove_NavigationStarting), METH_O, nullptr },
        { "add_new_window_requested", reinterpret_cast<PyCFunction>(WebUIView_add_NewWindowRequested), METH_O, nullptr },
        { "remove_new_window_requested", reinterpret_cast<PyCFunction>(WebUIView_remove_NewWindowRequested), METH_O, nullptr },
        { "add_permission_requested", reinterpret_cast<PyCFunction>(WebUIView_add_PermissionRequested), METH_O, nullptr },
        { "remove_permission_requested", reinterpret_cast<PyCFunction>(WebUIView_remove_PermissionRequested), METH_O, nullptr },
        { "add_script_notify", reinterpret_cast<PyCFunction>(WebUIView_add_ScriptNotify), METH_O, nullptr },
        { "remove_script_notify", reinterpret_cast<PyCFunction>(WebUIView_remove_ScriptNotify), METH_O, nullptr },
        { "add_unsafe_content_warning_displaying", reinterpret_cast<PyCFunction>(WebUIView_add_UnsafeContentWarningDisplaying), METH_O, nullptr },
        { "remove_unsafe_content_warning_displaying", reinterpret_cast<PyCFunction>(WebUIView_remove_UnsafeContentWarningDisplaying), METH_O, nullptr },
        { "add_unsupported_uri_scheme_identified", reinterpret_cast<PyCFunction>(WebUIView_add_UnsupportedUriSchemeIdentified), METH_O, nullptr },
        { "remove_unsupported_uri_scheme_identified", reinterpret_cast<PyCFunction>(WebUIView_remove_UnsupportedUriSchemeIdentified), METH_O, nullptr },
        { "add_unviewable_content_identified", reinterpret_cast<PyCFunction>(WebUIView_add_UnviewableContentIdentified), METH_O, nullptr },
        { "remove_unviewable_content_identified", reinterpret_cast<PyCFunction>(WebUIView_remove_UnviewableContentIdentified), METH_O, nullptr },
        { "add_web_resource_requested", reinterpret_cast<PyCFunction>(WebUIView_add_WebResourceRequested), METH_O, nullptr },
        { "remove_web_resource_requested", reinterpret_cast<PyCFunction>(WebUIView_remove_WebResourceRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_WebUIView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIView[] = {
        { "ignore_application_content_uri_rules_navigation_restrictions", reinterpret_cast<getter>(WebUIView_get_IgnoreApplicationContentUriRulesNavigationRestrictions), reinterpret_cast<setter>(WebUIView_put_IgnoreApplicationContentUriRulesNavigationRestrictions), nullptr, nullptr },
        { "application_view_id", reinterpret_cast<getter>(WebUIView_get_ApplicationViewId), nullptr, nullptr, nullptr },
        { "source", reinterpret_cast<getter>(WebUIView_get_Source), reinterpret_cast<setter>(WebUIView_put_Source), nullptr, nullptr },
        { "default_background_color", reinterpret_cast<getter>(WebUIView_get_DefaultBackgroundColor), reinterpret_cast<setter>(WebUIView_put_DefaultBackgroundColor), nullptr, nullptr },
        { "can_go_back", reinterpret_cast<getter>(WebUIView_get_CanGoBack), nullptr, nullptr, nullptr },
        { "can_go_forward", reinterpret_cast<getter>(WebUIView_get_CanGoForward), nullptr, nullptr, nullptr },
        { "contains_full_screen_element", reinterpret_cast<getter>(WebUIView_get_ContainsFullScreenElement), nullptr, nullptr, nullptr },
        { "deferred_permission_requests", reinterpret_cast<getter>(WebUIView_get_DeferredPermissionRequests), nullptr, nullptr, nullptr },
        { "document_title", reinterpret_cast<getter>(WebUIView_get_DocumentTitle), nullptr, nullptr, nullptr },
        { "settings", reinterpret_cast<getter>(WebUIView_get_Settings), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIView[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIView) },
        { },
    };

    static PyType_Spec type_spec_WebUIView =
    {
        "_winsdk_Windows_UI_WebUI.WebUIView",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIView
    };

    // ----- WebUIVoiceCommandActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIVoiceCommandActivatedEventArgs = "WebUIVoiceCommandActivatedEventArgs";

    static PyObject* _new_WebUIVoiceCommandActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIVoiceCommandActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIVoiceCommandActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIVoiceCommandActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIVoiceCommandActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIVoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIVoiceCommandActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIVoiceCommandActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIVoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIVoiceCommandActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIVoiceCommandActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIVoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIVoiceCommandActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIVoiceCommandActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIVoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIVoiceCommandActivatedEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIVoiceCommandActivatedEventArgs_get_Result(py::wrapper::Windows::UI::WebUI::WebUIVoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIVoiceCommandActivatedEventArgs", L"Result"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIVoiceCommandActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIVoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIVoiceCommandActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIVoiceCommandActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIVoiceCommandActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIVoiceCommandActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIVoiceCommandActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIVoiceCommandActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIVoiceCommandActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIVoiceCommandActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIVoiceCommandActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIVoiceCommandActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIVoiceCommandActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIVoiceCommandActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIVoiceCommandActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "result", reinterpret_cast<getter>(WebUIVoiceCommandActivatedEventArgs_get_Result), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIVoiceCommandActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIVoiceCommandActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIVoiceCommandActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIVoiceCommandActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIVoiceCommandActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIVoiceCommandActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIVoiceCommandActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIVoiceCommandActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIVoiceCommandActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIVoiceCommandActivatedEventArgs
    };

    // ----- WebUIWalletActionActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIWalletActionActivatedEventArgs = "WebUIWalletActionActivatedEventArgs";

    static PyObject* _new_WebUIWalletActionActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIWalletActionActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIWalletActionActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIWalletActionActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIWalletActionActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWalletActionActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWalletActionActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWalletActionActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWalletActionActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWalletActionActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWalletActionActivatedEventArgs_get_ActionId(py::wrapper::Windows::UI::WebUI::WebUIWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWalletActionActivatedEventArgs", L"ActionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWalletActionActivatedEventArgs_get_ActionKind(py::wrapper::Windows::UI::WebUI::WebUIWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWalletActionActivatedEventArgs", L"ActionKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActionKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWalletActionActivatedEventArgs_get_ItemId(py::wrapper::Windows::UI::WebUI::WebUIWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWalletActionActivatedEventArgs", L"ItemId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ItemId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWalletActionActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWalletActionActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIWalletActionActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIWalletActionActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIWalletActionActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIWalletActionActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIWalletActionActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIWalletActionActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIWalletActionActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIWalletActionActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIWalletActionActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIWalletActionActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIWalletActionActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "action_id", reinterpret_cast<getter>(WebUIWalletActionActivatedEventArgs_get_ActionId), nullptr, nullptr, nullptr },
        { "action_kind", reinterpret_cast<getter>(WebUIWalletActionActivatedEventArgs_get_ActionKind), nullptr, nullptr, nullptr },
        { "item_id", reinterpret_cast<getter>(WebUIWalletActionActivatedEventArgs_get_ItemId), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIWalletActionActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIWalletActionActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIWalletActionActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIWalletActionActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIWalletActionActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIWalletActionActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIWalletActionActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIWalletActionActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIWalletActionActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIWalletActionActivatedEventArgs
    };

    // ----- WebUIWebAccountProviderActivatedEventArgs class --------------------
    static constexpr const char* const type_name_WebUIWebAccountProviderActivatedEventArgs = "WebUIWebAccountProviderActivatedEventArgs";

    static PyObject* _new_WebUIWebAccountProviderActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIWebAccountProviderActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIWebAccountProviderActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIWebAccountProviderActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIWebAccountProviderActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIWebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWebAccountProviderActivatedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWebAccountProviderActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIWebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWebAccountProviderActivatedEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWebAccountProviderActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIWebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWebAccountProviderActivatedEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWebAccountProviderActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIWebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWebAccountProviderActivatedEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWebAccountProviderActivatedEventArgs_get_Operation(py::wrapper::Windows::UI::WebUI::WebUIWebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWebAccountProviderActivatedEventArgs", L"Operation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Operation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWebAccountProviderActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIWebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWebAccountProviderActivatedEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIWebAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIWebAccountProviderActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIWebAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIWebAccountProviderActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIWebAccountProviderActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIWebAccountProviderActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIWebAccountProviderActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIWebAccountProviderActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIWebAccountProviderActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIWebAccountProviderActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIWebAccountProviderActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIWebAccountProviderActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "operation", reinterpret_cast<getter>(WebUIWebAccountProviderActivatedEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIWebAccountProviderActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIWebAccountProviderActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIWebAccountProviderActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIWebAccountProviderActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIWebAccountProviderActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIWebAccountProviderActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIWebAccountProviderActivatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIWebAccountProviderActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIWebAccountProviderActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIWebAccountProviderActivatedEventArgs
    };

    // ----- WebUIWebAuthenticationBrokerContinuationEventArgs class --------------------
    static constexpr const char* const type_name_WebUIWebAuthenticationBrokerContinuationEventArgs = "WebUIWebAuthenticationBrokerContinuationEventArgs";

    static PyObject* _new_WebUIWebAuthenticationBrokerContinuationEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebUIWebAuthenticationBrokerContinuationEventArgs);
        return nullptr;
    }

    static void _dealloc_WebUIWebAuthenticationBrokerContinuationEventArgs(py::wrapper::Windows::UI::WebUI::WebUIWebAuthenticationBrokerContinuationEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIWebAuthenticationBrokerContinuationEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIWebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWebAuthenticationBrokerContinuationEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWebAuthenticationBrokerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIWebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWebAuthenticationBrokerContinuationEventArgs", L"PreviousExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWebAuthenticationBrokerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIWebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWebAuthenticationBrokerContinuationEventArgs", L"SplashScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWebAuthenticationBrokerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::UI::WebUI::WebUIWebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWebAuthenticationBrokerContinuationEventArgs", L"ContinuationData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContinuationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWebAuthenticationBrokerContinuationEventArgs_get_WebAuthenticationResult(py::wrapper::Windows::UI::WebUI::WebUIWebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWebAuthenticationBrokerContinuationEventArgs", L"WebAuthenticationResult"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WebAuthenticationResult());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWebAuthenticationBrokerContinuationEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIWebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWebAuthenticationBrokerContinuationEventArgs", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIWebAuthenticationBrokerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIWebAuthenticationBrokerContinuationEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIWebAuthenticationBrokerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIWebAuthenticationBrokerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIWebAuthenticationBrokerContinuationEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIWebAuthenticationBrokerContinuationEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIWebAuthenticationBrokerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebUIWebAuthenticationBrokerContinuationEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIWebAuthenticationBrokerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIWebAuthenticationBrokerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIWebAuthenticationBrokerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(WebUIWebAuthenticationBrokerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "web_authentication_result", reinterpret_cast<getter>(WebUIWebAuthenticationBrokerContinuationEventArgs_get_WebAuthenticationResult), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIWebAuthenticationBrokerContinuationEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebUIWebAuthenticationBrokerContinuationEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIWebAuthenticationBrokerContinuationEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIWebAuthenticationBrokerContinuationEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIWebAuthenticationBrokerContinuationEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIWebAuthenticationBrokerContinuationEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebUIWebAuthenticationBrokerContinuationEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.WebUIWebAuthenticationBrokerContinuationEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIWebAuthenticationBrokerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIWebAuthenticationBrokerContinuationEventArgs
    };

    // ----- IActivatedEventArgsDeferral interface --------------------
    static constexpr const char* const type_name_IActivatedEventArgsDeferral = "IActivatedEventArgsDeferral";

    static PyObject* _new_IActivatedEventArgsDeferral(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IActivatedEventArgsDeferral);
        return nullptr;
    }

    static void _dealloc_IActivatedEventArgsDeferral(py::wrapper::Windows::UI::WebUI::IActivatedEventArgsDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IActivatedEventArgsDeferral_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::IActivatedEventArgsDeferral* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.IActivatedEventArgsDeferral", L"ActivatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IActivatedEventArgsDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::IActivatedEventArgsDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IActivatedEventArgsDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::IActivatedEventArgsDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IActivatedEventArgsDeferral[] = {
        { "_assign_array_", _assign_array_IActivatedEventArgsDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IActivatedEventArgsDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IActivatedEventArgsDeferral[] = {
        { "activated_operation", reinterpret_cast<getter>(IActivatedEventArgsDeferral_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IActivatedEventArgsDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IActivatedEventArgsDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IActivatedEventArgsDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IActivatedEventArgsDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IActivatedEventArgsDeferral) },
        { },
    };

    static PyType_Spec type_spec_IActivatedEventArgsDeferral =
    {
        "_winsdk_Windows_UI_WebUI.IActivatedEventArgsDeferral",
        sizeof(py::wrapper::Windows::UI::WebUI::IActivatedEventArgsDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IActivatedEventArgsDeferral
    };

    // ----- IWebUIBackgroundTaskInstance interface --------------------
    static constexpr const char* const type_name_IWebUIBackgroundTaskInstance = "IWebUIBackgroundTaskInstance";

    static PyObject* _new_IWebUIBackgroundTaskInstance(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IWebUIBackgroundTaskInstance);
        return nullptr;
    }

    static void _dealloc_IWebUIBackgroundTaskInstance(py::wrapper::Windows::UI::WebUI::IWebUIBackgroundTaskInstance* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWebUIBackgroundTaskInstance_get_Succeeded(py::wrapper::Windows::UI::WebUI::IWebUIBackgroundTaskInstance* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.IWebUIBackgroundTaskInstance", L"Succeeded"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Succeeded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebUIBackgroundTaskInstance_put_Succeeded(py::wrapper::Windows::UI::WebUI::IWebUIBackgroundTaskInstance* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.IWebUIBackgroundTaskInstance", L"Succeeded"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Succeeded(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IWebUIBackgroundTaskInstance(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::IWebUIBackgroundTaskInstance>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWebUIBackgroundTaskInstance(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::IWebUIBackgroundTaskInstance>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebUIBackgroundTaskInstance[] = {
        { "_assign_array_", _assign_array_IWebUIBackgroundTaskInstance, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWebUIBackgroundTaskInstance), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWebUIBackgroundTaskInstance[] = {
        { "succeeded", reinterpret_cast<getter>(IWebUIBackgroundTaskInstance_get_Succeeded), reinterpret_cast<setter>(IWebUIBackgroundTaskInstance_put_Succeeded), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IWebUIBackgroundTaskInstance[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWebUIBackgroundTaskInstance) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWebUIBackgroundTaskInstance) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWebUIBackgroundTaskInstance) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWebUIBackgroundTaskInstance) },
        { },
    };

    static PyType_Spec type_spec_IWebUIBackgroundTaskInstance =
    {
        "_winsdk_Windows_UI_WebUI.IWebUIBackgroundTaskInstance",
        sizeof(py::wrapper::Windows::UI::WebUI::IWebUIBackgroundTaskInstance),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebUIBackgroundTaskInstance
    };

    // ----- IWebUINavigatedEventArgs interface --------------------
    static constexpr const char* const type_name_IWebUINavigatedEventArgs = "IWebUINavigatedEventArgs";

    static PyObject* _new_IWebUINavigatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IWebUINavigatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IWebUINavigatedEventArgs(py::wrapper::Windows::UI::WebUI::IWebUINavigatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWebUINavigatedEventArgs_get_NavigatedOperation(py::wrapper::Windows::UI::WebUI::IWebUINavigatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.IWebUINavigatedEventArgs", L"NavigatedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NavigatedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IWebUINavigatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::IWebUINavigatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWebUINavigatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::IWebUINavigatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebUINavigatedEventArgs[] = {
        { "_assign_array_", _assign_array_IWebUINavigatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWebUINavigatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWebUINavigatedEventArgs[] = {
        { "navigated_operation", reinterpret_cast<getter>(IWebUINavigatedEventArgs_get_NavigatedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IWebUINavigatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWebUINavigatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWebUINavigatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWebUINavigatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWebUINavigatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_IWebUINavigatedEventArgs =
    {
        "_winsdk_Windows_UI_WebUI.IWebUINavigatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::IWebUINavigatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebUINavigatedEventArgs
    };

    // ----- Windows.UI.WebUI Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::UI::WebUI");

    static PyMethodDef module_methods[] = {
        {"_register_PrintContent", register_PrintContent, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_PrintContent);
        Py_VISIT(state->type_ActivatedDeferral);
        Py_VISIT(state->type_ActivatedOperation);
        Py_VISIT(state->type_BackgroundActivatedEventArgs);
        Py_VISIT(state->type_EnteredBackgroundEventArgs);
        Py_VISIT(state->type_HtmlPrintDocumentSource);
        Py_VISIT(state->type_LeavingBackgroundEventArgs);
        Py_VISIT(state->type_NewWebUIViewCreatedEventArgs);
        Py_VISIT(state->type_SuspendingDeferral);
        Py_VISIT(state->type_SuspendingEventArgs);
        Py_VISIT(state->type_SuspendingOperation);
        Py_VISIT(state->type_WebUIApplication);
        Py_VISIT(state->type_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs);
        Py_VISIT(state->type_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs);
        Py_VISIT(state->type_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs);
        Py_VISIT(state->type_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs);
        Py_VISIT(state->type_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs);
        Py_VISIT(state->type_WebUIBackgroundTaskInstance);
        Py_VISIT(state->type_WebUIBackgroundTaskInstanceRuntimeClass);
        Py_VISIT(state->type_WebUIBarcodeScannerPreviewActivatedEventArgs);
        Py_VISIT(state->type_WebUICachedFileUpdaterActivatedEventArgs);
        Py_VISIT(state->type_WebUICameraSettingsActivatedEventArgs);
        Py_VISIT(state->type_WebUICommandLineActivatedEventArgs);
        Py_VISIT(state->type_WebUIContactCallActivatedEventArgs);
        Py_VISIT(state->type_WebUIContactMapActivatedEventArgs);
        Py_VISIT(state->type_WebUIContactMessageActivatedEventArgs);
        Py_VISIT(state->type_WebUIContactPanelActivatedEventArgs);
        Py_VISIT(state->type_WebUIContactPickerActivatedEventArgs);
        Py_VISIT(state->type_WebUIContactPostActivatedEventArgs);
        Py_VISIT(state->type_WebUIContactVideoCallActivatedEventArgs);
        Py_VISIT(state->type_WebUIDeviceActivatedEventArgs);
        Py_VISIT(state->type_WebUIDevicePairingActivatedEventArgs);
        Py_VISIT(state->type_WebUIDialReceiverActivatedEventArgs);
        Py_VISIT(state->type_WebUIFileActivatedEventArgs);
        Py_VISIT(state->type_WebUIFileOpenPickerActivatedEventArgs);
        Py_VISIT(state->type_WebUIFileOpenPickerContinuationEventArgs);
        Py_VISIT(state->type_WebUIFileSavePickerActivatedEventArgs);
        Py_VISIT(state->type_WebUIFileSavePickerContinuationEventArgs);
        Py_VISIT(state->type_WebUIFolderPickerContinuationEventArgs);
        Py_VISIT(state->type_WebUILaunchActivatedEventArgs);
        Py_VISIT(state->type_WebUILockScreenActivatedEventArgs);
        Py_VISIT(state->type_WebUILockScreenCallActivatedEventArgs);
        Py_VISIT(state->type_WebUILockScreenComponentActivatedEventArgs);
        Py_VISIT(state->type_WebUINavigatedDeferral);
        Py_VISIT(state->type_WebUINavigatedEventArgs);
        Py_VISIT(state->type_WebUINavigatedOperation);
        Py_VISIT(state->type_WebUIPhoneCallActivatedEventArgs);
        Py_VISIT(state->type_WebUIPrint3DWorkflowActivatedEventArgs);
        Py_VISIT(state->type_WebUIPrintTaskSettingsActivatedEventArgs);
        Py_VISIT(state->type_WebUIPrintWorkflowForegroundTaskActivatedEventArgs);
        Py_VISIT(state->type_WebUIProtocolActivatedEventArgs);
        Py_VISIT(state->type_WebUIProtocolForResultsActivatedEventArgs);
        Py_VISIT(state->type_WebUIRestrictedLaunchActivatedEventArgs);
        Py_VISIT(state->type_WebUISearchActivatedEventArgs);
        Py_VISIT(state->type_WebUIShareTargetActivatedEventArgs);
        Py_VISIT(state->type_WebUIStartupTaskActivatedEventArgs);
        Py_VISIT(state->type_WebUIToastNotificationActivatedEventArgs);
        Py_VISIT(state->type_WebUIUserDataAccountProviderActivatedEventArgs);
        Py_VISIT(state->type_WebUIView);
        Py_VISIT(state->type_WebUIVoiceCommandActivatedEventArgs);
        Py_VISIT(state->type_WebUIWalletActionActivatedEventArgs);
        Py_VISIT(state->type_WebUIWebAccountProviderActivatedEventArgs);
        Py_VISIT(state->type_WebUIWebAuthenticationBrokerContinuationEventArgs);
        Py_VISIT(state->type_IActivatedEventArgsDeferral);
        Py_VISIT(state->type_IWebUIBackgroundTaskInstance);
        Py_VISIT(state->type_IWebUINavigatedEventArgs);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_PrintContent);
        Py_CLEAR(state->type_ActivatedDeferral);
        Py_CLEAR(state->type_ActivatedOperation);
        Py_CLEAR(state->type_BackgroundActivatedEventArgs);
        Py_CLEAR(state->type_EnteredBackgroundEventArgs);
        Py_CLEAR(state->type_HtmlPrintDocumentSource);
        Py_CLEAR(state->type_LeavingBackgroundEventArgs);
        Py_CLEAR(state->type_NewWebUIViewCreatedEventArgs);
        Py_CLEAR(state->type_SuspendingDeferral);
        Py_CLEAR(state->type_SuspendingEventArgs);
        Py_CLEAR(state->type_SuspendingOperation);
        Py_CLEAR(state->type_WebUIApplication);
        Py_CLEAR(state->type_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs);
        Py_CLEAR(state->type_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs);
        Py_CLEAR(state->type_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs);
        Py_CLEAR(state->type_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs);
        Py_CLEAR(state->type_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs);
        Py_CLEAR(state->type_WebUIBackgroundTaskInstance);
        Py_CLEAR(state->type_WebUIBackgroundTaskInstanceRuntimeClass);
        Py_CLEAR(state->type_WebUIBarcodeScannerPreviewActivatedEventArgs);
        Py_CLEAR(state->type_WebUICachedFileUpdaterActivatedEventArgs);
        Py_CLEAR(state->type_WebUICameraSettingsActivatedEventArgs);
        Py_CLEAR(state->type_WebUICommandLineActivatedEventArgs);
        Py_CLEAR(state->type_WebUIContactCallActivatedEventArgs);
        Py_CLEAR(state->type_WebUIContactMapActivatedEventArgs);
        Py_CLEAR(state->type_WebUIContactMessageActivatedEventArgs);
        Py_CLEAR(state->type_WebUIContactPanelActivatedEventArgs);
        Py_CLEAR(state->type_WebUIContactPickerActivatedEventArgs);
        Py_CLEAR(state->type_WebUIContactPostActivatedEventArgs);
        Py_CLEAR(state->type_WebUIContactVideoCallActivatedEventArgs);
        Py_CLEAR(state->type_WebUIDeviceActivatedEventArgs);
        Py_CLEAR(state->type_WebUIDevicePairingActivatedEventArgs);
        Py_CLEAR(state->type_WebUIDialReceiverActivatedEventArgs);
        Py_CLEAR(state->type_WebUIFileActivatedEventArgs);
        Py_CLEAR(state->type_WebUIFileOpenPickerActivatedEventArgs);
        Py_CLEAR(state->type_WebUIFileOpenPickerContinuationEventArgs);
        Py_CLEAR(state->type_WebUIFileSavePickerActivatedEventArgs);
        Py_CLEAR(state->type_WebUIFileSavePickerContinuationEventArgs);
        Py_CLEAR(state->type_WebUIFolderPickerContinuationEventArgs);
        Py_CLEAR(state->type_WebUILaunchActivatedEventArgs);
        Py_CLEAR(state->type_WebUILockScreenActivatedEventArgs);
        Py_CLEAR(state->type_WebUILockScreenCallActivatedEventArgs);
        Py_CLEAR(state->type_WebUILockScreenComponentActivatedEventArgs);
        Py_CLEAR(state->type_WebUINavigatedDeferral);
        Py_CLEAR(state->type_WebUINavigatedEventArgs);
        Py_CLEAR(state->type_WebUINavigatedOperation);
        Py_CLEAR(state->type_WebUIPhoneCallActivatedEventArgs);
        Py_CLEAR(state->type_WebUIPrint3DWorkflowActivatedEventArgs);
        Py_CLEAR(state->type_WebUIPrintTaskSettingsActivatedEventArgs);
        Py_CLEAR(state->type_WebUIPrintWorkflowForegroundTaskActivatedEventArgs);
        Py_CLEAR(state->type_WebUIProtocolActivatedEventArgs);
        Py_CLEAR(state->type_WebUIProtocolForResultsActivatedEventArgs);
        Py_CLEAR(state->type_WebUIRestrictedLaunchActivatedEventArgs);
        Py_CLEAR(state->type_WebUISearchActivatedEventArgs);
        Py_CLEAR(state->type_WebUIShareTargetActivatedEventArgs);
        Py_CLEAR(state->type_WebUIStartupTaskActivatedEventArgs);
        Py_CLEAR(state->type_WebUIToastNotificationActivatedEventArgs);
        Py_CLEAR(state->type_WebUIUserDataAccountProviderActivatedEventArgs);
        Py_CLEAR(state->type_WebUIView);
        Py_CLEAR(state->type_WebUIVoiceCommandActivatedEventArgs);
        Py_CLEAR(state->type_WebUIWalletActionActivatedEventArgs);
        Py_CLEAR(state->type_WebUIWebAccountProviderActivatedEventArgs);
        Py_CLEAR(state->type_WebUIWebAuthenticationBrokerContinuationEventArgs);
        Py_CLEAR(state->type_IActivatedEventArgsDeferral);
        Py_CLEAR(state->type_IWebUIBackgroundTaskInstance);
        Py_CLEAR(state->type_IWebUINavigatedEventArgs);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_UI_WebUI",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::UI::WebUI

PyMODINIT_FUNC PyInit__winsdk_Windows_UI_WebUI(void) noexcept
{
    using namespace py::cpp::Windows::UI::WebUI;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_ActivatedDeferral = py::register_python_type(module.get(), type_name_ActivatedDeferral, &type_spec_ActivatedDeferral, bases.get(), nullptr);
    if (!state->type_ActivatedDeferral)
    {
        return nullptr;
    }

    state->type_ActivatedOperation = py::register_python_type(module.get(), type_name_ActivatedOperation, &type_spec_ActivatedOperation, bases.get(), nullptr);
    if (!state->type_ActivatedOperation)
    {
        return nullptr;
    }

    state->type_BackgroundActivatedEventArgs = py::register_python_type(module.get(), type_name_BackgroundActivatedEventArgs, &type_spec_BackgroundActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_BackgroundActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_EnteredBackgroundEventArgs = py::register_python_type(module.get(), type_name_EnteredBackgroundEventArgs, &type_spec_EnteredBackgroundEventArgs, bases.get(), nullptr);
    if (!state->type_EnteredBackgroundEventArgs)
    {
        return nullptr;
    }

    state->type_HtmlPrintDocumentSource = py::register_python_type(module.get(), type_name_HtmlPrintDocumentSource, &type_spec_HtmlPrintDocumentSource, bases.get(), nullptr);
    if (!state->type_HtmlPrintDocumentSource)
    {
        return nullptr;
    }

    state->type_LeavingBackgroundEventArgs = py::register_python_type(module.get(), type_name_LeavingBackgroundEventArgs, &type_spec_LeavingBackgroundEventArgs, bases.get(), nullptr);
    if (!state->type_LeavingBackgroundEventArgs)
    {
        return nullptr;
    }

    state->type_NewWebUIViewCreatedEventArgs = py::register_python_type(module.get(), type_name_NewWebUIViewCreatedEventArgs, &type_spec_NewWebUIViewCreatedEventArgs, bases.get(), nullptr);
    if (!state->type_NewWebUIViewCreatedEventArgs)
    {
        return nullptr;
    }

    state->type_SuspendingDeferral = py::register_python_type(module.get(), type_name_SuspendingDeferral, &type_spec_SuspendingDeferral, bases.get(), nullptr);
    if (!state->type_SuspendingDeferral)
    {
        return nullptr;
    }

    state->type_SuspendingEventArgs = py::register_python_type(module.get(), type_name_SuspendingEventArgs, &type_spec_SuspendingEventArgs, bases.get(), nullptr);
    if (!state->type_SuspendingEventArgs)
    {
        return nullptr;
    }

    state->type_SuspendingOperation = py::register_python_type(module.get(), type_name_SuspendingOperation, &type_spec_SuspendingOperation, bases.get(), nullptr);
    if (!state->type_SuspendingOperation)
    {
        return nullptr;
    }

    state->type_WebUIApplication = py::register_python_type(module.get(), type_name_WebUIApplication, &type_spec_WebUIApplication, nullptr, nullptr);
    if (!state->type_WebUIApplication)
    {
        return nullptr;
    }

    state->type_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs, &type_spec_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs, &type_spec_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs, &type_spec_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs, &type_spec_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs, &type_spec_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs)
    {
        return nullptr;
    }

    py::pyobj_handle type_WebUIBackgroundTaskInstance_Meta{PyType_FromSpec(&type_spec_WebUIBackgroundTaskInstance_Meta)};
    if (!type_WebUIBackgroundTaskInstance_Meta)
    {
        return nullptr;
    }

    state->type_WebUIBackgroundTaskInstance = py::register_python_type(module.get(), type_name_WebUIBackgroundTaskInstance, &type_spec_WebUIBackgroundTaskInstance, nullptr, reinterpret_cast<PyTypeObject*>(type_WebUIBackgroundTaskInstance_Meta.get()));
    if (!state->type_WebUIBackgroundTaskInstance)
    {
        return nullptr;
    }

    state->type_WebUIBackgroundTaskInstanceRuntimeClass = py::register_python_type(module.get(), type_name_WebUIBackgroundTaskInstanceRuntimeClass, &type_spec_WebUIBackgroundTaskInstanceRuntimeClass, bases.get(), nullptr);
    if (!state->type_WebUIBackgroundTaskInstanceRuntimeClass)
    {
        return nullptr;
    }

    state->type_WebUIBarcodeScannerPreviewActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIBarcodeScannerPreviewActivatedEventArgs, &type_spec_WebUIBarcodeScannerPreviewActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIBarcodeScannerPreviewActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUICachedFileUpdaterActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUICachedFileUpdaterActivatedEventArgs, &type_spec_WebUICachedFileUpdaterActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUICachedFileUpdaterActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUICameraSettingsActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUICameraSettingsActivatedEventArgs, &type_spec_WebUICameraSettingsActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUICameraSettingsActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUICommandLineActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUICommandLineActivatedEventArgs, &type_spec_WebUICommandLineActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUICommandLineActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIContactCallActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIContactCallActivatedEventArgs, &type_spec_WebUIContactCallActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIContactCallActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIContactMapActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIContactMapActivatedEventArgs, &type_spec_WebUIContactMapActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIContactMapActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIContactMessageActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIContactMessageActivatedEventArgs, &type_spec_WebUIContactMessageActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIContactMessageActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIContactPanelActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIContactPanelActivatedEventArgs, &type_spec_WebUIContactPanelActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIContactPanelActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIContactPickerActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIContactPickerActivatedEventArgs, &type_spec_WebUIContactPickerActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIContactPickerActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIContactPostActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIContactPostActivatedEventArgs, &type_spec_WebUIContactPostActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIContactPostActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIContactVideoCallActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIContactVideoCallActivatedEventArgs, &type_spec_WebUIContactVideoCallActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIContactVideoCallActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIDeviceActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIDeviceActivatedEventArgs, &type_spec_WebUIDeviceActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIDeviceActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIDevicePairingActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIDevicePairingActivatedEventArgs, &type_spec_WebUIDevicePairingActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIDevicePairingActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIDialReceiverActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIDialReceiverActivatedEventArgs, &type_spec_WebUIDialReceiverActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIDialReceiverActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIFileActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIFileActivatedEventArgs, &type_spec_WebUIFileActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIFileActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIFileOpenPickerActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIFileOpenPickerActivatedEventArgs, &type_spec_WebUIFileOpenPickerActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIFileOpenPickerActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIFileOpenPickerContinuationEventArgs = py::register_python_type(module.get(), type_name_WebUIFileOpenPickerContinuationEventArgs, &type_spec_WebUIFileOpenPickerContinuationEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIFileOpenPickerContinuationEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIFileSavePickerActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIFileSavePickerActivatedEventArgs, &type_spec_WebUIFileSavePickerActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIFileSavePickerActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIFileSavePickerContinuationEventArgs = py::register_python_type(module.get(), type_name_WebUIFileSavePickerContinuationEventArgs, &type_spec_WebUIFileSavePickerContinuationEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIFileSavePickerContinuationEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIFolderPickerContinuationEventArgs = py::register_python_type(module.get(), type_name_WebUIFolderPickerContinuationEventArgs, &type_spec_WebUIFolderPickerContinuationEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIFolderPickerContinuationEventArgs)
    {
        return nullptr;
    }

    state->type_WebUILaunchActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUILaunchActivatedEventArgs, &type_spec_WebUILaunchActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUILaunchActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUILockScreenActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUILockScreenActivatedEventArgs, &type_spec_WebUILockScreenActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUILockScreenActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUILockScreenCallActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUILockScreenCallActivatedEventArgs, &type_spec_WebUILockScreenCallActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUILockScreenCallActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUILockScreenComponentActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUILockScreenComponentActivatedEventArgs, &type_spec_WebUILockScreenComponentActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUILockScreenComponentActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUINavigatedDeferral = py::register_python_type(module.get(), type_name_WebUINavigatedDeferral, &type_spec_WebUINavigatedDeferral, bases.get(), nullptr);
    if (!state->type_WebUINavigatedDeferral)
    {
        return nullptr;
    }

    state->type_WebUINavigatedEventArgs = py::register_python_type(module.get(), type_name_WebUINavigatedEventArgs, &type_spec_WebUINavigatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUINavigatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUINavigatedOperation = py::register_python_type(module.get(), type_name_WebUINavigatedOperation, &type_spec_WebUINavigatedOperation, bases.get(), nullptr);
    if (!state->type_WebUINavigatedOperation)
    {
        return nullptr;
    }

    state->type_WebUIPhoneCallActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIPhoneCallActivatedEventArgs, &type_spec_WebUIPhoneCallActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIPhoneCallActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIPrint3DWorkflowActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIPrint3DWorkflowActivatedEventArgs, &type_spec_WebUIPrint3DWorkflowActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIPrint3DWorkflowActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIPrintTaskSettingsActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIPrintTaskSettingsActivatedEventArgs, &type_spec_WebUIPrintTaskSettingsActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIPrintTaskSettingsActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIPrintWorkflowForegroundTaskActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIPrintWorkflowForegroundTaskActivatedEventArgs, &type_spec_WebUIPrintWorkflowForegroundTaskActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIPrintWorkflowForegroundTaskActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIProtocolActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIProtocolActivatedEventArgs, &type_spec_WebUIProtocolActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIProtocolActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIProtocolForResultsActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIProtocolForResultsActivatedEventArgs, &type_spec_WebUIProtocolForResultsActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIProtocolForResultsActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIRestrictedLaunchActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIRestrictedLaunchActivatedEventArgs, &type_spec_WebUIRestrictedLaunchActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIRestrictedLaunchActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUISearchActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUISearchActivatedEventArgs, &type_spec_WebUISearchActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUISearchActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIShareTargetActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIShareTargetActivatedEventArgs, &type_spec_WebUIShareTargetActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIShareTargetActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIStartupTaskActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIStartupTaskActivatedEventArgs, &type_spec_WebUIStartupTaskActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIStartupTaskActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIToastNotificationActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIToastNotificationActivatedEventArgs, &type_spec_WebUIToastNotificationActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIToastNotificationActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIUserDataAccountProviderActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIUserDataAccountProviderActivatedEventArgs, &type_spec_WebUIUserDataAccountProviderActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIUserDataAccountProviderActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIView = py::register_python_type(module.get(), type_name_WebUIView, &type_spec_WebUIView, bases.get(), nullptr);
    if (!state->type_WebUIView)
    {
        return nullptr;
    }

    state->type_WebUIVoiceCommandActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIVoiceCommandActivatedEventArgs, &type_spec_WebUIVoiceCommandActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIVoiceCommandActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIWalletActionActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIWalletActionActivatedEventArgs, &type_spec_WebUIWalletActionActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIWalletActionActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIWebAccountProviderActivatedEventArgs = py::register_python_type(module.get(), type_name_WebUIWebAccountProviderActivatedEventArgs, &type_spec_WebUIWebAccountProviderActivatedEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIWebAccountProviderActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_WebUIWebAuthenticationBrokerContinuationEventArgs = py::register_python_type(module.get(), type_name_WebUIWebAuthenticationBrokerContinuationEventArgs, &type_spec_WebUIWebAuthenticationBrokerContinuationEventArgs, bases.get(), nullptr);
    if (!state->type_WebUIWebAuthenticationBrokerContinuationEventArgs)
    {
        return nullptr;
    }

    state->type_IActivatedEventArgsDeferral = py::register_python_type(module.get(), type_name_IActivatedEventArgsDeferral, &type_spec_IActivatedEventArgsDeferral, bases.get(), nullptr);
    if (!state->type_IActivatedEventArgsDeferral)
    {
        return nullptr;
    }

    state->type_IWebUIBackgroundTaskInstance = py::register_python_type(module.get(), type_name_IWebUIBackgroundTaskInstance, &type_spec_IWebUIBackgroundTaskInstance, bases.get(), nullptr);
    if (!state->type_IWebUIBackgroundTaskInstance)
    {
        return nullptr;
    }

    state->type_IWebUINavigatedEventArgs = py::register_python_type(module.get(), type_name_IWebUINavigatedEventArgs, &type_spec_IWebUINavigatedEventArgs, bases.get(), nullptr);
    if (!state->type_IWebUINavigatedEventArgs)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::UI::WebUI::PrintContent>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PrintContent;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::PrintContent is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::ActivatedDeferral>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ActivatedDeferral;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::ActivatedDeferral is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::ActivatedOperation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ActivatedOperation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::ActivatedOperation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::BackgroundActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::BackgroundActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::EnteredBackgroundEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EnteredBackgroundEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::EnteredBackgroundEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::HtmlPrintDocumentSource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HtmlPrintDocumentSource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::HtmlPrintDocumentSource is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::LeavingBackgroundEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LeavingBackgroundEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::LeavingBackgroundEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::NewWebUIViewCreatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NewWebUIViewCreatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::NewWebUIViewCreatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::SuspendingDeferral>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SuspendingDeferral;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::SuspendingDeferral is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::SuspendingEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SuspendingEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::SuspendingEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::SuspendingOperation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SuspendingOperation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::SuspendingOperation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIApplication>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIApplication;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIApplication is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderAddAppointmentActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIAppointmentsProviderAddAppointmentActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIBackgroundTaskInstance>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIBackgroundTaskInstance;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIBackgroundTaskInstance is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIBackgroundTaskInstanceRuntimeClass;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIBarcodeScannerPreviewActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIBarcodeScannerPreviewActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIBarcodeScannerPreviewActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUICachedFileUpdaterActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUICachedFileUpdaterActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUICachedFileUpdaterActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUICameraSettingsActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUICameraSettingsActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUICameraSettingsActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUICommandLineActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUICommandLineActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUICommandLineActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIContactCallActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIContactMapActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIContactMapActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIContactMapActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIContactMessageActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIContactPanelActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIContactPanelActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIContactPanelActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIContactPickerActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIContactPickerActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIContactPickerActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIContactPostActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIContactVideoCallActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIDeviceActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIDevicePairingActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIDevicePairingActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIDevicePairingActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIDialReceiverActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIFileActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIFileActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIFileActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIFileOpenPickerActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIFileOpenPickerActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIFileOpenPickerActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIFileOpenPickerContinuationEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIFileOpenPickerContinuationEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIFileOpenPickerContinuationEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIFileSavePickerActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIFileSavePickerContinuationEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIFileSavePickerContinuationEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIFileSavePickerContinuationEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIFolderPickerContinuationEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIFolderPickerContinuationEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIFolderPickerContinuationEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUILaunchActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUILaunchActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUILaunchActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUILockScreenActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUILockScreenActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUILockScreenActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUILockScreenCallActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUILockScreenComponentActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUILockScreenComponentActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUILockScreenComponentActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUINavigatedDeferral>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUINavigatedDeferral;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUINavigatedDeferral is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUINavigatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUINavigatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUINavigatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUINavigatedOperation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUINavigatedOperation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUINavigatedOperation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIPhoneCallActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIPhoneCallActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIPhoneCallActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIPrint3DWorkflowActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIPrint3DWorkflowActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIPrint3DWorkflowActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIPrintTaskSettingsActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIPrintTaskSettingsActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIPrintTaskSettingsActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIPrintWorkflowForegroundTaskActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIPrintWorkflowForegroundTaskActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIPrintWorkflowForegroundTaskActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIProtocolActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIProtocolForResultsActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIRestrictedLaunchActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIRestrictedLaunchActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIRestrictedLaunchActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUISearchActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUISearchActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUISearchActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIShareTargetActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIShareTargetActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIShareTargetActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIStartupTaskActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIStartupTaskActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIStartupTaskActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIToastNotificationActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIToastNotificationActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIToastNotificationActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIUserDataAccountProviderActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIUserDataAccountProviderActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIUserDataAccountProviderActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIView>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIView;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIView is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIVoiceCommandActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIVoiceCommandActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIVoiceCommandActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIWalletActionActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIWalletActionActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIWalletActionActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIWebAccountProviderActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIWebAccountProviderActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIWebAccountProviderActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::WebUIWebAuthenticationBrokerContinuationEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebUIWebAuthenticationBrokerContinuationEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::WebUIWebAuthenticationBrokerContinuationEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::IActivatedEventArgsDeferral>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IActivatedEventArgsDeferral;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::IActivatedEventArgsDeferral is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::IWebUIBackgroundTaskInstance>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IWebUIBackgroundTaskInstance;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::IWebUIBackgroundTaskInstance is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::WebUI::IWebUINavigatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::WebUI;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::WebUI");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IWebUINavigatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::WebUI::IWebUINavigatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}
